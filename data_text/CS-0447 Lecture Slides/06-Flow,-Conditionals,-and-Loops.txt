#6

Flow, Conditionals,
and Loops
Original slides by: Jarrett Billingsley
Modified with bits from: Bruce
Childers, David Wilkinson

CS 0447
Introduction to
Computer Programming

Luís Oliveira

Fall 2020

So far…
● Putting numbers into registers

li a0, 3

la a0, x

label

.data
x: .word 4

● COPYing register contents

move a0, t0

These do zero
Unsigned! 
extension

● COPYing from/to memory

lw/sw, lh/lhu/sh, lb/lbu/sb
la t1, x
lw t0, 0(t1)
lw t0, x

la t1, x
sw t0, 0(t1)
sw t0, x

Do the
same thing
2

In another perspective
lw, lh, lhu, lb, lbu
move
CPU

Memory
Registers

li, la

sw, sh, sb
Other operations

Datatypes

add

word

sub

half

mul

byte

syscall

asciiz

…

…

3

Introduction to conditions
● What distinguishes a computer from a calculator?
● It can make decisions based on values that it calculates
o If the value of this register is this, do something.
o Otherwise, do something else.
● The possible decisions make up the potential control flow of the program.
o When there is no possible route to a piece of code in your program, that is
called dead code.
 It’s like procrastination!

if(false) {
do_some_work()
}
4

Control flow

5

With great power…
● Control flow determines the order that your instructions run in
o What kinds of control flow statements do you know of?
o What about functions?
● In asm, the only thing you get for free is that instructions run in order
● You're responsible for coming up with everything else.
o If you screw up your control flow, the CPU doesn't care
o You'll just have a broken, malfunctioning program
 And it'll be half an hour before the lab is due
– And you'll be sad
» This is like 90% of the bugs

6

Getting a little further from familiarity
● all control flow is done with branches and jumps
o these are instructions which say "go somewhere else"
● for example…

this is an infinite loop,
which is sometimes useful
but not too interesting

_main_loop:
# clear screen
# draw one thing
# sleep
# draw another thing
j stands for ”jump" – go
# etc
somewhere else
j _main_loop

7

Building blocks
● A basic block is a chunk of code that has no control flow in it
● Control flow statements separate basic blocks

if(x == w - 1) {
do_thing()
} else {
other_thing()
}
third_thing()

x == w - 1?

other_thing

do_thing

third_thing

thinking about this is REAL HELPFUL
8

Essentially…
● The way control flow works in asm is you make basic blocks
o You gotta name (label) them
● Then, you use special instructions to choose where to go
o Ask yourself “Which basic block runs next?"
o Select the instruction you need!
 Don’t worry, we look into these instructions in a moment
● And don’t forget!
o Write pseudo-code (with comments) to keep track of control flow
o Or make a drawing of a flow-chart!
o Or … any other guide you think it’s helpful

9

Conditionals: if and if-else

10

MIPS ISA: conditional branch instructions
● conditional branch instructions do one of two things:
o if the condition is met, we go to the label
o otherwise, nothing happens, and we go to the next instruction

Instruction

Meaning

beq a, b, label

if(a == b) { goto label }

bne a, b, label

if(a != b) { goto label }

above, a must be a register, but b can be a register or immediate
(by the powers of the pseudo-instruction)
11

How do these work?

Previous
instruction

This is the branch

beq t0, t1, label
# branch if equal

t0==t1

True

False

Next
instruction

label:

Other
instruction
12

How do these work?
label:

beq t0, t1, label
# branch if equal

Other
instruction
Previous
instruction

True

t0==t1
This is the branch
False

Next
instruction
13

How to write asm (again!)
● Remember:

WRITE PSEUDOCODE

ALWAYS

REALLY!!!

if(x == w - 1) {
do_thing()
} else {
other_thing()
}

14

Like mad libs, but for code
● From now on, I’ll use these 'blocks' to represent the basic blocks
o cause they don’t matter

if(some condition) {
block A
} else {
block B
}
block C

15

A simple conditional block (if)
● If there is no else, it's pretty simple.

if(s0 == 30) {
block A
}
block B

bne s0, 30, blockB
blockA:
blockB:

16

A simple conditional block (if)
● If there is no else, it's pretty simple.

if(s0 == 30) {
block A
}
block B

bne s0, 30, blockB

In Java/C what happens in an if?
You JUMP OVER when the condition is true or
false?

When its FALSE!!

17

A simple conditional block (if)

●In MIPS you jump when the condition is TRUE
if(s0 == 30) {
block A
}
block B

bne s0, 30, blockB
blockA:
block A
blockB:
block B

18

An if-else with a simple condition
● more blocks now…

if(s0 == 30) {
block A
}
else {
block B
}
block C

bne s0, 30, blockB
block A
j blockC
blockB:
block B
blockC:
block C

we NEED THIS – the CPU doesn't
see/care about your labels!!

19

The other way around
● Because in HLL we “execute smth if” and In assembly we “jump over if”
● We usually negate the condition in the assembly to skip over code
o It’s a preference.
o You can still invert the process
 How?
if(s0 == 30) {
}
else {
}

block A
block B

block C

beq s0, 30, blockA
j blockElse
blockA:
block A
j blockExit # skip the else
blockElse:
block B
blockExit:
block C
20

MIPS ISA: conditional branch instructions
● MIPS also supports instructions that compare to zero

Instruction

Meaning

bltz a, label

if(a < 0) { goto label }

blez a, label

if(a <= 0) { goto label }

bgtz a, label

if(a > 0)

bgez a, label

if(a >= 0) { goto label }

{ goto label }

21

MIPS ISA: set if less than
● And…

Instruction
slt

c, a, b

Meaning
if(a < b) { c = 1 } else { c = 0 }

Set if Less Than: register c will be set to 1 if a<b.
Otherwise, register c will be set to 0.
Using slt together with bne and beq all conditionals can be implemented!
a=b , a≠b, a>b, a≥b, a<b, a≤b

Thanks, De Morgan

22

MIPS ISA: conditional branch instructions
● Or… we can just use the pseudo-instructions :D

Instruction

Meaning

blt a, b, label

if(a < b)

{ goto label }

ble a, b, label

if(a <= b) { goto label }

bgt a, b, label

if(a > b)

bge a, b, label

if(a >= b) { goto label }

{ goto label }

above, a must be a register, but b can be a register or immediate

23

Examples
Example 1: branch if a>b
bgt a, b, label

# Goto label if a>b

Solution: branch if b<a
slt t, b, a
bne t, zero, label

# t=1 if b<a
# Goto label if t≠0

Example 2: branch if a≥b
bge a, b, label

# Goto label if a≥b

Solution: branch if !(a<b)
slt t, a, b
beq t, zero, label

# t=1 if a<b
# Goto label if t=0
24

Complex conditionals

25

In this code…
if(dog_size < 10 || dog_name() == "Fluffy")

if dog_size is 3, is dog_name() called?

NO!

this is short circuit evaluation.

for || (logical OR), if the first condition is true, the
second one is skipped. (cause there's no way for
the result of the OR to be false.)
for && (logical AND), if the first condition is
false, the second one is skipped.

26

In this code…
if(dog_size < 10)
small();
if dog_size is 3, is this
else if(dog_size < 20)
condition checked?
medium();
NO!
else if(dog_size < 30)
large();
else
once a true condition is found, no
enormous();
more conditions are checked.
after small(), it comes down here.

27

And-and!
● Block A is run if both conditions are true.
o to think of it another way… it's skipped if? What’s the inverse?
o either condition is false…

if(s0 == 30 &&
s1 > 1) {
block A
}

bne s0, 30, skipA
ble s1, 1, skipA
block A
skipA:

28

Or-or!
● We go to block A if either condition is true.
o to think of it another way… it's skipped if? What’s the inverse?
o all conditions are false.

if(s0 == 30 ||
s1 > 1)
{
block A
}

beq s0, 30, blockA
ble s1, 1, skipA
blockA:
block A
skipA:
29

Looooops
o o
o
o
o
o
oo oo
30

Dis-assembling a for-loop
● How does a for loop work?

What is the first thing a for does?

Initialize: i=0
for(i=0; i<10; i++) And???
Check condition:
{
execute while i<10
block A
Then…
}
// carry on
block A
Finally?

Increment: i++
Go back up to the top

31

Looping in MIPS assembly
What’s the first
li
s0,
0
__________ thing a for
loop_top:
does?
for(i=0; i<10; i++)
which conditional branch?
__________________
{
block A
block A
}
How do we
// carry on
increment?
addi s0, s0, 1
_______________
j loop_top
____________
Let’s start with a
How do
recipe
carry_on:
we go up?
# carry on

● Let’s use s0 to hold i

32

That’s bge, actually
We want to leave the loop…
when the opposite of i<10
happens!
● In HLL we “execute smth if”
● In assembly we “jump over if”
● Thus negate the condition in
the assembly to skip over
code

li s0, 0
__________
loop_top:
bge s0, 10, carry_on
_____________________
s0
move a0, ___
li v0, 1
syscall
addi s0, s0, 1
_______________
j loop_top
____________
carry_on:
# carry on
33

The other way around
li s0, 0
__________
loop_top:
blt s0, 10, loop_code
b carry_on
loop_code:
s0
move a0, ___
li v0, 1
syscall
addi s0, s0, 1
_______________
j loop_top
____________
carry_on:
# carry on

34

While looks the same, no initialization or increment

while(s2 < 10)
{
// stuff!!
}
// more stuff

loop_top:
bge s2, 10, more_stuff
________
stuff:
# stuff!!
j loop_top
more_stuff:
# more stuff

35

