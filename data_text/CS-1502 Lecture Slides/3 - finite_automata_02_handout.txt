Finite Automata 02
Thumrongsak Kosiyatrakul
tkosiyat@cs.pitt.edu

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Finite Automata 02

Finite Automata
The computational model called finite automata can be used
to simulate a set of simple algorithms
Check whether a string starts with 010
Check whether a string ends with 111
Check whether a string contains 0101 as a substring
Check whether a string contains substrings 000 and 111 where
000 comes before 111

It is a powerful tool in compiler
Accept or reject your source code based on a programming
syntax
Example: the for statement:
starts with for
followed by (
followed by assignment statement(s)
followed by ;
followed by conditional statement(s)
followed by ;
followed by assignment statement(s)
followed by )
Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Finite Automata 02

Formal Definition of Computation

Let M = (Q, Σ, δ, q0 , F ) be a finite automaton and let
w = w1 w2 . . . wn be a string where each wi is a member of
the alphabet Σ.
M accepts w if a sequence of states r0 , r1 , . . . , rn in Q exists
with three conditions:
1
2
3

r0 = q 0
δ(ri , wi+1 ) = ri+1 , where i = 0, . . . , n − 1
rn ∈ F

Think in terms of processing the input string w
w

w

w

w

w

wn−1

w

r0 →1 r1 →2 r2 →3 r3 →4 r4 →5 . . . → rn−1 →n rn

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Finite Automata 02

Regular Languages
A language L over an alphabet Σ is said to be a regular
language if some finite-state automaton recognizes it.
Consider the following machine M :
0

0
1

q0

q1

1

What is the language of this machine?
L(M ) = {w | w contains an odd number of 1s}

“The set of all strings consisting of an odd number of 1s” is a
regular language
L(M ) is a regular language

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Finite Automata 02

Regular Languages

Why regular language is important in our discussion?
Definition: A language is regular if some finite-state machines
recognize it.
If we can prove that a language is regular
We must be able to construct a finite-state machine to
recognize it
It maybe hard to build but I know that it exists

If we can prove that a language is not regular
We cannot construct a finite-state machine to recognize it

This is an example of a limitation of this computational model

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Finite Automata 02

Problem and Language
In theory of computation, a problem is represented as a
language
A problem of determining whether a string contains 011 as a
substring
L(M ) = {x | x contains 011 as a substring}
We already see a Deterministic Finite Automaton (DFA) M
that accepts all strings that contains 011 as a substring and
reject those that does not contain 011 as a substring
It means this problem is solvable by the algorithm captured by
the previous DFA
In case of algorithm in a form of DFA (not all algorithms)
if L(M ) is regular, the problem represented by L(M ) is
solvable
if L(M ) is not regular, no DFA exists, the problem
represented by L(M ) is unsolvable

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Finite Automata 02

Problems and Languages
Solvable problems that we see so far
The problem of determining whether a string ends with a 1
{x | x ends with a 1}
The problem of determining whether a string is an empty
string or ends in a 0
{x | x is an empty string or ends in a 0}
The problem of determining whether a string starts and ends
with the same symbol
{x | x starts and ends with the same symbol}
The problem of determining whether a string contains either
11 or 00 as a substring
{x | x contains either 11 or 00 as a substring}
Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Finite Automata 02

Problems and Languages
Solvable problems that we see so far (continue)
The problem of determining whether a string contains 011 as a
substring
{x | x contains 011 as a substring}
The problem of determining whether a string ends with 0110
{x | x ends with 0110}
The problem of determining whether a string contains an odd
number of 1s
{x | x contains an odd number of 1s}

Each of the above languages is regular since we can construct
a DFA that recognizes it.
But if a language is very complicate, it will be difficult to
construct a DFA that recognizes it

We need tools to help us to determine whether a language is
regular or not
Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Finite Automata 02

The Regular Operations
In arithmetic:
Objects are numbers
Tools are operations for manipulating numbers (e.g., + and ×)
1 + 1 gives you a new number which is 2

In the theory of computation,
Objects are languages (sets of strings)
Tools are operations for manipulating languages

Definition 1.23
Let A and B be languages. We define the regular operations as
follows:
Union: A ∪ B = {x | x ∈ A or x ∈ B}
Concatenation: A ◦ B = {xy | x ∈ A and y ∈ B}
Star: A∗ = {x1 x2 . . . xk | k ≥ 0 and each xi ∈ A}
Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Finite Automata 02

Examples (Union)

Let Σ = {0, 1}
Consider the following languages A and B
A = {00, 11}
B = {010, 101}

The union operations is identical to the set’s union operation:
A ∪ B = {x | x ∈ A or x ∈ B}
From the above definition:
A ∪ B = {00, 11, 010, 101}

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Finite Automata 02

Examples (Concatenation)

Let Σ = {0, 1}
Consider the following languages A and B
A = {00, 11}
B = {010, 101}

The definition of concatenation is defined as
A ◦ B = {xy | x ∈ A and y ∈ B}
From the above definition:
A ◦ B = {00010, 00101, 11010, 11101}
For simplicity, sometimes we write AB instead of A ◦ B

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Finite Automata 02

Examples (Star)
Let Σ = {0, 1}
Consider the following language A
A = {00, 11}

The definition of start is defined as
A∗ = {x1 x2 . . . xk | k ≥ 0 and xi ∈ A}
If k = 0, the above definition becomes
{ | 0 ≥ 0} = {ε}
If k = 1, the above definition becomes
{x1 | 1 ≥ 0 and xi ∈ A} = {00, 11}
If k = 2, the above definition becomes
{x1 x2 | 2 ≥ 0 and xi ∈ A} = {0000, 0011, 1100, 1111}
If k = 3, the above definition becomes
{x1 x2 x3 | 3 ≥ 0 and xi ∈ A} = {000000, 000011, . . . , 111111}
Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Finite Automata 02

Examples (Star)
Let Σ = {0, 1}
Suppose A = {00, 11}, what is A∗ ?
A∗ = {ε, 00, 11, 0000, 0011, 1100, 1111, 000000, . . . }
Suppose A = {011}, what is A∗ ?
A∗ = {ε, 011, 011011, 011011011, 011011011011, . . . }
Suppose A = {0, 1}, what is A∗ ?
A∗ = {ε, 0, 1, 00, 01, 10, 11, 000, 001, 010, 011, 100, . . . }
This is the set of all strings over {0, 1}
Suppose A = ∅, what is A∗ ?
A∗ = {ε}
Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Finite Automata 02

Definition of Closed Under Operations

Let A be a set of objects (a collection of object)
We say that A is closed under operation 4 if for any x ∈ A
and y ∈ A, x4y is also in A.
Example: Let N be the set of natural number
N is closed under addition
For any two natural numbers x and y, x + y is a natural
number

N is closed under multiplication
For any two natural numbers x and y, x × y is a natural
number

N is not closed under subtraction
5 − 7 is not a natural number

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Finite Automata 02

Definition of Closed Under Operations

Let L be the set of all regular languages
This is a set of sets

Recall that we have three operations, union, concatenation,
and star
Is L closed under union operation?
For any regular languages A and B, is A ∪ B a regular
language?

Is L closed under concatenation operation?
For any regular languages A and B, is A ◦ B a regular
language?

Is L closed under star operation?
For any regular language A, is A∗ a regular language?

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Finite Automata 02

L is regular under union operation
Let A be a set of strings over {0, 1} that contain a 00 as a
substring
Is A a regular language?
Can you construct a DFA that recognizes the language A?
One of the machine that recognizes A can be as follows:
1

0,1

0

qa

0

qb

qc

1

Because there exists a DFA that recognizes A, A is a regular
language

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Finite Automata 02

L is regular under union operation

Let B be a set of strings over {0, 1} that end with a 1
Is B a regular language?
Can you construct a DFA that recognizes the language B?
One of the machine that recognizes B can be as follows:
0

1
1

q0

q1
0

Because there exists a DFA that recognizes B, B is a regular
language

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Finite Automata 02

L is regular under union operation
We have A = {x | x contains 00 as a substring} is regular
We have B = {x | x ends with a 1} is regular
How about A ∪ B?
A ∪ B = {x | x contains 00 as a substring or x ends with a 1}
It is quite straightforward to construct a machine that
recognizes A ∪ B (try to build one yourself)
1

0,1

0
1
1
0

0

This does not prove that if A and B are regular, A ∪ B is
regular
This is just one example out of infinite may instances of
regular languages
Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Finite Automata 02

L is regular under union operation
We need to show that for any two regular languages A and B,
A ∪ B is regular
Given a regular language A over a Σ, what do we know about
the language A?
There exists a DFA MA that recognizes A (L(MA ) = A)
MA = (QA , Σ, δA , qA , FA ) for some QA , δA , qA , and FA

Similarly, given a regular language B over a Σ:
There exists a DFA MB that recognizes B (L(MB ) = B)
MB = (QB , Σ, δB , qB , FB ) for some QB , δB , qB , and FB

To show that A ∪ B is regular for any regular languages A
and B, we need to construct a DFA that recognizes A ∪ B
from MA and MB
To understand the process, we are going to work on a specific
example

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Finite Automata 02

L is regular under union operation
Recall the previous two regular languages and its DFAs where
Σ = {0, 1}
A = {x | x contains 00 as a substring}
1

0,1

0

qa

0

qb

qc

1

MA = (QA , Σ, δA , qA , FA ) and L(MA ) = A
B = {x | x ends with a 1}
0

1
1

q0

q1
0

MB = (QB , Σ, δB , qB , FB ) and L(MB ) = B

Given a string w and these two DFAs, how to check whether
w is in A ∪ B?
Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Finite Automata 02

L is regular under union operation
Recall that A = L(MA ) and B = L(MB )
Thus, A ∪ B = L(MA ) ∪ L(MB )

w ∈A∪B
iff w ∈ A or w ∈ B
iff w ∈ L(MA ) or w ∈ L(MB )
iff MA accepts w or w ∈ L(MB )
iff MA accepts w or MB accepts w

In other words,
w ∈ A ∪ B if and only if MA accepts w or MB accepts w
To check whether w ∈ A ∪ B:
Run both MA and MB on input w
If one of them or both accepts w, w ∈ A ∪ B
If both reject w, w 6∈ A ∪ B

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Finite Automata 02

L is regular under union operation
We can run both machines simultaneously
1

0,1

0

1
1

0

qa

0

qb

qc

q0

q1

1
0

Let state (p, q) represents the situation where
The current state of MA is p
The current state of MB is q

With the new notion of states, we have
0

(qa , q0 )
1
1
1

(qa , q1 )

0

(qb , q0 )
0

0

1

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

(qb , q1 )

Finite Automata 02

(qc , q0 )
0

0
1

(qc , q1 )

1

L is regular under union operation
Let MA recognizes A, where MA = (QA , Σ, δA , qA , FA )
Let MB recognizes B, where MB = (QB , Σ, δB , qB , FB )
Machine M = (Q, Σ, δ, q0 , F ) that recognizes A ∪ B can be
constructed as follows:
1
2

Q = {(r1 , r2 ) | r1 ∈ QA and r2 ∈ QB }
For each (r1 , r2 ) ∈ Q and a ∈ Σ
δ((r1 , r2 ), a) = (δA (r1 , a), δB (r2 , a))

3
4

q0 = (qA , qB )
F = {(r1 , r2 ) | r1 ∈ FA or r2 ∈ FB }

To recognize A ∩ B, simply change the set of accept states to
F = {(r1 , r2 ) | r1 ∈ FA and r2 ∈ FB }
If A and B are regular languages, A ∪ B is regular
Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Finite Automata 02

Conclusions

A language is regular if it is recognized by some finite-state
machines
If you can prove that a language is regular:
there exists a finite-state machine that recognizes it

If you can prove that a language is not regular:
there is no finite-state machine that recognizes it

In formally, we show that if A and B are regular languages,
A ∪ B is a regular language
To prove the closure of concatenation and star operators, we
need a sightly different computational model

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Finite Automata 02

