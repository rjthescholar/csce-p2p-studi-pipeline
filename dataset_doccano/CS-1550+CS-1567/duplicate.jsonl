{"id":302,"course": "cs1550", "lec": "lec26", "text":"Introduction to Operating Systems\nCS 1550\nSpring 2022\n\nSherif Khattab\nksm73@pitt.edu\n(Some slides are from Silberschatz, Galvin and Gagne ©2013)\n\n\fAnnouncements\n• Upcoming deadlines:\n• Homework 12: due on 4\/25\n• Lab 5: due on 5\/2\n• Project 4 and Quiz 4: due on 5\/2\n• Bonus Opportunities\n• Bonus Homework: due on 5\/2\n• Course Post-Test: due on 5\/2\n• Bonus point for all when OMET response rate >= 80%\n•\n\nCurrently at 36%\n\n•\n\nDeadline is Sunday 4\/24\n\n• Final Exam\n• Open book and open notes\nCS 1550 – Operating Systems – Sherif Khattab\n\n2\n\n\fPrevious Lecture …\n• OS Protection\n• Access Control Matrix\n\nCS 1550 – Operating Systems – Sherif Khattab\n\n3\n\n\fMuddiest Points\n• Can I use my laptop for the open book exam? Or should I print\nout the information I need?\n• Also, can you go over the top hat question for the access\nmatrix again? Is it because dom 2 does not have modify for\ndom 2 itself? What if dom 2 has modify for dom 2?\n• Could a domain modify access to itself?\n• can you release more practice exam answer keys? i worry that\ni will study the wrong approach if i can’t verify my answers\n• ACL permissions (3 bit representations)\n• special flags in ACL\n• everything :\/\n• How the table thing works and how you can determine which\nthings can\/can't be read\/written\n• How did the soccer matches go ?\n• homework 12 question explained in class\nCS 1550 – Operating Systems – Sherif Khattab\n\n4\n\n\fProtection\n• Protection is about controlling access of programs,\nprocesses, or users to the system resources (e.g.,\nmemory pages, files, devices, CPUs)\n• How to decide who can access what?\n• Specifications must be\n• Correct\n• Efficient\n• Easy to use (or nobody will use them!)\n\nCS 1550 – Operating Systems – Sherif Khattab\n\n5\n\n\fDomains as objects in the protection matrix\nDomain\n\n•\n\n•\n\nFile1\n\nFile2\n\n1 Read\n\nRead\nWrite\n\nFile3\n\nFile4\n\nFile5\n\nPrinter1\n\nCamera\n\nDom1\n\nDom2\n\nDom3\n\nModify\n\n2\n\nRead\n\n3\n\nWrite\n\nRead\nWrite\nExecute\n\nRead\nWrite\n\nWrite\n\nWrite\n\nModify\n\nRead\n\nEnter\n\nSpecify permitted operations on domains in the matrix\n•\n\nDomains may (or may not) be able to modify themselves\n\n•\n\nDomains can modify other domains\n\n•\n\nSome domain transfers (switching) permitted, others not\n\nDoing this allows flexibility in specifying domain permissions\n•\n\nRetains ability to restrict modification of domain policies\nCS 1550 – Operating Systems – Sherif Khattab\n\n6\n\n\fCapabilities\n•\n\nEach process has a capability\nlist\n\n•\n\nList has one entry per object\nthe process can access\n•\n\nObject name\n\n•\n\nObject permissions\n\n•\n\nObjects not listed are not\naccessible\n\n•\n\nHow are these secured?\n•\n\nKept in kernel\n\n•\n\nCryptographically secured\n\nProcess\nA\n\nProcess\nB\n\nFile1: <R,W>\nFile2: <R>\nFile3: <R,W,X>\n\nFile2: <R,W>\nFile4: <R,W,X>\nFile7: <W>\nFile9: <R,W>\n\nCS 1550 – Operating Systems – Sherif Khattab\n\n7\n\n\fCryptographically protected capability\nServer\n\n•\n\n•\n\nObject\n\nRights\n\nH(Object,Rights,Check)\n\nRights include generic rights (read, write, execute) and\n•\n\nCopy capability\n\n•\n\nCopy object\n\n•\n\nRemove capability\n\n•\n\nDestroy object\n\nServer has a secret (Check) and uses it to verify capabilities presented to it\n•\n\nAlternatively, use public-key signature techniques\n\nCS 1550 – Operating Systems – Sherif Khattab\n\n8\n\n\fProtecting the access matrix: summary\n• OS must ensure that the access matrix isn’t modified\n(or even accessed) in an unauthorized way\n• Access control lists\n• Reading or modifying the ACL is a system call\n• OS makes sure the desired operation is allowed\n\n• Capability lists\n• Can be handled the same way as ACLs: reading and\nmodification done by OS\n• Can be handed to processes and verified\ncryptographically later on\n• May be better for widely distributed systems where capabilities\ncan’t be centrally checked\nCS 1550 – Operating Systems – Sherif Khattab\n\n9\n\n\fReference monitor\n\nAll system calls go\nthrough the reference\nmonitor for security\nchecking\n\nProcess\nA\n\nReference monitor\n\nUser\nspace\n\nKernel\nspace\n\nTrusted computing base\nOperating system kernel\n\nCS 1550 – Operating Systems – Sherif Khattab\n\n10\n\n\f•\n\nFormal models of secure systems\nLimited set of primitive operations on access matrix\n•\n\nCreate\/delete object\n\n•\n\nCreate\/delete domain\n\n•\n\nInsert\/remove right\n\n•\n\nPrimitives can be combined into protection commands\n\n•\n\nOS can enforce policies, but can’t decide what policies are\nappropriate\n\n•\n\nQuestion: is it possible to go from an “authorized” matrix to an\n“unauthorized” one?\n•\n\nIn general, undecidable\n\n•\n\nMay be provable for limited cases\n\nCS 1550 – Operating Systems – Sherif Khattab\n\n11\n\n\fBell-La Padula multilevel security model\n•\n\nProcesses, objects have\nsecurity level\n\n•\n\nSimple security property\n\n•\n\n•\n\nProcess at level k can only read\nobjects at levels k or lower\n\n* property\n•\n\nProcess at level k can only write\nobjects at levels k or higher\n\n4\n3\n\n•\n\nThese prevent information\n2\nfrom leaking from higher levels\nto lower levels\n\n•\n\nRead down, write up\n\n1\n\n3\n\n5\n\nE\n\n6\n\nC\n\n4\n\nD\n\nB\n\n2\n\n1\n\nA\n\nCS 1550 – Operating Systems – Sherif Khattab\n\nA writes 4\n\n12\n\n\fBiba multilevel integrity model\n• Principles to guarantee integrity of data\n• Simple integrity principle\n• A process can write only objects at its security level or\nlower\n• No way to plant fake information at a higher level\n\n• The integrity * property\n• A process can read only objects at its security level or\nhigher\n\n• Read up, write down\n• Biba is in direct conflict with Bell-La Padula\n• Difficult to implement both at the same time!\nCS 1550 – Operating Systems – Sherif Khattab\n\n13\n\n\fCovert channels\n• Circumvent security model by using more subtle\nways of passing information\n• Can’t directly send data against system’s wishes\n• Send data using “side effects”\n• Allocating resources\n• Using the CPU\n\n• Locking a file\n• Making small changes in legal data exchange\n\n• Very difficult to plug leaks in covert channels!\n\nCS 1550 – Operating Systems – Sherif Khattab\n\n14\n\n\fCovert channel using file locking\n• Exchange information using file locking\n• Assume n+1 files accessible to both A and B\n\n• A sends information by\n• Locking files 0..n-1 according to an n-bit quantity to be\nconveyed to B\n• Locking file n to indicate that information is available\n\n• B gets information by\n• Reading the lock state of files 0..n+1\n• Unlocking file n to show that the information was received\n\n• May not even need access to the files (on some\nsystems) to detect lock status!\nCS 1550 – Operating Systems – Sherif Khattab\n\n15\n\n\fCovert Channel Using File Locking\n\nCS 1550 – Operating Systems – Sherif Khattab\n\n16\n\n\fSteganography\n• Hide information in other data\n• Picture on right has text of 5 Shakespeare plays\n• Encrypted, inserted into low order bits of color values\n\nZebras\n\nHamlet, Macbeth, Julius Caesar\nMerchant of Venice, King Lear\nCS 1550 – Operating Systems – Sherif Khattab\n\n17\n\n\fProtection vs Security\nProtection is an internal problem\n• Assumes users are authenticated and programs are run\nonly by authorized users\n\nSecurity = Protection + defending attacks from\nexternal environment\n\nCS 1550 – Operating Systems – Sherif Khattab\n\n18\n\n\f•\n\n•\n\nSecurity environment: threats\nGoal\n\nThreat\n\nData confidentiality\n\nExposure of data\n\nData integrity\n\nTampering with data\n\nSystem availability\n\nDenial of service\n\nSecurity goals:\n•\n\nConfidentiality\n\n•\n\nIntegrity\n\n•\n\nAvailability\n\nSomeone attempts to subvert the goals\n•\n\nFun\n\n•\n\nCommercial gain\n\nCS 1550 – Operating Systems – Sherif Khattab\n\n19\n\n\fProblem of the Day 1: Password Attacks\n• Passwords can be\n• stolen,\n• guessed, or\n• cracked\n\n• How would you defend against these attacks?\n\nCS 1550 – Operating Systems – Sherif Khattab\n\n20\n\n\fUser authentication\n• Problem: how does the computer know who you are?\n• Solution: use authentication to identify\n• Something the user knows\n• Something the user has\n• Something the user is\n\n• This must be done before user can use the system\n\n• Important: from the computer’s point of view…\n• Anyone who can duplicate your ID is you\n• Fooling a computer isn’t all that hard…\n\nCS 1550 – Operating Systems – Sherif Khattab\n\n21\n\n\fPassword Stealing\n• Stealing the password file\n• Social Engineering\n• e.g., spoofing login screen\n\n• Key loggers\n• e.g., trojan horse programs\n\nCS 1550 – Operating Systems – Sherif Khattab\n\n22\n\n\fHow should an OS store passwords?\n• Passwords should be memorable?\n• Passwords shouldn’t be stored “in the clear”\n• Password file is often readable by all system users!\n• Password must be checked against entry in this file\n\n• Solution: use hashing to hide “real” password\n• One-way function converting password to meaningless\nstring of digits (Unix password hash, SHA-2)\n• Difficult to find another password that hashes to the same\nstring\n• Knowing the hashed value and hash function gives no\nclue to the original password\n\nCS 1550 – Operating Systems – Sherif Khattab\n\n23\n\n\fStoring passwords\n• Some OSs use encryption algorithms to hash the\npasswords\n• Use the password as the key, not the plain text\n\n• But, what is encryption?\n\nCS 1550 – Operating Systems – Sherif Khattab\n\n24\n\n\fCryptography\n• Goal: keep information from those who aren’t\nsupposed to see it\n• Do this by “scrambling” the data\n\n• Use a well-known algorithm to scramble data\n• Algorithm has two inputs: data & key\n• Key is known only to “authorized” users\n• Relying upon the secrecy of the algorithm is a very bad\nidea (see WW2 Enigma for an example…)\n\n• Cracking codes is very difficult, Sneakers and other\nmovies notwithstanding\n\nCS 1550 – Operating Systems – Sherif Khattab\n\n25\n\n\fCryptography basics\n•\n\nAlgorithms (E, D) are widely known\n\n•\n\nKeys (KE, KD) may be less widely distributed\n\n•\n\nFor this to be effective, the ciphertext should be the only\ninformation that’s available to the world\n\n•\n\nPlaintext is known only to the people with the keys (in an ideal\nworld…)\n\nEncryption\nkey\n\nP\n\nKE\n\nKD\n\nC=E(P,KE)\n\nE\n\nPlaintext\n\nD\n\nP\nPlaintext\n\nCiphertext\nEncryption\n\nDecryption\nkey\n\nDecryption\n\nCS 1550 – Operating Systems – Sherif Khattab\n\n26\n\n\fSecret-key encryption\n•\n\nAlso called symmetric-key encryption\n\n•\n\nMonoalphabetic substitution\n\n•\n\n•\n\nEach letter replaced by different letter\n\nVigenere cipher\n•\n\nUse a multi-character key\nTHEMESSAGE\nELMELMELME\nXSQQPEWLSI\n\n•\n\nBoth are easy to break!\n\n•\n\nGiven the encryption key, easy to generate the decryption key\n\n•\n\nAlternatively, use different (but similar) algorithms for encryption\nand decryption\n\nCS 1550 – Operating Systems – Sherif Khattab\n\n27\n\n\fModern encryption algorithms\n• Data Encryption Standard (DES)\n• Uses 56-bit keys\n• Same key is used to encrypt & decrypt\n• Keys used to be difficult to guess\n• Needed to try 255 different keys, on average\n• Modern computers can try millions of keys per second with\nspecial hardware\n• For $250K, EFF built a machine that broke DES quickly in 1998\n\n• Current algorithms (AES, Blowfish) use 128 bit keys\n• Adding one bit to the key makes it twice as hard to guess\n• Must try 2127 keys, on average, to find the right one\n• At 1015 keys per second, this would require over 1021\nseconds, or 1000 billion years!\n• Modern encryption isn’t usually broken by brute force…\nCS 1550 – Operating Systems – Sherif Khattab\n\n28\n\n\f•\n\n•\n\nUnbreakable codes\nThere is such a thing as an unbreakable code: one-time pad\n•\n\nUse a truly random key as long as the message to be encoded\n\n•\n\nXOR the message with the key a bit at a time\n\nCode is unbreakable because\n•\n\nKey could be anything\n\n•\n\nWithout knowing key, message could be anything with the correct number\nof bits in it\n\n•\n\nDifficulty: distributing key is as hard as distributing message\n\n•\n\nDifficulty: generating truly random bits\n•\n\nCan’t use computer random number generator!\n\n•\n\nMay use physical processes\n•\n\nRadioactive decay\n\n•\n\nLeaky diode\n\n•\n\nLava lamp (!) [https:\/\/www.atlasobscura.com\/places\/encryption-lava-lamps]\nCS 1550 – Operating Systems – Sherif Khattab\n\n29\n\n\fPublic-key cryptography\n• Instead of using a single shared secret, keys come in\npairs\n• One key of each pair distributed widely (public key), Kp\n\n• One key of each pair kept secret (private or secret key),\nKs\n• Two keys are inverses of one another, but not identical\n• Encryption & decryption are the same algorithm, so\nE(Kp,E(Ks,M) = E(Ks,E(Kp,M) = M\n\n• Currently, most popular method involves primes and\nexponentiation\n• Difficult to crack unless large numbers can be factored\n\n• Very slow for large messages\nCS 1550 – Operating Systems – Sherif Khattab\n\n30\n\n\fDigital signatures\n\nOriginal\ndocument\n\nOne-way\nhash\nfunction\n\nHash\n\nHash result\nencrypted\nwith Ks\n\nDigital\nsignature\n\nReceiver gets\n\n•\n\n•\n\nOriginal\ndocument\n\nDigital\nsignature\n\nDigital signature computed by\n•\n\nApplying one-way hash function to original document\n\n•\n\nEncrypting result with sender’s private key\n\nReceiver can verify by\n•\n\nApplying one-way hash function to received document\n\n•\n\nDecrypting signature using sender’s public key\n\n•\n\nComparing the two results: equality means document unmodified\nCS 1550 – Operating Systems – Sherif Khattab\n\n31\n\n\f•\n\nPretty Good Privacy (PGP)\nUses public key encryption\n•\n\nFacilitates key distribution\n\n•\n\nAllows messages to be sent encrypted to a person (encrypt with person’s\npublic key)\n\n•\n\nAllows person to send message that must have come from her (encrypt\nwith person’s private key)\n\n•\n\nProblem: public key encryption is very slow\n\n•\n\nSolution: use public key encryption to exchange a shared key\n\n•\n\n•\n\nShared key is relatively short (~128 bits)\n\n•\n\nMessage encrypted using symmetric key encryption\n\nPGP can also be used to authenticate sender\n•\n\nUse digital signature and send message as plaintext\n\nCS 1550 – Operating Systems – Sherif Khattab\n\n32\n\n\fSocial Engineering\n• Convince a system programmer to add a trap door\n• Beg admin's secretary (or other people) to help a poor user\nwho forgot password\n\n• Pretend you’re tech support and ask random users for their\nhelp in debugging a problem\n\nCS 1550 – Operating Systems – Sherif Khattab\n\n33\n\n\fLogin spoofing\nLogin:\n\nLogin:\n\nReal login screen\n\nPhony login screen\n\n•\n\nNo difference between real & phony login screens\n\n•\n\nIntruder sets up phony login, walks away\n\n•\n\nUser logs into phony screen\n\n•\n\n•\n\nPhony screen records user name, password\n\n•\n\nPhony screen prints “login incorrect” and starts real screen\n\n•\n\nUser retypes password, thinking there was an error\n\nSolution: don’t allow certain characters (ctrl+alt+delete) to be “caught”\nCS 1550 – Operating Systems – Sherif Khattab\n\n34\n\n\f•\n\n•\n•\n\nTrojan horses\nFree program made available to unsuspecting user\n•\n\nActually contains code to do harm\n\n•\n\nMay do something useful as well…\n\nAltered version of utility program on victim's computer\n•\n\nTrick user into running that program\n\nExample (getting superuser access?)\n•\n\nPlace a file called ls in your home directory\n•\n\nFile creates a shell in \/tmp with privileges of whoever ran it\n•\n\n•\n\ncp \/bin\/bash \/tmp\/.SecretShell && chmod 4755 \/tmp\/.SecretShell\n\nFile then actually runs the real ls\n\n•\n\nComplain to your sysadmin that you can’t see any files in your directory\n\n•\n\nSysadmin runs ls in your directory\n•\n\nHopefully, he runs your ls rather than the real one (depends on his search path)\nCS 1550 – Operating Systems – Sherif Khattab\n\n35\n\n\fBuffer overflow\nStack\npointer\n\nVariables\nfor main()\n\nSP\nCode\n\n•\n\n•\n\n•\n\nVariables\nfor main()\n\nVariables\nfor main()\n\nReturn addr\n\nReturn addr\n\nA’s local\nvariables\n\nA’s local\nvariables\n\nBuffer B\n\nSP\n\nCode\n\nBuffer B\n\nCode\n\nAltered\nreturn\naddress\n\nBuffer overflow is a big source of bugs in operating systems\n•\n\nMost common in user-level programs that help the OS do something\n\n•\n\nMay appear in “trusted” daemons\n\nExploited by modifying the stack to\n•\n\nReturn to a different address than that intended\n\n•\n\nInclude code that does something malicious\n\nAccomplished by writing past the end of a buffer on the stack\nCS 1550 – Operating Systems – Sherif Khattab\n\n36\n\n\fProblem of the Day 1: Password Attacks\n• Passwords can be\n• stolen,\n• guessed, or\n• cracked\n\n• How would you defend against these attacks?\n\nCS 1550 – Operating Systems – Sherif Khattab\n\n37\n\n\fPassword Guessing: Sample breakin (from LBL)\n\nLBL> telnet elxsi\nELXSI AT LBL\nLOGIN: root\nPASSWORD: root\nINCORRECT PASSWORD, TRY AGAIN\nLOGIN: guest\nPASSWORD: guest\nINCORRECT PASSWORD, TRY AGAIN\nLOGIN: uucp\nPASSWORD: uucp\nWELCOME TO THE ELXSI COMPUTER AT LBL\n\nMoral: change all the default system passwords!\nCS 1550 – Operating Systems – Sherif Khattab\n\n38\n\n\fPassword Cracking\n• Offline cracking\n• The attacker has the password files\n• password files contains password hashes\n\n• Online cracking\n• The attacker doesn’t have the password file\n\nCS 1550 – Operating Systems – Sherif Khattab\n\n39\n\n\f•\n\nOffline Password Cracking\nPasswords can be cracked\n•\n\nHackers can get a copy of the password file\n\n•\n\nRun through dictionary words and names\n•\n\nHash each name\n\n•\n\nLook for a match in the file\n\n•\n\nHashes can be pre-computed offline!\n\n•\n\nSolution: use “salt”\n•\n\nRandom characters added to the password before hashing\n\n•\n\nSalt characters stored “in the clear”\n\n•\n\nIncrease the number of possible hash values for a given password\n\n•\n\n•\n\nActual password is “pass”\n\n•\n\nSalt = “aa” => hash “passaa”\n\n•\n\nSalt = “bb” => hash “passbb”\n\nResult: cracker has to store many more combinations\nCS 1550 – Operating Systems – Sherif Khattab\n\n40\n\n\fOnline Password Cracking\n\nLogin: elm\nPassword: foobar\n\nLogin: jimp\nUser not found!\n\nWelcome to Linux!\n\nLogin:\nLogin:\n\n•\n\nSuccessful login lets the user in\n\n•\n\nIf things don’t go so well…\n\n•\n\nLogin: elm\nPassword: barfle\nInvalid password!\n\n•\n\nLogin rejected after name entered\n\n•\n\nLogin rejected after name and incorrect password entered\n\nDon’t notify the user of incorrect user name until after the\npassword is entered!\n•\n\nEarly notification can make it easier to guess valid user names\nCS 1550 – Operating Systems – Sherif Khattab\n\n41\n\n\fCountermeasures\n• Limiting times when someone can log in\n• Automatic callback at number prespecified\n• Can be hard to use unless there’s a modem involved\n\n• Limited number of login tries\n• Prevents attackers from trying lots of combinations quickly\n\n• A database of all logins\n\n• Simple login name\/password as a trap\n• Security personnel notified when attacker bites\n• Variation: allow anyone to “log in,” but don’t let intruders\ndo anything useful\nCS 1550 – Operating Systems – Sherif Khattab\n\n42\n\n\fSecurity flaws: TENEX OS password problem\n• Cracking passwords using side-channel attack\n\nFirst page\n(in memory)\n\nSecond page\n(not in memory)\n\nA\nA\nA\nA\nA\nA\nA\nA\n\nPage\nboundary\n\nB\nA\nA\nA\nA\nA\nA\nA\n\nCS 1550 – Operating Systems – Sherif Khattab\n\nB\nA\nA\nA\nA\nA\nA\nA\n\n43\n\n\fAuthentication using a physical object\n\n•\n\n•\n\nMagnetic card\n•\n\nStores a password encoded in the magnetic strip\n\n•\n\nAllows for longer, harder to memorize passwords\n\nSmart card\n•\n\nCard has secret encoded on it, but not externally readable\n\n•\n\nRemote computer issues challenge to the smart card\n\n•\n\nSmart card computes the response and proves it knows the secret\nCS 1550 – Operating Systems – Sherif Khattab\n\n44\n\n\fAuthentication using biometrics\n•\n\nUse basic body properties to prove identity\n\n•\n\nExamples include\n\n•\n\n•\n\nFingerprints\n\n•\n\nVoice\n\n•\n\nHand size\n\n•\n\nRetina patterns\n\n•\n\nIris patterns\n\n•\n\nFacial features\n\nPotential problems\n•\n\nDuplicating the measurement\n\n•\n\nStealing it from its original owner?\n\nCS 1550 – Operating Systems – Sherif Khattab\n\n45\n\n\fBypassing Passwords\n• Request “free” memory, disk space, tapes and just\nread what was left there (not zero-filled on dealloc)\n• Try illegal system calls – if the system gets confused\nenough, you may be in\n• Start a login and hit DEL, RUBOUT, or BREAK to\npossibly kill password checking\n• Try to do specified DO NOTs\n\nCS 1550 – Operating Systems – Sherif Khattab\n\n46\n\n\fSecurity Problem 2: Viruses and Worms\n• Virus: program that embeds itself into other\n(legitimate) code to reproduce and do its job\n• Attach its code to another program\n• Additionally, may do harm\n\n• Goals of virus writer\n•\n•\n•\n•\n\nQuickly spreading virus\nDifficult to detect\nHard to get rid of\nOptional: does something malicious\n• e.g., Ransomware\n\nCS 1550 – Operating Systems – Sherif Khattab\n\n47\n\n\fHow viruses work\n• Virus language\n• Assembly language: infects programs\n• “Macro” language: infects email and other documents\n• Runs when email reader \/ browser program opens message\n• Program “runs” virus (as message attachment) automatically\n\n• Inserted into another program\n• Use tool called a “dropper”\n\n• May also infect system code (boot block, etc.)\n\n• Virus dormant until program executed\n• Then infects other programs\n• Eventually executes its “payload”\nCS 1550 – Operating Systems – Sherif Khattab\n\n48\n\n\fWhere viruses live in the program\n\nVirus\nVirus\nExecutable\nprogram\nExecutable\nprogram\nStarting\naddress\n\nExecutable\nprogram\n\nExecutable\nprogram\nVirus\nVirus\n\nVirus\nHeader\n\nHeader\n\nHeader\n\nHeader\n\nUninfected\nprogram\n\nVirus at\nstart of\nprogram\n\nVirus at\nend of\nprogram\n\nVirus in\nprogram’s\nfree spaces\n\nCS 1550 – Operating Systems – Sherif Khattab\n\n49\n\n\fViruses infecting the operating system\n\nOperating\nsystem\n\nOperating\nsystem\n\nOperating\nsystem\n\nVirus\n\nVirus\n\nVirus\n\nSyscall traps\n\nSyscall traps\n\nSyscall traps\n\nDisk vector\n\nDisk vector\n\nDisk vector\n\nClock vector\n\nClock vector\n\nClock vector\n\nKbd vector\n\nKbd vector\n\nKbd vector\n\nVirus has captured\ninterrupt & trap vectors\n\nOS retakes\nkeyboard vector\n\nVirus notices,\nrecaptures keyboard\n\nCS 1550 – Operating Systems – Sherif Khattab\n\n50\n\n\fHow do viruses spread?\n• Virus placed where likely to be copied\n• Popular download site\n• Photo site\n\n• When copied and run\n• Infects programs on hard drive, flash drive\n• May try to spread over LAN or WAN\n\n• Attach to innocent looking email\n• When it runs, use mailing list to replicate\n• May mutate slightly so recipients don’t get suspicious\n\nCS 1550 – Operating Systems – Sherif Khattab\n\n51\n\n\fHiding a virus in a file\n•\n\nStart with an uninfected\nprogram\n\n•\n\nAdd the virus to the end of the\nprogram\n\n•\n\n•\n\n•\n\nProblem: file size changes\n\n•\n\nSolution: compression\n\nVirus\nUnused\n\nCompress infected program\n•\n\nDecompressor: for running\nexecutable\n\n•\n\nCompressor: for compressing\nnewly infected binaries\n\n•\n\nLots of free space (if needed)\n\nProblem (for virus writer): virus\neasy to recognize\n\nVirus\nExecutable\nprogram\n\nExecutable\nprogram\n\nCompressor\nDecompressor\n\nCompressed\nexecutable\nprogram\nHeader\n\nCS 1550 – Operating Systems – Sherif Khattab\n\nHeader\n\nHeader\n\n52\n\n\f•\n\n•\n\nUsing encryption to hide a virus\nHide virus by encrypting it\n•\n\nVary the key in each file\n\n•\n\nVirus “code” varies in each\ninfected file\n\n•\n\nProblem: lots of common\ncode still in the clear\n•\n\nCompress \/ decompress\n\n•\n\nEncrypt \/ decrypt\n\nEven better: leave only\ndecryptor and key in the\nclear\n•\n\nLess constant per virus\n\n•\n\nUse polymorphic code\n(more in a bit) to hide even\nthis\n\nUnused\n\nUnused\n\nVirus\n\nVirus\n\nCompressor\n\nCompressor\n\nUnused\n\nVirus\n\nDecompressor Decompressor\n\nEncryptor\n\nEncryptor\n\nCompressor\n\nKey\n\nKey\n\nDecompressor\n\nDecryptor\n\nDecryptor\n\nCompressed\nexecutable\nprogram\n\nCompressed\nexecutable\nprogram\n\nCompressed\nexecutable\nprogram\n\nHeader\n\nHeader\n\nHeader\n\nCS 1550 – Operating Systems – Sherif Khattab\n\n53\n\n\fPolymorphic viruses\n•\n\nAll of these code seqences do the same thing\n\n•\n\nAll of them are very different in machine code\n\n•\n\nUse “snippets” combined in random ways to hide code\n\nCS 1550 – Operating Systems – Sherif Khattab\n\n54\n\n\f•\n\n•\n\n•\n\n•\n\nHow can viruses be foiled?\nIntegrity checkers\n•\n•\n\nVerify one-way function (hash) of program binary\nProblem: what if the virus changes that, too?\n\nBehavioral checkers\n•\n•\n\nPrevent certain behaviors by programs\nProblem: what about programs that can legitimately do these things?\n\nAvoid viruses by\n•\n•\n•\n•\n\nHaving a good (secure) OS\nInstalling only shrink-wrapped software (just hope that the shrink-wrapped\nsoftware isn’t infected!)\nUsing antivirus software\nNot opening email attachments\n\nRecovery from virus attack\n•\n•\n\nHope you made a recent backup!\nRecover by halting computer, rebooting from safe disk (CD-ROM?), using\nan antivirus program\nCS 1550 – Operating Systems – Sherif Khattab\n\n55\n\n\fWhat if I have to run untrusted code?\n•\n\nGoal: run (untrusted) code on my machine\n\n•\n\nProblem: how can untrusted code be prevented from damaging\nmy resources?\n\n•\n\nOne solution: sandboxing\n\n•\n\n•\n\n•\n\nMemory divided into 1 MB sandboxes\n\n•\n\nAccesses may not cross sandbox boundaries\n\n•\n\nSensitive system calls not in the sandbox\n\nAnother solution: interpreted code\n•\n\nRun the interpreter rather than the untrusted code\n\n•\n\nInterpreter doesn’t allow unsafe operations\n\nThird solution: signed code\n•\n\nUse cryptographic techniques to sign code\n\n•\n\nCheck to ensure that mobile code signed by reputable organization\nCS 1550 – Operating Systems – Sherif Khattab\n\n56\n\n\fWorms vs. viruses\n• Viruses require other programs to run\n• Worms are self-running (separate process)\n\n• The 1988 Internet Worm\n• Consisted of two programs\n• Bootstrap to upload worm\n• The worm itself\n\n• Exploited bugs in sendmail and finger\n• Worm first hid its existence\n• Next replicated itself on new machines\n• Brought the Internet (1988 version) to a screeching halt\n\nCS 1550 – Operating Systems – Sherif Khattab\n\n57\n\n\fVirtualization Overview\nVirtual machine\n\nNon-virtual machine\n\nCS 1550 – Operating Systems – Sherif Khattab\n\n58\n\n\fBenefits and Features\n• Host system protected from VMs, VMs protected from each\nother\n•\n\nA virus less likely to spread\n\n•\n\nSharing is provided though via shared file system volume, network\ncommunication\n\n• Freeze, suspend, running VM\n•\n\nThen can move or copy somewhere else and resume\n\n•\n\nSnapshot of a given state, able to restore back to that state\n•\n\n•\n\nSome VMMs allow multiple snapshots per VM\n\nClone by creating copy and running both original and copy\n\n• Great for OS research, better system development efficiency\n• Run multiple, different OSes on a single machine\n•\n\nConsolidation, app dev, …\nCS 1550 – Operating Systems – Sherif Khattab\n\n59\n\n\fBenefits and Features (cont.)\n• Templating – create an OS + application VM,\nprovide it to customers, use it to create multiple\ninstances of that combination\n\n• Live migration – move a running VM from one host\nto another!\n• No interruption of user access\n\n• All those features taken together -> cloud\ncomputing\n• Using APIs, programs tell cloud infrastructure (servers,\nnetworking, storage) to create new guests, VMs, virtual\ndesktops\nCS 1550 – Operating Systems – Sherif Khattab\n\n60\n\n\fImplementation of VMMs\n• Vary greatly, with options including:\n•\n\nType 0 hypervisors - Hardware-based solutions that provide\nsupport for virtual machine creation and management via firmware\n\n•\n\nType 1 hypervisors - Operating-system-like software built to\nprovide virtualization\n• Including VMware ESX, Joyent SmartOS, and Citrix XenServer\n\n•\n\nType 1 hypervisors – Also includes general-purpose operating\nsystems that provide standard functions as well as VMM functions\n• Including Microsoft Windows Server with HyperV and RedHat Linux\nwith KVM\n\n•\n\nType 2 hypervisors - Applications that run on standard operating\nsystems but provide VMM features to guest operating systems\n• Including VMware Workstation and Fusion, Parallels Desktop, and\nOracle VirtualBox\nCS 1550 – Operating Systems – Sherif Khattab\n\n61\n\n\f","label":[[560,573,"Concept"],[576,597,"Concept"],[810,823,"Concept"],[936,942,"Concept"],[1094,1109,"Concept"],[1153,1156,"Concept"],[1720,1727,"Concept"],[1731,1738,"Concept"],[1746,1763,"Concept"],[1764,1770,"Concept"],[1995,2002,"Concept"],[2020,2027,"Concept"],[2078,2085,"Concept"],[2103,2110,"Concept"],[2120,2126,"Concept"],[2216,2234,"Concept"],[2282,2297,"Concept"],[2348,2360,"Concept"],[2383,2398,"Concept"],[2426,2432,"Concept"],[2459,2470,"Concept"],[2475,2493,"Concept"],[2498,2505,"Concept"],[2777,2815,"Concept"],[2830,2836,"Concept"],[2885,2899,"Concept"],[2930,2945,"Concept"],[2950,2961,"Concept"],[2966,2983,"Concept"],[2988,3002,"Concept"],[3054,3066,"Concept"],[3105,3136,"Concept"],[3203,3216,"Concept"],[3252,3265,"Concept"],[3325,3345,"Concept"],[3373,3376,"Concept"],[3382,3393,"Concept"],[3446,3462,"Concept"],[3496,3500,"Concept"],[3660,3672,"Concept"],[3750,3767,"Concept"],[3773,3785,"Concept"],[3801,3818,"Concept"],[3853,3870,"Concept"],[3898,3920,"Concept"],[3921,3944,"Concept"],[4047,4067,"Concept"],[4071,4084,"Concept"],[4088,4108,"Concept"],[4113,4133,"Concept"],[4138,4157,"Concept"],[4162,4172,"Concept"],[4194,4213,"Concept"],[4496,4536,"Concept"],[4583,4607,"Concept"],[4965,4996,"Concept"],[5043,5069,"Concept"],[5196,5216,"Concept"],[5308,5312,"Concept"],[5340,5354,"Concept"],[5454,5469,"Concept"],[5769,5784,"Concept"],[5838,5852,"Concept"],[5859,5871,"Concept"],[5901,5913,"Concept"],[6379,6393,"Concept"],[6465,6478,"Concept"],[8045,8066,"Concept"],[8090,8111,"Concept"],[8508,8526,"Concept"],[8528,8533,"Concept"],[8772,8793,"Concept"],[8842,8845,"Concept"],[8882,8892,"Concept"],[8946,8958,"Concept"],[9142,9145,"Concept"],[9148,9151,"Concept"],[9415,9427,"Concept"],[9477,9481,"Concept"],[9556,9566,"Concept"],[9632,9641,"Concept"],[9679,9683,"Concept"],[9706,9720,"Concept"],[9747,9756,"Concept"],[9763,9772,"Concept"],[9774,9784,"Concept"],[9785,9795,"Concept"],[9797,9811,"Concept"],[9813,9823,"Concept"],[9876,9897,"Concept"],[9913,9937,"Concept"],[9942,9969,"Concept"],[10019,10034,"Concept"],[10044,10063,"Concept"],[10139,10153,"Concept"],[10176,10190,"Concept"],[10253,10263,"Concept"],[10268,10278,"Concept"],[10331,10359,"Concept"],[10362,10386,"Concept"],[10388,10391,"Concept"],[10434,10441,"Concept"],[10444,10451,"Concept"],[10519,10523,"Concept"],[10575,10579,"Concept"],[10626,10629,"Concept"],[10657,10660,"Concept"],[10700,10703,"Concept"],[11050,11067,"Concept"],[11096,11112,"Concept"],[11219,11222,"Concept"],[11313,11316,"Concept"],[11411,11414,"Concept"],[11576,11593,"Concept"],[11598,11609,"Concept"],[11614,11623,"Concept"],[11739,11762,"Concept"],[11806,11810,"Concept"],[11831,11834,"Concept"],[11868,11878,"Concept"],[11891,11894,"Concept"],[11921,11942,"Concept"],[11954,11958,"Concept"],[12008,12018,"Concept"],[12021,12031,"Concept"],[12381,12390,"Concept"],[12567,12577,"Concept"],[12730,12740,"Concept"],[12861,12886,"Concept"],[12892,12913,"Concept"],[12929,12932,"Concept"],[12977,12986,"Concept"],[13000,13007,"Concept"],[13022,13032,"Concept"],[13098,13105,"Concept"],[13120,13131,"Concept"],[13146,13167,"Concept"],[13199,13220,"Concept"],[13235,13245,"Concept"],[13253,13263,"Concept"],[13308,13317,"Concept"],[13324,13348,"Concept"],[13350,13353,"Concept"],[13439,13448,"Concept"],[13560,13569,"Concept"],[13794,13808,"Concept"],[14295,14308,"Concept"],[15038,15053,"Concept"],[15281,15296,"Concept"],[18163,18188,"Concept"],[18216,18235,"Concept"],[18453,18466,"Concept"],[18571,18581,"Concept"],[18688,18698,"Concept"],[18839,18849,"Concept"],[19281,19288,"Concept"],[19552,19559,"Concept"],[19564,19569,"Concept"],[19572,19577,"Concept"],[19740,19745,"Concept"],[19780,19785,"Concept"],[19868,19878,"Concept"],[19935,19942,"Concept"],[19950,19955,"Concept"],[20131,20136,"Concept"],[20229,20236,"Concept"],[20270,20280,"Concept"],[20291,20296,"Concept"],[20451,20458,"Concept"],[20480,20485,"Concept"],[20486,20491,"Concept"],[20587,20592,"Concept"],[20593,20598,"Concept"],[20600,20605,"Concept"],[20658,20663,"Concept"],[20685,20690,"Concept"],[20710,20715,"Concept"],[20793,20800,"Concept"],[20887,20892,"Concept"],[20894,20899,"Concept"],[20901,20906,"Concept"],[20908,20921,"Concept"],[20923,20936,"Concept"],[20938,20951,"Concept"],[20953,20964,"Concept"],[20966,20977,"Concept"],[20979,20990,"Concept"],[20992,21004,"Concept"],[21006,21018,"Concept"],[21020,21032,"Concept"],[21034,21044,"Concept"],[21046,21056,"Concept"],[21058,21068,"Concept"],[21070,21075,"Concept"],[21089,21113,"Concept"],[21126,21141,"Concept"],[21143,21148,"Concept"],[21237,21244,"Concept"],[21255,21260,"Concept"],[21636,21641,"Concept"],[21700,21705,"Concept"],[21783,21794,"Concept"],[21796,21801,"Concept"],[21810,21818,"Concept"],[21839,21851,"Concept"],[21880,21890,"Concept"],[21896,21907,"Concept"],[21996,22001,"Concept"],[22021,22026,"Concept"],[22067,22077,"Concept"],[22078,22090,"Concept"],[22092,22102,"Concept"],[22209,22219,"Concept"],[22230,22235,"Concept"],[22241,22246,"Concept"],[22250,22260,"Concept"],[22276,22279,"Concept"],[22297,22302,"Concept"],[22394,22402,"Concept"],[22405,22415,"Concept"],[22420,22427,"Concept"],[22430,22437,"Concept"],[22463,22472,"Concept"],[22477,22480,"Concept"],[22515,22520,"Concept"],[22597,22602,"Concept"],[22604,22609,"Concept"],[22611,22621,"Concept"],[22623,22633,"Concept"],[22643,22648,"Concept"],[22650,22662,"Concept"],[22663,22675,"Concept"],[22677,22686,"Concept"],[22688,22697,"Concept"],[22699,22709,"Concept"],[22711,22714,"Concept"],[22716,22719,"Concept"],[22721,22733,"Concept"],[22735,22744,"Concept"],[22746,22755,"Concept"],[22757,22767,"Concept"],[22788,22798,"Concept"],[22819,22829,"Concept"],[22925,22944,"Concept"],[23172,23179,"Concept"],[23285,23290,"Concept"],[23449,23456,"Concept"],[23602,23620,"Concept"],[23666,23671,"Concept"],[24035,24045,"Concept"],[24081,24090,"Concept"],[24118,24125,"Concept"],[24175,24182,"Concept"],[24202,24218,"Concept"],[24230,24241,"Concept"],[24277,24288,"Concept"],[24338,24349,"Concept"],[24516,24521,"Concept"],[24526,24533,"Concept"],[24536,24543,"Concept"],[24576,24581,"Concept"],[24639,24643,"Concept"],[24674,24683,"Concept"],[24694,24698,"Concept"],[24705,24709,"Concept"],[24760,24764,"Concept"],[25145,25150,"Concept"],[26000,26015,"Concept"],[26209,26213,"Concept"],[26257,26275,"Concept"],[26385,26403,"Concept"],[26481,26491,"Concept"],[26493,26507,"Concept"],[26513,26529,"Concept"],[26534,26552,"Concept"],[26646,26649,"Concept"],[26702,26708,"Concept"],[26713,26734,"Concept"],[26739,26757,"Concept"],[26824,26827,"Concept"],[26876,26894,"Concept"],[26899,26905,"Concept"],[26907,26924,"Concept"],[26930,26947,"Concept"]],"Comments":[]}
{"id":13,"course": "cs1502", "lec": "finite_automata_03","text":"Finite Automata 03\nThumrongsak Kosiyatrakul\ntkosiyat@cs.pitt.edu\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fNondeterministic Finite Automaton\n0, 1\n\n0, 1\n\n1\n\nq1\n\n0, ε\n\nq2\n\n1\n\nq3\n\nq4\n\nLet Σ = {0, 1}\nDifferent between Deterministic Finite Automaton (DFA) and\nNondeterministic Finite Automaton (NFA):\nDFA always has exactly one exiting transition arrow for each\nsymbol in the alphabet\nNFA may have none, one, or many exiting arrows for each\nsymbol\n\nDFA have no arrow with the label ε\nNFA may have Zero, one, or many arrows exiting from each\nstate with the label ε.\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fCompute an NFA\n0, 1\n\n0, 1\n\n1\n\nq1\n\n0, ε\n\nq2\n\n1\n\nq3\n\nq4\n\nIf you encounter a state with multiple way to proceed for a\nregular input:\nThe machine splits into multiple copies of itself\nThe machines follow all the possibilities in parallel.\nEach copy of the machine takes one of the possible ways.\n\nIf you encounter a state with an ε symbol as an exiting arrow:\nWithout reading any input, the machine splits into multiple\ncopies.\nEach follows each of the exiting ε-labeled arrows, and\nOne stays at the current state.\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fCompute an NFA (Computational Tree)\nComputation of the machine on input 010110\n\nSymbol read\n\nq1\n\nStart\n\n0, 1\n\n0, 1\n\n1\n\nq1\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n0, ε\n\nq2\n\n1\n\nq3\n\nq4\n\n\fCompute an NFA (Computational Tree)\nComputation of the machine on input 010110\n\nSymbol read\n\nq1\n\nStart\n\n0\n\nq1\n\n0, 1\n\n0, 1\n\n1\n\nq1\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n0, ε\n\nq2\n\n1\n\nq3\n\nq4\n\n\fCompute an NFA (Computational Tree)\nComputation of the machine on input 010110\n\nq1\n\nSymbol read\n\nStart\n\n0\n\nq1\n1\n\nq1\n\nq2\n\nq3\n\n0, 1\n\n0, 1\n\n1\n\nq1\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n0, ε\n\nq2\n\n1\n\nq3\n\nq4\n\n\fCompute an NFA (Computational Tree)\nComputation of the machine on input 010110\n\nq1\n\nSymbol read\n\nStart\n\n0\n\nq1\n1\n\nq1\n\nq2\n\nq1\n\nq3\n\nq3\n\n0, 1\n\n0, 1\n\n0\n1\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nq1\n\nFinite Automata 03\n\n0, ε\n\nq2\n\n1\n\nq3\n\nq4\n\n\fCompute an NFA (Computational Tree)\nComputation of the machine on input 010110\n\nq1\n\nSymbol read\n\nStart\n\n0\n\nq1\n1\n\nq1\n\nq2\n\nq1\n\nq3\n\nq3\n\n0, 1\n\n0, 1\n\n0\n1\n\nq1\n\n1\n\nq1\n\nq2\n\nq3\n\nq4\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n0, ε\n\nq2\n\n1\n\nq3\n\nq4\n\n\fCompute an NFA (Computational Tree)\nComputation of the machine on input 010110\n\nq1\n\nSymbol read\n\nStart\n\n0\n\nq1\n1\n\nq1\n\nq2\n\nq1\n\nq3\n\nq3\n\n0, 1\n\n0, 1\n\n0\n1\n\nq1\n\n1\n\nq1\n\nq2\n\nq3\n\nq4\n\nq2\n\nq3\n\nq4\n\nq4\n\n1\n\nq1\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n0, ε\n\nq2\n\n1\n\nq3\n\nq4\n\n\fCompute an NFA (Computational Tree)\nComputation of the machine on input 010110\n\nq1\n\nSymbol read\n\nStart\n\n0\n\nq1\n1\n\nq1\n\nq2\n\nq1\n\nq3\n\nq3\n\n0, 1\n\n0, 1\n\n0\n1\n\nq1\n\n0, ε\n\nq2\n\n1\n\nq3\n\n1\n\nq1\n\nq2\n\nq3\n\nq4\n\nq1\n\nq2\n\nq3\n\nq4\n\nq4\n\nq1\n\nq3\n\nq4\n\nq4\n\n1\n\n0\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nIf there is at least one copy in an accept state,\nthe machine accept the input string.\nFinite Automata 03\n\nq4\n\n\fExample\nLet A be the language consisting of all strings over {0, 1}\ncontaining a 1 in the third position from the end (e.g., 000100 is in\nA but 0011 is not in A).\nDesign a DFA for this problem is quite complicate\nDesign an NFA is easier\n0, 1\n\n1\n\nq1\n\n0, 1\n\nq2\n\n0, 1\n\nq3\n\nq4\n\nThe transition from q1 to q2 is our guess that this is the 1 in\nthe third position from the end.\nIf our guess is wrong:\nThe input string is shorter, it will end at reject state.\nThe input string is longer, the machine will die but other one\nremains alive.\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fExample\nAn equivalent DFA machine\n0\n\n0\n\n0\n\nq000\n1\n1\n\n0\n\nq100\n\nq010\n\nq110\n1\n\n0\n\n1\n\n0\n\n0\n\n0\n\nq001\n\nq101\n\n1\n\nq011\n\n1\n\n1\n\nName states according to the last three symbols\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\nq111\n\n1\n\n\fExample\nSuppose the alphabet Σ is {0}. Design a machine that recognizes\nthe language A where A is an empty string or all strings over Σ\nthat their length is a multiple of 2 or 3.\n0\n\n0\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fExample\nSuppose the alphabet Σ is {0}. Design a machine that recognizes\nthe language A where A is an empty string or all strings over Σ\nthat their length is a multiple of 2 or 3.\n0\n\n0\n\n0\n\n0\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\n0\n\nFinite Automata 03\n\n\fExample\nSuppose the alphabet Σ is {0}. Design a machine that recognizes\nthe language A where A is an empty string or all strings over Σ\nthat their length is a multiple of 2 or 3.\n0\n\nε\n\n0\n\nε\n0\n\n0\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\n0\n\nFinite Automata 03\n\n\fFormal Definition of A Nondeterministic Finite Automaton\nA nondeterministic finite automaton is a 5-tuple\n(Q, Σ, δ, q0, F )\n1\n2\n3\n\nQ is a finite set of states\nΣ is a finite alphabet\nδ : Q × Σε → P(Q) is the transition function,\nΣε = Σ ∪ {ε} and\nP(Q) is the powerset of Q (set of set of states).\n\n4\n5\n\nq0 ∈ Q is the start state\nF ⊆ Q is the set of accept states.\n\nNotes\nIn an NFA, one input symbol can change the state of the\nmachine to multiple states.\nSplit to multiple copies with different current states\nExample: δ(q0 , 1) = {q0 , q1 }\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fExample\n0, 1\n\n0, 1\n\n1\n\nq1\n\n0, ε\n\nq2\n\n1\n\nq3\n\nQ = {q1 , q2 , q3 , q4 }\nΣ = {0, 1} and Σε = {0, 1, ε}\nδ is given as\nδ\n0\n1\nq1 {q1 } {q1 , q2 }\nq2 {q3 }\n∅\nq3\n∅\n{q4 }\nq4 {q4 }\n{q4 }\n\nq4\n\nε\n∅\n{q3 }\n∅\n∅\n\nWe treat ε as a regular input symbol\nIf there is no ε transitions, we can ignore the ε column\n\nq1 is the start state\nF = {q4 }\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fNFA and DFA\n\nNFA is a slightly different computation model compared to\nDFA\nNFA can split into multiple copies\nNFA may have ε transitions\n\nIs there a language that can be recognized by an NFA but\ncannot be recognized by any DFAs?\nIn theory of computation, we try to see whether we can\ncapture the behavior of an NFA using a DFA\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fSimulating and NFA with a DFA\nSimulate 010110\nδ\n\n0\n\nε\n\n1\n\nq1\n\nq1 {q1 } {q1 , q2 } ∅\n{q3 }\nq2 {q3 }\n∅\n{q4 }\n∅\nq3 ∅\n∅\nq4 {q4 } {q4 }\n\nStart\n\n{q1 }\n\n= {q1 }\n\n{q1 }\n\n= {q1 }\n\n{q1 , q2 , q3 }\n\n= {q1 , q2 , q3 }\n\n{q1 } ∪ {q3 } ∪ ∅\n\n= {q1 , q3 }\n\n{q1 , q2 , q3 } ∪ {q4 }\n\n= {q1 , q2 , q3 , q4 }\n\n0\n\nq1\n1\n\nq1\n\nq2\n\nq3\n0\n\nq1\n\nq3\n1\n\nq1\n\nq2\n\nq3\n\nq4\n1\n\nq1\n\nq2\n\nq3\n\nq4\n\n{q1 , q2 , q3 } ∪ ∅ ∪ {q4 } ∪ {q4 } = {q1 , q2 , q3 , q4 }\n\nq4\n0\n\nq1\n\nq3\n\nq4\n\nq4\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\n{q1 } ∪ {q3 } ∪ ∅ ∪ {q4 } ∪ {q4 } = {q1 , q3 , q4 }\nFinite Automata 03\n\n\fEquivalence of NFAs and DFAs\n\nEvery nondeterministic finite automaton has an equivalent\ndeterministic finite automaton.\nLet N = (Q, Σ, δ, q0 , F ) be the NFA recognizing some\nlanguage A\nWe are going to construct a DFA M = (Q0 , Σ, δ 0 , q00 , F 0 )\nrecognizing A\nLet’s consider the case where N has no ε transitions.\n1\n2\n\nQ0 = P(Q) [\nδ 0 (R, a) =\nδ(r, a)\nr∈R\n\n3\n4\n\nq00 = {q0 }\nF 0 = {R ∈ Q0 | R contains an accept state of N }\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fExample\nLet Σ be {0, 1}. The following NFA N recognizes the\nlanguage A where A is a set of strings that end with a 1.\n0, 1\n\n1\n\nq0\n\nq1\n\nN = (Q, Σ, δ, q0 , F )\n1\n2\n3\n\nQ = {q0 , q1 },\nΣ = {0, 1}\nδ is given as\nq0\nq1\n\n4\n5\n\n0\n{q0 }\n∅\n\n1\n{q0 , q1 }\n∅\n\nq0 is the start state\nF = {q1 }\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fExample\n\nConstruct a DFA M = (Q0 , Σ, δ 0 , q00 , F 0 )\nQ0 = P(Q) = P({q0 , q1 })\nQ0 = {∅, {q0 }, {q1 }, {q0 , q1 }}\nWe will construct δ 0 later\nq00 = {q0 } where q0 is the start state of the NFA\nF 0 = {R ∈ Q0 | R contains an accept state of N }\nF 0 = {{q1 }, {q0 , q1 }}\nwhere F = {q1 }\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fExample\n\nLet’s focus on transition functions\nThe transition function δ of the NFA is as follows:\n0\n1\nq0 {q0 } {q0 , q1 }\nq1\n∅\n∅\nRecall that the set of state of the equivalent DFA is the power\nset of set of state of the NFA\nδ0\n0\n1\n∅\n∅\n∅\n{q0 } {q0 , q1 }\n{q0 }\n{q1 }\n∅\n∅\n{q0 , q1 } {q0 } {q0 , q1 }\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fExample\nMachine M = (Q0 , Σ, δ 0 , q00 , F 0 ) equivalent to N can be\ndefined as follows:\nQ0 = P(Q) [\n= {∅, {q0 }, {q1 }, {q0 , q1 }},\n0\nδ (R, a) =\nδ(r, a)\nr∈R\n0\n\nδ (∅, 0) =\n\n[\n\nδ(r, 0) = ∅\n\nr∈∅\n\nδ 0 (∅, 1) =\n\n[\n\nδ(r, 1) = ∅\n\nr∈∅\n\nδ 0 ({q0 }, 0) =\n\n[\n\nδ(r, 0) = δ(q0 , 0) = {q0 }\n\nr∈{q0 }\n\nδ 0 ({q0 }, 1) =\n\n[\n\nδ(r, 1) = δ(q0 , 1) = {q0 , q1 }\n\nr∈{q0 }\n\nδ 0 ({q1 }, 0) =\n\n[\n\nδ(r, 0) = δ(q1 , 0) = ∅\n\nr∈{q1 }\n\nδ 0 ({q1 }, 1) =\n\n[\n\nδ(r, 1) = δ(q1 , 1) = ∅\n\nr∈{q1 }\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fExample\n\nMachine M (Continue)\nδ 0 (Continue)\nδ 0 ({q0 , q1 }, 0) =\n\n[\n\nδ(r, 0) = δ(q0 , 0) ∪ δ(q1 , 0) =\n\nr∈{q0 ,q1 }\n\n{q0 } ∪ ∅ = {q0 }\nδ 0 ({q0 , q1 }, 1) =\n\n[\n\nδ(r, 0) = δ(q0 , 1) ∪ δ(q1 , 1) =\n\nr∈{q0 ,q1 }\n\n{q0 , q1 } ∪ ∅ = {q0 , q1 }\n\nThus δ 0 is given by\nδ0\n∅\n{q0 }\n{q1 }\n{q0 , q1 }\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\n0\n∅\n{q0 }\n∅\n{q0 }\n\n1\n∅\n{q0 , q1 }\n∅\n{q0 , q1 }\n\nFinite Automata 03\n\n\fExample\nThe state diagram of the machine M = (Q0 , Σ, δ 0 , q00 , F 0 )\nequivalent to N (L(M ) = L(N )) is shown below:\n0\n\n1\n\n1\n\n{q0 }\n\n{q0 , q1 }\n\n0\n0\n\n0\n\n{q1 }\n\n∅\n1\n\n1\n\nWithout bottom part, it is the same as one of our previous\nexample\nIt is okay for a DFA to have unreachable states\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fNFA to DFA with ε Symbol\nLet E(R) be the collection of states that can be reached from\nmembers of R by going only along ε arrows, including the\nmembers of R themselves.\nE(R) = {q | q can be reached from R by travel along\n0 or more ε arrows}\nNote that a state q can be reached from its own state q by\ntravel along no ε arrow (R ⊆ E(R))\nExample:\n0, 1\n\n0, 1\n\n1\n\nq1\n\n0, ε\n\nq2\n\n1\n\nq3\n\nE({q1 }) = {q1 }\nE({q2 }) = {q2 , q3 }\nE({q1 , q2 }) = {q1 , q2 , q3 }\nE({q1 , q3 }) = {q1 , q3 }\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\nq4\n\n\fNFA to DFA with ε Symbol\n\nLet NFA N = (Q, Σ, δ, q0 , F ) with ε transitions that\nrecognizes a language A\nWe can construct a DFA M = (Q0 , Σ, δ 0 , q00 , F 0 ) as\n1\n2\n\nQ0 = P(Q)\nδ 0 is given by\nδ 0 (R, a) =\n\n[\n\nE(δ(r, a))\n\nr∈R\n3\n\nq00 = E({q0 })\nIf q0 has no exiting arrow for ε, q00 = {q0 }\n\n4\n\nF 0 = {R ∈ Q0 | R contains an accept state of N }\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fExample\nConsider the following NFA machine:\n1\nb\n\na\n\nε\n2\n\na\n\n3\na, b\n\nN = (Q, Σ, δ, q0 , F )\nQ = {1, 2, 3}\nΣ = {a, b}\nδ is given by\n1\n2\n3\n\na\n∅\n{2, 3}\n{1}\n\nb\n{2}\n{3}\n∅\n\nε\n{3}\n∅\n∅\n\nq0 = 1\nF = {1}\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fExample\n\nMachine M = (Q0 , Σ, δ 0 , q00 , F 0 ) equivalent to N :\nQ0 = P(Q) = P({1, 2, 3})\nQ0 = {∅, {1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3}}\nStart state is E({1}) = {1, 3}\nF 0 is a set of set of states that contain accept states of N\n(F = {1}).\nF 0 = {{1}, {1, 2}, {1, 3}, {1, 2, 3}}\n[\nδ 0 (R, a) =\nE(δ(r, a))\nr∈R\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fExample\nLet’s focus on transition functions\nThe transition function δ of the NFA is as follows:\nδ\na\nb\nε\n1\n∅\n{2} {3}\n2 {2, 3} {3}\n∅\n{1}\n∅\n∅\n3\nRecall that the set of state of the equivalent DFA is the power\nset of set of state of the NFA\nδ0\na\nb\n∅\n∅\n∅\n∅\n{2}\n{1}\n{2}\n{2, 3}\n{3}\n{3}\n{1, 3}\n∅\n{2, 3}\n{2, 3}\n{1, 2}\n{1, 3}\n{2}\n{1, 3}\n{2, 3}\n{1, 2, 3}\n{3}\n{1, 2, 3} {1, 2, 3} {2, 3}\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fMachine M ’s δ 0\n0\n\nδ (∅, a) =\n\n[\n\nE(δ(r, a))\n\n0\n\n= E(δ(2, b))\n= E({3})\n\nr∈∅\n\n= {3}\n[\nδ ({3}, a) =\n\n=∅\n0\n\n0\n\n[\n\nE(δ(r, b))\n\nr∈{2}\n\n=∅\n[\n0\nδ (∅, b) =\nE(δ(r, b))\n\nδ ({1}, a) =\n\n[\n\nδ ({2}, b) =\n\nr∈∅\n\nE(δ(r, a))\n\nE(δ(r, a))\n\nr∈{3}\n\nr∈{1}\n\n= E(δ(3, a))\n\n= E(δ(1, a))\n\n= E({1})\n\n= E(∅)\n=∅\n0\n\nδ ({1}, b) =\n\n0\n\n[\n\n= {1, 3}\n[\n\nδ ({3}, b) =\n\nE(δ(r, b))\n\nE(δ(r, b))\n\nr∈{3}\n\nr∈{1}\n\n= E(δ(3, b))\n\n= E(δ(1, b))\n\n= E(∅)\n\n= E({2})\n= {2}\n[\n0\nδ ({2}, a) =\n\n=∅\n0\n\nE(δ(r, a))\n\nδ ({1, 2}, a) =\n\n[\n\nE(δ(r, a))\n\nr∈{1,2}\n\nr∈{2}\n\n= E(δ(1, a)) ∪ E(δ(2, a))\n\n= E(δ(2, a))\n\n= ∅ ∪ {2, 3}\n\n= E({2, 3})\n\n= {2, 3}\n\n= {2, 3}\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fMachine M ’s δ 0\n0\n\nδ ({1, 2}, b) =\n\n[\n\nE(δ(r, b))\n\nr∈{1,2}\n\n0\n\nδ ({2, 3}, b) =\n\n= E(δ(1, b)) ∪ E(δ(2, b))\n= {2} ∪ {3}\n= {2, 3}\n[\n0\nδ ({1, 3}, a) =\n\n= E(δ(2, b)) ∪ E(δ(3, b))\nE(δ(r, a))\n\n= {3}\n0\n\n= E(δ(1, a)) ∪ E(δ(3, a))\n\nδ ({1, 2, 3}, a) =\n\nE(δ(3, a))\nE(δ(r, b))\n\nr∈{1,3}\n\n= {2} ∪ ∅\n= {2}\n[\nδ ({2, 3}, a) =\n\nE(δ(r, a))\n\n= E(δ(1, a) ∪ E(δ(2, a))∪\n\n= E(δ(1, b)) ∪ E(δ(3, b))\n\n0\n\n[\nr∈{1,2,3}\n\n= ∅ ∪ {1, 3}\n= {1, 3}\n[\nδ ({1, 3}, b) =\n\nE(δ(r, b))\n\n= {3} ∪ ∅\n\nr∈{1,3}\n\n0\n\n[\nr∈{2,3}\n\n= ∅ ∪ {2, 3} ∪ {1, 3}\n= {1, 2, 3}\n[\nδ ({1, 2, 3}, b) =\nE(δ(r, b))\n0\n\nr∈{1,2,3}\n\n= E(δ(1, b) ∪ E(δ(2, b))∪\nE(δ(r, a))\n\nE(δ(3, b))\n\nr∈{2,3}\n\n= {2} ∪ {3} ∪ ∅\n\n= E(δ(2, a)) ∪ E(δ(3, a))\n\n= {2, 3}\n\n= {2, 3} ∪ {1, 3}\n= {1, 2, 3}\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fExample\nRecall the transition function of M\na\n∅\n∅\n{2, 3}\n{1, 3}\n{2, 3}\n{1, 3}\n{1, 2, 3}\n{1, 2, 3}\n\n∅\n{1}\n{2}\n{3}\n{1, 2}\n{1, 3}\n{2, 3}\n{1, 2, 3}\n\nb\n∅\n{2}\n{3}\n∅\n{2, 3}\n{2}\n{3}\n{2, 3}\n\nThe state diagram of M\na\na, b\n\nb\n{1}\n\nφ\n\n{2}\na, b\n\nb\n\nb\n\n{1,2}\n\na\n\nb\n\na\n{3}\n\na\n\n{1,3}\n\na\n\n{2,3}\n\n{1,2,3}\nb\n\nb\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\na\n\n\fClosure Under Union Operation\nN1\n\nN\n\nε\n\nε\nN2\n\nN1 recognizes a regular language A\nN2 recognizes a regular language B\nN recognizes A ∪ B (A ∪ B is regular)\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fClosure Under Union Operation\n\nLet N1 = (Q1 , Σ, δ1 , q1 , F1 ) recognizes A1 .\nLet N2 = (Q2 , Σ, δ2 , q2 , F2 ) recognizes A2 .\nTo construct N = (Q, Σ, δ, q0 , F ) to recognizes A1 ∪ A2 :\n1\n2\n3\n4\n\nQ = {q0 } ∪ Q1 ∪ Q2\nThe state q0 is the start state of N\nThe set of accept state F = F1 ∪ F2\nδ is given by\n\nδ1 (q, a) q ∈ Q1\n\n\n\nδ (q, a) q ∈ Q\n2\n2\nδ(q, a) =\n\n{q\n,\nq\n}\nq\n=\nq\nand a = ε\n1\n2\n0\n\n\n\n∅\nq = q0 and a 6= ε\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fClosure Under Union Operation\n\nGiven state diagrams of finite-state machines N1 and N2\nTo draw a state diagram of a new machine N where\nL(N ) = L(N1 ) ∪ L(N2 ):\n1\n2\n3\n4\n\nDraw the state diagram of N1 on the top half\nDraw the state diagram of N2 on the bottom half\nAdd a new start state\nAdd ε transitions from the new start state to the start states\nof N1 and N2 , respectively\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fClosure Under Union Operation\nDraw N1 on the top half\nN1\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fClosure Under Union Operation\nDraw N2 on the bottom half\nN1\n\nN2\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fClosure Under Union Operation\nAdd new start state\nN1\n\nN2\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fClosure Under Union Operation\nAdd ε transitions\nN\n\nN1\nε\n\nε\n\nN2\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fClosure Under Concatenation Operation\nLet N1 recognizes A and N2 recognizes B\nGiven a string w, how do we know whether w ∈ AB?\nRecall the definition of AB (A concatenated by B)\nAB = {xy | x ∈ A and y ∈ B}\nFor w to be in AB, w must be divided into two strings x and\ny where w = xy such that x ∈ A and y ∈ B\nIf x ∈ A, x ∈ L(N1 )\nSince x ∈ L(N1 ), by simulating N1 on input x, the simulation\nwill end in an accept state of N1 (N1 accepts x)\n\nBut if x 6∈ A, simulation will end in a non-accept state of N1\nIf y ∈ B, y ∈ L(N2 )\nSince y ∈ L(N2 ), by simulating N2 on input y, the simulation\nwill end in an accept state of N2 (N2 accepts y)\n\nBut if y 6∈ B, simulation will end in a non-accept state of N2\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fClosure Under Concatenation Operation\nN1\n\nN2\n\nN\n\nε\nε\nε\n\nN1 recognizes a regular language A\nN2 recognizes a regular language B\nN recognizes AB (AB is regular)\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fClosure Under Concatenation Operation\n\nLet N1 = (Q1 , Σ, δ1 , q1 , F1 ) recognizes A1 .\nLet N2 = (Q2 , Σ, δ2 , q2 , F2 ) recognizes A2 .\nTo construct N = (Q, Σ, δ, q0 , F ) to recognizes A1 ◦ A2 :\n1\n2\n3\n4\n\nQ = Q1 ∪ Q2\nThe state q1 is the start state of N\nThe set of accept state F = F2\nδ is given by\n\nδ1 (q, a)\nq ∈ Q1 and q 6∈ F1\n\n\n\nδ (q, a)\nq\n∈ Q2 and a 6= ε\n2\nδ(q, a) =\n\nδ1 (q, a) ∪ {q2 } q ∈ F1 and a = ε\n\n\n\nδ2 (q, a)\nq ∈ Q2\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fClosure Under Concatenation Operation\n\nGiven state diagrams of finite-state machines N1 and N2\nTo draw a state diagram of a new machine N where\nL(N ) = L(N1 ) ◦ L(N2 ):\n1\n2\n3\n\n4\n\nDraw the state diagram of N1 on the left side\nDraw the state diagram of N2 on the right side\nFor every accept state of N1 , add the ε transition to the start\nstate of N2\nChange all accept states of N1 to non-accept states\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fClosure Under Concatenation Operation\n\nDraw the state diagram of N1 on the left side\nN1\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fClosure Under Concatenation Operation\n\nDraw the state diagram of N2 on the right side\nN1\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nN2\n\nFinite Automata 03\n\n\fClosure Under Concatenation Operation\n\nε from accept states of N1 to start state of N2\nN1\n\nN2\nε\nε\nε\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fClosure Under Concatenation Operation\n\nAccept states of N1 to non-accept states\nN\n\nN1\n\nN2\nε\nε\nε\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fClosure Under Star Operation\nStar operator is similar to concatenation except that it can be\nconcatenated any number of times:\nA∗ = {x1 x2 x3 . . . xk | k ≥ 0 and xi ∈ A}\nand\nε ∈ A∗\nN1\n\nfor any language A\nN\nε\nε\nε\n\nN1 recognizes a regular language A\nN recognizes A∗ (A∗ is regular)\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fClosure Under Star Operation\n\nLet N1 = (Q1 , Σ, δ1 , q1 , F1 ) recognizes A1 .\nTo construct N = (Q, Σ, δ, q0 , F ) to recognizes A∗1 :\n1\n2\n3\n4\n\nQ = {q0 } ∪ Q1\nThe state q0 is the start state of N\nThe set of accept state F = {q0 } ∪ F1\nδ is given by\n\n\nδ1 (q, a)\nq ∈ Q1 and q 6∈ F1\n\n\n\n\n\nq ∈ F1 and a 6= ε\nδ1 (q, a)\nδ(q, a) = δ1 (q, a) ∪ {q1 } q ∈ F1 and a = ε\n\n\n\n{q1 }\nq = q0 and a = ε\n\n\n\n∅\nq = q0 and a 6∈ ε\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fClosure Under Star Operation\n\nGiven state diagrams of finite-state machines N1\nTo draw a state diagram of a new machine N where\nL(N ) = L(N1 )∗ :\n1\n2\n3\n\n4\n\nDraw the state diagram of N1\nAdd a new start state and make it an accept state\nAdd ε transition from the new start state to the start state of\nN1\nFor each original accept state of N1 , add ε transition to the\noriginal start state of N1\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fClosure Under Star Operation\n\nDraw the state diagram of N1\nN1\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fClosure Under Star Operation\n\nAdd a new start state and make it an accept state\nN1\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fClosure Under Star Operation\n\nAdd ε from thew new start state to the original start state of\nN1\nN1\nε\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fClosure Under Star Operation\n\nFor each original accept state of N1 , add ε transition to the\noriginal start state of N1\nN\n\nN1\nε\nε\nε\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\fConclusions\n\nA Nondeterministic Finite Automata (NFA) has an equivalent\nDeterministic Finite Automata (DFA)\nThe algorithm how to convert from an NFA N to an\nequivalent DFA D where L(N ) = L(D) has been discussed\n\nThe set of all regular languages is closed under union,\nconcatenation, and star operations:\nIf A and B are regular languages, A ∪ B is a regular language\nIf A and B are regular languages, AB (A ◦ B) is a regular\nlanguage\nIf A is a regular language, A∗ is a regular language\n\nThe proof process also gives us an algorithm how to construct\nDFAs\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 03\n\n\f","label":[[134,167,"Concept"],[282,315,"Concept"],[317,320,"Concept"],[407,410,"Concept"],[666,669,"Concept"],[1245,1248,"Concept"],[1250,1268,"Concept"],[4762,4795,"Concept"],[9530,9531,"Concept"],[11152,11172,"Concept"],[11177,11196,"Concept"],[11197,11198,"Concept"],[13588,13617,"Concept"],[15038,15075,"Concept"],[17659,17687,"Concept"],[17688,17701,"Concept"],[17716,17729,"Concept"],[17752,17764,"Concept"]],"Comments":[]}
{"id":9,"course": "cs0449", "lec": "lec11","text":"11\n\nHow\nPrograms\n\nAre Managed\n\nCS\/COE 0449\nIntroduction to\nSystems Software\n\nLuis Oliveira\n(with content borrowed from wilkie and Vinicius Petrucci)\n\n\fWhere’s the Lie?\nAnd other operating systems questions.\n\n2\n\n\fOn the last episode…\n• Programs are loaded into memory by the\noperating system.\n• They have to exist in memory before they can\nbe executed.\n\nKernel Memory\nstack\nlibz.so .data\n\nlibz.so .text\n\n• Programs go through a lot of trouble to have\nall their data\/code in memory.\n\n.bss\n.data\n\n.text\n\n3\n\n3\n\n\fThe Lie\n• Programs are told that they are\nthe only things running…\n• The only things in memory…\n• We know that this is not true!\n• Operating Systems are big liars\ncrafting illusions.\n\n4\n\n\fThe Truth\n• In reality, many programs can be running at the same time.\n• Each program, when running, is typically called a process.\n▪ A multitasking OS is (a rather common) one that supports concurrent\nprocesses.\n\n• The OS must handle switching from one process to another.\n▪ Which processes get to run?\n▪ What if you have more processes than CPUs?\n▪ When do you switch from one to another?\n▪ What if one is more urgent??\n5\n\n\fMy process is one of method…\n• A process is an abstraction representing a single instance of a program.\n▪ An executable represents the initial state of a program and thus the process.\n▪ A program can be instantiated multiple times, if needed.\n▪ Each one would be a separate process… of the same program.\n▪ Note: A processor is the hardware unit that executes a process. (makes sense!!)\n\n• The Operating System defines what a process and its abstraction is.\n▪ There is an OS representation and metadata associated with a process.\n▪ The OS maintains two key lies:\n\n• The control flow (exclusive use of CPU): as defined by the code (this lecture)\n• The memory layout (exclusive use of memory): defined by executable\/code (next lecture)\n\n• We are focusing on the control flow, here.\n\n▪ How do we determine when a program runs? When does the lie… break down?\n6\n\n\fCPU Scheduling\nEeny Meeny Miney Moe\n\n7\n\n\fThe Reality\n• Let us say that we have a machine with four separate CPUs.\n▪ You could run four processes concurrently (at the same time) relatively easily.\n▪ What about the fifth?\nstack\n\nstack\n\nstack\n\nstack\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\nCPU State:\nRegisters\n,\n\n8\n\n\fMultiplexing the CPU\n• Truth be told, we often have fewer resources than needed.\n▪ Sharing a common resource is called multiplexing.\n\n• Now, consider a machine with a single CPU.\n\nProcess\n\nstack\n.bss\n\n• We often want to run something in the foreground.\n\n▪ Word processor, web browser, minesweeper… whatever.\n\n.data\n\n• We still want some things running the background…\n\n.text\n\n• We need to switch from one process to another at\nparticular times.\n\nCPU State:\nRegisters\n,\n\n▪ Music player, virus scanner, chat client.\n\n▪ Yet… we have to keep the illusion that the program is\nuninterrupted…\n\nCPU\n\n9\n\n\fNaïve Campbell was great in The Craft (1996)\n• One way is to run processes sequentially (the naïve solution)\n▪ When one process ends… run the next.\n▪ Yet that’s not very flexible. (Stop your music player to open a PDF)\n• Humans are in the mix! We need computers to be useful to us.\n\nstack\n\nstack\n\nstack\n\nstack\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\nMemory\nCPU\n\n10\n\n\fThe cruel passage of time\n• To multiplex the CPU, we quickly switch from process to process.\n• The OS retains\/restores the state (context) of the process.\n▪ The OS must store this as a form of process metadata in memory.\nstack\n\nstack\n\nstack\n\nstack\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\nCPU State A:\nRegisters\n,\n\nCPU State B:\nRegisters\n,\n\nCPU State C:\nRegisters\n,\n\nCPU State D:\nRegisters\n,\n\nMemory\nCPU\n\n11\n\n\fThe Context Switch\n• When an Operating System goes from\none process to another, it performs a\ncontext switch.\n• This swaps out the CPU state of one\nprocess for the next one to run.\n1. Store registers (including stack\npointer and program counter) to\nmemory.\n2. Determine next process to run.\n3. Load those registers from memory.\nSwitch memory space. (see next lecture:\n\nstack\n\nstack\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\nContext\n\nContext\n\nCPU State A:\nRegisters\n,\n\nCPU State B:\nRegisters\n,\n\nvirtual memory)\n\n4. Jump to old program counter. Go!\n\nCPU\n\n12\n\n\fA deeper dive\n• When we pause a process… we store the state of registers (context)\nx86-64 (gas \/ AT&T syntax) – Process A\n\nContext (A)\n\nx86-64 (gas \/ AT&T syntax) – Process B\n\nCPU State\n\n13\n\n\fWhen is a good time to call you?\n• When should a program pause and let another one go?\n• When programs voluntarily pause, this is called cooperative\nscheduling.\n▪ They may give up control at convenient points such as system calls.\n\n• We often do not expect this, so modern Operating Systems forcibly\npause programs from time to time. Called preemptive scheduling.\n▪ Processes give up control when hardware interjects via an “interrupt”\n▪ How does this work?\n\n14\n\n\fRound Robin Scheduling\n• One method is to just cycle through each process each for equal time.\n▪ This is an element of “fairness” … each gets equal stake.\n50ms\n\n50ms\n\n50ms\n\n50ms\n\nstack\n\nstack\n\nstack\n\nstack\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\nCPU State A:\nRegisters\n,\n\nCPU State B:\nRegisters\n,\n\nCPU State C:\nRegisters\n,\n\nCPU State D:\nRegisters\n,\n\nMemory\nCPU\n\n15\n\n\fProblems with “fairness”\n• Let’s say I want to play Doom Eternal\n▪ In round-robin, I give the video game 25% of my resources.\n50ms\n\n50ms\n\n50ms\n\n50ms\n\nstack\n\nstack\n\nstack\n\nstack\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\nCPU State A:\nRegisters\n,\n\nCPU State B:\nRegisters\n,\n\nCPU State C:\nRegisters\n,\n\nCPU State D:\nRegisters\n,\n\nThis should get\nmore priority.\n\nCPU\n\n16\n\n\fI have priorities!\n• Round-Robin schedulers are fair; then we tweak to meet expectations.\n▪ How might we add a sense of “priority” to the scheduler?\n\n• Let’s look at a visualization of how processes are currently scheduled\nwith a round-robin scheme: (Doom gets only 25% of resources!) \n50ms\n\n50ms\n\n50ms\n\n50ms\n\n50ms\n\n50ms\n\nA\n\nA\nB\n\nB\n\nC\n50ms \/ 200ms = 25%\n\n17\n\n\fI have priorities!\n• Round-Robin schedulers are fair; then we tweak to meet expectations.\n▪ How might we add a sense of “priority” to the scheduler?\n\n• We could give some tasks a longer quantum.\n▪ A quantum is the amount of time a task is guaranteed to run.\n100ms\n\n50ms\n\n50ms\n\n50ms\n\n100ms\n\nA\nB\n\nC\n100ms \/ 250ms = 40%\n\n18\n\n\fI have priorities!\n• Round-Robin schedulers are fair; then we tweak to meet expectations.\n▪ How might we add a sense of “priority” to the scheduler?\n\n• We could increase the chance a specific task is scheduled.\n▪ Round-robin + priority: two queues, switch back and forth and round-robin\nwithin them.\n50ms\n\n50ms\n\n50ms\n\n50ms\n\n50ms\n\n50ms\n\nA\nB\n\nC\n100ms \/ 200ms = 50%\n\n19\n\n\fI have priorities!\n• Round-Robin schedulers are fair; then we tweak to meet expectations.\n▪ How might we add a sense of “priority” to the scheduler?\n\n• We can then always do some sort of combination.\n▪ Hybrid approaches do seem very alluring. Hmm. The power of trade-offs.\n100ms\n\n50ms\n\n100ms\n\n50ms\n\nA\nB\n200ms \/ 300ms = 67%\n\n20\n\n\fIdeal circumstances: Human perception\n• The reality: (very quickly switching)\n100ms\n\n50ms\n\n100ms\n\n50ms\n\nA\nB\n\n• The illusion: (an ideal: perceived concurrency… no delay noticed)\n100ms\n\n50ms\n\n100ms\n\n50ms\n\nA\nB\n\n21\n\n\fThere is no optimal.\n• Like many of the topics in this course, there is no possible “best”.\n▪ That is, there is no way to perfectly schedule general processes.\n\n• Consider: It would be very lovely to schedule a process that handles\nsome user input, like a button press or a network request.\n▪ Perfect situation: the OS schedules the task that handles the button\nimmediately before the button is pressed. What luck!\n\n• However: You do not know when that button will be pressed.\n▪ Maybe it is a sensor, like for detecting a fire!\n• FIRE SEEMS IMPORTANT!! … and yet.\n\n• Moral of the story: humans being users make things very hard.\n\n22\n\n\fAgain, it is not magic.\n• But… wait… how does hardware stop a program?\n▪ For instance, when the quantum is up, how does the OS get control and\nperform the context switch?\n\n• Ah, the hardware has support for “being rude” which is called an\ninterrupt.\n▪ A programmable mechanism for asynchronously calling a function when a\nparticular type of error or signal is noticed.\n\n• Let’s take a look.\n\n23\n\n\fInterrupts\nIt’s rude… but necessary.\n\n24\n\n\fHow rude\n• An interrupt is an exceptional state that diverts execution from its\nnormal flow.\n▪ When issued by hardware, sometimes referred to as a hardware exception\n• For instance, a hardware timer or external event caused by a sensor.\n\n▪ When caused by a user process, sometimes referred to as a software trap\n• Divide-by-zero error, some floating-point exceptions, system calls.\n\n• We have seen these before!\n▪ System calls are a type of interrupt (software trap).\n▪ This is an intentional interrupt caused by a specific program instruction.\n• The program is “interrupted” while the OS performs a task.\n\n• We have also encountered them in our failures.\n▪ Segmentation \/ Protection \/ Page Faults are also interrupts. (trap? exception?)\n▪ These are (usually) unintentional interrupts caused by a generic instruction. 25\n\n\fHere are some typical UNIX\/Linux system calls:\nNumber\n\nName\n\nDescription\n\nread\n\nReads bytes from an open file.\n\nwrite\n\nWrites bytes to an open file.\n\nopen\n\nOpens a file and returns the file handle.\n\nclose\n\nCloses an open file.\n\nstat\n\nReturns metadata about a file.\n\nfork\n\nSpawns a copy of the current process.\n\nexecve\n\nLoads and then executes a program.\n\n26\n\n\fSystem calls\n• System calls: predictable, intentional interrupts at specific instructions.\n▪ Interrupts occurring at specific instructions are synchronous interrupts.\n\n• In x86-64, the program pauses at a\ninstruction, then resumes\nat the following instruction when the OS finishes the task\n▪ (… and the OS calls the\n\ninstruction)\n\n• Let’s take a deeper look.\n27\n\n\fHello, Hello World\nx86-64 (gas \/ AT&T syntax) - Application\n\nx86-64 (gas \/ AT&T syntax) - Kernel (main OS program)\n\nPre-registered to be called on syscall\nSaves CPU state\n\nA jump to the kernel\n\nPerforms action\nRestores state\n\nReturns to process\n\n28\n\n\fTick tock tick tock merrily sings the clock\n• A hardware timer can preempt (forcibly pause) a program at any time.\n▪ Interrupts that occur at any instruction are asynchronous interrupts.\n\n• In a preemptive operating system, a hardware timer is used to give a\nmaximum bound to how long a process runs.\n▪ Your operating system programs the timer such that it sends a signal at a\nregular interval.\n▪ Your operating system has a function that is called when such a signal is read.\n▪ That function will respond by invoking the scheduler and pausing the current\ntask and resuming or starting another.\n\n• Let’s look at the basic procedure an OS uses to program an interrupt.\n29\n\n\fProgramming interruption\n• On most hardware, there is a programmable table somewhere in\nmemory that, when written to, defines where code exist to handle\neach interrupt.\n• Every possible interrupt is given a number. Segmentation faults might\nbe interrupt 10. Timers might be interrupt 0. Et cetera.\n• When an interrupt occurs, based on its interrupt number, the\ncorresponding entry in a lookup table called an interrupt vector table\nor an interrupt descriptor table would be used to determine where in\nthe kernel to jump.\n30\n\n\fThe Interrupt Table\n#\n\nValue\n\n• The interrupt table is a simple table.\n\nDescription\nDivide by zero\n\n• Fun Fact: It is often located at\naddress 0x0 in memory!\n\nOverflow\nDouble Fault\nGeneral Protection Fault\nPage Fault\nStack Fault\nAlignment Error\n...\nTimer Signal\nNetwork Device Signal\n\n▪ So, operating system kernels can’t\nexactly always treat zero as an invalid\naddress…\n\n• When a process triggers a listed\ninterrupt or external hardware sends\na signal to the interrupt controller…\n▪ the CPU jumps to the given address.\n\nAudio Device Signal\n\n31\n\n\fAh! There art thee ol’ interrupt!\n• Let’s take a look at interrupt handling…\nx86-64 (gas \/ AT&T syntax) – Process B\nA\n\nContext (A)\n\nCPU State\n\nx86-64 (gas \/ AT&T syntax) – Kernel\n\n• An interrupt is the likely\ncause of our prior\ninterruption.\n• The interrupt handler is the\ncode that handles context\nswitching and scheduling\n32\n\n\fOverview\n• Interrupts can be categorized in several ways:\n▪ They can occur outside of our program:\nhardware exceptions\n▪ They can occur on an instruction in our program: software trap\n▪ They can occur at any time:\nasynchronous interrupts\n▪ They can occur at specific times:\nsynchronous interrupts\n\n• Interrupts are what allow operating systems to function!\n▪ When you press a key on your keyboard.\n▪ When you receive a packet on the network.\n▪ When your sound card wants the next second of audio.\n▪ When you divide by zero…\n• To then mercilessly murder your process.\n\n33\n\n\f","label":[[819,826,"Concept"],[832,844,"Concept"],[898,907,"Concept"],[950,957,"Concept"],[978,987,"Concept"],[1024,1033,"Concept"],[1125,1132,"Concept"],[1155,1162,"Concept"],[1231,1241,"Concept"],[1297,1304,"Concept"],[1310,1317,"Concept"],[1396,1403,"Concept"],[1417,1424,"Concept"],[1483,1490,"Concept"],[1547,1554,"Concept"],[1642,1649,"Concept"],[1984,1994,"Concept"],[2115,2124,"Concept"],[2447,2459,"Concept"],[2508,2515,"Concept"],[2733,2740,"Concept"],[2888,2895,"Concept"],[2989,2998,"Concept"],[3044,3051,"Concept"],[3355,3364,"Concept"],[3397,3404,"Concept"],[3408,3415,"Concept"],[3454,3461,"Concept"],[3470,3477,"Concept"],[3517,3524,"Concept"],[3770,3784,"Concept"],[3826,3833,"Concept"],[3860,3874,"Concept"],[3914,3921,"Concept"],[4041,4048,"Concept"],[4351,4358,"Concept"],[4393,4400,"Concept"],[4560,4567,"Concept"],[4605,4613,"Concept"],[4648,4670,"Concept"],[4817,4825,"Concept"],[4852,4873,"Concept"],[4877,4886,"Concept"],[4936,4945,"Concept"],[4974,4997,"Concept"],[5792,5814,"Concept"],[6331,6338,"Concept"],[6476,6498,"Concept"],[6845,6867,"Concept"],[8240,8249,"Concept"],[8398,8408,"Concept"],[8455,8464,"Concept"],[8703,8710,"Concept"],[8882,8891,"Concept"],[8934,8943,"Concept"],[9004,9015,"Concept"],[9148,9158,"Concept"],[9215,9225,"Concept"],[9678,9688,"Concept"],[9717,9727,"Concept"],[9767,9789,"Concept"],[10306,10313,"Concept"],[10356,10366,"Concept"],[10401,10424,"Concept"],[10434,10444,"Concept"],[10896,10905,"Concept"],[11070,11079,"Concept"],[11098,11107,"Concept"],[11156,11165,"Concept"],[11186,11195,"Concept"],[11220,11229,"Concept"],[11251,11260,"Concept"],[11321,11343,"Concept"],[11350,11376,"Concept"],[11819,11826,"Concept"],[11845,11854,"Concept"],[12008,12017,"Concept"],[12042,12051,"Concept"],[12170,12179,"Concept"],[12213,12225,"Concept"],[12233,12242,"Concept"],[12276,12293,"Concept"],[12298,12308,"Concept"],[12325,12335,"Concept"],[12528,12551,"Concept"],[12588,12610,"Concept"],[12614,12624,"Concept"]],"Comments":[]}
{"id":17,"course": "cs1502", "lec": "turing_machine_02","text":"Turing Machine 02\nThumrongsak Kosiyatrakul\ntkosiyat@cs.pitt.edu\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 02\n\n\fTuring Machine Example\n\nDesign a Turing machine that recognizes the language B\nwhere\nB = {w#w | w ∈ Σ∗ }\nOn input string w:\n1\n\n2\n\nZig-zag across the tape to corresponding positions on either\nside of the # symbol to check whether those positions contain\nthe same symbol. If they do not, or if no # is found, reject.\nCross off symbols as they are checked to keep track of which\nsymbols correspond.\nWhen all symbols to the left of the # have been crossed off,\ncheck for any remaining symbols to the right of the #. If any\nsymbols remain, reject; otherwise, accept.\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 02\n\n\fTuring Machine M1\nA Turing machine that decides B = {w#w | w ∈ Σ∗ }.\n\n1\n\nx,\nR\n\nq1\n\n0\n\nR\nx,\n\n→\n\n→\n\n#→R\n\n0, 1 → R\n\nq2\n#→R\n\nx→R\n\nx→R\n\nq8\nt\n\nq4\n\n→R\n\n#→R\n\nqaccept\n\nq5\n\n1\n\nL\nx,\n\n→\n\n→\n\nx,\n\nL\n\n0\n\n0, 1, x → L\n\nq6\n#→L\nx→R\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nq7\n\n0, 1 → R\n\nq3\n\n0, 1 → L\n\nTuring Machine 02\n\nx→R\n\n\fTuring Machine M1\nΣ = {0, 1, #}\nΓ = {0, 1, #, x, t}\n1 → x, R\nRead 1, write x, and move the tape head to the right direction\n\n#→R\nA shorthand notation for # → #, R\nRead #, write #, and move the tape head to the right direction\n\n0, 1 → L\nA shorthand notation representing two transitions:\n0 → L which is 0 → 0, L\n1 → L which is 1 → 1, L\n\nqreject is omitted\nAll missing exiting arrows go to qreject\nAssume that it moves the tape head to the right direction\nbefore entering qreject without writing a symbol (writing the\nsame symbol it read)\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 02\n\n\fTuring Machine M1\nComputing 01#01\n\n1\n\nx,\nR\n\nq1\n\n0, 1 → R\n\nR\n\n0\n\nx,\n\n→\n\n→\n\n#→R\n\nq2\n#→R\n\nx→R\n\nx→R\n\nq8\nt\n\nq4\n\n0, 1 → R\n\nq3\n\n→R\n\n#→R\n\nqaccept\n\nq5\n\n1\n\nL\nx,\n\n→\n\n→\n\nx,\nL\n\n0\n\n0, 1, x → L\n\nq6\n#→L\nx→R\n\nq7\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\n0, 1 → L\n\nTuring Machine 02\n\nx→R\n\nq1 01#01\nxq2 1#01\nx1q2 #01\nx1#q4 01\nx1q6 #x1\nxq7 1#x1\nq7 x1#x1\nxq1 1#x1\nxxq3 #x1\nxx#q5 x1\nxx#xq5 1\nxx#q6 xx\nxxq6 #xx\nxq7 x#xx\nxxq1 #xx\nxx#q8 xx\nxx#xq8 x\nxx#xxq8 t\nxx#xxtqaccept\n\n\fTuring Machine M1\nComputing 01#10\n\n1\n\nx,\nR\n\nq1\n\n0, 1 → R\n\nR\n\n0\n\nx,\n\n→\n\n→\n\n#→R\n\nq2\n#→R\n\nx→R\n\nx→R\n\nq8\nt\n\nq4\n\n0, 1 → R\n\nq3\n\n→R\n\n#→R\n\nqaccept\n\nq5\n\n1\n\nL\nx,\n\n→\n\n→\n\nx,\nL\n\n0\n\n0, 1, x → L\n\nq6\n#→L\nx→R\n\nq7\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\n0, 1 → L\n\nTuring Machine 02\n\nx→R\n\nq1 01#10\nxq2 1#10\nx1q2 #10\nx1#q4 10\nx1#1qreject 0\n\n\fTuring Machine M1\nComputing 01 (no # symbol)\n\n1\n\nx,\nR\n\nq1\n\n0, 1 → R\n\nR\n\n0\n\nx,\n\n→\n\n→\n\n#→R\n\nq2\n#→R\n\nx→R\n\nx→R\n\nq8\nt\n\nq4\n\n0, 1 → R\n\nq3\n\n→R\n\n#→R\n\nqaccept\n\nq5\n\n1\n\nL\nx,\n\n→\n\n→\n\nx,\nL\n\n0\n\n0, 1, x → L\n\nq6\n#→L\nx→R\n\nq7\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\n0, 1 → L\n\nTuring Machine 02\n\nx→R\n\nq1 01\nxq2 1\nx1q2 t\nx1tqreject\n\n\fTuring Machine Example\n\nDesign a Turing machine that recognizes the language A\nwhere\nn\nA = {02 | n ≥ 0}\nOn input string w:\n1\n2\n3\n\n4\n5\n\nSweep left to right across the tape, crossing off every other 0\nIf in stage 1 the tape contained a single 0, accept\nIf in stage 1 the tape contained more than a single 0 and the\nnumber of 0s was odd, reject\nReturn the head to the left-hand end of the tape\nGo to stage 1\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 02\n\n\fMoving the Tape Head Back\nSuppose we want to move the tape head back to the left most\nend of the tape\nNeed a state to do that\n0, 1, x → L\n\nThis will result in an infinite loop\n\nRecall that if the tape head is at the left-most square and the\ntransition is L, it will stay at the same place\nThere is no signal telling a TM that its tape head is currently\nat the left-most square\n\nThe trick is to mark the left-most symbol (depending on Γ)\nTurn 0 or 1 to t\nTurn 0 to 0̇ or x\nTurn 1 to 1̇ or t\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 02\n\n\fTuring Machine M2\nn\n\nA Turing machine that decides A = {02 | n ≥ 0}.\n0→L\nx→L\n\n→\nt\n\n→R\nx→R\n\n0 → x, R\n\nt\n\nt\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\n→R\n\nq3\n\n0→R\n\nqaccept\n\nt\n\nx→R\n\nL\n\nq2\n\n0 → t, R\n\nqreject\n\n→\n\nx→R\nq1\n\nt\n\nR\n\nq5\n\n→R\n\nTuring Machine 02\n\n0 → x, R\n\nq4\n\nx→R\n\n\fTuring Machine M2\nComputing 0000\nq1 0000\nq2 000\ntxq3 00\ntx0q4 0\ntx0xq3 t\ntx0q5 x\ntxq5 0x\ntq5 x0x\nq5 tx0x\ntq2 x0x\ntxq2 0x\ntxxq3 x\ntxxxq3 t\ntxxq5 x\ntxq5 xx\ntq5 xxx\nq5 txxx\ntq2 xxx\ntxq2 xx\ntxxq2 x\ntxxxq2 t\ntxxxtqaccept\nt\n\n0→L\nx→L\n\n→\nt\n\n→R\nx→R\n\n→R\n\nqaccept\n\nt\n\nq3\n\n0 → x, R\n\nt\n\nx→R\n\nL\n\nq2\n\n0 → t, R\n\nt\n\nqreject\n\n→\n\nx→R\nq1\n\nt\n\nR\n\nq5\n\n0→R\n\n0 → x, R\n\nq4\n\nx→R\n\n→R\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 02\n\n\fTuring Machine M2\n\nComputing 000\n0→L\nx→L\n\n→\nt\n\n→R\nx→R\n\n→R\n\nqaccept\n\nt\n\nq3\n\n0 → x, R\n\nt\n\nx→R\n\nL\n\nq2\n\n0 → t, R\n\nt\n\nqreject\n\n→\n\nx→R\nq1\n\nt\n\nR\n\nq5\n\n0→R\n\n0 → x, R\n\nq4\n\nx→R\n\n→R\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nq1 000\nq2 00\ntxq3 0\ntx0q4 t\ntx0tqreject\nt\n\nTuring Machine 02\n\n\fDesigning a TM\nDesigning a TM in a form of a state diagram is hard\nNeed to keep in mind out the content of the tape\nNeed to worry about moving tape head\n\nBut for a simple problem, it is not that bad\nLet’s create a TM that shift all symbols on the tape to the\nright by one square by inserting the blank symbol at the\nleft-most square and move the tape head back to the\nleft-most square\nLet Σ = {0, 1} and Γ = {0, 1, t}\nHere are some input\/output (on the tape)\nInput\nOutput\n01101 t01101\n0\nt0\n111\nt111\nε\nε\nNote that this TM always accepts all strings over Σ\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 02\n\n\fDesigning a TM\nSolution\n0→R\n\nq1\n0 → t, R\n1 → 0, R\n\n0 → 1, R\n\nq0\n\nt\n\n1 → t, R\n\n→ 0, L\n0, 1 → L\n\nq3\nt\n\n→ 1, L\n\nt\n\n→L\nqaccept\n\nq2\n\n1→R\nt\n\n→L\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 02\n\n\f","label":[[132,146,"Concept"],[4934,4943,"Concept"]],"Comments":[]}