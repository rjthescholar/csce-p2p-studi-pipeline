{"id": 106, "segment": ["train_set", "labeled"],  "course": "cs1622", "lec": "lec14_more_codegen", "text": "More Codegen and Arrays\nCS 1622\nJarrett Billingsley\n\n\fClass Announcements\n\u25cf?\n\n2\n\n\fQuick Recap Our Calling Convention\n\n3\n\n\fCaller\n\u25cf remember that the caller passes all arguments on the stack.\nglob = f(1, 2);\naddi sp, sp, -8\nli\nt0, 1\nsw\nt0, 0(sp)\nli\nt0, 2\nsw\nt0, 4(sp)\njal f\nsw\nv0, glob\n\npush the two arguments\u2026\n\ncall the function\u2026\nv0 is the return value (if any).\n\nand remember the ATV rule: after a jal, a, t, v registers'\nvalues may differ, but s registers' values will be the same.\n4\n\n\fCallee\n\u25cf every function has a stack frame to hold the arguments, locals, and\nsaved registers for that call.\nfn f(x: int, y: int) {\nlet z = x + y;\nfor i in 0, z {\nprintln_i(i);\n}\n}\n\ny\n\n4(fp)\n\nx\n\n0(fp)\n\narguments are accessed with\npositive offsets from fp;\n\nfp\nra\n\ni\nz\nthese are the saved copies of\nthe caller's fp/ra registers.\n\n-12(fp) and locals are accessed with\n-16(fp) negative offsets from fp.\nsp always points at\nthe top of the stack.\n5\n\n\fPrologue and Epilogue\n\u25cf the stack frame is set up by the prologue and torn down by the\nepilogue; these will surround every function.\nf:\nsw\nfp, -4(sp)\nsw\nra, -8(sp)\nmove fp, sp\naddi sp, sp, -n\ncode goes here!\nlw\nra, -8(fp)\nlw\nfp, -4(fp)\naddi sp, sp, x\njr\nra\n\nhere, n represents the size (in bytes) of\nall locals and saved registers.\nand here, x represents the size (in bytes) of\nall locals, saved registers, and arguments.\nthis leaves the stack completely clean.\n6\n\n\fThe Code Inside Functions\n\n7\n\n\fNot a tutorial\n\u25cf this isn't going to be a point-by-point explanation of how to\ngenerate code for every statement and expression.\n\u25cf rather, I want to give you an idea of what generating code is like\u2026\no and to go over some of the trouble spots that come up.\n\u25cf so, this section might be a bit rambly and unfocused, and that's why:\nit's just a bunch of codegen-related ideas.\n\u25cf after all, project 4 is where you'll be generating code, and I don't wanna give too much away ;)\n\n8\n\n\fBlock statements\n\u25cf the body of a function is a { block }, which is just several statements.\n\u25cf this is easy to generate code for: you just concatenate the code.\n{\nstmt1;\nstmt2;\nstmt3;\n\ncode for stmt1\ncode for stmt2\ncode for stmt3\n\n}\nthis works because the runtime semantics of block statements are\na very good match for how code is naturally executed by the CPU.\nbut that's not the case for all statements\u2026\n9\n\n\fAccessing variables\n\u25cf HLLs hide how variables are accessed at the point of use.\nlet g = 10;\nfn main() {\nlet x = 1;\n\n}\n\nhere we store to a local variable:\nsw t0, -12(fp)\n\ng = 2;\n\nhere we store to a global variable:\nsw t0, g\n\nprint_i(x);\n\nhere we load from a local variable:\nlw t0, -12(fp)\n\nprint_i(g);\n\nhere we load from a global variable:\nlw t0, g\n10\n\n\fEvaluating expressions\n\u25cf things start to get really tricky here.\n\ng = x + y;\n\nlw\nlw\nadd\nsw\n\nt0, 0(fp)\nnow we have to come up\nt1, 4(fp)\nt0, t0, t1 with registers to use for each\npart of the expression.\nt0, g\n\nthe order we do things in can affect how many registers we need.\n\ng = x + y + z;\n\nlw\nlw\nadd\nlw\nadd\nsw\n\nt0, 0(fp)\nt1, 4(fp)\nt0, t0, t1\nt1, 8(fp)\nt0, t0, t1\nt0, g\n\nlw\nlw\nor? lw\nadd\nadd\nsw\n\nt0, 0(fp)\nt1, 4(fp)\nt2, 8(fp)\nt0, t0, t1\nt0, t0, t2\nt0, g\n11\n\n\fThe need for saved registers\n\u25cf once you mix function calls in, it gets all kinds of complicated.\n\ng = x + f();\n\nlw\njal\nadd\nsw\n\nt0, 0(fp)\nf\nt0, t0, v0\nt0, g\n\nthis is bad code! we are\nviolating the ATV rule.\n\nthis is because the value of t0 from before the call may not\nsurvive until its use after the call. f is allowed to change t0.\nso we have to use the saved (s) registers for some\ntemporaries, so their values will persist across calls.\nto make things simpler, we could use only the saved\nregisters, and ignore the t registers altogether.\n12\n\n\fA little detour\n\u25cf expressions are represented as trees, and trees \u2764\ufe0f stacks, so\u2026\n\u25cf let's first imagine evaluating an AST by pushing and popping things\non a stack, instead of dealing with registers.\ng = a + b;\n\n1. push a\n\n2. push b\n\n=\n\ng\n\n+\na\n\n3. pop them,\npush sum\n\nb\nb\n\nlet's evaluate the\nassignment's rhs.\n\na\n\na\n\na + b\n\nyou can use this strategy to evaluate\nany expression of any complexity.\n(let's do a few examples.)\n13\n\n\fOk? And? How does that help?\n\u25cf well\u2026 we can map that imaginary stack onto the registers.\ng = a + b;\n\ns1\n\n=\n\ns0\ng\n\na\n\ns0\n\nb\na\n\ns0\n\na + b\n\n+\na\n\nb\n\nthis tells us what register to put each value into!\n\nlw\nlw\nadd\nsw\n\ns0, 0(fp) # a\ns1, 4(fp) # b\ns0, s0, s1\ns0, g\n\nbut now we come to an important issue: to be allowed to use the\nsaved registers, we must save the caller's versions of them.\n14\n\n\fThe last piece of the calling convention\n\u25cf only after we have generated the code for a function, do we know\nhow many saved registers it needs.\n\u25cf so there is one more part of the stack frame:\ny\n\nx\n\nfp\n\nfp\nra\n\nin the prologue, we will have to store each of\nthese saved registers to the stack\u2026\n\n\u2026and in the epilogue, we will load them back.\n\ni\n\nz\ns1\ns0\n\nwe have to save the caller's values of any\nsaved registers this function uses.\n\nsp\n\nthis is how the saved register contract works.\nI taught it in 447 and it's just as relevant now.\n15\n\n\fSome last register allocation thoughts\n\u25cf can we use t registers at all?\no sure, as long as we can prove that there are no function calls\nfrom the time we put a value in it to the time we use that value.\no that might be pretty simple: look at the AST \"to the right\" and if\nthere are no \u201cfunction call\u201d nodes, we can use a t register instead.\no this is more complicated, but it will use fewer (or no) s registers,\nmeaning less time/space spent saving/restoring them.\n\u25cf there are only 8 saved registers (s0 .. s7). what if we need more?\no uhh \ud83d\udca6\no well, this register allocation scheme will work for simple code.\no we'll talk about a much more sophisticated algorithm at the end\nof the course, which will solve this problem (and others, like using\na registers for arguments instead of the stack).\n16\n\n\fControl flow statements\n\u25cf assuming we've got expressions worked out, another surprisingly\ntricky bit is control flow statements: conditionals and loops.\no specifically, the conditions for these statements can be hard to\ngenerate good code for. (but that's not a primary goal here.)\nif i < 10 {\n...\n}\n\nlw\nbge\n...\n_end:\n\ns0, -16(fp)\ns0, 10, _end\n\ngetting the condition that simple is hard to\ndo; we might do something like this instead:\nlw\nli\nslt\nbeq\n...\n_end:\n\ns0, -16(fp)\ns1, 10\ns0, s0, s1\ns0, zero, _end\n\n17\n\n\fLazy operators (\"short-circuiting\")\n\u25cf recall that like in most languages, logical and and or will only\nevaluate their rhs if they have to \u2013 making their codegen very\ndifferent from the other operators.\nif i < 10 or i > 20 {\n...\n}\nsee how it skips right to the code\nwhen the first condition is true?\n\nlw\ns0, -16(fp)\nli\ns1, 10\nslt s0, s0, s1\nbne s0, zero, _true\nlw\ns0, -16(fp)\nli\ns1, 20\nsgt s0, s0, s1\nbeq s0, zero, _end\n_true:\n...\n_end:\n\n18\n\n\fYou can assign comparison operators into variables\n\u25cf it seems like no one teaches you this but this is totally valid code in\nJava (and in lots of other languages too):\nboolean b = x < 10;\nboolean d = i < 10 || i > 20;\n\u25cf because of this, you may not be able to use the same codegen\nalgorithm for e.g. logical OR in all cases!\no you still have to do the short-circuiting\u2026\no but now you're producing a value to be put into a variable\no which, depending on how your codegen works, could be a very\ndifferent thing from \"writing a condition for a loop\"\n\n19\n\n\fArrays\n\n20\n\n\fAdding features is Fun\u2122\n\u25cf okay. now let's assume we've implemented lexing, parsing, semantic\nanalysis, and codegen for all the basic features of our language:\no variables, functions, ints, bools, strings. just the simple stuff.\n\u25cf let's now think about how we'd go about adding a new feature to\nthe language, from design all the way through to codegen.\no and along the way, this might give you an appreciation for how\nparts of the language interact with one another.\n\u25cf we'll be adding arrays, which will work very similarly to how they do\nin Java, but with some slightly different syntax.\n\n21\n\n\fMinimum Viable Product\n\u25cf a good place to start is by writing some code to get a feel for how\nwe want this feature to look and work.\n\u25cf let's focus on the absolute core features of arrays: allocating them,\naccessing their items, and getting their length.\nlet a = new [int; 10];\n\nthis syntax might look a bit odd, but it's meant to echo a similar\nsyntax used in Rust. it's also easier to parse than new int[10].\na[0] = 5;\n\nI think it's clear what's happening here.\nfor i in 0, a.length { println_i(a[i]); }\n\nand this is familiar too!\n22\n\n\fLexing and Parsing\n\u25cf for lexing, we only need to add two tokens to our lexer: [ and ].\n\u25cf for parsing, we've got a few new rules to add.\nnew [int; 10]\n\nNew:\n'new' (StructNew | ArrayNew)\nStructNew: Id '(' ')'\nArrayCtor: '[' Type ';' Exp ']'\n\na[0] = 5;\n\nPostfixOp: FuncCall | Field | Index\nIndex:\n'[' Exp ']'\n\none more important rule: we have to be able to write array\ntypes, for things like function arguments and struct fields.\nType:\n\nfn f(a: [int])\nArrayType:\n\nVoidType | 'bool' | 'int' |\n'string' | FuncType |\nStructType | ArrayType\n'[' Type ']'\n\n23\n\n\fSemantic analysis: typing rules\n\u25cf arrays don't interact with the naming rules at all, so let\u2019s skip to types.\nnew [T; n]\n\na[i]\n\na.length\n\n\u25aa n must be int\n\u25aa the type of the whole expression is [T]\n\u25aa a must be [T]\n\u25aa i must be int\n\u25aa the type of the whole expression is T\n\u25aa if a is [T]:\n\u25aa the only allowed field is length\n\u25aa the type of the whole expression is int\n\u25aa and this cannot be the lhs of =\n24\n\n\fMore semantics: evaluation rules\n\u25cf these explain what the code does, which can also require runtime\nerror checking.\nnew [T; n]\n\na[i]\n\na.length\n\n\u25aa dynamically allocates an array on the heap.\n\u25aa n must be >= 0.\n\u25aa if not, the program halts with an error.\n\u25aa gets the ith item in a, zero-based.\n\u25aa a is evaluated before i.\n\u25aa i must be >= 0 and < a.length.\n\u25aa if not, the program halts with an error.\n\u25aa gets the length of a.\n25\n\n\fRuntime representation: data\n\u25cf as you hopefully learned in 447, an array is represented in memory by\nplacing its items next to each other, equidistantly spaced.\n\u25cf consider an array of 3 ints which are 32 bits (4 Bytes) each:\n\nA[0]\nbyte offset:\n\n0\n\nA[1]\n1\n\n2\n\n3\n\n4\n\nA[2]\n5\n\n6\n\n7\n\n8\n\n9\n\n10 11\n\ngiven a pointer A that points to the beginning of the\narray, we can get the ith item with the formula A + S\u00b7i,\nwhere S is the size of one item.\n\nhere, S = 4, so A + 4\u00b7i gives us the byte offset of item i.\n26\n\n\fRuntime representation: length\n\u25cf each array also has to remember its length, because there's\nnothing to tell you where \"the end of the array\" is.\nlet a = new [int; 3];\n3\n\nthe length comes first\nand takes up 4 bytes.\n\n0\n\n0\n\n0\n\nso now our item access formula must be\noffset by 4 to skip the length: A + S\u00b7i + 4\n(different types use different values of S, so\nwe can't do A + S(i + 1) in general.)\n\nnow we have all we need to be able to implement\na[i] and a.length! but what about new[int; 3]?\n27\n\n\fRuntime library: allocating arrays\n\u25cf dynamic memory allocation is something the runtime library is\nresponsible for. so, we'll need a function to allocate arrays.\n\u25cf fn rt$new_array(item_size: int, len: int)\no this will allocate an array of len items, where each item is\nitem_size bytes; zero out the data; set its length field to len;\nand return a pointer to it.\no it will also crash the program if len is negative, as per the\nevaluation semantics.\n\u25cf the code generation will turn array allocations into calls to this\nfunction, using a constant for item_size based on the type.\no e.g. for an array of bool, item_size is 1; for int it's 4; etc.\n\n28\n\n\fCodegen\n\u25cf finally, code generation is fairly straightforward.\nnew [T; n]\na.length\na[i]\n\ngenerated as a call to rt$new_array(S, n)\nload an int from the memory a points to\nfirst, crash if i is negative or >= a.length. if not,\ncalculate address as a + Si + 4; then load/store\n\nand we're done! yay, our language has arrays now!\n\n29\n\n\fOr does it?\n\u25cf this is just the minimum viable version of this feature.\n\u25cf what about things like:\no array initializers/literals, for allocating and filling in arrays at the\nsame time like in Java: int[] a = new int[]{ 1, 2, 3 };\no better multi-dimensional array initialization, again like Java:\nint[][] a = new int[10][20];\n\u25aa remember, this is an array of arrays: each item in the outer array\n(the 10 dimension) is a reference to an array of 20 ints\no standard library functions for sorting, searching, filling,\nmodifying arrays?\n\u25cf such a simple-seeming feature, and yet so many things to consider\u2026\no but think about how each of these might be implemented on top\nof the basic features we talked about here.\n30\n\n\f", "label": [[5, 12, "Concept"], [17, 23, "Concept"], [98, 116, "Concept"], [122, 128, "Concept"], [149, 155, "Concept"], [167, 176, "Concept"], [184, 189, "Concept"], [212, 214, "Concept"], [216, 218, "Concept"], [241, 243, "Concept"], [263, 265, "Concept"], [286, 290, "Concept"], [299, 308, "Concept"], [311, 315, "Concept"], [340, 352, "Concept"], [381, 389, "Concept"], [488, 494, "Concept"], [518, 529, "Concept"], [542, 551, "Concept"], [553, 559, "Concept"], [565, 580, "Concept"], [674, 676, "Concept"], [684, 686, "Concept"], [689, 698, "Concept"], [739, 741, "Concept"], [744, 746, "Concept"], [789, 797, "Concept"], [798, 800, "Concept"], [820, 822, "Concept"], [828, 834, "Concept"], [857, 859, "Concept"], [883, 885, "Concept"], [887, 889, "Concept"], [922, 927, "Concept"], [933, 941, "Concept"], [946, 954, "Concept"], [961, 972, "Concept"], [990, 998, "Concept"], [1020, 1028, "Concept"], [1079, 1081, "Concept"], [1093, 1095, "Concept"], [1102, 1104, "Concept"], [1106, 1108, "Concept"], [1114, 1116, "Concept"], [1118, 1120, "Concept"], [1151, 1153, "Concept"], [1165, 1167, "Concept"], [1174, 1176, "Concept"], [1178, 1180, "Concept"], [1237, 1243, "Concept"], [1248, 1263, "Concept"], [1315, 1321, "Concept"], [1323, 1338, "Concept"], [1344, 1353, "Concept"], [1371, 1376, "Concept"], [1509, 1522, "Concept"], [1604, 1619, "Concept"], [1779, 1786, "Concept"], [1844, 1859, "Concept"], [1906, 1922, "Concept"], [1929, 1933, "Concept"], [1955, 1960, "Concept"], [2016, 2029, "Concept"], [2161, 2178, "Concept"], [2182, 2198, "Concept"], [2316, 2335, "Concept"], [2338, 2342, "Concept"], [2669, 2691, "Concept"], [2820, 2829, "Concept"], [2923, 2932, "Concept"], [3140, 3155, "Concept"], [3323, 3331, "Concept"], [3482, 3501, "Concept"], [3511, 3522, "Concept"], [3613, 3628, "Concept"], [3692, 3703, "Concept"], [3723, 3728, "Concept"], [3734, 3739, "Concept"], [3742, 3748, "Concept"], [3790, 3793, "Concept"], [3797, 3804, "Concept"], [3809, 3816, "Concept"], [3829, 3834, "Concept"], [3886, 3890, "Concept"], [3897, 3901, "Concept"], [3919, 3922, "Concept"], [3930, 3934, "Concept"], [4163, 4168, "Concept"], [4422, 4436, "Concept"], [4456, 4464, "Concept"], [4510, 4528, "Concept"], [4605, 4619, "Concept"], [4666, 4677, "Concept"], [4685, 4687, "Concept"], [4689, 4691, "Concept"], [4703, 4711, "Concept"], [4749, 4763, "Concept"], [4772, 4777, "Concept"], [4792, 4800, "Concept"], [4859, 4867, "Concept"], [4882, 4896, "Concept"], [4919, 4921, "Concept"], [4939, 4953, "Concept"], [5035, 5054, "Concept"], [5424, 5435, "Concept"], [5509, 5524, "Concept"], [5580, 5599, "Concept"], [5822, 5845, "Concept"], [5927, 5950, "Concept"], [6333, 6348, "Concept"], [6351, 6367, "Concept"], [6487, 6494, "Concept"], [7049, 7056, "Concept"], [7128, 7144, "Concept"], [7238, 7245, "Concept"], [7328, 7334, "Concept"], [7409, 7415, "Concept"], [7417, 7424, "Concept"], [7426, 7443, "Concept"], [7449, 7456, "Concept"], [7685, 7692, "Concept"], [7826, 7832, "Concept"], [8115, 8121, "Concept"], [8471, 8478, "Concept"], [8483, 8490, "Concept"], [8497, 8503, "Concept"], [8529, 8535, "Concept"], [8543, 8548, "Concept"], [8565, 8572, "Concept"], [8831, 8842, "Concept"], [9024, 9041, "Concept"], [9043, 9055, "Concept"], [9058, 9064, "Concept"], [9127, 9132, "Concept"], [9184, 9188, "Concept"], [9258, 9262, "Concept"], [9326, 9331, "Concept"], [9335, 9341, "Concept"], [9348, 9352, "Concept"], [9428, 9437, "Concept"], [9439, 9455, "Concept"], [9515, 9537, "Concept"], [9569, 9590, "Concept"], [9594, 9599, "Concept"], [9607, 9611, "Concept"], [9764, 9770, "Concept"], [9826, 9832, "Concept"], [9844, 9866, "Concept"], [9868, 9872, "Concept"], [10190, 10195, "Concept"], [10346, 10368, "Concept"], [10370, 10376, "Concept"], [10384, 10389, "Concept"], [10415, 10421, "Concept"], [10521, 10527, "Concept"], [10635, 10641, "Concept"], [10800, 10806, "Concept"], [10841, 10856, "Concept"], [10858, 10875, "Concept"], [10878, 10903, "Concept"], [10921, 10936, "Concept"], [10986, 11001, "Concept"], [11154, 11160, "Concept"], [11295, 11310, "Concept"], [11321, 11338, "Concept"], [11490, 11497, "Concept"], [11509, 11524, "Concept"], [11802, 11808, "Concept"], [11919, 11924, "Concept"], [11978, 11984, "Concept"], [12166, 12171, "Concept"], [12175, 12181, "Concept"], [12206, 12211, "Concept"], [12271, 12287, "Concept"], [12341, 12347, "Concept"]], "Comments": []}
{"id":107,"segment": ["train_set", "labeled"],  "course": "cs1622", "lec": "lec16_CFGs_and_IR","text":"Control Flow Graphs and\nIR\nCS 1622\nJarrett Billingsley\n\n\fClass Announcements\n● today: a second definition for CFG in the same course\no naming is hard, ok\no at least IR is new ;O\n\n2\n\n\fWe have a problem\n\n3\n\n\fOur compiler is producing terrible code. Oh no!\n● this is what my code generator produces for this tiny function.\nfn main() {\nprintln_i(5);\n}\nmain:\nsw\nfp, -4(sp)\nsw\nra, -8(sp)\nmove fp, sp\naddi sp, sp, -12\nsw\ns0, -12(fp)\naddi sp, sp, -4\nli\ns0, 5\nsw\ns0, 0(sp)\njal println_i\nlw\ns0, -12(fp)\nlw\nra, -8(fp)\nlw\nfp, -4(fp)\naddi sp, sp, 12\njr\nra\n\nit's a little excessive. a better compiler might\nproduce this (using the real MIPS ABI):\nmain:\naddi sp, sp, -4\nsw\nra, 0(sp)\nli\na0, 5\njal println_i\nlw\nra, 0(sp)\naddi sp, sp, 4\njr\nra\n\nso… how do we get closer to that?\n4\n\n\fSomething is holding us back\n● there's a limit on the quality of code we can produce by going\ndirectly from the AST to machine\/assembly code.\no we could tweak and bodge and kludge improvements on what we\nhave, and we'll asymptotically approach \"good code\" without ever\nreally getting there.\n● generating good code requires certain kinds of analyses to extract\nmore information about the program being compiled.\no control flow analysis determines the sequence in which pieces of\ncode are run (i.e. \"this runs before that; this may run before that\").\no data flow analysis determines how values are computed, copied,\nmoved, reused, saved in variables, passed to functions, and so on.\n● unfortunately, the AST is not a good fit for doing these analyses.\n\n5\n\n\fWhat's the S in AST stand for, again?\n● consider these pieces of code and their ASTs.\nlet x = 0;\nif x < 10 {\nprintln_s(\"hi!\");\n}\nprintln_s(\"done.\");\nLet\n\nId(x)\nIntLit(0)\n<\n\n{}\n\nIf\nCall\nCall\n\nId(x)\nIntLit(10)\n\ndo these two\npieces of code\nbehave similarly?\nnot at all. is it\neasy to tell that by\nlooking at the AST?\n\nId(println_s)\n[StrLit(\"hi\")]\n\nId(println_s)\n[StrLit(\"done.\")]\n\nnot really… {}\n\nlet x = 0;\nwhile x < 10 {\nprintln_s(\"hi!\");\n}\nprintln_s(\"done.\");\nLet\n\nId(x)\nIntLit(0)\n<\n\nWhile\nCall\nCall\n\nId(x)\nIntLit(10)\nId(println_s)\n[StrLit(\"hi\")]\n\nId(println_s)\n[StrLit(\"done.\")]\n\n6\n\n\fSufficiently Smart Compilers\n● there's a (possible) mistake in this code that we humans can see easily.\nlet x = 0;\nwhile x < 10 {\nprintln_s(\"hi!\");\n}\nprintln_s(\"done.\");\n\nthis loop never terminates, does it?\n\nthink about how you determined that.\n\n1. x is assigned a constant 0.\n2. x is never assigned anywhere else, not even in the loop.\n3. so, x can only be 0 in the loop condition…\n4. and 0 < 10, meaning the condition is tautologically true.\njust looking at the AST, how would you prove these things?\nwhat if the control flow were a lot more complex?\n7\n\n\fProgram execution is not a tree.\n● the AST models what the programmer typed. there's another way\nof representing programs that models how the program executes.\nlet x = 0;\nif x < 10 {\nprintln_s(\"hi!\");\n}\nprintln_s(\"done.\");\nx = 0\n\nx < 10?\n\np(\"done.\")\n\nflowcharts make it\nimmediately obvious\nthat the structure of\nthese two programs\nis different.\n\np(\"hi!\")\n\nlet x = 0;\nwhile x < 10 {\nprintln_s(\"hi!\");\n}\nprintln_s(\"done.\");\nx = 0\n\nx < 10?\n\np(\"hi!\")\n\np(\"done.\")\n8\n\n\fSufficiently Simple Algorithms\n● a flowchart makes it easier to detect the problem here.\nif we consider all possible paths\nthat take us to the condition…\n\nx = 0\n\nx < 10?\n\np(\"done.\")\n\np(\"hi!\")\n\nthen we can see that the only possible\nvalue for x is the constant 0.\n\nwe could give an error (or warning)\nabout the condition, or tell them that\nthis last piece of code is unreachable.\n\nthis sort of algorithm is crucial for detecting subtle bugs, doing\ncertain kinds of semantic analysis, and generating better code.\n9\n\n\fIntermediate\nRepresentation (IR)\n\n10\n\n\fReal languages are a lot bigger.\n● the AST is an abstract representation of the source language.\n● but the source language can be… complicated.\n\nshhhHHHHHHHHHH\n\nthere are so many pieces of syntax! so\nmany kinds of AST nodes! aaaHHH\n11\n\n\fTight coupling is bad.\n● a codegen algorithm that goes directly from source AST to target\nmachine code is also not very flexible.\n\nTruss AST\n\nCodegen\n\nwhat if you want to modify the\nsource language? or change the\nAST representation?\n\nMIPS Code\nwhat if you want to output a\ndifferent target language?\n\nthis algorithm tightly couples the input and output: if you want\nto change either of them, you have to change the algorithm.\n12\n\n\fHidden complexity\n● the AST can also hide operations and control flow that we have to\nknow about to be able to analyze the code properly.\nif cond { code }\n\nwhile cond { code }\n\nfor i in lo, hi { code }\n\nif !<cond> goto end\n<code>\nend:\ntop: if !<cond> goto end\n<code>\ngoto top\nend:\ni = <lo>\ntop: if i >= <hi> goto end\n<code>\ni += 1\ngoto top\nend:\n\n13\n\n\fSo instead…\n\nFrontend\n\nSemantic\n\nAST\n\nLowering\n\n● an intermediate representation (IR) is essentially a third language\nthat acts as a bridge between the source and target languages.\nMIPS Backend\n\nCodegen\n\nMIPS code\n\nIR\nx86 Backend\n\nCodegen\n\nx86 code\n\nnow we can work on the frontend and backend parts in\nisolation, swap out the backend, change the AST\nwithout having to change the codegen, etc…\n\n14\n\n\fIR Goals\n● we want a language with a small number of simple operations\no …which can be efficiently implemented on most\/all targets\n● so, something similar to assembly language…\no but without being tied to a particular ISA.\n● a representation amenable to optimization would also be nice…\no optimization rewrites code to do the same thing, but faster.\no simple code is easier to optimize, so we've got that covered.\n● finally, we'll want to represent control flow as a graph,\no as this enables lots of analyses for optimization and codegen that a\nlinear or tree structure would not.\n● the IR we'll be discussing is based on rustc's MIR,\no but lots of IRs are similar in their goals and structure.\n\n15\n\n\fOur IR\n\n16\n\n\fThe big picture\n● each function in the source language will be represented by a CFG.\no this is a control flow graph: essentially, a flowchart.\nfn main() {\nprintln_i(5);\n}\n\nfn test(x: bool) {\nif x {\nprintln_s(\"y\");\n} else {\nprintln_s(\"n\");\n}\n}\n\neach node in the CFG is\ncalled a basic block. this\nfunction only has one.\nbasic blocks can have 0, 1, or 2\nsuccessors: what will be run\nafter the basic block completes.\nblocks with 2 successors are\nclearly making decisions…\n\n17\n\n\fThe little picture\n● each basic block will contain instructions in a simple language.\no basically, each line only does one thing.\n\nd = (x + y) * (-z \/ w)\nif this reminds you of asm, good.\n\n$t1 = x + y\n$t2 = -z\n$t3 = $t2 \/ w\nd\n= $t1 * $t3\ndestination,\nsource, operation\n\nadd\nneg\ndiv\nmul\n\n$t1, x, y\n$t2, z\n$t3, $t2, w\nd,\n$t1, $t3\n\nit's kind of like asm without loads\/stores,\nand with infinite temporary registers.\n18\n\n\fLocals\/temporaries\n● each function has a list of locals: places where values can be stored.\n● some of these are local variables that the user declared; others are\ntemporaries created by the code generation.\nfn func(a: int, b: int) {\nlet x = (a + b) * 3;\nprintln_i(x);\n}\n\neach local has a type and\noptionally a name (from the code).\n\nLocals\n\nCode\n\nIdx Name Type\n\n$t3 = a + b\nx = $t3 * 3\nprintln_i(x)\nreturn\n\n0\n\n()\n\n1\n\na\n\nint\n\n2\n\nb\n\nint\n\n3\n4\n\nif a local has no name, it's\nreferred to by its index in\nthe code (like $t3).\nwe'll come back to\n$t0 shortly…\n\nint\nx\n\nint\n\n19\n\n\fPlaces, Constants, and Sources\n● the operands of instructions are a little freer than in assembly.\n\nSources\nPlaces\nLocals (x, $t1)\nGlobal variables\nFields (x.y)\n\na place is what can appear on\nthe LHS of an assignment.\n\nConstants\nInt Literals\nString Literals\nBool Literals\nFunction Addresses\n\na constant is just what it sounds\nlike. function addresses are\nused in function calls.\n\nboth places and constants can be used as sources, which are the\noperands on the RHS of assignments, arguments, etc.\n20\n\n\fInstruction examples\n● here are some examples of valid instructions in this IR language.\nx = 1\n\nsimple assignment of a constant to a local.\n\n$t5.y = x.y\n\nfield access can happen on either (or both)\nside(s) of an assignment.\n\nx.y = a.b.c + 1 this is still just one instruction. field access\ndoesn't count as an \"operation;\" + does.\n\n$t0 = f(1, $t1) function calls can take any number of\narguments, which are all sources.\np = &println_s\n\na function's address can be put in a place…\n\np(\"hi\")\n\n…and then that place can be called.\n21\n\n\fTerminators\n● a basic block (BB) contains 0 or more regular instructions, and ends\nwith a terminator, which is a control flow instruction.\na return terminator\nreturns from the function.\n\na goto terminator\nunconditionally goes to\nanother BB.\n\n...\nreturn\n\n...\ngoto bb7\n\nand a conditional terminator goes to one of\ntwo BBs, based on the condition.\n...\nif $t4 bb9 else bb12\n22\n\n\fOne way in, one way out\n● every function has at least one BB, its entry point. it's named bb0.\n● we will also ensure every function has exactly one BB with a return.\no all return statements will jump (goto) to it.\nfn f(x: bool, y: bool) {\nif x {\nif y {\nreturn;\n}\nprintln_s(\"just x\");\n} else {\nprintln_s(\"not x\");\nreturn;\n}\nprintln_s(\"done\");\n}\n\nnotice how both returns\nbecome arrows to the\nred BB (which has a\nreturn terminator).\n\nbb0\nnot x\n\njust x\ndone\n\nthis is going to make\ncertain analyses much\neasier, since some of\nthem start at the end\nand go backwards.\n23\n\n\fReturn values\n● there is a special temporary, $t0, which is used for the return value.\n● similar to the $v0 register in MIPS, a value is returned by assigning\nsomething into it before you get to the return terminator.\nfn ret(x: bool): int {\nif x {\nreturn 5;\n} else {\nreturn 10;\n}\n}\n\nLocals\n\nIdx Name Type\n0\n1\n\nint\nx\n\nbool\n\nbb0: if x bb1 else bb2\n\nbb1: $t0 = 5\ngoto bb3\n\nbb2: $t0 = 10\ngoto bb3\nbb3:\nreturn\n\nthe special parsing rule about returning\nstatements (remember that?) along with the\ntypechecking pass will ensure that this\nlocation is always assigned a value.\n24\n\n\fCodegen, but different\n\n25\n\n\fLowering\n● lowering is the process of converting the high-level, abstract syntax\ntree into the mid-level IR that we just looked at.\n● it's a kind of code generation, so there are some similarities with\nwhat we talked about before. but in many ways it's a lot simpler:\no there are infinite temporary locations, so there's no need for\ncomplex register allocation algorithms.\no it also means there's no need for stack frames, loads, stores etc.\no all locations are typed, so some implementation details are left out\n(e.g. a + b can mean addition or string concatenation, like in the\nsource language)\n● so all we have to do is:\no convert complex operations into sequences of simpler ones\no build the CFG according to the control flow statements\n26\n\n\fBuilding the CFG: straight-line code (animated)\n● if a function has no control flow, it's super simple.\nfn do_gravity(vy: int): int\nyou start with an empty BB, and\nlet ret = min(vy + 98, 800); generate IR instructions into it.\nprintln_i(ret);\nbb0: $t2 = vy + 98\nreturn ret;\nret = min($t2, 800)\n}\nLocals\nprintln_i(ret)\n$t0 = ret\nIdx Name Type\ngoto bb1\n0\nint\n1\n\nvy\n\n2\n\n3\n\nint\nint\n\nret\n\nint\n\nbb1: return\n\nwe can make a new BB for the return like here,\nor special-case it if we want a simpler CFG.\n27\n\n\fBuilding the CFG: a while loop (animated)\n● control flow structures tell us exactly where BBs need to begin\/end.\nprintln_s(\"nums:\");\nlet i = 10;\nwhile i > 0 {\nprintln_i(i);\ni = i – 2;\n}\n\nthe loop needs a new BB.\nwhen we start a new BB,\nthe previous one must\ngoto the new one.\ndone with the body;\nmake a new BB after it.\n\nbb0: println_s(\"nums:\")\ni = 10\ngoto bb1\nbb1: $t2 = i > 0\nif $t2 then bb2 else bb_\n3\n\nbb2: println_i(i)\ni = i - 2\ngoto bb1\nbb3:\n28\n\n\fThe shape of control flow\n● what kind of control flow statement would make each CFG?\n\nwhile true\n\nif\n\nif … else if … else\nfor(i=a; i<b; i++){…}\nwhile\n29\n\n\fSome graph-related stuff\n\n30\n\n\fHow they connect (animated)\n● graphs always have all sorts of vocabulary, huh?\na BB's predecessors are all\nthe BBs that point to it.\n\na BB's successors are the\nBBs which it points to.\n\na BB can be its own\nsuccessor, in which case it is\nalso its own predecessor!\n\na back edge is one that\ngoes back to an earlier BB.\nremember: whenever you\nsee cyclic graphs, things\nare gonna get weird. 31\n\n\fVisiting arbitrary graphs\n● visiting a tree is easy: just recurse for each child node.\n● but doing that for an arbitrary graph will get you into trouble.\n1\n2\n3\n\nfn visit_node(n) {\nprint(n's number);\nfor s in n.successors() {\nvisit_node(s);\n}\n}\n\nif we run this code\non this graph,\nwhat happens?\n\nwe'll visit node 1… then 2… then 1… then 2… then 1…\nclearly this isn't sufficient. when visiting an\narbitrary graph, you must manually keep track\nof which nodes have already been visited.\n32\n\n\fPostorder using depth-first traversal\n● a really common way to visit CFGs is using postorder: each node is\nvisited after all its successors have been visited.\nfn visit_node(n, visited) {\nif visited[n] { return; }\nvisited[n] = true;\nfor s in n.successors() {\nvisit_node(s, visited);\n}\nactually \"visit\" n here!\n}\n\nthis bit is what prevents us\nfrom looping infinitely.\n\nand this is where we do whatever\nwork is needed to \"visit\" n, after\nwe've visited its successors.\n\nif we say, printed out the node's name\/number there,\nthis would print out the postorder of the graph.\n33\n\n\f","label":[[0,19,"Concept"],[24,26,"Concept"],[110,113,"Concept"],[165,167,"Concept"],[210,218,"Concept"],[272,286,"Concept"],[578,586,"Concept"],[627,630,"Concept"],[876,879,"Concept"],[883,904,"Concept"],[1177,1198,"Concept"],[1315,1333,"Concept"],[1466,1469,"Concept"],[1535,1538,"Concept"],[1599,1603,"Concept"],[1828,1831,"Concept"],[2123,2132,"Concept"],[2569,2572,"Concept"],[2620,2632,"Concept"],[2701,2704,"Concept"],[2913,2923,"Concept"],[2961,2970,"Concept"],[3160,3169,"Concept"],[3589,3606,"Concept"],[3640,3667,"Concept"],[3669,3671,"Concept"],[3718,3721,"Concept"],[3786,3801,"Concept"],[3893,3896,"Concept"],[3943,3950,"Concept"],[3992,3995,"Concept"],[4006,4018,"Concept"],[4047,4052,"Concept"],[4053,4056,"Concept"],[4058,4065,"Concept"],[4098,4113,"Concept"],[4129,4132,"Concept"],[4199,4214,"Concept"],[4371,4374,"Concept"],[4404,4416,"Concept"],[4711,4719,"Concept"],[4721,4729,"Concept"],[4731,4734,"Concept"],[4736,4744,"Concept"],[4752,4778,"Concept"],[4780,4782,"Concept"],[4850,4856,"Concept"],[4861,4877,"Concept"],[4884,4891,"Concept"],[4893,4900,"Concept"],[4913,4915,"Concept"],[4929,4936,"Concept"],[4971,4979,"Concept"],[4984,4991,"Concept"],[5025,5032,"Concept"],[5045,5048,"Concept"],[5078,5085,"Concept"],[5098,5100,"Concept"],[5256,5273,"Concept"],[5316,5319,"Concept"],[5352,5364,"Concept"],[5387,5399,"Concept"],[5475,5483,"Concept"],[5547,5559,"Concept"],[5565,5570,"Concept"],[5611,5623,"Concept"],[5628,5635,"Concept"],[5685,5687,"Concept"],[5747,5750,"Concept"],[5803,5805,"Concept"],[5892,5895,"Concept"],[5909,5927,"Concept"],[5944,5953,"Concept"],[6061,6065,"Concept"],[6073,6076,"Concept"],[6089,6100,"Concept"],[6130,6142,"Concept"],[6163,6173,"Concept"],[6202,6213,"Concept"],[6225,6231,"Concept"],[6239,6249,"Concept"],[6312,6323,"Concept"],[6337,6349,"Concept"],[6703,6709,"Concept"],[6710,6721,"Concept"],[6752,6758,"Concept"],[6815,6830,"Concept"],[6866,6877,"Concept"],[6893,6908,"Concept"],[6979,6984,"Concept"],[6991,6995,"Concept"],[7036,7042,"Concept"],[7149,7154,"Concept"],[7272,7278,"Concept"],[7280,7289,"Concept"],[7295,7302,"Concept"],[7309,7317,"Concept"],[7372,7379,"Concept"],[7380,7386,"Concept"],[7387,7393,"Concept"],[7436,7441,"Concept"],[7491,7500,"Concept"],[7544,7562,"Concept"],[7566,7574,"Concept"],[7605,7622,"Concept"],[7657,7663,"Concept"],[7668,7677,"Concept"],[7693,7700,"Concept"],[7716,7724,"Concept"],[7849,7851,"Concept"],[7892,7900,"Concept"],[7906,7911,"Concept"],[8121,8135,"Concept"],[8159,8168,"Concept"],[8184,8191,"Concept"],[8211,8229,"Concept"],[8246,8251,"Concept"],[8278,8283,"Concept"],[8304,8315,"Concept"],[8320,8331,"Concept"],[8333,8335,"Concept"],[8394,8404,"Concept"],[8417,8429,"Concept"],[8445,8462,"Concept"],[8493,8508,"Concept"],[8541,8543,"Concept"],[8550,8556,"Concept"],[8562,8566,"Concept"],[8578,8600,"Concept"],[8620,8623,"Concept"],[8737,8739,"Concept"],[8745,8756,"Concept"],[8827,8829,"Concept"],[8837,8843,"Concept"],[8851,8857,"Concept"],[8880,8884,"Concept"],[8932,8938,"Concept"],[8992,8998,"Concept"],[9040,9047,"Concept"],[9073,9075,"Concept"],[9089,9106,"Concept"],[9245,9258,"Concept"],[9318,9330,"Concept"],[9444,9460,"Concept"],[9528,9534,"Concept"],[9605,9609,"Concept"],[9629,9633,"Concept"],[9643,9649,"Concept"],[9663,9670,"Concept"],[9682,9702,"Concept"],[9817,9824,"Concept"],[9846,9854,"Concept"],[9857,9865,"Concept"],[9911,9931,"Concept"],[9951,9953,"Concept"],[9995,10010,"Concept"],[10187,10217,"Concept"],[10255,10267,"Concept"],[10308,10313,"Concept"],[10542,10545,"Concept"],[10563,10575,"Concept"],[10605,10608,"Concept"],[10663,10675,"Concept"],[10748,10750,"Concept"],[10794,10796,"Concept"],[10854,10860,"Concept"],[10888,10894,"Concept"],[10986,10992,"Concept"],[11012,11014,"Concept"],[11023,11029,"Concept"],[11081,11084,"Concept"],[11104,11107,"Concept"],[11135,11147,"Concept"],[11181,11184,"Concept"],[11299,11301,"Concept"],[11323,11325,"Concept"],[11349,11353,"Concept"],[11398,11400,"Concept"],[11443,11447,"Concept"],[11525,11529,"Concept"],[11557,11569,"Concept"],[11585,11597,"Concept"],[11624,11627,"Concept"],[11760,11766,"Concept"],[11811,11815,"Concept"],[11816,11828,"Concept"],[11841,11844,"Concept"],[11866,11870,"Concept"],[11871,11881,"Concept"],[11890,11893,"Concept"],[11917,11919,"Concept"],[11935,11944,"Concept"],[11979,11990,"Concept"],[11995,12004,"Concept"],[12041,12043,"Concept"],[12079,12085,"Concept"],[12120,12145,"Concept"],[12148,12156,"Concept"],[12159,12163,"Concept"],[12241,12246,"Concept"],[12284,12289,"Concept"],[12290,12294,"Concept"],[12345,12350,"Concept"],[12351,12355,"Concept"],[12393,12398,"Concept"],[12427,12431,"Concept"],[12503,12511,"Concept"],[12525,12530,"Concept"],[12570,12575,"Concept"],[12608,12617,"Concept"],[12624,12645,"Concept"],[12671,12676,"Concept"],[12677,12681,"Concept"],[12691,12700,"Concept"],[12715,12722,"Concept"],[12737,12747,"Concept"],[12758,12765,"Concept"],[12770,12775,"Concept"],[12776,12780,"Concept"],[12798,12805,"Concept"],[12821,12828,"Concept"],[12866,12871,"Concept"],[12902,12907,"Concept"],[13027,13032,"Concept"],[13061,13071,"Concept"],[13101,13107,"Concept"],[13152,13161,"Concept"],[13169,13174,"Concept"]],"Comments":[]}
{"id":108,"segment": ["train_set", "labeled"],  "course": "cs1622", "lec": "lec13_ABI_and_codegen","text":"ABI and Codegen\nCS 1622\nJarrett Billingsley\n\n\fClass Announcements\n● how's the project?\n● project 2 grades will be posted today!\n\n2\n\n\fApplication\nBinary Interfaces (ABIs)\n\n3\n\n\fLike API, but with a B instead of a P\n● the backend converts the concept of \"a program\" into something the\nCPU can actually execute – machine code.\n● an Application Binary Interface is a set of rules that sets the\nstandards for how machine code programs look and work.\no so, the ABI will guide how we actually generate the code.\nto make things more interesting,\n\"the\" ABI is probably composed\nof multiple layers of rules.\n\nthings can get very interesting at the\nboundaries between these layers…\n\nLanguage ABI\nOS ABI\nArchitectural ABI\n\n4\n\n\fThe lowest layer: the Architectural ABI\n● the designers of an ISA may define an ABI to go with it.\no as the designers, they may have included special features for e.g.\nmaking function calls faster if you use those features as intended.\n● these may be bare-bones, including rules on how to do function\ncalls and object file formats, and not much else.\nthese are widely used on embedded\ndevices where there is no OS – your\nprogram runs \"on the bare metal.\"\n\n5\n\n\fBut Operating Systems have opinions\n● the goal of an operating system is to control access to your\ncomputer's resources and make the programs share them.\n● so, the designers of OSes will define their own ABI which are much\nmore extensive, including rules for:\no how function calls work\n▪ this may be built on the architectural ABI, or it may be unique!\no how system calls work, to ask the OS to do things for you\no how asynchronous messages are delivered to running programs\no how executables and shared libraries are packaged\no how memory is laid out and where parts of your program exist\n● these are the kinds of ABIs most compilers are generating code for,\nmost of the time.\n\n6\n\n\fThe highest layer: your language's own ABI\n● HLLs can have features which are not accounted for by either the\narchitectural or OS ABIs, so they have to make their own rules.\n● this might include features like:\nexceptions!\n\ndynamic method dispatch!\n\ntry {\n...throw...\n} catch(...) {\n...\n} finally {\n...\n}\n\nString s = obj.toString();\n\nfunction closures!\nauto f = [&]() {\ncout << \"wheee!\\n\";\n};\n\nhowever, if you're not careful defining your language, different\ncompilers for the same language can use different ABIs…\n7\n\n\fWhen ABIs collide\n● let's say a language has no standardized ABI for method calls.\n● then, different compilers may have their own incompatible ways of\ngenerating code for method calls, leading to really nasty situations.\nthis program was compiled\nwith Compiler A.\n\nyou wrote a plugin in the same\nlanguage, but you used Compiler B.\n\nProgram\n\nPlugin\n\nplugin.getName()\n\nthe program tries to call a method in\nyour plugin, and… what happens?\n\nwho knows? it might silently fail, it might crash immediately, it\nmight corrupt the stack or heap in more subtle ways, etc.\n8\n\n\fBreak the rules, get a broken program.\n● if two pieces of code use different ABIs…\n● or if your compiler generates code that doesn't follow the ABI…\n● you lose all the nice abstraction guarantees of the HLL.\n● think back to when you were writing MIPS in 447.\no do you really want to deal with those kinds of bugs again?\n● C – or rather its ABI – has remained popular for decades. why?\no because it's super simple, meaning just about every OS and\ncompiler can follow it without much difficulty.\no with it, you can hook pieces of machine code together reliably.\n● but, its simplicity means it doesn't support advanced features…\no so it's up to you, as the language designer or compiler writer, to\ndecide how those features are implemented.\n● so! what goes into an ABI, anyway?\n9\n\n\fParts of an ABI\n\n10\n\n\fThe call stack\n● any ISA from the last 50 years or so will have provisions for a stack.\nStack\n16\n\n0\n48580372\n0\n0\n5\n\nit'll have, at the very least, a register that points to\nthe top of the stack… a stack pointer, if you will.\n(well, maybe it has two registers. we'll get to that.)\n\nsp it might have special instructions for pushing and\npopping things to this stack, or it might not.\npush eax\n\npop ecx\n\ncall func\n\nret\n\nthe ABI defines things like: the direction the stack\ngrows; the size of each item on the stack; stack\nalignment (if the stack pointer must move in\nmultiples of some number); and so on.\n11\n\n\fYou can't stack things up forever…\n● statistically, most programs never need more than a few megabytes\nof stack space, and most use far, far less than that.\n● since the OS makes all the programs share resources, it may only\nallocate something like 4-16 MB of memory for your program.\no this is allocated before your program starts; you don't have to do\nanything to get it.\n● and what happens if you push more than that on the stack?\no stack overflow! yay!\n● so, however we implement our language's ABI, it will have to work\nwithin this limit.\n\n12\n\n\fThe calling convention\n● this is the set of rules used to call and return from functions.\n● it defines things like:\nhow arguments are passed;\n\nhow the return\naddress is calculated\nand where it's stored;\n\nfn add(x: int, y: int): int {\nlet sum = x + y;\nprintln_i(sum);\nreturn sum;\n}\nhow values are returned;\n\nwhich CPU registers must be saved,\nand which can be used freely.\n\nra\n\nv0\n\ns0\nt0\n\na0\n\nf0\n\nfp\n13\n\n\fBorder conflicts\n● within your language, you can use any calling convention you like.\no as long as every function uses the same rules, it will work fine.\n● it's at the boundaries where things get tricky.\nYour Language\n\nmain\n\ninit\n\nOS API\n\nprompt\n\nread\n\nprintln\n\nwrite\n\nfunctions from outside your\nlanguage may use a different\nABI, so your code generator\nmust be very careful about it.\nit has to know what ABI each\nfunction uses, so it can use the\nright rules when calling them.\nor, we could punt it…\n14\n\n\fIf it hurts, don't do it\n● you could make it so you can't directly call functions from other\nlanguages\/which use different ABIs.\n● Java does this.\no public static native int someExternalFunction();\no this function is not written in Java.\no instead, it's probably written in C++, and compiled into a plugin.\no that plugin is then loaded into the JVM when your program runs.\n● this provides a controlled boundary between \"the safe Java world\"\nand \"the scary non-Java world,\" and lets Java programs call functions\nthey would normally be unable to.\n● systems programming languages will give you a way to deal with\ncalling conventions yourself.\no but Java isn't a systems language, and there's no shame in saying\n\"hey, it's not my language's responsibility!\"\n15\n\n\fAnother kind of call, another calling convention\n● system calls are how your program asks the OS to do things on the\nprogram's behalf: I\/O, resource management, even exiting…\no without syscalls, about all a program can do is make the CPU hot.\n● the ISA defines the system call (syscall) mechanism…\no which usually requires using a special instruction. (like syscall.)\no the OS will also define how values are passed into\/out of them.\n● essentially this is just another calling convention, meaning we will\nrun into the same issues as before.\no if a language cannot use syscalls directly, it will have to rely on\ncode written in some other language to do so.\n● it feels like this interface between our language and the OS is\ngoing to have to be somewhat… substantial. so let's talk about it.\n\n16\n\n\fStandard and\nRuntime Libraries\n\n17\n\n\fstd::\n● you kind of take the standard library (stdlib) for granted.\no there are these functions and classes that are just… there!\no System.out.println() and ArrayList and Vec and so on.\no but someone had to write them. and if you're making your own\nlanguage, that \"someone\" is going to be you.\n● standard libraries are out of the scope of this course, but…\no the standard library is going to have to make calls to OS APIs to do\nthings like input and output, somehow.\n● and all code in your language will rely on some special hidden code\nto work properly at runtime.\no and the compiler will be relying on that code as well!\n\n18\n\n\fcore::\n● there are likely many operations in your HLL that don't map neatly\nonto a few instructions in the target ISA.\nis there a MIPS instruction\nfor string concatenation?\n\nhow about for allocating\nobjects on the heap?\n\n\"hi\" + \"bye\"\n\nnew Cat()\n\nchecking array bounds?\n\nthrowing exceptions?\n\nA[1000000000]\n\nthrow new OhMyGodWhyAreAllTheExcept\nionNamesSoLongException();\n\nthere are a lot of hidden operations going on in each of these\ncases, and it is the runtime library which implements them.\n19\n\n\fThe language runtime\n● a language's runtime library implements the features which would\nbe difficult or impossible to codegen directly.\n● unlike the standard library, this is tied more closely to the compiler\nand how the compiler has decided to implement those features.\no so, different compilers – and even different versions of the same\ncompiler – can have different runtime libraries.\no ever install the many versions of Visual C++ Redistributable?\n▪ thaaaaat's what it iiiiiiiis\n● the runtime may be written in a different language (like C or C++)\nfrom the source language that the compiler compiles.\no in our case, Truss's tiny runtime library is written in MIPS. (so is its\n\"standard library\" of a few print functions, lol.)\n\n20\n\n\fThe compiler's job\n● during codegen, the compiler is essentially going to turn some\npieces of code into function calls into the runtime library.\n● if we take string concatenation as an example:\nsource code: let msg = \"hello, \" + name;\ncodegen treats it as: let msg = rt$concat(\"hello, \", name);\ngets generated as: addi sp, sp, -8\nla\nsw\nlw\nsw\njal\nsw\n\nt0, STRLIT$3\nt0, 0(sp)\nt0, 0(fp)\nt0, 4(sp)\nrt$concat\nv0, -20(fp)\n\nfp? what's that??\n21\n\n\fTruss's MIPS ABI\n\n22\n\n\fKind of standard, kind of not\n● Truss’s MIPS ABI is based on the standard MIPS ABI, but is more\nlimited in some ways in order to make the codegen simpler.\n● we’re generating code for a slightly weird target, MARS, which:\no has no operating system\no has no executable format, only textual assembly as input\n● those aspects will also simplify our job!\n● a large part of the ABI is the calling convention, but first, we have to\nspecify…\n\n23\n\n\fMemory regions\n● there are three regions of memory.\nlet g1 = 10;\nlet g2 = \"world\";\n\nthe .data segment holds the global\nvariables and any string literals.\n\nfn main() {\nprintln_i(g1);\nthe heap holds dynamically\nallocated strings and structs\nlet msg = \"hi, \" + g2;\n(like new Cat()).\nprintln_s(msg);\n}\nthe heap could be managed with\nthe stack holds the\na tracing garbage collector, if this\nlocal variables.\nwere a real language. but our\nimplementation won't.\n24\n\n\fHow global variables are generated\n● int and bool globals become .word and .byte variables, respectively.\nlet ivar = 10;\nlet bvar = true;\n\nstrings are more subtle…\n\nlet svar = \"hi\";\n\n.data\nivar: .word 10\nbvar: .byte 1\n\n.data\nSTRLIT$0: .asciiz \"hi\"\nsvar: .word STRLIT$0\n\nbools are represented with\n1 for true and 0 for false.\n\nevery string literal in the program\ngets a uniquely-named STRLIT label;\nstring variables just point to strings.\n25\n\n\fRuntime data representation\n● to be thorough we have to define how every type in the language is\nrepresented at runtime. fortunately, Truss doesn’t have many!\no we already saw int and bool on the previous slide.\n● strings, function pointers, and struct references are all reference\ntypes, meaning they are represented as a pointer, which is a word.\n● the data of a string is defined as zero-terminated ASCII, which is kind\nof a terrible string representation but is exactly what MARS wants, so.\n● the data of a struct is… well… we’ll come back to structs. ;o\n\n26\n\n\fFunction calls\n● the caller has an easy time calling functions, but the protocol is a\nlittle different than you may remember from 447.\n● rather than using those a registers, all arguments are passed on the\nstack, in the same order they are written in the source.\nf(1, 2);\neach stack slot is 4 bytes, so 2\narguments requires 8 bytes.\naddi sp, sp, -8\nli\nt0, 1\nsw\nt0, 0(sp)\nli\nt0, 2\nsw\nt0, 4(sp)\njal f\n\nrecall this means 0 + sp.\nthe second argument is at 4 + sp;\nthe third at 8 + sp etc.\n27\n\n\fAfter the call completes…\n● return values come out in v0, like you learned before.\n● assuming glob is a global variable…\nglob = f(1);\n\naddi sp, sp, -4\nli\nt0, 1\nsw\nt0, 0(sp)\njal f\nsw\nv0, glob\n\nnotice: the caller changes sp before calling,\nbut it does not change it after. we say the\ncallee \"cleans the stack\" (as we'll see shortly)\n\nimportant: there is a line here. below this line,\nthe contents of the a, t, and v registers may\nbe different than they were before the jal.\n\nhowever, the contents of the s registers are\nguaranteed to be the same as before the jal.\n\n28\n\n\fStack Frames\n● every function in the program needs a stack frame: a way of storing\nall the arguments, variables, and saved registers on the stack.\n● let's look at a super simple function's stack frame first.\nfn simple(x: int) {\nprintln_i(x);\n}\nx\nra\n\nthere's the argument. it was pushed by the caller.\nwe're going to push ra, the return address register,\nso we won't lose our way back to the caller when\nwe call println_i.\nwhat about when we have local variables?\n29\n\n\fLocal variables\n● after pushing ra, we will then make space for the locals.\nfn more_complex(x: int) {\nx\nlet y = x + 10;\nra\nfor i in 0, y {\nprintln_i(i);\ni\n}\ny\n}\nevery local variable gets its own stack slot.\n\n12(sp)\n\n4(sp)\n0(sp)\n\nsince the stack pointer is pointing at the lowest slot, we\ncan access the locals and arguments with offsets from it.\nbut that's going to make things difficult for us\nwhen we want to actually call println_i…\n30\n\n\fShifting sands (animated)\n● let's say we're generating code for println_i(i).\nfn more_complex(x: int) {\nlet y = x + 10;\nfor i in 0, y {\nprintln_i(i);\n}\n}\nx\n\n12(sp)\n16(sp)\n\nra\ni\n\n4(sp)\n8(sp)\n\ny\n\n0(sp)\n4(sp)\n\n__\n\n0(sp)\n\nthe first thing we do is make\nroom for the argument.\naddi sp, sp, -4\nbut what does that do to\nthe offsets from sp??\n\nit's absolutely possible to keep track of\nthe \"virtual sp\" and adjust the offsets\naccordingly. but I don't waaaaanna\nwhat if we had a second stack pointer,\none that didn't move around?\n31\n\n\fThe Frame Pointer register\n● MIPS has a second register for just this purpose, called fp.\n● this will point sort of weirdly into the middle of the stack frame,\ngiving us a stationary reference point for accessing locals.\n● going back to the super simple function…\nfn simple(x: int) {\nprintln_i(x);\n}\n\nx\n\nfp\n\nfp\nra\n\nsp\n\nwe're going to push both fp and ra!\nfp points at the first argument, and\nsp still points at the top of the stack.\nand what about locals?\n32\n\n\fThe local problem, solved (animated)\n● you aren't restricted to positive offsets from the stack\/frame pointers!\nfn more_complex(x: int) {\nlet y = x + 10;\nfor i in 0, y {\nprintln_i(i);\n}\n}\nsp\n\nx\n\n0(fp)\n\nfp\nra\ni\n\n-12(fp)\n\ny\n\n-16(fp)\n\n__\nnow, even when sp moves around during the\nfunction, the offsets from fp never change.\n\n33\n\n\fFunction Prologue\n● the function prologue is the code that sets up the stack frame,\nessentially switching stack frames from the caller to the callee.\n● it looks like this:\nsw\nfp, -4(sp) this pushes the caller's frame pointer, so we\ncan get it back later.\nsw\n\nra, -8(sp)\n\nmove fp, sp\naddi sp, sp, -n\n\nthis pushes the callee's return address.\n\nthis sets up the callee's frame pointer, so it\npoints to the first argument (if any).\nand finally, this sets up the callee's stack\npointer, so we have room for the locals.\n\nhere, n is the number of bytes needed for all the\nlocals, plus the two saved registers from above.\n34\n\n\fFunction Epilogue\n● finally, the epilogue does the opposite: it restores the stack and\nrequired registers to the way they were when the function began.\nlw\n\nra, -8(fp)\n\nthis restores our return address.\n\nlw\n\nfp, -4(fp)\n\nthis restores the caller's frame pointer.\n\naddi sp, sp, x\n\nthis completely cleans the stack, removing\nthe locals, saved regs, and all arguments.\n\njr\n\nand this returns!\n\nra\n\n35\n\n\fWhat about the juicy middles?\n● it seems like a lot of buildup to only a handful of instructions, but…\no this shit is important okay\no we have to do this right or else our program falls apart!!\n● but by setting up our stack frame neatly like this, it will make\ngenerating the code inside the functions a lot more straightforward.\no and that's what we'll talk about next time!\n\n36","label":[[0,3,"Concept"],[8,15,"Concept"],[133,162,"Concept"],[164,168,"Concept"],[180,183,"Concept"],[219,226,"Concept"],[309,321,"Concept"],[328,356,"Concept"],[407,419,"Concept"],[454,457,"Concept"],[543,546,"Concept"],[671,683,"Concept"],[684,690,"Concept"],[691,708,"Concept"],[736,753,"Concept"],[776,779,"Concept"],[794,797,"Concept"],[1125,1127,"Concept"],[1178,1195,"Concept"],[1227,1243,"Concept"],[1351,1355,"Concept"],[1378,1381,"Concept"],[1440,1454,"Concept"],[1487,1504,"Concept"],[1533,1545,"Concept"],[1593,1614,"Concept"],[1655,1666,"Concept"],[1671,1687,"Concept"],[1707,1713,"Concept"],[1789,1793,"Concept"],[1799,1808,"Concept"],[1896,1899,"Concept"],[1902,1906,"Concept"],[1967,1991,"Concept"],[2067,2077,"Concept"],[2080,2103,"Concept"],[2315,2324,"Concept"],[2365,2369,"Concept"],[2380,2384,"Concept"],[2436,2439,"Concept"],[2444,2456,"Concept"],[2476,2485,"Concept"],[2613,2621,"Concept"],[2627,2635,"Concept"],[2694,2702,"Concept"],[3018,3022,"Concept"],[3037,3045,"Concept"],[3085,3088,"Concept"],[3144,3147,"Concept"],[3281,3284,"Concept"],[3380,3382,"Concept"],[3387,3395,"Concept"],[3616,3624,"Concept"],[3703,3706,"Concept"],[3732,3735,"Concept"],[3751,3756,"Concept"],[3763,3766,"Concept"],[3823,3828,"Concept"],[3830,3835,"Concept"],[3930,3935,"Concept"],[3939,3952,"Concept"],[4023,4025,"Concept"],[4065,4072,"Concept"],[4077,4084,"Concept"],[4100,4105,"Concept"],[4163,4166,"Concept"],[4206,4211,"Concept"],[4248,4253,"Concept"],[4255,4260,"Concept"],[4261,4270,"Concept"],[4359,4364,"Concept"],[4455,4460,"Concept"],[4775,4780,"Concept"],[4784,4798,"Concept"],[4847,4850,"Concept"],[4902,4920,"Concept"],[5018,5027,"Concept"],[5049,5063,"Concept"],[5359,5377,"Concept"],[5628,5631,"Concept"],[5641,5655,"Concept"],[5707,5710,"Concept"],[5930,5934,"Concept"],[6417,6436,"Concept"],[6596,6614,"Concept"],[6617,6629,"Concept"],[6751,6759,"Concept"],[6815,6818,"Concept"],[6831,6842,"Concept"],[6844,6851,"Concept"],[6924,6931,"Concept"],[7035,7053,"Concept"],[7134,7142,"Concept"],[7362,7392,"Concept"],[7428,7444,"Concept"],[7446,7452,"Concept"],[7695,7713,"Concept"],[7762,7778,"Concept"],[7975,7983,"Concept"],[8078,8081,"Concept"],[8142,8145,"Concept"],[8483,8498,"Concept"],[8540,8547,"Concept"],[8563,8578,"Concept"],[8645,8652,"Concept"],[8676,8692,"Concept"],[8727,8735,"Concept"],[8748,8756,"Concept"],[8814,8823,"Concept"],[8866,8874,"Concept"],[8896,8913,"Concept"],[9016,9023,"Concept"],[9113,9121,"Concept"],[9160,9175,"Concept"],[9208,9224,"Concept"],[9268,9278,"Concept"],[9292,9299,"Concept"],[9305,9313,"Concept"],[9368,9382,"Concept"],[9499,9506,"Concept"],[9703,9710,"Concept"],[9716,9719,"Concept"],[9758,9765,"Concept"],[9771,9774,"Concept"],[9805,9808,"Concept"],[9864,9871,"Concept"],[10098,10101,"Concept"],[10109,10127,"Concept"],[10166,10180,"Concept"],[10254,10267,"Concept"],[10278,10294,"Concept"],[10337,10341,"Concept"],[10352,10356,"Concept"],[10363,10384,"Concept"],[10467,10471,"Concept"],[10498,10503,"Concept"],[10517,10542,"Concept"],[10552,10567,"Concept"],[10630,10646,"Concept"],[10676,10683,"Concept"],[11069,11096,"Concept"],[11181,11188,"Concept"],[11203,11208,"Concept"],[11634,11648,"Concept"],[11655,11661,"Concept"],[11679,11696,"Concept"],[11812,11821,"Concept"],[11840,11845,"Concept"],[11911,11916,"Concept"],[11939,11948,"Concept"],[11972,11974,"Concept"],[11976,11978,"Concept"],[12001,12003,"Concept"],[12023,12025,"Concept"],[12071,12079,"Concept"],[12090,12092,"Concept"],[12152,12165,"Concept"],[12228,12243,"Concept"],[12264,12266,"Concept"],[12268,12270,"Concept"],[12293,12295,"Concept"],[12328,12334,"Concept"],[12353,12360,"Concept"],[12406,12412,"Concept"],[12414,12430,"Concept"],[12693,12705,"Concept"],[12746,12757,"Concept"],[12784,12793,"Concept"],[12795,12804,"Concept"],[12810,12825,"Concept"],[12833,12838,"Concept"],[12882,12893,"Concept"],[12955,12963,"Concept"],[12986,12992,"Concept"],[13022,13036,"Concept"],[13139,13154,"Concept"],[13161,13176,"Concept"],[13328,13342,"Concept"],[13356,13361,"Concept"],[13372,13374,"Concept"],[13379,13381,"Concept"],[13385,13387,"Concept"],[13400,13413,"Concept"],[13464,13470,"Concept"],[13475,13484,"Concept"],[13646,13661,"Concept"],[13762,13764,"Concept"],[13769,13771,"Concept"],[13782,13784,"Concept"],[13788,13790,"Concept"],[13798,13800,"Concept"],[13804,13806,"Concept"],[13815,13817,"Concept"],[13863,13871,"Concept"],[13878,13880,"Concept"],[13882,13884,"Concept"],[13931,13933,"Concept"],[13992,13994,"Concept"],[14078,14091,"Concept"],[14131,14144,"Concept"],[14213,14215,"Concept"],[14274,14285,"Concept"],[14340,14346,"Concept"],[14471,14473,"Concept"],[14482,14484,"Concept"],[14519,14521,"Concept"],[14553,14558,"Concept"],[14575,14581,"Concept"],[14592,14597,"Concept"],[14678,14698,"Concept"],[14776,14778,"Concept"],[14785,14787,"Concept"],[14790,14792,"Concept"],[14803,14805,"Concept"],[14815,14817,"Concept"],[14838,14840,"Concept"],[14892,14894,"Concept"],[14915,14932,"Concept"],[14939,14956,"Concept"],[14986,14997,"Concept"],[15021,15033,"Concept"],[15043,15049,"Concept"],[15057,15063,"Concept"],[15090,15092,"Concept"],[15097,15099,"Concept"],[15117,15125,"Concept"],[15126,15139,"Concept"],[15181,15183,"Concept"],[15191,15193,"Concept"],[15195,15197,"Concept"],[15203,15205,"Concept"],[15207,15209,"Concept"],[15231,15239,"Concept"],[15240,15254,"Concept"],[15274,15282,"Concept"],[15283,15296,"Concept"],[15324,15332,"Concept"],[15373,15381,"Concept"],[15382,15395,"Concept"],[15421,15427,"Concept"],[15480,15486,"Concept"],[15501,15516,"Concept"],[15534,15551,"Concept"],[15567,15575,"Concept"],[15598,15616,"Concept"],[15697,15699,"Concept"],[15720,15734,"Concept"],[15748,15750,"Concept"],[15771,15779,"Concept"],[15780,15793,"Concept"],[15801,15803,"Concept"],[15805,15807,"Concept"],[15828,15844,"Concept"],[15859,15865,"Concept"],[15867,15877,"Concept"],[15887,15896,"Concept"],[16149,16160,"Concept"],[16192,16211,"Concept"]],"Comments":[]}
{"id": 109, "segment": ["train_set", "labeled"],  "course": "cs1622", "lec": "lec05_top_down_parsing", "text": "Top-down Parsing\nCS 1622\nJarrett Billingsley\n\n\fClass Announcements\n\u25cf how was your weekeeeeend\n\u25cf project 2 will come out this weekend so you\u2019ll have 2 weeks for it\n\n2\n\n\fParsing\n\n3\n\n\fA generative view\n\u25cf one way to use a grammar is to produce sentences in the language.\nExp:\nId | Num | Parens\nParens: '(' Exp+ ')'\nId:\n<id token>\nNum:\n<int literal token>\n\nwe can produce valid\nsentences by starting at the\nroot rule and repeatedly\nreplacing nonterminals with\ntheir right-hand sides.\n\nExp\n=> Parens\n=> '(' Exp+ ')'\n=> '(' Exp Exp Exp ')'\n\n=> '(' Id Id Num ')'\n=> '(' 'add' Id Num ')'\n=> '(' 'add' 'x' Num ')'\n=> '(' 'add' 'x' '3' ')'\n\nthis sequence is called a derivation.\n\nnow suppose we were given (add x 3) as our input. could\nwe work backwards to figure out how to get to Exp?\n\n4\n\n\fThat's what parsing is.\n\u25cf given a grammar and an input string\u2026\n\u25cf parsing is figuring out the derivation that was needed to produce\nthe input string. (and if there is no such derivation, it's an error!)\n\u25cf we represent the derivation as... an abstract syntax tree!\nExp: Id | Num | Parens\nParens: '(' Exp+ ')'\nId:\n<id token>\nNum:\n<int token>\n\nInput\ne\n(e)\n(1 2)\n(e\ne)\n()\n\nOutput AST\nId(\"e\")\nParens(Id(\"e\"))\nParens(Num(1), Num(2))\nerror!\nerror!\nerror!\n\nthe last three would benefit from some\nerror messages that help the programmer.\n\n5\n\n\fOkay what is this language?\n\u25cf this is a variety of Lisp, a language family that started in 1958.\n\u25cf we're not going to get into what it means, but it's a very easy-toparse example language.\n()\n\n(defun fact (x)\n(if (eq x 0)\ndefun\n1\n(mul x (fact (sub x 1)))))\n\nfact\n\nLisp code is basically an AST already;\nparentheses group children.\n\n()\nx\n\n()\nif\neq\n\n()\nx\n\n0\n\nthis is going to make our job of\nparsing much easier.\n\n1\n\n()\nmul\n\nx\n\n()\n\nfact ()\nsub\n\nx\n\n1\n6\n\n\fSo how do we do it?\n\u25cf well it's a bit like lexing:\no we start at the beginning, looking at tokens one-by-one.\no based on the token, we decide which rule we should use.\no if none of the rules apply, or if we see something that we don't\nexpect, we can give an error.\n\u25cf speaking of which\u2026\n\n7\n\n\fError Handling in Rust\ntime check: \u2264 17\n\n8\n\n\fThe Result type\n\u25cf Rust doesn't have exceptions like Java does.\n\u25cf if your function needs to indicate failure, it returns a Result.\n\nResult<T, E>\nT is the type of value\nreturned on success.\n\nif the function doesn't return\nany value on success, you can\nuse () \u2013 this is Rust's void.\n\nE is the type of value\nreturned for errors.\nany type can be used for errors,\nbut typically it's an enum.\n\nResult<Box<AstNode>, ParseError>\nthis is a bit unwieldy, so we can use a type alias to shorten it:\ntype ParseResult = Result<Box<AstNode>, ParseError>;\n9\n\n\fErr, ok\u2026\n\u25cf you create Results with the Ok() and Err() constructors.\nif thing.is_bad() {\n// common to use 'return' to immediately\n// leave the function. kinda like throwing\nreturn Err(ParseError::whatever());\n}\nyou can match on a Result using Ok() and Err():\nmatch parse_thing(input) {\nOk(ast) => { println!(\"{:?}\", ast); }\nErr(e) => { println!(\"o no: {}\", e); }\n}\nmatch patterns declare local variables usable in\ntheir code blocks, if that was unclear before.\n10\n\n\f???????\n\u25cf when using Result-returning functions, a really ugly pattern appears:\nmatch step_one(input) {\nOk(a) => {\nmatch step_two(a) {\nOk(b) => {\nmatch step_three(b) {\nOk(c) => {\nreturn Ok(c.to_string());\n}\nErr(e) => { return Err(e); }\n}\n}\nErr(e) => { return Err(e); }\n}\n}\nErr(e) => { return Err(e); }\n}\n\nthis is terrible. instead:\nlet a = step_one(input)?;\nlet b = step_two(a)?;\nlet c = step_three(b)?;\nOk(c.to_string())\n\nx? means, \"if x is an error,\nreturn it; otherwise, give\nme the success value.\nwe'll be seeing this a lot\nin parsing code!\n11\n\n\fRecursive Descent\ntime check: \u2264 34\n\n12\n\n\fCan we intuit our way through this?\n\u25cf with this grammar, and this sequence of tokens as our input\u2026\n\n'(', '(', 'hi', '5', ')', ')'\n\nExp:\nId | Num | Parens\nParens: '(' Exp+ ')'\nId:\n<id token>\nNum:\n<int literal token>\n\nwe are here. our ultimate goal is to build an Exp. this token is\na left-paren, so which rule do we think applies here?\nParens!\nafter the left-paren, we should see one or\nmore Exps, followed by a right-paren.\n\nbut we're already trying to parse an Exp. how do\nwe parse a new Exp without finishing this one?\n13\n\n\fThe rules are recursive, so\u2026\n\u25cf recall that all CFGs have this recursive rule structure.\n\u25cf well if the dependencies between the rules are recursive\u2026\no why not use recursive functions to model the rules?\nExp: Id | Num | Parens\nParens: '(' Exp+ ')'\nId:\n<id token>\nNum:\n<int token>\n\nlet's write some pseudocode to\nget our thoughts down.\n\nfn parse_exp() {\nmatch self.cur() {\nId\n=> parse_id(),\nIntLit => parse_num(),\nLParen => parse_parens(),\n}\n}\n\nfn parse_parens() {\neat_an_lparen();\nlet exps = \u2026parse_exp()\u2026\neat_an_rparen();\nreturn Parens(exps);\n}\n(looping happens here)\n\n14\n\n\fBelieve it or not, that's pretty much right!\n\u25cf what we've just (pseudo-)written is a recursive descent parser:\no recursive, because uh, it is!\no and descent, because we start at the root rule, and descend into\nthe other rules until we get to the terminals.\n\u25cf the issue with \"trying to parse an Exp while parsing an Exp\" is solved\nby using recursion\no when you recurse, the caller rule's execution is paused, and it\nremembers its place in the rule.\no it can then resume parsing after the callee rule has done its work.\n\u25cf so how can we be a little less \"pseudo\" about this code?\n\n15\n\n\fFrom Rules to Rust\n\u25cf each grammar rule is really a list of steps, and translating them to\nreal code is relatively straightforward:\n\nParens: '(' Exp+ ')'\nthis says that to parse a Parens:\n1. expect a '(' token and skip it.\n2. parse one Exp, since that's the minimum number.\n3. while we don't see a ')' token,\n\u2022 keep parsing Exps and put them into a list.\n4. expect a ')' token and skip it.\n\nif all of these steps succeed, we can create an\nParens AST node and return it!\n16\n\n\fOther metalanguage rule correspondences\n\u25cf there's a nice correspondence between the things we see in the\ngrammar metalanguage and the patterns we use in our code.\n\nA B\nA | B\n\nsequencing: parse an A; if that succeeds, then parse a B.\nalternation: an if-else (or a match); either parse\nan A or parse a B.\n\nA*\n\n0+ repetition: while the next token looks like an A,\nkeep parsing As.\n\nA+\n\n1+ repetition: parse an A, then do a while loop\nlike for 0+.\n\nA?\n\noptional: if the next token looks like an A, parse it.\n17\n\n\fFrom rules to AST nodes\n\u25cf similarly, when we design our AST nodes, these metalanguage rules\nimply different data structures:\n\nA B\nA | B\n\na struct, with an A field and a B field.\nan enum, where A and B are two variants.\n\nA*\nA+\n\nan array/vector, whose length is the number of\nrepetitions.\n\nA?\n\nan Option<A> field, since it might not exist.\n18\n\n\fThe example\n\u25cf now let's have a look at the new parsing_lisp example I added.\no src/lib.rs is where all the goodies are.\no the Token and AstNode types are familiar to you by now.\n\u25aa there's an extra Program rule in the grammar though.\no ParseError is an example of an error enum.\no Parser looks a lot like Lexer from your project\u2026\n\u25aa except it iterates over Tokens, not chars.\no and there are three parsing methods for the three main rules.\n\u25cf this real parser handles errors, too.\no the expect_blah methods and the match in parse_exp deal with\nunexpected terminals (tokens) in various positions.\n\u25aa they also give customized errors for each of these possibilities.\n\u25aa there's no location info, because it's an example. :B\n\n19\n\n\fLimits of Recursive\nDescent\ntime check: \u2264 68\n\n20\n\n\fIf it works so well, why not use it for everything?\n\u25cf there are lots of cases where recursive descent works great!\no import java.util.Arrays;\no use std::blah;\no fn name() { \u2026 }\no class A { \u2026 }\no if x == y { \u2026 }\no match value { \u2026 }\n\u25cf but there's something all of these things have in common:\no they all start with a token that unambiguously indicates which\nrule should be used to parse them.\no if you don't have that, recursive descent gets a lot harder to use.\n\u25cf but, what kind of code looks like that?\n\n21\n\n\fExpressions!\n\u25cf we want to be able to write expressions like we do in math.\no that is, we want 4 + 5, not (add 4 5).\n\u25cf but this presents a few problems.\n\nInput\n\nOutput\n\nx + y + z\n\n(x + y) + z or either is fine..? what\nx + (y + z) ? if it were *, -, or / ?\n\nx + 4 * y\n\n(x + 4) * y or\nx + (4 * y) ?\n\nthe second\none is right.\n\nand if we allow ** for exponents, like Python:\n\n2 ** x ** 2\n\n(2 ** x) ** 2 or\n2 ** (x ** 2) ?\n\nthe second\none is right.\n22\n\n\fEven worse\u2026\n\u25cf how do we know what kind of expression we're looking at?\n\n(3 + x + y * 2) / 50\nlet's say our parser is\nlooking at this token\u2026.\n\n\u2026how will it know it's a\ndivision until it gets here?\n\nso what do we do? look ahead? how\nmany tokens? 5? 10? is there a limit?\nwhat we would have to do here is try each\npossible parse, and backtrack if we mess up.\n23\n\n\fOH NO, BACKTRACKING\n\u25cf this is an exponential time (O(2n)) algorithm! just awful!\no and from an intuitive sense, it feels kind of silly to commit to\nparsing something when you don't actually have enough\ninformation yet to parse it.\n\u25cf so for these (and other similar) situations, there is another way to\nparse that's a little more mind-bending, but more powerful.\no that's for next time!\n\n24\n\n\fError Reporting\ntime check: \u2264 85\n\n25\n\n\fCompilers have a bit of a reputation\n\u25cf how many times have you gotten compiler errors that:\no seemed totally confused by very simple/common typos, like\nmissing a semicolon or comma or closing brace?\no pointed 100 lines after where the actual error was?\no used weird terminology, like \"specifier-qualifier-list\"?\no gave almost no information, like \"syntax error\"?\n\u25cf is it because the compiler writers suck?\no no\no good error reporting is really hard to do right, okay,\n\n26\n\n\fWho are error messages for?\n\u25cf I've said it many times: programming languages exist for humans.\n\u25cf so when a compiler gives errors, they should be\u2026 for humans!\n\u25cf but there are two things working against us here.\nthe compiler is a dumb\nalgorithm that doesn't\nunderstand our human\nmistakes\n\nf(3 4)\n----^\nexpected `)' or `,' in\nargument-list, not `4'\n\npeople who write\ncompilers tend to forget\nthat other people don't\nknow how they work\n\n(substitution of deduced\ntemplate arguments resulted\nin errors seen above)\n27\n\n\fCarry on, my wayward son\n\u25cf you know how you sometimes get like 1000 error messages?\no and it's all because you forgot ONE closing brace?\n\u25cf this is error recovery: instead of stopping at the first error, the\ncompiler tries to keep going.\nenum E {\nX,\nY\n// uh oh.\n\nbut how would you algorithmically determine\nwhere the closing brace should go?\n\nfn func() {\nlet x = E::X // oops\n(blah).y();\n}\n\nthis could even parse differently\ndepending on where we infer\nthe semicolon \"should\" be.\n28\n\n\fTo recover or not?\n\u25cf in the past, languages were simpler, and so was error recovery.\no compilers also ran on huge computers in batch jobs.\no since a compile might take hours, it was useful to report as many\nerrors as possible.\n\u25cf but now, a really, really common thing to do is:\no compile, fix the first error, repeat\n\u25aa (I really recommend you do this if you don't already)\n\n\u25cf so maybe stopping at the first error is fine?\no but what about IDEs?\no they can show multiple errors inline with the code\no so maybe there's still some use to it?\n\u25aa or does it just make using an IDE more annoying? :^)\n\n\u25cf personally I think lexing/parsing error recovery is pointless, but\ngiving multiple semantic errors can still be useful. sometimes.\n29\n\n\fA philosophy for good errors\n\u25cf there are three ways to improve error messages.\n1. say where it is\ntest.foo(9:17)\n\nbare minimum\u2026\n\ntest.foo(9:17):\nfor num in 10 {\n^ here\nbetter!\n\n2. give a unique message for that particular error\nexpected ',', not '{'\nehh\u2026\n\nfor-loop missing upper bound\nbetter!\n\n3. extra credit: tell the user how they might fix it\n\nhelp: maybe you meant \"for num in 10, something\"?\n^^^^^^^^^^^\n30\n\n\fFirst: location information\n\u25cf the lexer can associate a line and column with each token.\no well, some tokens span more than one column\u2026\no or even more than one line, if you allow multi-line strings!\no so maybe each token should have a range of locations? hmm\n\u25cf when parsing, that info can be carried from the tokens into the AST.\no that way, we can report errors during semantic analysis.\no or maybe we want to refer back to the token list somehow\u2026?\n\u25aa there are lots of ways to implement this!\n\n31\n\n\fSecond: accurate error messages\n\u25cf it's really easy to make unhelpful, uninformative messages, sadly!\n\u25cf giving accurate errors is largely about customizing the error\nmessages for each place an error could happen.\no looking through the parser code, every ? is a potential error spot.\no in parse_paren_exp, there are several of these.\n\u25cf matches are another place ripe for better errors:\no in parse_exp, there are a number of possible options, so we\nshould list the options in the error message, like \"expected\nidentifier, integer, or parenthesized expression, not blah blah\"\n\u25cf one possibility is to pass some kind of \"error context\" to the parsing\nfunctions which can be used to tailor the messages better\no since parse_exp is called from multiple places, the error message\nmight be different depending on who calls it.\n32\n\n\fThird: giving help\n\u25cf this is extremely broad and it's up to you what to say.\no it's really kind of an extension of the previous rule.\n\u25cf have a look at the error messages Rust gives.\no sometimes it's as simple as \"remove this semicolon.\"\no sometimes it links to the appropriate part of the docs.\no sometimes it even detects common mistakes and explains why\nthey won't work. it's amazing!\n\n33\n\n\f", "label": [[0, 16, "Concept"], [168, 175, "Concept"], [218, 225, "Concept"], [232, 239, "Concept"], [240, 249, "Concept"], [373, 382, "Concept"], [402, 411, "Concept"], [437, 449, "Concept"], [656, 666, "Concept"], [793, 800, "Concept"], [815, 822, "Concept"], [846, 853, "Concept"], [874, 884, "Concept"], [955, 965, "Concept"], [1002, 1012, "Concept"], [1022, 1042, "Concept"], [1156, 1159, "Concept"], [1207, 1212, "Concept"], [1214, 1219, "Concept"], [1221, 1226, "Concept"], [1268, 1282, "Concept"], [1365, 1369, "Concept"], [1479, 1484, "Concept"], [1604, 1607, "Concept"], [1704, 1711, "Concept"], [1809, 1815, "Concept"], [1857, 1863, "Concept"], [1891, 1896, "Concept"], [1914, 1918, "Concept"], [1951, 1956, "Concept"], [2024, 2029, "Concept"], [2057, 2071, "Concept"], [2106, 2112, "Concept"], [2120, 2124, "Concept"], [2224, 2230, "Concept"], [2233, 2239, "Concept"], [2369, 2375, "Concept"], [2419, 2425, "Concept"], [2452, 2458, "Concept"], [2489, 2495, "Concept"], [2607, 2613, "Concept"], [2645, 2648, "Concept"], [2667, 2674, "Concept"], [2684, 2686, "Concept"], [2693, 2696, "Concept"], [2824, 2827, "Concept"], [2863, 2868, "Concept"], [2874, 2880, "Concept"], [2887, 2889, "Concept"], [2896, 2899, "Concept"], [2903, 2908, "Concept"], [2909, 2914, "Concept"], [2930, 2932, "Concept"], [2933, 2936, "Concept"], [2960, 2963, "Concept"], [2968, 2971, "Concept"], [3009, 3014, "Concept"], [3131, 3137, "Concept"], [3190, 3195, "Concept"], [3214, 3216, "Concept"], [3225, 3230, "Concept"], [3245, 3247, "Concept"], [3256, 3261, "Concept"], [3278, 3280, "Concept"], [3296, 3298, "Concept"], [3317, 3320, "Concept"], [3336, 3339, "Concept"], [3350, 3353, "Concept"], [3369, 3372, "Concept"], [3383, 3386, "Concept"], [3402, 3405, "Concept"], [3514, 3516, "Concept"], [3533, 3535, "Concept"], [3660, 3677, "Concept"], [3749, 3756, "Concept"], [3779, 3785, "Concept"], [4005, 4009, "Concept"], [4241, 4250, "Concept"], [4274, 4278, "Concept"], [4289, 4298, "Concept"], [4299, 4303, "Concept"], [4354, 4359, "Concept"], [4364, 4373, "Concept"], [4389, 4398, "Concept"], [4885, 4909, "Concept"], [4913, 4922, "Concept"], [4981, 4991, "Concept"], [5020, 5025, "Concept"], [5046, 5055, "Concept"], [5139, 5148, "Concept"], [5160, 5167, "Concept"], [5242, 5246, "Concept"], [5269, 5276, "Concept"], [5388, 5393, "Concept"], [5409, 5421, "Concept"], [5828, 5831, "Concept"], [5876, 5880, "Concept"], [5962, 5969, "Concept"], [6032, 6042, "Concept"], [6044, 6049, "Concept"], [6079, 6084, "Concept"], [6090, 6101, "Concept"], [6135, 6140, "Concept"], [6149, 6154, "Concept"], [6165, 6178, "Concept"], [6223, 6230, "Concept"], [6240, 6253, "Concept"], [6255, 6260, "Concept"], [6306, 6314, "Concept"], [6328, 6333, "Concept"], [6351, 6356, "Concept"], [6371, 6376, "Concept"], [6380, 6389, "Concept"], [6422, 6431, "Concept"], [6452, 6457, "Concept"], [6505, 6511, "Concept"], [6547, 6551, "Concept"], [6593, 6608, "Concept"], [6661, 6670, "Concept"], [6835, 6840, "Concept"], [6845, 6852, "Concept"], [6944, 6954, "Concept"], [6989, 6995, "Concept"], [7013, 7018, "Concept"], [7064, 7070, "Concept"], [7105, 7112, "Concept"], [7159, 7165, "Concept"], [7174, 7180, "Concept"], [7261, 7270, "Concept"], [7272, 7278, "Concept"], [7330, 7336, "Concept"], [7432, 7459, "Concept"], [7567, 7584, "Concept"], [7798, 7803, "Concept"], [7809, 7822, "Concept"], [7839, 7843, "Concept"], [7862, 7867, "Concept"], [7900, 7917, "Concept"], [7992, 8003, "Concept"], [8035, 8046, "Concept"], [8482, 8492, "Concept"], [8547, 8553, "Concept"], [8573, 8578, "Concept"], [8760, 8765, "Concept"], [8771, 8780, "Concept"], [8808, 8820, "Concept"], [8834, 8850, "Concept"], [8949, 8956, "Concept"], [9022, 9027, "Concept"], [9193, 9208, "Concept"], [9232, 9241, "Concept"], [9302, 9317, "Concept"], [9580, 9592, "Concept"], [9650, 9665, "Concept"], [9714, 9728, "Concept"], [9813, 9821, "Concept"], [9828, 9834, "Concept"], [9920, 9928, "Concept"], [10070, 10079, "Concept"], [10287, 10301, "Concept"], [10366, 10380, "Concept"], [10426, 10434, "Concept"], [10625, 10630, "Concept"], [10706, 10713, "Concept"], [10772, 10786, "Concept"], [10790, 10799, "Concept"], [10852, 10859, "Concept"], [10983, 10990, "Concept"], [11006, 11011, "Concept"], [11110, 11115, "Concept"], [11173, 11179, "Concept"], [11319, 11325, "Concept"], [11326, 11333, "Concept"], [11334, 11348, "Concept"], [11383, 11398, "Concept"], [11499, 11513, "Concept"], [11858, 11878, "Concept"], [11885, 11890, "Concept"], [11907, 11911, "Concept"], [11916, 11922, "Concept"], [11933, 11938, "Concept"], [11953, 11959, "Concept"], [11979, 11985, "Concept"], [12011, 12015, "Concept"], [12066, 12071, "Concept"], [12117, 12124, "Concept"], [12160, 12166, "Concept"], [12176, 12179, "Concept"], [12207, 12213, "Concept"], [12221, 12238, "Concept"], [12280, 12285, "Concept"], [12359, 12382, "Concept"], [12461, 12476, "Concept"], [12510, 12524, "Concept"], [12543, 12548, "Concept"], [12585, 12591, "Concept"], [12621, 12626, "Concept"], [12685, 12692, "Concept"], [12727, 12733, "Concept"], [12740, 12745, "Concept"], [12828, 12841, "Concept"], [12988, 12995, "Concept"], [13062, 13067, "Concept"], [13108, 13121, "Concept"], [13328, 13342, "Concept"], [13343, 13347, "Concept"]], "Comments": []}
{"id": 110, "segment": ["train_set", "labeled"],  "course": "cs1622", "lec": "lec15_structs_and_classes_oop", "text": "Structs and Classes, OOP\nCS 1622\nJarrett Billingsley\n\n\fClass Announcements\n\u25cf yet another \"real example\" of adding a language feature\no though you already did the lexing, parsing, and some of the\nsemantic analysis for this stuff in the projects\u2026\no so we\u2019ll kinda skip that stuff!\n\n2\n\n\fStructured types\n\n3\n\n\fType survey\n\u25cf primitive types can only get you so far.\no remember these are things like int, bool, and char.\n\u25cf arrays give the programmer a lot of problem-solving power.\no even in very simplistic languages (like old BASIC dialects), arrays\ngive you the power of indirection and dynamically-sized data\nstructures, which you can't do with primitives.\n\u25cf but more complex problems will require the user to define their own\ntypes suited to solving the problem.\no and if we want to let the user define their own types, the most\nobvious place to start is with\u2026 classes structs tuples!\n\n4\n\n\fTuples??\n\u25cf a tuple is an ordered sequence of heterogeneous types.\no heterogeneous = \"they can be different\"\n\u25cf typically, tuple types are written in parens, like (T1, \u2026, Tn)\n\u25cf you could use them to represent\u2026\no coordinates in an n-dimensional space: (10, 4)\n\u25aa this one's type is (int, int)\no the absence of a value: ()\n\u25aa this is also called unit or, in our language, void\no simple objects: (\"Billingsley\", \"Jarrett\", 35)\n\u25aa this one's type is (string, string, int)\no maybe you can see where this is going\u2026\n\n5\n\n\fOperations on tuples\n\u25cf like arrays, we can index them to access their values:\no t[2] = 34;\n\u25cf unlike arrays, we know their length statically\u2026\no but each element can be a different type!\no therefore: we can only index them with constant values.\n\u25cf what if we had a way of defining named constants?\nconst LNAME = 0;\nconst FNAME = 1;\nconst AGE\n= 2;\nlet me = (\"Billingsley\", \"Jarrett\", 35);\nme[AGE] = 36; // next year..\n\n\u25cf\ud83e\udd14\n6\n\n\f\u2026yeah okay that's basically a struct isn't it\n\u25cf a struct or record type is like a class that only has data.\n\u25cf tuples and structs are almost the same thing, except\u2026\no tuples' fields are anonymous while structs' fields are named.\n\u25cf it's probably pretty obvious now how structs work:\n\nstruct Point {\nx: int, y: int\n}\nlet p = new Point(3, 8);\np.x = p.x + 1;\n\n\u2248\n\u2248 let p = (3, 8);\np[0] = p[0] + 1;\n\u2248\n(int, int)\n\n7\n\n\fOne important difference\n\u25cf in most languages that have both structs and tuples:\no tuples have structural identity, but structs have nominal identity\n\u25cf what that means is:\n\n(int, int, int)\n\n\u2248\n\nstruct Point3D {\nx: int, y: int, z: int\n}\n\nsame type!\n\ndifferent types!\n\n(int, int, int)\n\nstruct Color {\nr: int, g: int, b: int\n}\n\n\u2248\n\n8\n\n\fValue types and reference types\n\u25cf all variables contain bit patterns.\n\u25cf for value type variables, that bit pattern is the value.\no examples include int, float, char, and bool.\n\u25cf for reference type variables, that bit pattern is a memory address.\no examples include Java arrays and objects.\n\u25cf assigning from one variable to another copies the bit patterns.\n\u25cf for value types, that means you copy the entire value.\nint x = 5;\nint y = x; // now we have two 5s!\n\u25cf but for reference types, you only copy the address.\nObject x = new Object();\nObject y = x; // still only one Object...\n\n9\n\n\fDecision time!\n\u25cf Rust, C, C++, and C# consider structs to be value types. In Rust:\nlet s = Point { x: 3, y: 8 };\nlet t = s; // now we have two Points, both {3, 8}!\n\u25cf in these languages, this is nonsense: struct Node { next: Node }\no how can something contain itself??\n\u25cf Java doesn't let the programmer create their own value types.\no so, this is fine: class Node { Node next; }\no because Node next; declares a reference variable.\n\u25cf so: should Truss\u2019s structs be value types, or reference types?\n\u25cf well, for \"simplicity,\" let's stick with reference types.\no reference types let us solve more problems than value types do,\njust sometimes with more space/time overhead.\n\u25cf but if we have references, then we probably need\u2026 null.\n10\n\n\fThe billion dollar mistake: null\n\u25cf null is a special value you can put into a reference variable to\nindicate that it is uninitialized or \u201cnot pointing to anything.\u201d\n\u25cf trying to perform any operation besides assignment on null will\nlead to a runtime error (a crash).\n\u25cf unfortunately, most of the time, you do not want references to be null.\no so by putting null in a language, and not requiring checks before\nusing a reference, you are adding a huge number of potential\ncrashes into virtually every program.\n\u25cf also it\u2019s just weird when it comes to typechecking.\no it\u2019s the only value that can be put into multiple different types.\no String s = null; Object o = null; int[] a = null;\n\u25cf so null does not have a type of its own! type theory calls it a\nbottom type, because it is at the bottom of the type hierarchy and\nacts as a subtype of all other types.\n11\n\n\fStruct Runtime\nRepresentation\n\n12\n\n\fData layout\n\u25cf how are structs (and classes?) going to be represented in memory?\no arrays work by putting the values next to each other.\no okay, let's do that.\n\nstruct Point3D { x: int, y: int, z: int }\nassuming int is\n32 bits (4 Bytes)\u2026\n\n0\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10 11\n\nthese numbers are the offsets from the beginning of the struct.\n(assuming we're using a byte-addressable machine)\n\nthey say how far \"into the struct\" each field is.\n13\n\n\fNot so fast, Mister Gordon!\n\u25cf since bool takes up 1 byte, what if we had a struct like this:\nstruct Hmm { b: bool, i: int }\n\nb\n\ni\n\n0\n\n1\n\nthis is a totally valid way of doing it.\n\n2\n\n3\n\n4\n\nunfortunately, lots of CPU\narchitectures hate this.\n\nCPUs like values to be aligned. that means: the memory\naddress in an n-byte load/store must be a multiple of n.\nx86 CPUs will access unaligned values very slowly.\nMIPS CPUs will crash. (unless you use the much slower unaligned loads/stores)\n\nso, we need to insert padding (extra unused bytes) into\nour structs to ensure each field is properly aligned.\n14\n\n\fStruct padding\n\u25cf we place each field at an offset that is a multiple of its alignment.\n\u25cf then, the struct's size as a whole is rounded up to the largest\nalignment of any field. (this is important for arrays of structs.)\n\u25cf so for this: struct Hmm { b: bool, i: int }\n\nb\n0\n\ni\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\nand if we swapped b and i:\n\ni\n0\n\nb\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\neither way, the struct is\n8 bytes, and it must be\n4-byte aligned\nbecause of the int.\n15\n\n\fWait, why does the whole struct need to be padded?\n\u25cf strictly speaking, for our language where structs are reference types,\nthe structs don't need padding at the end.\n\u25cf but in languages where they're value types, it's crucial for maintaining\nalignment in arrays of structs. consider these arrays of two structs:\ni\n0\n\nb\n1\n\n2\n\n3\n\ni\n0\n\n1\n\n2\n\n3\n\ni\n\n4\n\n5\n\nb\n\ni\n\n4\n\n5\n\n6\n\n7\n\n8\n\nb\n9\n\n10 11 12 13 14 15\n\nb\n6\n\n7\n\n8\n\n9\n\nwithout the end-padding, this int field\nof the second item is now misaligned.\n\nthe memory allocator will\nhave to allocate things at\naligned memory addresses\nas well, for this to work.\n16\n\n\fAnyway\u2026 allocation\n\u25cf now we know the size and alignment of each struct.\n\u25cf we'll need a runtime library function to dynamically allocate structs.\no let's call it rt$new(size: int). it'll return an address.\no to keep it simple, it'll always align things to 4 bytes.\nstruct Thing {\n// size: 12\nname:\nstring,\nin_use: bool,\nflag:\nbool,\ncount: int,\n}\n\nlet t = new Thing();\n\nallocations get generated\nas calls to this function.\naddi sp, sp, -4\nli\ns0, 12\nsw\ns0, 0(sp) # size\njal rt$new\nsw\nv0, -24(fp) # t\n\n17\n\n\fAccessing fields\n\u25cf we use the fields' offsets and types to generate code for field access.\nstruct Thing {\nname:\nstring, // offs: 0\nin_use: bool,\n// offs: 4\nflag:\nbool,\n// offs: 5\ncount: int,\n// offs: 8\n}\n\nto access a field, we add its\noffset to the struct instance's\naddress, then use the right\n\"flavor\" of load/store.\n\nlet t = new Thing();\nt.in_use = true;\nt.count\n\n= 20;\n\nlw s0, -24(fp) # t\nli s1, 1\n# true\nsb s1, 4(s0)\n# t.in_use = true\nlw s0, -24(fp) # t\nli s1, 20\nsw s1, 8(s0)\n# t.count = 20\n18\n\n\fOOP\n\n19\n\n\fWhat is OOP (object-oriented programming)?\n\u25cf we might gesture vaguely in Java's direction and say \"it's like that\"\no but \"Java-flavored OOP\" isn't the only kind\u2026\n\u25cf C has structs, but it isn't \"OOP.\" C++ has \"classes\", and it is \"OOP.\"\n\u25cf the core idea of OOP is packaging data alongside operations on\nthat data into a single, indivisible entity.\no so: the main thing that distinguishes C++ from C\u2026 is methods.\n\u25cf a method call is a special kind of function call:\nobj.method();\no method calls can be more complex than \"regular\" function calls.\n\u25cf other OOP concepts, which are not required but are common, include\ninheritance, subtyping, interfaces, privacy, constructors, and runtime type identification.\n\n20\n\n\fMethods\n\u25cf methods are special functions which are associated with an object.\n\u25cf they take the object they are called on as an argument.\nstruct Point {\nthis is passed implicitly,\nx: int,\nbut it's still an argument.\ny: int\nfn to_string(): string {\nreturn to_string(this.x) + \", \" + to_string(this.y);\n}\n}\nlet p = new Point(3, 8);\nprintln_s(p.to_string());\n\nhere, the method call is syntactic\nsugar for something like:\nPoint.to_string(p)\n\nthis is static dispatch, because we can determine\nwhich method to call at compile-time.\n\n21\n\n\fConstructors\n\u25cf a constructor is just a method that is called on an instance of an\nobject immediately after allocating it, to let you initialize its fields.\nclass C {\nString s;\n\nC() {\n// s == null\ns = \"hi\";\n}\n}\nC c = new C();\n\nin this Java code, new C() does the following:\n\n1. allocates an instance of C\n2. initializes all its fields to default values*\n\n3. calls the constructor on that instance\nbut Java doesn\u2019t really enforce that you do\nanything useful in the constructor, and before\nit completes, the object may be in an\ninconsistent state (i.e. calling methods on\nthis may behave erratically or crash).\n22\n\n\fData inheritance\n\u25cf first, let's look at a simpler kind of inheritance, which just inherits data\nfields without inheriting methods, and does not imply subtyping.\nstruct RGB { r: int, g: int, b: int } the base class's fields are\nstruct RGBA : RGB { a: int }\ncopied into the derived\nlet color = new RGBA(255, 127, 0, 95);\nclass's definition.\n\nwe represent this in memory by prefixing:\nthe beginning of an RGBA is an RGB.\n\nRGB\nRGBA\n\nr\n\ng\n\nb\n\n0\n\n4\n\n8\n\nr\n\ng\n\nb\n\na\n\n0\n\n4\n\n8\n\n12\n\nreusing only the data is\nlimited in usefulness. reusing\nmethods is much more useful.\n23\n\n\fMethod inheritance\n\u25cf method inheritance takes advantage of the prefixed representation.\no base class methods can be called on derived class instances,\nbecause the base class fields are at the same offsets.\nstruct Animal {\nspecies: string\nfn to_string(): string {\nreturn \"Animal(\" + this.species + \")\";\n}\n}\nstruct Cat : Animal { whiskers: int }\nlet c = new Cat(\"felis cattus\", 15);\nprintln_s(c.to_string());\n\nthis is still static dispatch: the method\ncall is sugar for Animal.to_string(c).\n\nwe can now say that Cat\nis a subtype of Animal.\n\n24\n\n\fWhere it starts getting crazy\n\u25cf what if we want to specialize to_string() in the Cat struct?\nstruct Animal {\nspecies: string\nfn to_string(): string {\nreturn \"Animal(\" + this.species + \")\";\n}\nthe compiler might be able to\n}\nstatically determine in this case that\nstruct Cat : Animal {\nit should call Cat.toString(c).\nwhiskers: int\nfn to_string(): string {\nreturn \"meow meow meow!\";\nbut it can't determine that in\n}\nthe general case.\n}\nlet c = new Cat(\"felis cattus\", 15);\nprintln_s(c.to_string());\n25\n\n\fThe problem\n\u25cf since a subtype can be used anywhere a base type is expected\u2026\no a base type variable can contain different types of values.\n\u25cf and since subtypes can have different implementations of the\nsame methods as the supertype\u2026\no you can't know what subtype implementation to call until runtime!\nfn print(a: Animal) {\n// how does this call to\n// to_string know which\n// implementation to use?\nprintln_s(a.to_string());\n}\nprint(new Cat());\nprint(new Dog());\nprint(new Horse());\n\nthe problem (as it often is) is that\nwe lose type information in the\ntranslation from the source\nlanguage to the target language.\nso, let's\u2026 not do that. let's\nkeep some of that type info.\n26\n\n\fVirtual Methods and\nDynamic Dispatch\n\n27\n\n\fRTTI (Run-time Type Identification)\n\u25cf the solution is to make each class instance carry an ID card.\no this is implemented as a \"secret\" field in every class instance.\nc = new Cat(\u2026);\ntype: Cat\nspecies: \"felis cattus\"\nwhiskers: 15\n\nd = new Dog(\u2026);\ntype: Dog\nspecies: \"canis lupus\"\ndrooly: true\n\nfn print(a: Animal) {\nprintln_s(a.to_string());\n}\nthis method call could be\nimplemented something like:\n\nif a.type == Cat {\nCat.to_string(a)\n} else if a.type == Dog {\nDog.to_string(a)\n}\nbut that would be horribly inefficient.\n28\n\n\fVirtual method tables (vtables)\n\u25cf to implement this efficiently, and to allow an unlimited number of\nsubtypes, the \"ID card\" is a pointer to an array of function pointers.\nc = new Cat(\u2026);\n\nCat vtable\n\n0 vtbl\n\n0 breathe\n\nAnimal.breathe()\n\n4 species\n\n4 to_string\n\nCat.to_string()\n\n8 whiskers\n\n8 play_string\n\nCat.play_string()\n\nd = new Dog(\u2026);\n\nDog vtable\n\n0 vtbl\n\n0 breathe\n\n4 species\n\n4 to_string\n\nDog.to_string()\n\n8 drooly\n\n8 play_fetch\n\nDog.play_fetch()\n29\n\n\fVirtual method calls\n\u25cf to call a virtual method, we index the table to get the address\u2026\no and do an indirect function call to that address.\nthis method call becomes:\nfn print(a: Animal) {\na.vtbl[1](a)\nprintln_s(a.to_string());\n}\nor in assembly:\nthe compiler knows the\nmethod indexes because\nthe vtables for each class\nuse prefixing:\nsubtypes' vtables are\nprefixed with their\nsupertype's vtable.\n\naddi sp, sp, -4\nlw\ns0, -16(fp) # s0 = a\nsw\ns0, 0(sp)\n# pass 'this'\nlw\ns0, 0(s0)\n# s0 = a.vtbl\nlw\ns0, 4(s0)\n# s0 = a.vtbl[1]\njalr s0\n# call to_string\n\njalr works like jal, but uses a register\nas the address of the function to call.\n30\n\n\fThings to ponder on\n\u25cf what are interfaces, then?\no a \"slice\" of a vtable, sort of!\no when a class implements an interface, those methods are present\nin its vtable at runtime.\n\u25cf what about public/protected/private? final? override?\no these are all semantic; they have no effect on the implementation.\n\u25cf what about static variables/methods?\no they're globals whose names happen to be scoped inside a class.\n\u25cf what about null?\no we could have nullable reference types, like a restricted form of\nRust's Option<T> that only works for references.\n\u25cf what about inheriting from multiple classes?\no don't even go there. noooooope nope nope\n31\n\n\f", "label": [[0, 7, "Concept"], [12, 19, "Concept"], [21, 24, "Concept"], [162, 168, "Concept"], [170, 177, "Concept"], [195, 212, "Concept"], [284, 300, "Concept"], [306, 310, "Concept"], [417, 423, "Concept"], [539, 545, "Concept"], [568, 579, "Concept"], [584, 617, "Concept"], [725, 730, "Concept"], [812, 817, "Concept"], [860, 867, "Concept"], [868, 875, "Concept"], [876, 882, "Concept"], [889, 895, "Concept"], [902, 907, "Concept"], [948, 953, "Concept"], [1010, 1015, "Concept"], [1016, 1021, "Concept"], [1159, 1163, "Concept"], [1412, 1418, "Concept"], [1426, 1432, "Concept"], [1498, 1504, "Concept"], [1520, 1526, "Concept"], [1850, 1856, "Concept"], [1870, 1876, "Concept"], [1880, 1891, "Concept"], [1902, 1907, "Concept"], [1930, 1936, "Concept"], [1941, 1948, "Concept"], [1986, 1992, "Concept"], [2005, 2014, "Concept"], [2021, 2028, "Concept"], [2041, 2046, "Concept"], [2087, 2094, "Concept"], [2290, 2297, "Concept"], [2302, 2308, "Concept"], [2312, 2318, "Concept"], [2324, 2343, "Concept"], [2349, 2356, "Concept"], [2362, 2378, "Concept"], [2560, 2571, "Concept"], [2576, 2591, "Concept"], [2636, 2646, "Concept"], [2742, 2756, "Concept"], [2830, 2836, "Concept"], [2922, 2933, "Concept"], [3028, 3043, "Concept"], [3205, 3216, "Concept"], [3348, 3354, "Concept"], [3463, 3474, "Concept"], [3496, 3501, "Concept"], [3554, 3572, "Concept"], [3606, 3617, "Concept"], [3622, 3637, "Concept"], [3682, 3697, "Concept"], [3701, 3710, "Concept"], [3749, 3760, "Concept"], [3828, 3838, "Concept"], [3863, 3867, "Concept"], [3902, 3906, "Concept"], [3909, 3913, "Concept"], [3952, 3970, "Concept"], [4095, 4099, "Concept"], [4115, 4128, "Concept"], [4208, 4212, "Concept"], [4230, 4234, "Concept"], [4290, 4299, "Concept"], [4421, 4433, "Concept"], [4497, 4502, "Concept"], [4582, 4586, "Concept"], [4599, 4610, "Concept"], [4622, 4633, "Concept"], [4670, 4684, "Concept"], [4699, 4706, "Concept"], [4720, 4725, "Concept"], [4732, 4761, "Concept"], [4768, 4779, "Concept"], [4790, 4797, "Concept"], [4803, 4810, "Concept"], [4850, 4856, "Concept"], [4928, 4934, "Concept"], [5065, 5072, "Concept"], [5099, 5105, "Concept"], [5185, 5191, "Concept"], [5306, 5312, "Concept"], [5477, 5484, "Concept"], [5587, 5596, "Concept"], [5718, 5725, "Concept"], [5756, 5763, "Concept"], [5797, 5804, "Concept"], [5811, 5825, "Concept"], [5854, 5860, "Concept"], [5887, 5896, "Concept"], [5964, 5973, "Concept"], [6011, 6017, "Concept"], [6021, 6028, "Concept"], [6046, 6052, "Concept"], [6277, 6283, "Concept"], [6295, 6301, "Concept"], [6347, 6354, "Concept"], [6359, 6374, "Concept"], [6380, 6387, "Concept"], [6399, 6406, "Concept"], [6452, 6463, "Concept"], [6494, 6503, "Concept"], [6507, 6513, "Concept"], [6517, 6524, "Concept"], [6541, 6547, "Concept"], [6555, 6562, "Concept"], [6678, 6685, "Concept"], [6728, 6738, "Concept"], [6745, 6761, "Concept"], [6794, 6801, "Concept"], [6859, 6869, "Concept"], [6888, 6892, "Concept"], [6897, 6906, "Concept"], [6915, 6921, "Concept"], [6938, 6953, "Concept"], [6966, 6986, "Concept"], [6987, 6994, "Concept"], [7090, 7095, "Concept"], [7115, 7121, "Concept"], [7219, 7230, "Concept"], [7354, 7370, "Concept"], [7384, 7390, "Concept"], [7392, 7399, "Concept"], [7413, 7426, "Concept"], [7431, 7443, "Concept"], [7445, 7451, "Concept"], [7562, 7576, "Concept"], [7589, 7595, "Concept"], [7603, 7609, "Concept"], [7856, 7859, "Concept"], [7874, 7877, "Concept"], [7879, 7906, "Concept"], [8002, 8005, "Concept"], [8036, 8043, "Concept"], [8059, 8062, "Concept"], [8095, 8098, "Concept"], [8120, 8123, "Concept"], [8137, 8141, "Concept"], [8152, 8175, "Concept"], [8266, 8273, "Concept"], [8279, 8290, "Concept"], [8331, 8337, "Concept"], [8343, 8354, "Concept"], [8415, 8418, "Concept"], [8476, 8487, "Concept"], [8489, 8498, "Concept"], [8500, 8510, "Concept"], [8512, 8519, "Concept"], [8521, 8533, "Concept"], [8539, 8566, "Concept"], [8574, 8581, "Concept"], [8584, 8591, "Concept"], [8643, 8649, "Concept"], [8667, 8673, "Concept"], [8709, 8715, "Concept"], [8938, 8949, "Concept"], [8953, 8968, "Concept"], [9017, 9032, "Concept"], [9065, 9071, "Concept"], [9083, 9095, "Concept"], [9103, 9115, "Concept"], [9120, 9131, "Concept"], [9142, 9148, "Concept"], [9170, 9178, "Concept"], [9185, 9191, "Concept"], [9210, 9220, "Concept"], [9251, 9257, "Concept"], [9380, 9389, "Concept"], [9393, 9401, "Concept"], [9430, 9436, "Concept"], [9470, 9481, "Concept"], [9490, 9498, "Concept"], [9566, 9577, "Concept"], [9608, 9614, "Concept"], [9661, 9668, "Concept"], [9716, 9732, "Concept"], [9774, 9785, "Concept"], [9798, 9806, "Concept"], [9812, 9818, "Concept"], [9827, 9837, "Concept"], [9838, 9845, "Concept"], [9866, 9875, "Concept"], [9877, 9883, "Concept"], [9943, 9949, "Concept"], [9972, 9978, "Concept"], [10087, 10096, "Concept"], [10244, 10251, "Concept"], [10278, 10296, "Concept"], [10299, 10317, "Concept"], [10341, 10349, "Concept"], [10368, 10378, "Concept"], [10379, 10386, "Concept"], [10404, 10417, "Concept"], [10418, 10427, "Concept"], [10441, 10451, "Concept"], [10452, 10458, "Concept"], [10475, 10482, "Concept"], [10484, 10490, "Concept"], [10584, 10590, "Concept"], [10700, 10715, "Concept"], [10721, 10727, "Concept"], [10797, 10804, "Concept"], [10907, 10913, "Concept"], [10915, 10921, "Concept"], [11017, 11025, "Concept"], [11084, 11090, "Concept"], [11346, 11353, "Concept"], [11377, 11386, "Concept"], [11404, 11413, "Concept"], [11445, 11450, "Concept"], [11474, 11482, "Concept"], [11530, 11537, "Concept"], [11578, 11585, "Concept"], [11615, 11622, "Concept"], [11851, 11867, "Concept"], [12000, 12015, "Concept"], [12020, 12036, "Concept"], [12043, 12047, "Concept"], [12049, 12077, "Concept"], [12110, 12124, "Concept"], [12194, 12208, "Concept"], [12568, 12589, "Concept"], [12591, 12598, "Concept"], [12669, 12677, "Concept"], [12712, 12717, "Concept"], [12761, 12767, "Concept"], [12914, 12920, "Concept"], [13028, 13048, "Concept"], [13061, 13075, "Concept"], [13128, 13150, "Concept"], [13173, 13184, "Concept"], [13277, 13285, "Concept"], [13296, 13302, "Concept"], [13323, 13330, "Concept"], [13340, 13345, "Concept"], [13350, 13359, "Concept"], [13361, 13369, "Concept"], [13371, 13378, "Concept"], [13383, 13391, "Concept"], [13403, 13414, "Concept"], [13415, 13421, "Concept"], [13548, 13552, "Concept"], [13574, 13578, "Concept"], [13691, 13701, "Concept"], [13726, 13732, "Concept"], [13752, 13757, "Concept"], [13772, 13781, "Concept"], [13816, 13822, "Concept"], [13826, 13833, "Concept"], [13848, 13854, "Concept"], [13855, 13864, "Concept"], [13865, 13872, "Concept"], [13874, 13879, "Concept"], [13881, 13889, "Concept"], [13907, 13915, "Concept"], [14058, 14063, "Concept"], [14078, 14082, "Concept"], [14109, 14124, "Concept"], [14214, 14224, "Concept"]], "Comments": []}
