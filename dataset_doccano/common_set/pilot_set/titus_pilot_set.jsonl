{"id":295,"text":"Turing Machine 02\nThumrongsak Kosiyatrakul\ntkosiyat@cs.pitt.edu\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 02\n\n\fTuring Machine Example\n\nDesign a Turing machine that recognizes the language B\nwhere\nB = {w#w | w ∈ Σ∗ }\nOn input string w:\n1\n\n2\n\nZig-zag across the tape to corresponding positions on either\nside of the # symbol to check whether those positions contain\nthe same symbol. If they do not, or if no # is found, reject.\nCross off symbols as they are checked to keep track of which\nsymbols correspond.\nWhen all symbols to the left of the # have been crossed off,\ncheck for any remaining symbols to the right of the #. If any\nsymbols remain, reject; otherwise, accept.\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 02\n\n\fTuring Machine M1\nA Turing machine that decides B = {w#w | w ∈ Σ∗ }.\n\n1\n\nx,\nR\n\nq1\n\n0\n\nR\nx,\n\n→\n\n→\n\n#→R\n\n0, 1 → R\n\nq2\n#→R\n\nx→R\n\nx→R\n\nq8\nt\n\nq4\n\n→R\n\n#→R\n\nqaccept\n\nq5\n\n1\n\nL\nx,\n\n→\n\n→\n\nx,\n\nL\n\n0\n\n0, 1, x → L\n\nq6\n#→L\nx→R\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nq7\n\n0, 1 → R\n\nq3\n\n0, 1 → L\n\nTuring Machine 02\n\nx→R\n\n\fTuring Machine M1\nΣ = {0, 1, #}\nΓ = {0, 1, #, x, t}\n1 → x, R\nRead 1, write x, and move the tape head to the right direction\n\n#→R\nA shorthand notation for # → #, R\nRead #, write #, and move the tape head to the right direction\n\n0, 1 → L\nA shorthand notation representing two transitions:\n0 → L which is 0 → 0, L\n1 → L which is 1 → 1, L\n\nqreject is omitted\nAll missing exiting arrows go to qreject\nAssume that it moves the tape head to the right direction\nbefore entering qreject without writing a symbol (writing the\nsame symbol it read)\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 02\n\n\fTuring Machine M1\nComputing 01#01\n\n1\n\nx,\nR\n\nq1\n\n0, 1 → R\n\nR\n\n0\n\nx,\n\n→\n\n→\n\n#→R\n\nq2\n#→R\n\nx→R\n\nx→R\n\nq8\nt\n\nq4\n\n0, 1 → R\n\nq3\n\n→R\n\n#→R\n\nqaccept\n\nq5\n\n1\n\nL\nx,\n\n→\n\n→\n\nx,\nL\n\n0\n\n0, 1, x → L\n\nq6\n#→L\nx→R\n\nq7\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\n0, 1 → L\n\nTuring Machine 02\n\nx→R\n\nq1 01#01\nxq2 1#01\nx1q2 #01\nx1#q4 01\nx1q6 #x1\nxq7 1#x1\nq7 x1#x1\nxq1 1#x1\nxxq3 #x1\nxx#q5 x1\nxx#xq5 1\nxx#q6 xx\nxxq6 #xx\nxq7 x#xx\nxxq1 #xx\nxx#q8 xx\nxx#xq8 x\nxx#xxq8 t\nxx#xxtqaccept\n\n\fTuring Machine M1\nComputing 01#10\n\n1\n\nx,\nR\n\nq1\n\n0, 1 → R\n\nR\n\n0\n\nx,\n\n→\n\n→\n\n#→R\n\nq2\n#→R\n\nx→R\n\nx→R\n\nq8\nt\n\nq4\n\n0, 1 → R\n\nq3\n\n→R\n\n#→R\n\nqaccept\n\nq5\n\n1\n\nL\nx,\n\n→\n\n→\n\nx,\nL\n\n0\n\n0, 1, x → L\n\nq6\n#→L\nx→R\n\nq7\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\n0, 1 → L\n\nTuring Machine 02\n\nx→R\n\nq1 01#10\nxq2 1#10\nx1q2 #10\nx1#q4 10\nx1#1qreject 0\n\n\fTuring Machine M1\nComputing 01 (no # symbol)\n\n1\n\nx,\nR\n\nq1\n\n0, 1 → R\n\nR\n\n0\n\nx,\n\n→\n\n→\n\n#→R\n\nq2\n#→R\n\nx→R\n\nx→R\n\nq8\nt\n\nq4\n\n0, 1 → R\n\nq3\n\n→R\n\n#→R\n\nqaccept\n\nq5\n\n1\n\nL\nx,\n\n→\n\n→\n\nx,\nL\n\n0\n\n0, 1, x → L\n\nq6\n#→L\nx→R\n\nq7\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\n0, 1 → L\n\nTuring Machine 02\n\nx→R\n\nq1 01\nxq2 1\nx1q2 t\nx1tqreject\n\n\fTuring Machine Example\n\nDesign a Turing machine that recognizes the language A\nwhere\nn\nA = {02 | n ≥ 0}\nOn input string w:\n1\n2\n3\n\n4\n5\n\nSweep left to right across the tape, crossing off every other 0\nIf in stage 1 the tape contained a single 0, accept\nIf in stage 1 the tape contained more than a single 0 and the\nnumber of 0s was odd, reject\nReturn the head to the left-hand end of the tape\nGo to stage 1\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 02\n\n\fMoving the Tape Head Back\nSuppose we want to move the tape head back to the left most\nend of the tape\nNeed a state to do that\n0, 1, x → L\n\nThis will result in an infinite loop\n\nRecall that if the tape head is at the left-most square and the\ntransition is L, it will stay at the same place\nThere is no signal telling a TM that its tape head is currently\nat the left-most square\n\nThe trick is to mark the left-most symbol (depending on Γ)\nTurn 0 or 1 to t\nTurn 0 to 0̇ or x\nTurn 1 to 1̇ or t\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 02\n\n\fTuring Machine M2\nn\n\nA Turing machine that decides A = {02 | n ≥ 0}.\n0→L\nx→L\n\n→\nt\n\n→R\nx→R\n\n0 → x, R\n\nt\n\nt\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\n→R\n\nq3\n\n0→R\n\nqaccept\n\nt\n\nx→R\n\nL\n\nq2\n\n0 → t, R\n\nqreject\n\n→\n\nx→R\nq1\n\nt\n\nR\n\nq5\n\n→R\n\nTuring Machine 02\n\n0 → x, R\n\nq4\n\nx→R\n\n\fTuring Machine M2\nComputing 0000\nq1 0000\nq2 000\ntxq3 00\ntx0q4 0\ntx0xq3 t\ntx0q5 x\ntxq5 0x\ntq5 x0x\nq5 tx0x\ntq2 x0x\ntxq2 0x\ntxxq3 x\ntxxxq3 t\ntxxq5 x\ntxq5 xx\ntq5 xxx\nq5 txxx\ntq2 xxx\ntxq2 xx\ntxxq2 x\ntxxxq2 t\ntxxxtqaccept\nt\n\n0→L\nx→L\n\n→\nt\n\n→R\nx→R\n\n→R\n\nqaccept\n\nt\n\nq3\n\n0 → x, R\n\nt\n\nx→R\n\nL\n\nq2\n\n0 → t, R\n\nt\n\nqreject\n\n→\n\nx→R\nq1\n\nt\n\nR\n\nq5\n\n0→R\n\n0 → x, R\n\nq4\n\nx→R\n\n→R\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 02\n\n\fTuring Machine M2\n\nComputing 000\n0→L\nx→L\n\n→\nt\n\n→R\nx→R\n\n→R\n\nqaccept\n\nt\n\nq3\n\n0 → x, R\n\nt\n\nx→R\n\nL\n\nq2\n\n0 → t, R\n\nt\n\nqreject\n\n→\n\nx→R\nq1\n\nt\n\nR\n\nq5\n\n0→R\n\n0 → x, R\n\nq4\n\nx→R\n\n→R\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nq1 000\nq2 00\ntxq3 0\ntx0q4 t\ntx0tqreject\nt\n\nTuring Machine 02\n\n\fDesigning a TM\nDesigning a TM in a form of a state diagram is hard\nNeed to keep in mind out the content of the tape\nNeed to worry about moving tape head\n\nBut for a simple problem, it is not that bad\nLet’s create a TM that shift all symbols on the tape to the\nright by one square by inserting the blank symbol at the\nleft-most square and move the tape head back to the\nleft-most square\nLet Σ = {0, 1} and Γ = {0, 1, t}\nHere are some input\/output (on the tape)\nInput\nOutput\n01101 t01101\n0\nt0\n111\nt111\nε\nε\nNote that this TM always accepts all strings over Σ\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 02\n\n\fDesigning a TM\nSolution\n0→R\n\nq1\n0 → t, R\n1 → 0, R\n\n0 → 1, R\n\nq0\n\nt\n\n1 → t, R\n\n→ 0, L\n0, 1 → L\n\nq3\nt\n\n→ 1, L\n\nt\n\n→L\nqaccept\n\nq2\n\n1→R\nt\n\n→L\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 02\n\n\f","Comments":[],"label":[[0,1,"Concept"]]}
{"id":291,"text":"CS 0007: Introduction to Java\nLecture 7\nNathan Ong\nUniversity of Pittsburgh\nSeptember 22, 2016\n\n\fFUNCTIONS\n\n\fFunctions\n• A function is similar to its mathematical\ncounterpart\n• f(x) = x2, plug in 3, get 9\n• Contains several more parts\n\n\fJava Functions\n• Takes in zero or more parameters,\nprocesses them in the function body,\nand returns a result\n• Imagine going to BestBuyTM and telling\nthem you want your computer fixed.\nYou are telling them to run a fixing\nfunction, with your computer being a\nparameter. What you get back is your\nfixed computer.\n\n\fYou Already Have the Power!\n• You already know how to call functions!\nStatic:\nClassName.functionName(<parameters\n>);\nNon-static:\nobjectName.functionName(<parameter\ns>);\n• How do I make my own?\n\n\fFunction Components\n\n1.\n2.\n3.\nFunction 4.\nHeader 5.\n\nFunction\nBody 6.\n\nVisibility type (public\/protected\/private)\nstatic (For now, required)\nReturn Type\nfunctionName\nParentheses “()”\n–\na)\nb)\nc)\n\nParameters\nType1 parameterName1\nType2 parameterName2\n…\n\nCurly Brackets\/Braces “{}”\n–\n\nreturn a value\n\n\fA Simple Unnecessary\nFunction\n• I want this function to take two doubles\nand return their sum.\n• Let us go through the list and see what\nneeds to be incorporated for the\nfunction.\n\n\fFunction Components\n1.\n2.\n3.\n4.\n5.\n\nWe’ll just use public for now.\nstatic (For now, required)\nWhat is the Return Type?\nWhat is an appropriate functionName?\nParentheses “()”\n–\n\nWhat are the parameters?\n\n6. Curly Brackets\/Braces “{}”\n–\n–\n\nWhat do we do in the Function Body?\nWhat do we return?\n\n\fReturn Type\n• What kind of thing are we going to give\nback to the function caller?\n• “I want this function to take two\ndoubles and return their sum.”\n• The sum of two doubles better be a\ndouble.\n\n\fFunction Name\n• The function name should easily\ndescribe what the function does.\n• “I want this function to take two\ndoubles and return their sum.”\n• “sum”? Probably not enough detail,\nsince there are many types that can be\nsummed.\n• sumDoubles\n\n\fParameters\n• The required input to the function.\n• The data that the function needs in\norder to properly execute its duties.\n• “I want this function to take two\ndoubles and return their sum.”\n• Two doubles.\n• Names?\n\n\fFunction Header\n\n\/\/sums two doubles together\npublic static double sumDoubles\n(double addend1, double addend2)\n\n\fFunction Body\n…(Function Header)\n{\n???\n}\n\n\fFunction Body\n…(Function Header)\n{\ndouble sum = addend1 + addend2;\nreturn sum;\n}\/\/end method(double,double)\n\n\fFunction Body\n…(Function Header)\n{\nreturn addend1 + addend2;\n}\/\/end method(double,double)\n\n\fFunction Body\npublic class Functions\n{\n…(Function)\npublic static void main(String[] args)\n{\ndouble sum = sumDoubles(2.5,3.9);\nSystem.out.println(sum);\n}\/\/end method main\n}\/\/End class Functions\n\n\fimport java.util.Scanner;\npublic class AddingMachine\n{\n…(Function)\npublic static void main(String[] args)\n{\nScanner scan = new Scanner(System.in);\nSystem.out.println(\"Please enter a number:\");\ndouble firstNum = scan.nextDouble();\nSystem.out.println(\"Please enter a second\nnumber:\");\ndouble secondNum = scan.nextDouble();\ndouble sum = sumDoubles(firstNum,secondNum);\nSystem.out.println(\"The sum of \" + firstNum +\n\" and \" + secondNum + \" equals \" +\nsum);\n}\/\/end method main\n}\/\/End class AddingMachine\n\n\fScope\n• Why did we need to submit firstNum\nand secondNum to sumDoubles?\n• Why can’t sumDoubles just use the\nalready created variables?\n• This relates to scope.\n\n\fScope\nConfidential\nSecret\nTop Secret\n\n\fScope\npublic class\nAddingMachine\npublic\nstatic void\nmain\n\npublic\nstatic\ndouble\nsumDoubl\nes\n\n\fPassing-in Parameters\n• The act of providing parameters in a\nfunction call is called Passing-in.\n• Java has two kinds of passing-in.\n\n\fPass-by-Value\n• Passing-in a copy of the value of the\nvariable.\n• Any change made to the variable is not\nreflected when the function returns.\n• All primitive type parameters are passby-value.\n\n\fPass-by-Reference\n• Passing-in the actual variable.\n• Any change made to the variable IS\nreflected when the function returns,\nUNLESS the parameter name is\nREASSIGNED.\n• All non-primitive type parameters are\npass-by-reference.\n\n\fAnother Simple Function\n• I want a function that prints a nice\nBritish greeting, complete with the\nperson’s full name.\nSource:\nhttp:\/\/www.bbcamerica.com\/anglophen\nia\/2011\/07\/five-slang-ways-to-say-hello\/\n\n\fFunction Components\n1.\n2.\n3.\n4.\n5.\n\npublic\nstatic\nWhat is the Return Type?\nWhat is an appropriate functionName?\nParentheses “()”\n–\n\nWhat are the parameters?\n\n6. Curly Brackets\/Braces “{}”\n–\n–\n\nWhat do we do in the Function Body?\nWhat do we return?\n\n\fReturn Type\n• Does this function even need to return\nany data or information?\n• No, so we should use void as our\nreturn type.\n\n\fFunction Header\n\npublic static void britishGreeting\n(String fullName)\n\n\fFunction Body\n…(Function Header)\n{\nSystem.out.println(\"Wotcha \" +\nfullName +\n\". Fancy a cuppa?\");\n}\/\/end method(String)\n\/\/Note no return statement\n\n\f","Comments":[],"label":[[97,106,"Concept"],[109,118,"Concept"],[123,131,"Concept"],[242,251,"Concept"],[276,286,"Concept"],[310,323,"Concept"],[329,336,"Concept"],[459,467,"Concept"],[496,505,"Concept"],[610,619,"Concept"],[621,627,"Concept"],[668,678,"Concept"],[746,754,"Concept"],[776,784,"Concept"],[799,807,"Concept"],[817,832,"Concept"],[860,866,"Concept"],[887,898,"Concept"],[899,911,"Concept"],[941,951,"Concept"],[1027,1033,"Concept"],[1065,1073,"Concept"],[1088,1096,"Concept"],[1121,1127,"Concept"],[1214,1222,"Concept"],[1226,1234,"Concept"],[1293,1299,"Concept"],[1332,1338,"Concept"],[1368,1380,"Concept"],[1415,1425,"Concept"],[1484,1497,"Concept"],[1510,1516,"Concept"],[1520,1531,"Concept"],[1586,1594,"Concept"],[1618,1626,"Concept"],[1651,1657,"Concept"],[1717,1730,"Concept"],[1737,1750,"Concept"],[1783,1791,"Concept"],[1813,1821,"Concept"],[1846,1852,"Concept"],[1964,1974,"Concept"],[2104,2112,"Concept"],[2137,2143,"Concept"],[2182,2197,"Concept"],[2227,2233,"Concept"],[2234,2240,"Concept"],[2294,2307,"Concept"],[2310,2325,"Concept"],[2337,2350,"Concept"],[2353,2368,"Concept"],[2447,2460,"Concept"],[2463,2478,"Concept"],[2539,2552,"Concept"],[2580,2588,"Concept"],[2590,2596,"Concept"],[2597,2603,"Concept"],[2722,2731,"Concept"],[2791,2799,"Concept"],[3388,3393,"Concept"],[3397,3402,"Concept"],[3436,3441,"Concept"],[3442,3448,"Concept"],[3469,3475,"Concept"],[3476,3482,"Concept"],[3483,3487,"Concept"],[3494,3500,"Concept"],[3501,3507,"Concept"],[3540,3550,"Concept"],[3574,3584,"Concept"],[3664,3677,"Concept"],[3788,3796,"Concept"],[3797,3804,"Concept"],[3827,3837,"Concept"],[3842,3854,"Concept"],[3858,3875,"Concept"],[3995,4004,"Concept"],[4050,4060,"Concept"],[4065,4082,"Concept"],[4101,4109,"Concept"],[4121,4129,"Concept"],[4292,4300,"Concept"],[4328,4334,"Concept"],[4335,4341,"Concept"],[4354,4365,"Concept"],[4390,4402,"Concept"],[4437,4447,"Concept"],[4506,4519,"Concept"],[4532,4538,"Concept"],[4542,4553,"Concept"],[4643,4647,"Concept"],[4655,4666,"Concept"],[4670,4685,"Concept"],[4687,4693,"Concept"],[4694,4700,"Concept"],[4701,4705,"Concept"],[4742,4755,"Concept"],[4758,4773,"Concept"],[4872,4878,"Concept"]]}
{"id":294,"text":"11\n\nHow\nPrograms\n\nAre Managed\n\nCS\/COE 0449\nIntroduction to\nSystems Software\n\nLuis Oliveira\n(with content borrowed from wilkie and Vinicius Petrucci)\n\n\fWhere’s the Lie?\nAnd other operating systems questions.\n\n2\n\n\fOn the last episode…\n• Programs are loaded into memory by the\noperating system.\n• They have to exist in memory before they can\nbe executed.\n\nKernel Memory\nstack\nlibz.so .data\n\nlibz.so .text\n\n• Programs go through a lot of trouble to have\nall their data\/code in memory.\n\n.bss\n.data\n\n.text\n\n3\n\n3\n\n\fThe Lie\n• Programs are told that they are\nthe only things running…\n• The only things in memory…\n• We know that this is not true!\n• Operating Systems are big liars\ncrafting illusions.\n\n4\n\n\fThe Truth\n• In reality, many programs can be running at the same time.\n• Each program, when running, is typically called a process.\n▪ A multitasking OS is (a rather common) one that supports concurrent\nprocesses.\n\n• The OS must handle switching from one process to another.\n▪ Which processes get to run?\n▪ What if you have more processes than CPUs?\n▪ When do you switch from one to another?\n▪ What if one is more urgent??\n5\n\n\fMy process is one of method…\n• A process is an abstraction representing a single instance of a program.\n▪ An executable represents the initial state of a program and thus the process.\n▪ A program can be instantiated multiple times, if needed.\n▪ Each one would be a separate process… of the same program.\n▪ Note: A processor is the hardware unit that executes a process. (makes sense!!)\n\n• The Operating System defines what a process and its abstraction is.\n▪ There is an OS representation and metadata associated with a process.\n▪ The OS maintains two key lies:\n\n• The control flow (exclusive use of CPU): as defined by the code (this lecture)\n• The memory layout (exclusive use of memory): defined by executable\/code (next lecture)\n\n• We are focusing on the control flow, here.\n\n▪ How do we determine when a program runs? When does the lie… break down?\n6\n\n\fCPU Scheduling\nEeny Meeny Miney Moe\n\n7\n\n\fThe Reality\n• Let us say that we have a machine with four separate CPUs.\n▪ You could run four processes concurrently (at the same time) relatively easily.\n▪ What about the fifth?\nstack\n\nstack\n\nstack\n\nstack\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\nCPU State:\nRegisters\n,\n\n8\n\n\fMultiplexing the CPU\n• Truth be told, we often have fewer resources than needed.\n▪ Sharing a common resource is called multiplexing.\n\n• Now, consider a machine with a single CPU.\n\nProcess\n\nstack\n.bss\n\n• We often want to run something in the foreground.\n\n▪ Word processor, web browser, minesweeper… whatever.\n\n.data\n\n• We still want some things running the background…\n\n.text\n\n• We need to switch from one process to another at\nparticular times.\n\nCPU State:\nRegisters\n,\n\n▪ Music player, virus scanner, chat client.\n\n▪ Yet… we have to keep the illusion that the program is\nuninterrupted…\n\nCPU\n\n9\n\n\fNaïve Campbell was great in The Craft (1996)\n• One way is to run processes sequentially (the naïve solution)\n▪ When one process ends… run the next.\n▪ Yet that’s not very flexible. (Stop your music player to open a PDF)\n• Humans are in the mix! We need computers to be useful to us.\n\nstack\n\nstack\n\nstack\n\nstack\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\nMemory\nCPU\n\n10\n\n\fThe cruel passage of time\n• To multiplex the CPU, we quickly switch from process to process.\n• The OS retains\/restores the state (context) of the process.\n▪ The OS must store this as a form of process metadata in memory.\nstack\n\nstack\n\nstack\n\nstack\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\nCPU State A:\nRegisters\n,\n\nCPU State B:\nRegisters\n,\n\nCPU State C:\nRegisters\n,\n\nCPU State D:\nRegisters\n,\n\nMemory\nCPU\n\n11\n\n\fThe Context Switch\n• When an Operating System goes from\none process to another, it performs a\ncontext switch.\n• This swaps out the CPU state of one\nprocess for the next one to run.\n1. Store registers (including stack\npointer and program counter) to\nmemory.\n2. Determine next process to run.\n3. Load those registers from memory.\nSwitch memory space. (see next lecture:\n\nstack\n\nstack\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\nContext\n\nContext\n\nCPU State A:\nRegisters\n,\n\nCPU State B:\nRegisters\n,\n\nvirtual memory)\n\n4. Jump to old program counter. Go!\n\nCPU\n\n12\n\n\fA deeper dive\n• When we pause a process… we store the state of registers (context)\nx86-64 (gas \/ AT&T syntax) – Process A\n\nContext (A)\n\nx86-64 (gas \/ AT&T syntax) – Process B\n\nCPU State\n\n13\n\n\fWhen is a good time to call you?\n• When should a program pause and let another one go?\n• When programs voluntarily pause, this is called cooperative\nscheduling.\n▪ They may give up control at convenient points such as system calls.\n\n• We often do not expect this, so modern Operating Systems forcibly\npause programs from time to time. Called preemptive scheduling.\n▪ Processes give up control when hardware interjects via an “interrupt”\n▪ How does this work?\n\n14\n\n\fRound Robin Scheduling\n• One method is to just cycle through each process each for equal time.\n▪ This is an element of “fairness” … each gets equal stake.\n50ms\n\n50ms\n\n50ms\n\n50ms\n\nstack\n\nstack\n\nstack\n\nstack\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\nCPU State A:\nRegisters\n,\n\nCPU State B:\nRegisters\n,\n\nCPU State C:\nRegisters\n,\n\nCPU State D:\nRegisters\n,\n\nMemory\nCPU\n\n15\n\n\fProblems with “fairness”\n• Let’s say I want to play Doom Eternal\n▪ In round-robin, I give the video game 25% of my resources.\n50ms\n\n50ms\n\n50ms\n\n50ms\n\nstack\n\nstack\n\nstack\n\nstack\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\nCPU State A:\nRegisters\n,\n\nCPU State B:\nRegisters\n,\n\nCPU State C:\nRegisters\n,\n\nCPU State D:\nRegisters\n,\n\nThis should get\nmore priority.\n\nCPU\n\n16\n\n\fI have priorities!\n• Round-Robin schedulers are fair; then we tweak to meet expectations.\n▪ How might we add a sense of “priority” to the scheduler?\n\n• Let’s look at a visualization of how processes are currently scheduled\nwith a round-robin scheme: (Doom gets only 25% of resources!) \n50ms\n\n50ms\n\n50ms\n\n50ms\n\n50ms\n\n50ms\n\nA\n\nA\nB\n\nB\n\nC\n50ms \/ 200ms = 25%\n\n17\n\n\fI have priorities!\n• Round-Robin schedulers are fair; then we tweak to meet expectations.\n▪ How might we add a sense of “priority” to the scheduler?\n\n• We could give some tasks a longer quantum.\n▪ A quantum is the amount of time a task is guaranteed to run.\n100ms\n\n50ms\n\n50ms\n\n50ms\n\n100ms\n\nA\nB\n\nC\n100ms \/ 250ms = 40%\n\n18\n\n\fI have priorities!\n• Round-Robin schedulers are fair; then we tweak to meet expectations.\n▪ How might we add a sense of “priority” to the scheduler?\n\n• We could increase the chance a specific task is scheduled.\n▪ Round-robin + priority: two queues, switch back and forth and round-robin\nwithin them.\n50ms\n\n50ms\n\n50ms\n\n50ms\n\n50ms\n\n50ms\n\nA\nB\n\nC\n100ms \/ 200ms = 50%\n\n19\n\n\fI have priorities!\n• Round-Robin schedulers are fair; then we tweak to meet expectations.\n▪ How might we add a sense of “priority” to the scheduler?\n\n• We can then always do some sort of combination.\n▪ Hybrid approaches do seem very alluring. Hmm. The power of trade-offs.\n100ms\n\n50ms\n\n100ms\n\n50ms\n\nA\nB\n200ms \/ 300ms = 67%\n\n20\n\n\fIdeal circumstances: Human perception\n• The reality: (very quickly switching)\n100ms\n\n50ms\n\n100ms\n\n50ms\n\nA\nB\n\n• The illusion: (an ideal: perceived concurrency… no delay noticed)\n100ms\n\n50ms\n\n100ms\n\n50ms\n\nA\nB\n\n21\n\n\fThere is no optimal.\n• Like many of the topics in this course, there is no possible “best”.\n▪ That is, there is no way to perfectly schedule general processes.\n\n• Consider: It would be very lovely to schedule a process that handles\nsome user input, like a button press or a network request.\n▪ Perfect situation: the OS schedules the task that handles the button\nimmediately before the button is pressed. What luck!\n\n• However: You do not know when that button will be pressed.\n▪ Maybe it is a sensor, like for detecting a fire!\n• FIRE SEEMS IMPORTANT!! … and yet.\n\n• Moral of the story: humans being users make things very hard.\n\n22\n\n\fAgain, it is not magic.\n• But… wait… how does hardware stop a program?\n▪ For instance, when the quantum is up, how does the OS get control and\nperform the context switch?\n\n• Ah, the hardware has support for “being rude” which is called an\ninterrupt.\n▪ A programmable mechanism for asynchronously calling a function when a\nparticular type of error or signal is noticed.\n\n• Let’s take a look.\n\n23\n\n\fInterrupts\nIt’s rude… but necessary.\n\n24\n\n\fHow rude\n• An interrupt is an exceptional state that diverts execution from its\nnormal flow.\n▪ When issued by hardware, sometimes referred to as a hardware exception\n• For instance, a hardware timer or external event caused by a sensor.\n\n▪ When caused by a user process, sometimes referred to as a software trap\n• Divide-by-zero error, some floating-point exceptions, system calls.\n\n• We have seen these before!\n▪ System calls are a type of interrupt (software trap).\n▪ This is an intentional interrupt caused by a specific program instruction.\n• The program is “interrupted” while the OS performs a task.\n\n• We have also encountered them in our failures.\n▪ Segmentation \/ Protection \/ Page Faults are also interrupts. (trap? exception?)\n▪ These are (usually) unintentional interrupts caused by a generic instruction. 25\n\n\fHere are some typical UNIX\/Linux system calls:\nNumber\n\nName\n\nDescription\n\nread\n\nReads bytes from an open file.\n\nwrite\n\nWrites bytes to an open file.\n\nopen\n\nOpens a file and returns the file handle.\n\nclose\n\nCloses an open file.\n\nstat\n\nReturns metadata about a file.\n\nfork\n\nSpawns a copy of the current process.\n\nexecve\n\nLoads and then executes a program.\n\n26\n\n\fSystem calls\n• System calls: predictable, intentional interrupts at specific instructions.\n▪ Interrupts occurring at specific instructions are synchronous interrupts.\n\n• In x86-64, the program pauses at a\ninstruction, then resumes\nat the following instruction when the OS finishes the task\n▪ (… and the OS calls the\n\ninstruction)\n\n• Let’s take a deeper look.\n27\n\n\fHello, Hello World\nx86-64 (gas \/ AT&T syntax) - Application\n\nx86-64 (gas \/ AT&T syntax) - Kernel (main OS program)\n\nPre-registered to be called on syscall\nSaves CPU state\n\nA jump to the kernel\n\nPerforms action\nRestores state\n\nReturns to process\n\n28\n\n\fTick tock tick tock merrily sings the clock\n• A hardware timer can preempt (forcibly pause) a program at any time.\n▪ Interrupts that occur at any instruction are asynchronous interrupts.\n\n• In a preemptive operating system, a hardware timer is used to give a\nmaximum bound to how long a process runs.\n▪ Your operating system programs the timer such that it sends a signal at a\nregular interval.\n▪ Your operating system has a function that is called when such a signal is read.\n▪ That function will respond by invoking the scheduler and pausing the current\ntask and resuming or starting another.\n\n• Let’s look at the basic procedure an OS uses to program an interrupt.\n29\n\n\fProgramming interruption\n• On most hardware, there is a programmable table somewhere in\nmemory that, when written to, defines where code exist to handle\neach interrupt.\n• Every possible interrupt is given a number. Segmentation faults might\nbe interrupt 10. Timers might be interrupt 0. Et cetera.\n• When an interrupt occurs, based on its interrupt number, the\ncorresponding entry in a lookup table called an interrupt vector table\nor an interrupt descriptor table would be used to determine where in\nthe kernel to jump.\n30\n\n\fThe Interrupt Table\n#\n\nValue\n\n• The interrupt table is a simple table.\n\nDescription\nDivide by zero\n\n• Fun Fact: It is often located at\naddress 0x0 in memory!\n\nOverflow\nDouble Fault\nGeneral Protection Fault\nPage Fault\nStack Fault\nAlignment Error\n...\nTimer Signal\nNetwork Device Signal\n\n▪ So, operating system kernels can’t\nexactly always treat zero as an invalid\naddress…\n\n• When a process triggers a listed\ninterrupt or external hardware sends\na signal to the interrupt controller…\n▪ the CPU jumps to the given address.\n\nAudio Device Signal\n\n31\n\n\fAh! There art thee ol’ interrupt!\n• Let’s take a look at interrupt handling…\nx86-64 (gas \/ AT&T syntax) – Process B\nA\n\nContext (A)\n\nCPU State\n\nx86-64 (gas \/ AT&T syntax) – Kernel\n\n• An interrupt is the likely\ncause of our prior\ninterruption.\n• The interrupt handler is the\ncode that handles context\nswitching and scheduling\n32\n\n\fOverview\n• Interrupts can be categorized in several ways:\n▪ They can occur outside of our program:\nhardware exceptions\n▪ They can occur on an instruction in our program: software trap\n▪ They can occur at any time:\nasynchronous interrupts\n▪ They can occur at specific times:\nsynchronous interrupts\n\n• Interrupts are what allow operating systems to function!\n▪ When you press a key on your keyboard.\n▪ When you receive a packet on the network.\n▪ When your sound card wants the next second of audio.\n▪ When you divide by zero…\n• To then mercilessly murder your process.\n\n33\n\n\f","Comments":[],"label":[[832,847,"Concept"],[898,907,"Concept"],[950,957,"Concept"],[978,987,"Concept"],[1024,1033,"Concept"],[1155,1162,"Concept"],[1483,1490,"Concept"],[1547,1554,"Concept"],[1642,1649,"Concept"],[1690,1704,"Concept"],[1881,1893,"Concept"],[2115,2124,"Concept"],[2328,2340,"Concept"],[2447,2459,"Concept"],[2508,2515,"Concept"],[2733,2740,"Concept"],[2989,2998,"Concept"],[3044,3051,"Concept"],[3355,3364,"Concept"],[3397,3404,"Concept"],[3408,3415,"Concept"],[3470,3477,"Concept"],[3517,3524,"Concept"],[3826,3833,"Concept"],[3860,3874,"Concept"],[3914,3921,"Concept"],[4647,4670,"Concept"],[4851,4874,"Concept"],[4877,4886,"Concept"],[4975,4997,"Concept"],[5041,5048,"Concept"],[5445,5456,"Concept"],[5792,5814,"Concept"],[5960,5969,"Concept"],[6000,6012,"Concept"],[6153,6175,"Concept"],[6318,6325,"Concept"],[6331,6338,"Concept"],[6476,6498,"Concept"],[6668,6679,"Concept"],[6845,6867,"Concept"],[7515,7524,"Concept"],[7577,7584,"Concept"],[8097,8104,"Concept"],[8398,8408,"Concept"],[8455,8464,"Concept"],[8588,8606,"Concept"],[8855,8867,"Concept"],[8882,8891,"Concept"],[8934,8943,"Concept"],[9004,9015,"Concept"],[9148,9158,"Concept"],[9215,9225,"Concept"],[9297,9309,"Concept"],[9624,9636,"Concept"],[9639,9651,"Concept"],[9678,9688,"Concept"],[9717,9727,"Concept"],[9767,9789,"Concept"],[10356,10366,"Concept"],[10400,10424,"Concept"],[10896,10905,"Concept"],[10924,10936,"Concept"],[11070,11079,"Concept"],[11098,11107,"Concept"],[11127,11146,"Concept"],[11156,11165,"Concept"],[11186,11195,"Concept"],[11220,11229,"Concept"],[11251,11260,"Concept"],[11321,11330,"Concept"],[11350,11359,"Concept"],[11442,11451,"Concept"],[11474,11483,"Concept"],[11819,11826,"Concept"],[11845,11854,"Concept"],[11898,11907,"Concept"],[12008,12017,"Concept"],[12042,12051,"Concept"],[12170,12179,"Concept"],[12233,12250,"Concept"],[12325,12335,"Concept"],[12413,12432,"Concept"],[12528,12551,"Concept"],[12588,12610,"Concept"],[12614,12624,"Concept"]]}
