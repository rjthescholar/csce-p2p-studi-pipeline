{"id": 51, "segment": ["train_set", "labeled"], "course": "cs0447", "lec": "lec05", "text": "#5\nCS 0447\nIntroduction to\nComputer Programming\n\nArrays\nOriginal slides by: Jarrett Billingsley\nModified with bits from: Bruce\nChilders, David Wilkinson\n\nLu\u00eds Oliveira\n\nFall 2020\n\n\fArrays and Addresses\n\n2\n\n\fStrings, arrays, objects\u2026\n\u25cf When we wanted to store 4-byte values\u2026\no We split them up across consecutive bytes\n\u25cf What about a string?\no How is a string represented?\no How many bytes is a string?\n\u25aa Might be thousands or millions of characters\n\u25cf Any array might be that big too\n\u25cf The solution to storing it in memory is the same\no but how do you access these big things\n\u25aa they don't fit in registers!\n\u2013 ssssssssooooooooooooooooooooooooooo\u2026\n\nAddr\n\nVal\n\n0\n\n00\n\n1\n\n30\n\n2\n\n04\n\n3\n\n00\n\n4\n\nDE\n\n5\n\nC0\n\n6\n\nEF\n\n7\n\nBE\n\n8\n\n6C\n\n9\n\n34\n\nA\n\n00\n\nB\n\n01\n\nC\n\n02\n\n3\n\n\fWhat's an array?\n\u25cf If we did this in C or Java:\n\nbyte[] arr = {1, 2, 3, 4, 5, ...};\n\u25cf In memory it might look like this\n\u25cf What memory address is arr[0] at?\no What about arr[1]?\no What about arr[2]?\no What about arr[3]?\n\u25cf If an array starts at memory address A\u2026\no \u2026then item n is at address?\noA+n\n\u25aa Not really\n\u25aa Remember what we talked about last class?\n\nAddr\n\nVal\n\n...\n\n...\n\nF405\n\n06\n\nF404\n\n05\n\nF403\n\n04\n\nF402\n\n03\n\nF401\n\n02\n\nF400\n\n01\n\n4\n\n\fWhat if the array contains ints?\n\u25cf If we did this:\n\nint[] arr = {1, 2, 3};\n\n\u25cf In memory it'd look like this\no Why are there all these 0s?\no What endianness is being used here?\n\u25aa Is the End-byte(LSB)\nin the Little or in the Big memory address?\n\u25cf What memory address is arr[1] at? arr[2]?\n\u25cf If an array starts at memory address A\u2026\no \u2026and each item is b bytes long\u2026\no \u2026then item n is at address A + (n \u00d7 b)\n\u25aa On the last slide, b happened to be 1\n\u2013 Tricky tricky\n\nAddr\n\nVal\n\nF40B\n\n00\n\nF40A\n\n00\n\nF409\n\n00\n\nF408\n\n03\n\nF407\n\n00\n\nF406\n\n00\n\nF405\n\n00\n\nF404\n\n02\n\nF403\n\n00\n\nF402\n\n00\n\nF401\n\n00\n\nF400\n\n01\n5\n\n\fAccessing arrays\n\u25cf If you wanna print all the values in an array, how do??\n\nfor(int i = 0; i < length; i++)\nprint(data[i]);\n\n\u25cf Let's focus on ^this bit^ for now\n\u25cf Data is an array of words, so how big is each item?\n\u25cf In this calculation, what is A? b? n?\n\u25cf So what's the address calculation?\no Address of item i = data + (i * 4)\n\u25aa Do you think you could convert that into assembly?\n\u2013 Well we haven't done the loop yet\u2026\n\u00bb But we'll get to that\n\n6\n\n\fAccessing arrays in MIPS\n\n7\n\n\fMaking arrays in MIPS\n\u25cf First you need to make space for it just like a variable\no How did we write that variable?\n\nx: .word 4 # static int x=4;\n\n\u25cf For a small array you can list all the values:\n\nlittle_array: .word 1, 2, 3, 4\n\n\u25cf But for a big array, that would be annoying\n\u25cf So you can write:\n\nbig_array:\n\n.word 0xBEEFC0DE:100\n\n\u25cf This fills the array with 100 copies of 0xBEEFC0DE\n\u25cf Notice how similar these look to variables\no (that's cause there's not really any difference)\n\n8\n\n\fMIPS ISA: putting a variable's address in a register\n\u25cf If the address calculation needs the address of the array\u2026\no We've gotta get that address into a register right?\n\u25aa Can't add something unless it's in registers\n\u25cf Remember what the la instruction does?\n\nla t0, little_array\n\u25cf la means load address\n\no it doesn't load anything from memory.\n\no Only lw/lh/lhu/lb/lbu load from memory\no All the other \"loads\" (li, la) just \"put a value in a register\"\n\u25cf What it does: t0 now contains little_array's address\n9\n\n\fAccessing arrays in MIPS (let's do it together)\n\u25cf We want to print out the value in my_array[3].\n\nmy_array: .word 1, 2, 3, 4\n\n\u25cf What's the address calculation?\n\u25cf Now turn that into MIPS\no Let's come up with the instructions first\n\u25aa And then decide which registers to use\no How do we put the address of my_array in a register?\no Now to translate the math\no Now we have the address; how do we get the value?\no How do we print it out?\n\u25cf If we want to store a value into the array\u2026\no We just use a store instruction instead of a load\nCheck code example array_ex1.asm\n10\n\n\fHow does the CPU know that t0 holds an address?\n\u25cf WHAT DO YOU THINK\no IT DOESN\u2019T\n\u25cf Addresses are just numbers too!!\no Which is good! It means we can do math on addresses\n\u25aa As we just did\n\u25aa That's how arrays and strings and stuff work\n\u25cf You can also have a variable whose value is an address\no Hey\n\u25aa 449 students\n\u2013 What are these called?\n\u00bb Pointers (& is like la, * is like lw/sw)\n\n11\n\n\fWatch out\n\u25cf Let's remove the mul instruction\no \"fetch address not aligned on word boundary\"?\n\u25cf In MIPS, all memory accesses must be aligned\n\u25cf Alignment is just:\no the address of a n-byte value\nmust be a multiple of n\no so for 4-byte words\u2026\n\u25cf that's it, that's all, there's nothing more to it\no it's not scary\n\nAddr\n\nVal\n\nF40B\n\n00\n\nF40A\n\n00\n\nF409\n\n00\n\nF408\n\n03\n\nF407\n\n00\n\nF406\n\n00\n\nF405\n\n00\n\nF404\n\n02\n\nF403\n\n00\n\nF402\n\n00\n\nF401\n\n00\n\nF400\n\n01\n12\n\n\fWhat about strings?\n\u25cf Strings are also arrays:\n\nstring: .asciiz \u201cTest\u201d\n\no The z means it has a zero terminator\no The same as:\n\nstring: .byte 84, 101, 115, 116, 0\n\u25cf Be careful with:\n\nstring: .ascii \u201cTest\u201d\n\no If you print an unterminated string, strange things happen!\no The same as:\n\nstring: .byte 84, 101, 115, 116\n\nCheck code example arrays_ex3.asm\n\n13\n\n\fQuestions?\n\u25cf Is this a valid address for a word?\n\n0x0800 0001\n\n\u25cf How about for a half-word?\n\u25cf How about for a byte?\n\u25cf How can I make an array of halfwords with 25 elements set to 0?\no The first halfword is in address 0x0800 00F0, where is the second?\n\u25cf How is a string terminated?\n\n14\n\n\f", "label": [[49, 55, "Concept"], [181, 187, "Concept"], [192, 201, "Concept"], [762, 767, "Concept"], [879, 893, "Concept"], [1203, 1208, "Concept"], [1796, 1802, "Concept"], [1845, 1850, "Concept"], [2057, 2076, "Concept"], [2244, 2250, "Concept"], [2271, 2277, "Concept"], [2508, 2513, "Concept"], [3004, 3006, "Concept"], [3026, 3028, "Concept"], [3266, 3272, "Concept"], [3395, 3414, "Concept"], [4163, 4171, "Concept"]], "Comments": []}