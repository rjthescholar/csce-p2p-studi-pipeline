{"id": 8, "segment": ["test_set", "labeled"], "course": "cs0449", "lec": "lec08", "text": "8\n\nInvestigating\nthe Code\n\nCS/COE 0449\nIntroduction to\nSystems Software\n\nLuis Oliveira\n(with content borrowed from wilkie and Vinicius Petrucci)\n\n\fGoing with the Flow\nTracing the footsteps\n\n2\n\n\fBringing back our alphabet soup: The C ABI\n\u2022 The C Application Binary Interface (ABI) are assembly conventions\n\u2022 Like MIPS, certain registers are typically used for returns values, args, etc\n\u2022 It is not defined by the language, but rather the OS.\n\u2022 Windows and Linux (UNIX/System V) have a different C ABI \uf04c\n\n\u2022 In our x86-64 Linux C ABI, registers are used to pass arguments:\n\u2022\n,\n,\n,\n,\n,\n(First, second, etc) (Like MIPS\n\u2013\n)\n\u2022 Remaining arguments go on the stack.\n\u2022 Callee must preserve\n,\n,\n,\n,\n,\n(Like MIPS\n\u2013\n\u2022 Return value:\n(overflows into\nfor 128-bits) (MIPS\n\u2013\n)\n\u2022 Lots of other small things not worth going over.\n\n)\n\n\u2022 For reference: https://github.com/hjl-tools/x86-psABI/wiki/x86-64-psABI-1.0.pdf\n3\n\n\fFunction, function\u2026 what\u2019s your\u2026 function\n\u2022 The activation frame contains\ntemporary data needed by the function.\n\u2022\n\u2022\n\u2022\nC\n\nis the return value\nis the current stack address\nis the address of this frame\n\nWhat goes here?\n\nx86-64 (gas / AT&T syntax,\n\n)\n\n4\n\n\fOh, that\u2019s your function\n\u2022 First: it fills the activation frame\nwith initial variable values.\n\u2022 It may not allocate them in\nany strict order. Here, it\nallocates x first and further away.\nx86-64 (gas / AT&T syntax,\n\n\u2013\n)\n\n\u2013\nPreserves\n(caller activation frame)\nAllocates \u201c \u201d on stack (\nfrom top)\nAllocates \u201c \u201d on stack (\nfrom top)\n(it does not have to be in order)\n\nResets caller activation frame\nReturns (return value is in\n)\n\n5\n\n\fThese are actual sandwiches (no hot dogs or w/e)\n\u2022 When identifying\nfunctions, you are\nlooking for that\ntell-tale sandwich\npattern.\n\u2022A\nis a good sign\nof the beginning of a\nfunction\n\u2022 And the\nwill\nhappen before the\nat the end.\n\u2022 Everything between is\nthe sweet, sweet jam\nthat makes it unique.\n\n6\n\n\fWho controls the\n\u2022 Control flow is a\n\u2022\n\u2022\n\nwill set\nwill set\n\n\u2022\n\ngroup set\n\nor\n\ncontrols the flow\nfollowed by\n\nbased on the difference (subtraction) between values\nbased on bitwise AND of both values (faster, but less useful)\n\n(program counter) to an address based on\n\n\u2022 Often it is much more useful to just interpret the\nC\n\nx86-64 (gas / AT&T syntax,\n\n(\n\nis\n\n)\n)\n\n7\n\n\fWho controls the\n\u2022\n\ncontrols the flow\n\nhas bits that are set based on the ALU (CPU math logic) result\n\u2013 most significant bit of result\n\u2013 set if overflow occurred\n\n\u2022 Each jump looks at different\n\u2013 Jumps when\nC\n\nWorks because of 2\u2019s\ncomplement math.\n(thus, instead of its strict definition,\nbetter to think about it abstractly)\n\n\u2013 set if result is zero\n\u2013 set if last bit operation has carry\n\npatterns. (Look \u2018em up!)\n\u2013 set if\n\nor\n\nx86-64 (gas / AT&T syntax,\n\n)\n\nPerform x - 0 (does nothing!)\nJump if the result (that is, x)\ndoes not have a set sign bit.\n(x is positive in that case)\nPerform x - y\nJump if the result is 0 or\nif result is negative after overflow\nor positive and didn\u2019t overflow.\n(x is >= y in these cases)\n\n8\n\n\fcmp, simplifying\u2026 the confusion\n\u2022 Just remember that the order of operands is not the\u2026 best order\u2026\n\u2022 It\u2019s kinda swapped around in the AT&T syntax we have been looking at:\nJump if x > 0\n\nJump if x >= y\n\nWe negate the\ncondition\nBecause we are\ndeciding when to\nskip the code!\n\nJump if x < y\n\nJump if x != y\n\n9\n\n\ftest\u2026 adding some new confusion\n\u2022\n\nis somewhat stranger\u2026 and requires some more thought.\n\u2022 performs an AND of the arguments and sets flags on result\n\n\u2022 Thankfully, generally only commonly used in a couple of cases.\n\u2022 Generally to test a value against \u201ctrue\u201d or \u201cfalse\u201d.\n\u2022 Recall that\nand\nwill look at the zero flag (\n)\n\u2022 Keep in mind that jumps are built around\n(which performs:\nWe negate the\ncondition\n\n)\u2026\n\nJump if x != 0\n(\n?)\n\nJump if x == 0\n(\n?)\nCS/COE 0449 \u2013 Spring 2019/2020\n\n10\n\n\fPatterns\n\u2022 Control flow is a\nC\n\n/\n\nbefore a\n\u2013\n\u2013\nx86-64 (gas / AT&T syntax,\n\n)\n\n11\n\n\fAltogether now\u2026 Working backward\n\nNegate logic to form \u201cif\u201d logic\n\nNegate logic to form \u201cif\u201d logic\n\n12\n\n\fDeduction, dear watson\nNo use of\n\n\u2026 likely no arguments\n\nTwo stack allocations \u2026 Two local variables.\n(initialized to 5 and, likely, -2)\n\nLooking at\n\n\u2026 This simply returns zero.\n\n13\n\n\fConventional wisdom: counting arguments\n\nReadies\n\u2026 second argument!\nReadies\n\u2026 first argument!\nSince they are\n\u2026 yep! Both 32-bit!\nLike a\nin MIPS. A function call.\n\nStill have to follow the\n\nto the assembly of the function.\n\n14\n\n\fConventional wisdom: counting arguments\n\nCopies\n\u2026 function argument!\nCopies\n\u2026 second argument!\nSince they are\n\u2026 They are both 32-bit!\nis the return address\u2026\nmeans it is a 32-bit return\n\n15\n\n\f", "label": [[243, 273, "Concept"], [948, 964, "Concept"], [1200, 1216, "Concept"], [1393, 1409, "Concept"], [1530, 1546, "Concept"]], "Comments": []}