{"id": 18, "segment": ["test_set", "labeled"], "course": "cs1502", "lec": "lec12.5_exam_1_review", "text": "Exam 1 Review (Chapter 1)\nThumrongsak Kosiyatrakul\ntkosiyat@cs.pitt.edu\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\n\fDeterministic Finite Automaton (DFA)\n\nState Diagram of a DFA\nFormal Definition of a DFA (Q, \u03a3, \u03b4, q0 , F )\nQ is a non-empty set of states\n\u03a3 is a finite set of symbols\n\u03b4 : Q \u00d7 \u03a3 \u2192 Q transition function\nq0 \u2208 Q is the start state\nF is a set of accept states\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\n\fFormal Definition of a DFA\n0\n\n1\n\n0\n\n1\n\nq0\n\nq1\n\nq2\n0, 1\n\nM1 = (Q, \u03a3, \u03b4, q0 , F )\nQ = {q0 , q1 , q2 }\n\u03a3 = {0, 1}\n\u03b4 can be defined using the table below:\n\u03b4\n0\n1\nq0 q0 q1\nq1 q2 q1\nq2 q1 q1\nq0 is the start state\nF = {q1 }\n\nThe state diagram and its formal definition are equivalent\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\n\fDeterministic Finite Automaton (DFA)\n\nHow a DFA process an input string?\nAccept/Reject\n\nLanguage of a DFA\nThe set of all strings accepted by the DFA\n\nA language is regular is there are finite state machines that\nrecognize it\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\n\fLanguage Operators\n\nA language is a set of strings\nGiven language A and B:\nA \u222a B = {x | x \u2208 A or x \u2208 B}\nA \u25e6 B = {xy | x \u2208 A and y \u2208 B}\nA\u2217 = {x1 x2 . . . xk | k \u2265 0 and xi \u2208 A}\n\nRegular language is closed under union, concatenation, and\nstar operations\nGiven two regular languages A and B\nA \u222a B is a regular language\nAB is a regular language\nA\u2217 and B \u2217 are regular languages\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\n\fTool\n\nGiven two DFA MA and MB\nWe obtain an algorithm to construct a DFA M such that\nL(M ) = L(MA ) \u222a L(MB )\nThe algorithm is defined based on formal definitions of DFAs\nMA and MB\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\n\fL is regular under union operation\n\nLet MA recognizes A, where MA = (QA , \u03a3, \u03b4A , qA , FA )\nLet MB recognizes B, where MB = (QB , \u03a3, \u03b4B , qB , FB )\nMachine M = (Q, \u03a3, \u03b4, q0 , F ) that recognizes A \u222a B can be\nconstructed as follows:\n1\n2\n\nQ = {(r1 , r2 ) | r1 \u2208 QA and r2 \u2208 QB }\nFor each (r1 , r2 ) \u2208 Q and a \u2208 \u03a3\n\u03b4((r1 , r2 ), a) = (\u03b4A (r1 , a), \u03b4B (r2 , a))\n\n3\n4\n\nq0 = (qA , qB )\nF = {(r1 , r2 ) | r1 \u2208 FA or r2 \u2208 FB }\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\n\fNondeterministic Finite Automaton (NFA)\n\nCan split into multiple copies of itself\nAt a state, it may have 0, 1, or more than 1 exiting arrow for\neach symbol\nAt a state, it may have 0, 1, or more than 1 exiting arrow for \u03b5\nWe generally use a computational tree to compute an NFA\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\n\fFormal Definition of A Nondeterministic Finite Automaton\nA nondeterministic finite automaton is a 5-tuple\n(Q, \u03a3, \u03b4, q0, F )\n1\n2\n3\n\nQ is a finite set of states\n\u03a3 is a finite alphabet\n\u03b4 : Q \u00d7 \u03a3\u03b5 \u2192 P(Q) is the transition function,\n\u03a3\u03b5 = \u03a3 \u222a {\u03b5} and\nP(Q) is the powerset of Q (set of set of states).\n\n4\n5\n\nq0 \u2208 Q is the start state\nF \u2286 Q is the set of accept states.\n\nNotes\nIn an NFA, one input symbol can change the state of the\nmachine to multiple states.\nSplit to multiple copies with different current states\nExample: \u03b4(q0 , 1) = {q0 , q1 }\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\n\fExample\n0, 1\n\n0, 1\n\n1\n\nq1\n\n0, \u03b5\n\nq2\n\n1\n\nq3\n\nQ = {q1 , q2 , q3 , q4 }\n\u03a3 = {0, 1} and \u03a3\u03b5 = {0, 1, \u03b5}\n\u03b4 is given as\n\u03b4\n0\n1\nq1 {q1 } {q1 , q2 }\nq2 {q3 }\n\u2205\nq3\n\u2205\n{q4 }\nq4 {q4 }\n{q4 }\n\nq4\n\n\u03b5\n\u2205\n{q3 }\n\u2205\n\u2205\n\nWe treat \u03b5 as a regular input symbol\nIf there is no \u03b5 transitions, we can ignore the \u03b5 column\n\nq1 is the start state\nF = {q4 }\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\n\fEquivalence of NFAs and DFAs\n\nEvery nondeterministic finite automaton has an equivalent\ndeterministic finite automaton.\nLet N = (Q, \u03a3, \u03b4, q0 , F ) be the NFA recognizing some\nlanguage A\nWe are going to construct a DFA M = (Q0 , \u03a3, \u03b4 0 , q00 , F 0 )\nrecognizing A\nLet\u2019s consider the case where N has no \u03b5 transitions.\n1\n2\n\nQ0 = P(Q) [\n\u03b4 0 (R, a) =\n\u03b4(r, a)\nr\u2208R\n\n3\n4\n\nq00 = {q0 }\nF 0 = {R \u2208 Q0 | R contains an accept state of N }\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\n\fExample\nLet \u03a3 be {0, 1}. The following NFA N recognizes the\nlanguage A where A is a set of strings that end with a 1.\n0, 1\n\n1\n\nq0\n\nq1\n\nN = (Q, \u03a3, \u03b4, q0 , F )\n1\n2\n3\n\nQ = {q0 , q1 },\n\u03a3 = {0, 1}\n\u03b4 is given as\nq0\nq1\n\n4\n5\n\n0\n{q0 }\n\u2205\n\n1\n{q0 , q1 }\n\u2205\n\nq0 is the start state\nF = {q1 }\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\n\fExample\n\nConstruct a DFA M = (Q0 , \u03a3, \u03b4 0 , q00 , F 0 )\nQ0 = P(Q) = P({q0 , q1 })\nQ0 = {\u2205, {q0 }, {q1 }, {q0 , q1 }}\nWe will construct \u03b4 0 later\nq00 = {q0 } where q0 is the start state of the NFA\nF 0 = {R \u2208 Q0 | R contains an accept state of N }\nF 0 = {{q1 }, {q0 , q1 }}\nwhere F = {q1 }\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\n\fExample\n\nLet\u2019s focus on transition functions\nThe transition function \u03b4 of the NFA is as follows:\n0\n1\nq0 {q0 } {q0 , q1 }\nq1\n\u2205\n\u2205\nRecall that the set of state of the equivalent DFA is the power\nset of set of state of the NFA\n\u03b40\n0\n1\n\u2205\n\u2205\n\u2205\n{q0 } {q0 , q1 }\n{q0 }\n{q1 }\n\u2205\n\u2205\n{q0 , q1 } {q0 } {q0 , q1 }\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\n\fExample\nThe state diagram of the machine M = (Q0 , \u03a3, \u03b4 0 , q00 , F 0 )\nequivalent to N (L(M ) = L(N )) is shown below:\n0\n\n1\n\n1\n\n{q0 }\n\n{q0 , q1 }\n\n0\n0\n\n0\n\n{q1 }\n\n\u2205\n1\n\n1\n\nWithout bottom part, it is the same as one of our previous\nexample\nIt is okay for a DFA to have unreachable states\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\n\fRegular Expression\n\nA regular expression expresses a regular language\nA regular expression can be constructed using these rules:\n1\n2\n3\n4\n\n5\n\n6\n\nIf a \u2208 \u03a3, a is a regular expression\n\u03b5 is a regular expression\n\u2205 is a regular expression\nIf R1 and R2 are regular expressions, R1 \u222a R2 is a regular\nexpression\nIf R1 and R2 are regular expressions, R1 R2 is a regular\nexpression\nIf R1 is a regular expression, R1\u2217 is a regular expression\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\n\fTool: Regular Expression to NFA\n\nConstruct an NFA from a regular expression\nBased on closure of union, concatenation, and star\n\nGiven a regular expression\n1\n\n2\n\nBreak it down into steps how to construct the regular\nexpression\nFor each step, slowly construct an NFA\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\n\fRegular Expression to NFA\nConvert the regular expression (ab \u222a a)\u2217 to an NFA.\na\n\nb\n\nab\n\nab U a\n\n(ab U a) *\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\n\fRegular Expression to NFA\nConvert the regular expression (ab \u222a a)\u2217 to an NFA.\na\na\n\nb\n\nab\n\nab U a\n\n(ab U a) *\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\n\fRegular Expression to NFA\nConvert the regular expression (ab \u222a a)\u2217 to an NFA.\na\na\nb\nb\n\nab\n\nab U a\n\n(ab U a) *\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\n\fRegular Expression to NFA\nConvert the regular expression (ab \u222a a)\u2217 to an NFA.\na\na\nb\nb\na\nab\n\nab U a\n\n(ab U a) *\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\n\fRegular Expression to NFA\nConvert the regular expression (ab \u222a a)\u2217 to an NFA.\na\na\nb\nb\na\nab\n\nab U a\n\n(ab U a) *\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\nb\n\n\fRegular Expression to NFA\nConvert the regular expression (ab \u222a a)\u2217 to an NFA.\na\na\nb\nb\na\n\n\u03b5\n\nab\n\nab U a\n\n(ab U a) *\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\nb\n\n\fRegular Expression to NFA\nConvert the regular expression (ab \u222a a)\u2217 to an NFA.\na\na\nb\nb\na\n\n\u03b5\n\nab\n\nab U a\n\n(ab U a) *\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\nb\n\n\fRegular Expression to NFA\nConvert the regular expression (ab \u222a a)\u2217 to an NFA.\na\na\nb\nb\na\n\n\u03b5\n\nb\n\na\n\n\u03b5\n\nb\n\nab\n\nab U a\n\n(ab U a) *\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\n\fRegular Expression to NFA\nConvert the regular expression (ab \u222a a)\u2217 to an NFA.\na\na\nb\nb\na\n\n\u03b5\n\nb\n\na\n\n\u03b5\n\nb\n\nab\n\nab U a\na\n\n(ab U a) *\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\n\fRegular Expression to NFA\nConvert the regular expression (ab \u222a a)\u2217 to an NFA.\na\na\nb\nb\na\n\n\u03b5\n\nb\n\na\n\n\u03b5\n\nb\n\nab\n\n\u03b5\nab U a\na\n\u03b5\n\n(ab U a) *\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\n\fRegular Expression to NFA\nConvert the regular expression (ab \u222a a)\u2217 to an NFA.\na\na\nb\nb\na\n\n\u03b5\n\nb\n\na\n\n\u03b5\n\nb\n\n\u03b5\n\nb\n\nab\n\n\u03b5\nab U a\na\n\u03b5\n\na\n\u03b5\n(ab U a) *\na\n\u03b5\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\n\fRegular Expression to NFA\nConvert the regular expression (ab \u222a a)\u2217 to an NFA.\na\na\nb\nb\na\n\n\u03b5\n\nb\n\na\n\n\u03b5\n\nb\n\n\u03b5\n\nb\n\nab\n\n\u03b5\nab U a\na\n\u03b5\n\na\n\u03b5\n(ab U a) *\n\n\u03b5\na\n\u03b5\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\n\fRegular Expression to NFA\nConvert the regular expression (ab \u222a a)\u2217 to an NFA.\na\na\nb\nb\na\n\n\u03b5\n\nb\n\na\n\n\u03b5\n\nb\n\nab\n\n\u03b5\nab U a\na\n\u03b5\n\u03b5\n\na\n\n\u03b5\n\n\u03b5\n(ab U a) *\n\n\u03b5\na\n\u03b5\n\n\u03b5\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\nb\n\n\fRegular Language\n\nEvery regular language can be expressed by a regular\nexpression\nConvert from an DFA to a regular expression\n1\n\nConvert a given n-state DFA to n + 2 states (GNFA)\nAdd a new start state s with \u03b5 transition\nAdd a new accept state a with \u03b5 transitions\nConvert all transition function from symbol to regular\nexpression\n\n2\n\n3\n\nGet rid of original states of DFA without changing its language\nuntil we only have two states\nThe label from s to a is a regular expression that expresses the\nlanguage of a given DFA\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\n\fExample\nDFA\n1\n\na\n\nb\n\n2\n\na, b\n\n{w | w contains at least one b}\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\n\fExample\nDFA to GNFA\n\u03b5\n1\n\na\n\ns\n\n1\n\nb\n\na\n\nb\n\u03b5\n\n2\n\na, b\n\na\n\n2\n\n{w | w contains at least one b}\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\naUb\n\n\fExample\nGet rid of state 2\n\u03b5\n1\n\ns\n\na\n\n1\n\na\n\nb\n\nb\n\u03b5\n2\n\na, b\n\na\n\n2\n\n\u03b5\ns\n\n1\n\na\n\nb(a U b)*\na\n\n{w | w contains at least one b}\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\naUb\n\n\fExample\nGet rid of state 1\n\u03b5\n1\n\ns\n\na\n\n1\n\nb\n\na\n\nb\n\u03b5\na, b\n\n2\n\na\n\n2\n\n\u03b5\ns\n\n1\n\na\n\ns\n\na*b(a U b)*\n\nb(a U b)*\na\n\na\n\n{w | w contains at least one b}\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\naUb\n\n\fPumping Lemma\n\nThe Pumping Lemma is based on a property of a regular\nlanguage:\nIf A is regular, for a string s \u2208 A of length at least P , s can\nbe divided into s = xyz satisfying the following conditions:\n1\n2\n3\n\nxy i z \u2208 A for any i \u2265 0\n|y| > 0\n|xy| \u2264 p\n\nTo use the Pumping lemma to prove that a language is not\nregular, we use prove by contradiction\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\n\fShow that A = {ai bj | i = j or 2i = j}\nAssume that A is regular. Since A is regular, the Pumping lemma says that for any\nstring s \u2208 A of length at least p, s can be divided into s = xyz satisfying the following\nconditions:\n1\n\nxy i z \u2208 D for any i \u2265 0\n\n2\n\n|y| > 0\n\n3\n\n|xy| \u2264 p\n\nLet s = ap b2p . In this case, i = p and j = 2p. Since 2i = j, s \u2208 A. Since s starts\nwith p as, to satisfy the third condition, x and y are strings that contain nothing but\nas. In other words, x = aq for any q \u2265 0, and y = ar for any r > 0. Note that r must\nbe greater than 0 because |y| = |ak | = r, and the condition 2 says that |y| > 0. Since\nx = aq and y = ar , z = ap\u2212(q+r) b2p . Let i = 0. We have\nxy i z = xy 0 z = xz\n= aq ap\u2212(q+r) b2p\n= ap\u2212r b2p\nFor the string ap\u2212r b2p , i = p \u2212 r and j = 2p. Thus, for this string to be in A, p \u2212 r\nmust be equal to 2p or 2(p \u2212 r) must be equal to 2p. For p \u2212 r to be equal to 2p, r\nmust be equal to \u2212p. For 2(p \u2212 r) to be equal to 2p, r must be 0. But r must be\ngreater than 0. Thus, ap\u2212r b2p 6\u2208 A \u2014 contradiction. Therefore, A is not regular.\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\n\fNote\nLet \u03a3 = {0, 1} and consider the following language:\nB = {ww | w \u2208 \u03a3\u2217 }\nSuppose you pick the string s to be 0p 0p\nThis string does not lead to a contradiction\nWe get the usual x, y, and z\nx = 0j for j \u2265 0\ny = 0k for k > 0\nz = 0p\u2212(j+k) 0p\n\nxy i z = 0j (0k )i 0p\u2212(j+k) 0p = 02p+k(i\u22121)\nFor any i, you can always find k > 0 such that\n2p + k(i \u2212 1) = 2x for some positive integer x\nThis allows us to split 02p+k(i\u22121) to 0x 0x which is in the\nlanguage B\n\nYou need to pick another s\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nExam 1 Review (Chapter 1)\n\n\f", "label": [[148, 178, "Concept"], [180, 183, "Concept"], [186, 199, "Concept"], [205, 208, "Concept"], [209, 226, "Concept"], [232, 235, "Concept"], [830, 860, "Concept"], [862, 865, "Concept"], [918, 935, "Concept"], [982, 990, "Concept"], [994, 1001, "Concept"], [1042, 1051, "Concept"], [1131, 1149, "Concept"], [1308, 1324, "Concept"], [1341, 1346, "Concept"], [1348, 1361, "Concept"], [1367, 1371, "Concept"], [1393, 1410, "Concept"], [2330, 2363, "Concept"], [2365, 2368, "Concept"], [2684, 2740, "Concept"], [2743, 2776, "Concept"], [3504, 3505, "Concept"], [3733, 3766, "Concept"], [3785, 3815, "Concept"], [5674, 5692, "Concept"], [5705, 5721, "Concept"], [10445, 10458, "Concept"], [10464, 10477, "Concept"]], "Comments": []}