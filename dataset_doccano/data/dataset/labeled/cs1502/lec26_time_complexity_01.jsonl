{"id": 15, "segment": ["test_set", "labeled"], "course": "cs1502", "lec": "lec26_time_complexity_01", "text": "Time Complexity 01\nThumrongsak Kosiyatrakul\ntkosiyat@cs.pitt.edu\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 01\n\n\fMeasuring Complexity\nA solvable problem takes time to solve\nSome problems may take too long to solve\n\nWe are going to measure the time to solve a problem by an\nalgorithm\nAn algorithm will be represented by a TM\nCount the maximum number of steps to process an input of\nlength n until it halts\n\nLet M be a deterministic Turing machine that halts on all\ninputs\nThe running time or time complexity of M is the function\nf : N \u2192 N, where f (n) is the maximum number of steps that\nM uses on any input of length n\nIf f (n) is the running time of M , M runs in time f (n)\nM is an f (n) time Turing machine\n\nCustomarily we use n to represent the length of the input\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 01\n\n\fBig-O and Small-o Notations\n\nGiven a TM M , its running time f (n) may look like the\nfollowing:\nf (n) = 3n3 + 20n2 + 15n + 12\nTo eliminate the complexity of a running time of a Turing\nmachine, we estimate it\nThis is called asymptotic analysis\nConsider only when the Turing machine runs on large input\nConsider only the highest order term\nDiscard the coefficient\n\nWe generally use Big-O and Small-o notations\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 01\n\n\fBig-O Definition\n\nLet f and g be functions f, g : N \u2192 R+\nWe say that f (n) = O(g(n)) or f (n) is O(g(n)) if positive\nintegers c and n0 exist such that for every integer n \u2265 n0 ,\nf (n) \u2264 cg(n)\nWhen f (n) = O(g(n)):\ng(n) is an upper bound for f (n), or\nMore precisely, g(n) is an asymptotic upper bound for f (n)\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 01\n\n\fBig-O Examples\nShow that f (n) = 6n3 + 2n2 + 20n + 45 is O(n3 )\nNeed to find c and n0 such that f (n) \u2264 cn3 for n \u2265 n0\nWe know the following:\n2n2 \u2264 2n3 for n \u2265 1\n20n \u2264 20n3 for n \u2265 1\n45 \u2264 45n3 for n \u2265 1\n\nThus, we have\nf (n) = 6n3 + 2n2 + 20n + 45 \u2264 6n3 + 2n3 + 20n3 + 45n3\n= (6 + 2 + 20 + 45)n3\n= 73n3 for n \u2265 1\nIn other words,\nf (n) \u2264 73n3\n\nfor n \u2265 1\n\nFrom the above equation, what are c and n0 ?\nc = 73\nn0 = 1\n\nThus, 6n3 + 2n2 + 20 + 45 is O(n3 )\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 01\n\n\fBig-O Examples\nShow that f (n) = 2n log2 n + 20n + 10 is O(n log2 n)\nNeed to find c and n0 such that f (n) \u2264 c(n log2 n) for n \u2265 n0\nWe know the following:\n20n \u2264 20n log2 n for n \u2265 1\n10 \u2264 10n log2 n for n \u2265 1\n\nThus, we have\nf (n) = 2n log2 n + 20n + 10 \u2264 2n log2 n + 20n log2 n + 10n log2 n\n= (2 + 20 + 10)n log2 n\n= 32n log2 n for n \u2265 1\nIn other words,\nf (n) \u2264 32n log2 n for n \u2265 1\nFrom the above equation, what are c and n0 ?\nc = 32\nn0 = 1\n\nThus, 2n log2 n + 20n + 10 is O(n log2 n)\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 01\n\n\fBig-O Examples\n\nUpper bounds of the form nc where c > 0 is called\npolynomial bounds\nO(n2 )\nO(n10 )\nO(n log2 n) (bounded by O(n2 ))\n\u03b4\n\nUpper bounds of the form 2(n ) is called exponential bounds\nO(2n )\nO(3n )\n3n = (2log2 3 )n = 2log2 3\u00d7n and log2 3 is a constant\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 01\n\n\fSmall-o Notation\nDefinition 7.5\nLet f and g be functions f, g : N \u2192 R+ . Say that f (n) = o(g(n))\nif\nf (n)\n= 0.\nn\u2192\u221e g(n)\nlim\n\nIn other words, f (n) = o(g(n)) means that for any real number\nc > 0, a number n0 exists, where f (n) < cg(n) for all n \u2265 n0 .\nSimply strictly less than\n\u221a\n\nn = o(n)\nn = o(n log(log n))\nn log(log n) = o(n log n)\nn log n = o(n2 )\nn2 = o(n3 )\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 01\n\n\fAnalyzing Algorithms\nConsider a Turing machine M1 that decides\nA = {0k 1k | k \u2265 0}\nM1 = \u201cOn input string w:\n1\n\n2\n3\n4\n\nScan across the tape and reject if a 0 is found to the right of a\n1.\nRepeat if both 0s and 1s remain on the tape:\nScan across the tape, crossing off a single 0 and a single 1.\nIf 0s still remain after all the 1s have been crossed off, or if 1s\nstill remain after all the 0s have been crossed off, reject.\nOtherwise, if neither 0s nor 1s remain on the tape, accept.\u201d\n\nFind f (n), the maximum number of steps for M1 to process a\nstring w of length n\nThere are multiple input strings of length n\nThe number of steps of an input of length n depends on the\ninput pattern\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 01\n\n\fAnalyzing Algorithm\nConsider all possible inputs of length 4:\nInput\n0000\n0001\n0010\n0011\n0100\n0101\n0110\n0111\n1000\n1001\n1010\n1011\n1100\n1101\n1110\n1111\n\nStep that M1 halts\n4 (0 iterations)\n4 (1 iterations)\n1\n4 (2 iterations)\n1\n1\n1\n4 (1 iterations)\n1\n1\n1\n1\n1\n1\n1\n4 (0 iterations)\n\nThe maximum number of steps on an input of length n occurs\nwhen w = 0k 1k where k = n2\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 01\n\n\fAnalyzing Algorithms\n1\n\nScan across the tape and reject if a 0 is found to the right of\na1\nThis step requires TM M1 to move its tape head all the way\nto the right until it encounters a blank symbol and move its\ntape head all the way to the left-most square\nThis step requires either n or 2n steps\nIn other words, this step is O(n)\n\n2\n3\n\nRepeat if both 0s and 1s remain on the tape:\nScan across the tape, crossing off a single 0 and a single 1.\nStep 3 requires n steps or O(n)\nCross the first 0, move the tape head n/2 step to the first 1,\ncross it off and move the tape head n/2 step to position on\ntop of the first of the remaining 0s\n\nThere will be n/2 0s and n/2 1s\nThe step 3 is repeated n/2 times\n\nSteps 2 and 3 together is n/2 \u00d7 O(n) or O(n2 ).\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 01\n\n\fAnalyzing Algorithms\n\n4\n\nIf 0s still remain after all the 1s have been crossed off, or if 1s\nstill remain after all the 0s have been crossed off, reject.\nOtherwise, if neither 0s nor 1s remain on the tape, accept.\nSimply scan the whole tape looking for a 0 or a 1\nThis step can be done in n step\nThis step is O(n)\n\nThe running time of M1 is\nO(n) + O(n2 ) + O(n) = O(n2 + 2n) = O(n2 )\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 01\n\n\fTime Complexity Class\nDefinition 7.7\nLet t : N \u2192 R+ be a function. Define the time complexity class,\nTIME(t(n)), to be the collection of all languages that are\ndecidable by an O(t(n)) time Turing machine.\nFrom the previous language A = {0k 1k | k \u2265 0} with TM M1\nA \u2208 TIME(n2 )\nCan we construct a TM M2 such that f (n) = o(n2 )?\nAsymptotically better than O(n2 )\n\nWhat if we cross off two 0s and two 1s in step 3?\nPractically faster but not asymptotically better\nStep 3 will be repeated n/4 times but n/4 \u00d7 O(n) = O(n2 )\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 01\n\n\fAsymptotically Faster for Deciding A\n\nConsider TM M2 that decides A = {0k 1k | k \u2265 0}:\nM2 = \u201cOn input string w:\n1\n\n2\n3\n\n4\n\n5\n\nScan across the tape and reject if a 0 is found to the right of a\n1.\nRepeat as long as some 0s and some 1s remain on the tape.\nScan across the tape, checking whether the total number of\n0s and 1s remaining is even or odd. If it is odd, reject.\nScan again across the tape, crossing off every other 0\nstarting with the first 0, and then crossing off every\nother 1 starting with the first 1.\nIf no 0s and no 1s remain on the tape, accept. Otherwise,\nreject.\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 01\n\n\fAsymptotically Faster for Deciding A\nStep 1 and 5 are O(n) as in M1\nStep 3, to scan and check whether the number of 0s and 1s\nare even or odd is O(n)\nIn step 4, to cross off every other 0s and 1s is O(n)\nEvery time this step is executed, the number of 0s and 1s are\ncut in half\nIf there are n/2 0s and n/2 1s, step 4 needs to be repeated\n1 + log2 (n/2) times\nFor example (n = 16), 8 \u2192 4 \u2192 2 \u2192 1 \u2192 0 (cut in half 4\ntimes) for input 08 18\n\nSteps 2, 3 and 4 all together is\n(1 + log2 (n/2)) \u00d7 (O(n) + O(n)) = O(n log n)\nThus, TM M2 run-time is\nO(n) + O(n log n) + O(n) = O(n log n)\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 01\n\n\fDeciding A in Linear Time\nThe language A can be decided in O(n)\nBut we need the second tape\n\nTwo-tape TM M3 decides A in O(n)\nM3 =\u201cOn input string w:\n1\n2\n\n3\n\n4\n\nScan across tape 1 and reject if a 0 is found to the right of a 1.\nScan across the 0s on tape 1 until the first 1. At the same\ntime, copy the 0s onto tape 2.\nScan across the 1s on tape 1 until the end of the input. For\neach 1 read on tape 1, cross off a 0 on tape 2. If all 0s are\ncrossed off before all the 1s are read, reject.\nIf all the 0s have now been crossed off, accept. If any 0s\nremain, reject.\u201d\n\nRun-time of each step is O(n)\nTM M3 runs in O(n)\n\nThe run-time complexity of the language A depends on the\nmodel of computation\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 01\n\n\fComplexity Relationships Among Models\nTheorem 7.8\nLet t(n) be a function where t(n) \u2265 n. Then every t(n) time\nmultitape Turing machine has an equivalent O(t2 (n)) time\nsingle-tape Turing machine.\nSuppose we have a language A that can be decided by a\nmultitape Turing machine M in t(n) steps where n is the\nlength of an input string\nThe above theorem says that there exists a single-tape TM\nthat can decide A in O(t2 (n))\nt2 (n) = t(n) \u00d7 t(n)\n\nTo prove the above theorem, we simply need to construct a\nsingle tape TM that decides A in O(t2 (n))\nBut what is the language A?\nSince we do not know what the language, let\u2019s try to simply\nsimulate multitape TM using single-tape TM\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 01\n\n\fComplexity Relationships Among Models\nRecall that a multitape TM is a k-tape TM where its input\nappears on tape 1\n0\n\n1\n\n0\n\na\n\na\n\na\n\nb\n\na\n\n1\n\n0\n\nM\n\nWe can simulate multitape TM using a single-tape TM as\nshown below:\nS\n#\n\n0\n\n1\n\n0\n\n1\n\n0\n\n#\n\na\n\na\n\na\n\n#\n\nb\n\na\n\n#\n\nIf TM M halts in t(n) steps, how many step does TM S\nneeds in terms of O?\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 01\n\n\fProof of Theorem 7.8\nLet M be a k-tape TM for some k \u2265 2 that runs in t(n) on\ninput string of length n\nWe are going to construct a single-tape TM S that simulate\nmultitape TM M\nThe first step is for S to copy contents of all M \u2019s k tapes into\nits tape\nNote that contents of all M \u2019s k tapes are fixed except the first\none (input tape)\nSuppose the length of strings on tape 2 to tape k be a\nconstant c and the length of input string is n\nIt requires S to perform c + n + (k + 1) steps to copy\nThe k + 1 steps are from writing # symbols\n\nSince c and k are constant, this step is O(n)\n\nThe next step is to simulate M \u2019s steps\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 01\n\n\fProof of Theorem 7.8\n\nFor each step of M , first S needs to know symbols under M \u2019s\ntape heads\nS needs to scan and remember all k-dot symbols\nSince M performs t(n) steps, the maximum length of an\nactive portion of each tape is t(n)\nIf the length of the content of a tape is t(n) + 1, it requires\nTM M t(n) step to reach the last symbol\nBy the time it gets to the last symbol, TM M halts\n\nS needs k \u00d7 t(n) steps to scan for all k-dot symbols\nScanning for all dot symbols is O(t(n))\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 01\n\n\fProof of Theorem 7.8\nNext S needs to update all k-dot symbol\nSometime, M may move a tape head to the right over a blank\nsymbol\nBut for TM S, it will be on the # symbol\nIn this case, S needs to shift a portion of its own tape one cell\nto the right\nIf it is M \u2019s first tape head, it requires to shift the content of\nk \u2212 1 tapes\nRequire (k \u2212 1) \u00d7 t(n) steps for S to shift\nwhere t(n) is the maximum length of an active portion of\neach tape\nIf it is M \u2019s second tape head, it requires to shift the content\nof k \u2212 2 tapes\nRequire (k \u2212 2) \u00d7 t(n) steps for S to shift\nIf all need to be shifted, it requires k(k\u22121)\n\u00d7 t(n) steps\n2\n\nThis step is O(t(n)) since k(k\u22121)\nis a constant\n2\n\nTo simulate one step of M , it is\nscan for dots + update dots = O(t(n)) + O(t(n)) = O(t(n))\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 01\n\n\fProof of Theorem 7.8\nNote that M performs t(n) steps\nThus, for S to simulate M for t(n) steps, it needs to perform\nat most\nt(n) \u00d7 O(t(n)) = O(t2 (n))\nTherefore, the total run-time is\nO(n) + O(t2 (n)) = O(t2 (n))\nwhere\nO(n) steps to copying M \u2019s tape contents, and\nO(t2 (n)) steps to simulate M \u2019s t(n) steps\n\nIf a multitape TM M decides a language A in t(n) steps, we\ncan simulate TM M using a single tape TM S which can\ndecide A in O(t2 (n))\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 01\n\n\fNondeterministic Turing Machine\nDefinition 7.9\nLet N be a nondeterministic Turing machine that is a decider. The\nrunning time of N is the function f : N \u2192 N, where f (n) is the\nmaximum number of steps that N uses on any branch of its\ncomputation on any input of length n.\nDeterministic\n\nNondeterministic\n\nreject\n\nf (n)\n\nf (n)\n\naccept\n\naccept/reject\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nreject\n\nTime Complexity 01\n\n\fNondeterministic Turing Machine\nTheorem 7.11\nLet t(n) be a function, where t(n) \u2265 n. Then every t(n) time\nnondeterministic single-tape Turing machine has an equivalent\n2O(t(n)) time deterministic single-tape Turing machine.\nRecall the nondeterministic Turing machine\nThe computation is a tree\nThe machine accepts as soon as one of its branch enter the\naccept state\nThe machine rejects if all of its branch are in the reject state\n\nSince we have to consider the maximum number of steps on\nany branch, we have to consider the longest number of steps\nfor the machine to accept or reject an input string of length n\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 01\n\n\fComputation Tree\nThe following is an example of a computation tree of a\nnondeterministic Turing machine where at each state, it can\nsplit to at most two machines.\n\nThis can be applied to NTM that splits to at most k copies\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 01\n\n\fComputation Tree\nWe can not simulate one branch at a time\nThe computation of each branch may not end (enter infinite\nloop)\nNo chance to simulate the next branch\nBut NTM may accept the input string because another branch\nenters the accept state\n\nWe need to simulate like breadth first search\n\n1\n\n2\n\n3\n\n4\n\n7\n\n15\n\n8\n\n16\n\n17\n\n5\n\n9\n\n18\n\n19\n\n10\n\n20\n\n21\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\n6\n\n11\n\n22\n\n23\n\n12\n\n24\n\n25\n\nTime Complexity 01\n\n13\n\n26\n\n27\n\n14\n\n28\n\n29\n\n30\n\n\fComputation Tree\n\nRecall that this NTM runs in t(n) steps\nThe height of its computational tree will be t(n)\nThe number of steps to reach is node is at most t(n)\n\nThe number of nodes in a full binary tree of height h is 2h \u2212 1\nSince the height of its computational tree is t(n), the number\nof nodes is 2t(n) \u2212 1\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 01\n\n\fComputational Tree\n\nThus, the total run-time is\nt(n) \u00d7 2t(n) = 2O(t(n))\nThis is the run-time of multitape Turing machine\nFor a single tape TM, the run-time is the square of multitape\nTM\nThus, the run-time is\n(2O(t(n)) )2 = 22O(t(n)) = 2O(2t(n)) = 2O(t(n))\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 01\n\n\f", "label": [[113, 128, "Concept"], [144, 154, "Concept"], [157, 165, "Concept"], [496, 508, "Concept"], [512, 527, "Concept"], [859, 864, "Concept"], [869, 876, "Concept"], [907, 919, "Concept"], [1002, 1012, "Concept"], [1082, 1101, "Concept"], [1561, 1572, "Concept"], [1614, 1636, "Concept"], [2851, 2868, "Concept"], [2960, 2978, "Concept"], [9449, 9458, "Concept"], [12499, 12511, "Concept"]], "Comments": []}