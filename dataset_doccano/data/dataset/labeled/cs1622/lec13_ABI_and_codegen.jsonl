{"id": 108, "segment": ["train_set", "labeled"], "course": "cs1622", "lec": "lec13_ABI_and_codegen", "text": "ABI and Codegen\nCS 1622\nJarrett Billingsley\n\n\fClass Announcements\n\u25cf how's the project?\n\u25cf project 2 grades will be posted today!\n\n2\n\n\fApplication\nBinary Interfaces (ABIs)\n\n3\n\n\fLike API, but with a B instead of a P\n\u25cf the backend converts the concept of \"a program\" into something the\nCPU can actually execute \u2013 machine code.\n\u25cf an Application Binary Interface is a set of rules that sets the\nstandards for how machine code programs look and work.\no so, the ABI will guide how we actually generate the code.\nto make things more interesting,\n\"the\" ABI is probably composed\nof multiple layers of rules.\n\nthings can get very interesting at the\nboundaries between these layers\u2026\n\nLanguage ABI\nOS ABI\nArchitectural ABI\n\n4\n\n\fThe lowest layer: the Architectural ABI\n\u25cf the designers of an ISA may define an ABI to go with it.\no as the designers, they may have included special features for e.g.\nmaking function calls faster if you use those features as intended.\n\u25cf these may be bare-bones, including rules on how to do function\ncalls and object file formats, and not much else.\nthese are widely used on embedded\ndevices where there is no OS \u2013 your\nprogram runs \"on the bare metal.\"\n\n5\n\n\fBut Operating Systems have opinions\n\u25cf the goal of an operating system is to control access to your\ncomputer's resources and make the programs share them.\n\u25cf so, the designers of OSes will define their own ABI which are much\nmore extensive, including rules for:\no how function calls work\n\u25aa this may be built on the architectural ABI, or it may be unique!\no how system calls work, to ask the OS to do things for you\no how asynchronous messages are delivered to running programs\no how executables and shared libraries are packaged\no how memory is laid out and where parts of your program exist\n\u25cf these are the kinds of ABIs most compilers are generating code for,\nmost of the time.\n\n6\n\n\fThe highest layer: your language's own ABI\n\u25cf HLLs can have features which are not accounted for by either the\narchitectural or OS ABIs, so they have to make their own rules.\n\u25cf this might include features like:\nexceptions!\n\ndynamic method dispatch!\n\ntry {\n...throw...\n} catch(...) {\n...\n} finally {\n...\n}\n\nString s = obj.toString();\n\nfunction closures!\nauto f = [&]() {\ncout << \"wheee!\\n\";\n};\n\nhowever, if you're not careful defining your language, different\ncompilers for the same language can use different ABIs\u2026\n7\n\n\fWhen ABIs collide\n\u25cf let's say a language has no standardized ABI for method calls.\n\u25cf then, different compilers may have their own incompatible ways of\ngenerating code for method calls, leading to really nasty situations.\nthis program was compiled\nwith Compiler A.\n\nyou wrote a plugin in the same\nlanguage, but you used Compiler B.\n\nProgram\n\nPlugin\n\nplugin.getName()\n\nthe program tries to call a method in\nyour plugin, and\u2026 what happens?\n\nwho knows? it might silently fail, it might crash immediately, it\nmight corrupt the stack or heap in more subtle ways, etc.\n8\n\n\fBreak the rules, get a broken program.\n\u25cf if two pieces of code use different ABIs\u2026\n\u25cf or if your compiler generates code that doesn't follow the ABI\u2026\n\u25cf you lose all the nice abstraction guarantees of the HLL.\n\u25cf think back to when you were writing MIPS in 447.\no do you really want to deal with those kinds of bugs again?\n\u25cf C \u2013 or rather its ABI \u2013 has remained popular for decades. why?\no because it's super simple, meaning just about every OS and\ncompiler can follow it without much difficulty.\no with it, you can hook pieces of machine code together reliably.\n\u25cf but, its simplicity means it doesn't support advanced features\u2026\no so it's up to you, as the language designer or compiler writer, to\ndecide how those features are implemented.\n\u25cf so! what goes into an ABI, anyway?\n9\n\n\fParts of an ABI\n\n10\n\n\fThe call stack\n\u25cf any ISA from the last 50 years or so will have provisions for a stack.\nStack\n16\n\n0\n48580372\n0\n0\n5\n\nit'll have, at the very least, a register that points to\nthe top of the stack\u2026 a stack pointer, if you will.\n(well, maybe it has two registers. we'll get to that.)\n\nsp it might have special instructions for pushing and\npopping things to this stack, or it might not.\npush eax\n\npop ecx\n\ncall func\n\nret\n\nthe ABI defines things like: the direction the stack\ngrows; the size of each item on the stack; stack\nalignment (if the stack pointer must move in\nmultiples of some number); and so on.\n11\n\n\fYou can't stack things up forever\u2026\n\u25cf statistically, most programs never need more than a few megabytes\nof stack space, and most use far, far less than that.\n\u25cf since the OS makes all the programs share resources, it may only\nallocate something like 4-16 MB of memory for your program.\no this is allocated before your program starts; you don't have to do\nanything to get it.\n\u25cf and what happens if you push more than that on the stack?\no stack overflow! yay!\n\u25cf so, however we implement our language's ABI, it will have to work\nwithin this limit.\n\n12\n\n\fThe calling convention\n\u25cf this is the set of rules used to call and return from functions.\n\u25cf it defines things like:\nhow arguments are passed;\n\nhow the return\naddress is calculated\nand where it's stored;\n\nfn add(x: int, y: int): int {\nlet sum = x + y;\nprintln_i(sum);\nreturn sum;\n}\nhow values are returned;\n\nwhich CPU registers must be saved,\nand which can be used freely.\n\nra\n\nv0\n\ns0\nt0\n\na0\n\nf0\n\nfp\n13\n\n\fBorder conflicts\n\u25cf within your language, you can use any calling convention you like.\no as long as every function uses the same rules, it will work fine.\n\u25cf it's at the boundaries where things get tricky.\nYour Language\n\nmain\n\ninit\n\nOS API\n\nprompt\n\nread\n\nprintln\n\nwrite\n\nfunctions from outside your\nlanguage may use a different\nABI, so your code generator\nmust be very careful about it.\nit has to know what ABI each\nfunction uses, so it can use the\nright rules when calling them.\nor, we could punt it\u2026\n14\n\n\fIf it hurts, don't do it\n\u25cf you could make it so you can't directly call functions from other\nlanguages/which use different ABIs.\n\u25cf Java does this.\no public static native int someExternalFunction();\no this function is not written in Java.\no instead, it's probably written in C++, and compiled into a plugin.\no that plugin is then loaded into the JVM when your program runs.\n\u25cf this provides a controlled boundary between \"the safe Java world\"\nand \"the scary non-Java world,\" and lets Java programs call functions\nthey would normally be unable to.\n\u25cf systems programming languages will give you a way to deal with\ncalling conventions yourself.\no but Java isn't a systems language, and there's no shame in saying\n\"hey, it's not my language's responsibility!\"\n15\n\n\fAnother kind of call, another calling convention\n\u25cf system calls are how your program asks the OS to do things on the\nprogram's behalf: I/O, resource management, even exiting\u2026\no without syscalls, about all a program can do is make the CPU hot.\n\u25cf the ISA defines the system call (syscall) mechanism\u2026\no which usually requires using a special instruction. (like syscall.)\no the OS will also define how values are passed into/out of them.\n\u25cf essentially this is just another calling convention, meaning we will\nrun into the same issues as before.\no if a language cannot use syscalls directly, it will have to rely on\ncode written in some other language to do so.\n\u25cf it feels like this interface between our language and the OS is\ngoing to have to be somewhat\u2026 substantial. so let's talk about it.\n\n16\n\n\fStandard and\nRuntime Libraries\n\n17\n\n\fstd::\n\u25cf you kind of take the standard library (stdlib) for granted.\no there are these functions and classes that are just\u2026 there!\no System.out.println() and ArrayList and Vec and so on.\no but someone had to write them. and if you're making your own\nlanguage, that \"someone\" is going to be you.\n\u25cf standard libraries are out of the scope of this course, but\u2026\no the standard library is going to have to make calls to OS APIs to do\nthings like input and output, somehow.\n\u25cf and all code in your language will rely on some special hidden code\nto work properly at runtime.\no and the compiler will be relying on that code as well!\n\n18\n\n\fcore::\n\u25cf there are likely many operations in your HLL that don't map neatly\nonto a few instructions in the target ISA.\nis there a MIPS instruction\nfor string concatenation?\n\nhow about for allocating\nobjects on the heap?\n\n\"hi\" + \"bye\"\n\nnew Cat()\n\nchecking array bounds?\n\nthrowing exceptions?\n\nA[1000000000]\n\nthrow new OhMyGodWhyAreAllTheExcept\nionNamesSoLongException();\n\nthere are a lot of hidden operations going on in each of these\ncases, and it is the runtime library which implements them.\n19\n\n\fThe language runtime\n\u25cf a language's runtime library implements the features which would\nbe difficult or impossible to codegen directly.\n\u25cf unlike the standard library, this is tied more closely to the compiler\nand how the compiler has decided to implement those features.\no so, different compilers \u2013 and even different versions of the same\ncompiler \u2013 can have different runtime libraries.\no ever install the many versions of Visual C++ Redistributable?\n\u25aa thaaaaat's what it iiiiiiiis\n\u25cf the runtime may be written in a different language (like C or C++)\nfrom the source language that the compiler compiles.\no in our case, Truss's tiny runtime library is written in MIPS. (so is its\n\"standard library\" of a few print functions, lol.)\n\n20\n\n\fThe compiler's job\n\u25cf during codegen, the compiler is essentially going to turn some\npieces of code into function calls into the runtime library.\n\u25cf if we take string concatenation as an example:\nsource code: let msg = \"hello, \" + name;\ncodegen treats it as: let msg = rt$concat(\"hello, \", name);\ngets generated as: addi sp, sp, -8\nla\nsw\nlw\nsw\njal\nsw\n\nt0, STRLIT$3\nt0, 0(sp)\nt0, 0(fp)\nt0, 4(sp)\nrt$concat\nv0, -20(fp)\n\nfp? what's that??\n21\n\n\fTruss's MIPS ABI\n\n22\n\n\fKind of standard, kind of not\n\u25cf Truss\u2019s MIPS ABI is based on the standard MIPS ABI, but is more\nlimited in some ways in order to make the codegen simpler.\n\u25cf we\u2019re generating code for a slightly weird target, MARS, which:\no has no operating system\no has no executable format, only textual assembly as input\n\u25cf those aspects will also simplify our job!\n\u25cf a large part of the ABI is the calling convention, but first, we have to\nspecify\u2026\n\n23\n\n\fMemory regions\n\u25cf there are three regions of memory.\nlet g1 = 10;\nlet g2 = \"world\";\n\nthe .data segment holds the global\nvariables and any string literals.\n\nfn main() {\nprintln_i(g1);\nthe heap holds dynamically\nallocated strings and structs\nlet msg = \"hi, \" + g2;\n(like new Cat()).\nprintln_s(msg);\n}\nthe heap could be managed with\nthe stack holds the\na tracing garbage collector, if this\nlocal variables.\nwere a real language. but our\nimplementation won't.\n24\n\n\fHow global variables are generated\n\u25cf int and bool globals become .word and .byte variables, respectively.\nlet ivar = 10;\nlet bvar = true;\n\nstrings are more subtle\u2026\n\nlet svar = \"hi\";\n\n.data\nivar: .word 10\nbvar: .byte 1\n\n.data\nSTRLIT$0: .asciiz \"hi\"\nsvar: .word STRLIT$0\n\nbools are represented with\n1 for true and 0 for false.\n\nevery string literal in the program\ngets a uniquely-named STRLIT label;\nstring variables just point to strings.\n25\n\n\fRuntime data representation\n\u25cf to be thorough we have to define how every type in the language is\nrepresented at runtime. fortunately, Truss doesn\u2019t have many!\no we already saw int and bool on the previous slide.\n\u25cf strings, function pointers, and struct references are all reference\ntypes, meaning they are represented as a pointer, which is a word.\n\u25cf the data of a string is defined as zero-terminated ASCII, which is kind\nof a terrible string representation but is exactly what MARS wants, so.\n\u25cf the data of a struct is\u2026 well\u2026 we\u2019ll come back to structs. ;o\n\n26\n\n\fFunction calls\n\u25cf the caller has an easy time calling functions, but the protocol is a\nlittle different than you may remember from 447.\n\u25cf rather than using those a registers, all arguments are passed on the\nstack, in the same order they are written in the source.\nf(1, 2);\neach stack slot is 4 bytes, so 2\narguments requires 8 bytes.\naddi sp, sp, -8\nli\nt0, 1\nsw\nt0, 0(sp)\nli\nt0, 2\nsw\nt0, 4(sp)\njal f\n\nrecall this means 0 + sp.\nthe second argument is at 4 + sp;\nthe third at 8 + sp etc.\n27\n\n\fAfter the call completes\u2026\n\u25cf return values come out in v0, like you learned before.\n\u25cf assuming glob is a global variable\u2026\nglob = f(1);\n\naddi sp, sp, -4\nli\nt0, 1\nsw\nt0, 0(sp)\njal f\nsw\nv0, glob\n\nnotice: the caller changes sp before calling,\nbut it does not change it after. we say the\ncallee \"cleans the stack\" (as we'll see shortly)\n\nimportant: there is a line here. below this line,\nthe contents of the a, t, and v registers may\nbe different than they were before the jal.\n\nhowever, the contents of the s registers are\nguaranteed to be the same as before the jal.\n\n28\n\n\fStack Frames\n\u25cf every function in the program needs a stack frame: a way of storing\nall the arguments, variables, and saved registers on the stack.\n\u25cf let's look at a super simple function's stack frame first.\nfn simple(x: int) {\nprintln_i(x);\n}\nx\nra\n\nthere's the argument. it was pushed by the caller.\nwe're going to push ra, the return address register,\nso we won't lose our way back to the caller when\nwe call println_i.\nwhat about when we have local variables?\n29\n\n\fLocal variables\n\u25cf after pushing ra, we will then make space for the locals.\nfn more_complex(x: int) {\nx\nlet y = x + 10;\nra\nfor i in 0, y {\nprintln_i(i);\ni\n}\ny\n}\nevery local variable gets its own stack slot.\n\n12(sp)\n\n4(sp)\n0(sp)\n\nsince the stack pointer is pointing at the lowest slot, we\ncan access the locals and arguments with offsets from it.\nbut that's going to make things difficult for us\nwhen we want to actually call println_i\u2026\n30\n\n\fShifting sands (animated)\n\u25cf let's say we're generating code for println_i(i).\nfn more_complex(x: int) {\nlet y = x + 10;\nfor i in 0, y {\nprintln_i(i);\n}\n}\nx\n\n12(sp)\n16(sp)\n\nra\ni\n\n4(sp)\n8(sp)\n\ny\n\n0(sp)\n4(sp)\n\n__\n\n0(sp)\n\nthe first thing we do is make\nroom for the argument.\naddi sp, sp, -4\nbut what does that do to\nthe offsets from sp??\n\nit's absolutely possible to keep track of\nthe \"virtual sp\" and adjust the offsets\naccordingly. but I don't waaaaanna\nwhat if we had a second stack pointer,\none that didn't move around?\n31\n\n\fThe Frame Pointer register\n\u25cf MIPS has a second register for just this purpose, called fp.\n\u25cf this will point sort of weirdly into the middle of the stack frame,\ngiving us a stationary reference point for accessing locals.\n\u25cf going back to the super simple function\u2026\nfn simple(x: int) {\nprintln_i(x);\n}\n\nx\n\nfp\n\nfp\nra\n\nsp\n\nwe're going to push both fp and ra!\nfp points at the first argument, and\nsp still points at the top of the stack.\nand what about locals?\n32\n\n\fThe local problem, solved (animated)\n\u25cf you aren't restricted to positive offsets from the stack/frame pointers!\nfn more_complex(x: int) {\nlet y = x + 10;\nfor i in 0, y {\nprintln_i(i);\n}\n}\nsp\n\nx\n\n0(fp)\n\nfp\nra\ni\n\n-12(fp)\n\ny\n\n-16(fp)\n\n__\nnow, even when sp moves around during the\nfunction, the offsets from fp never change.\n\n33\n\n\fFunction Prologue\n\u25cf the function prologue is the code that sets up the stack frame,\nessentially switching stack frames from the caller to the callee.\n\u25cf it looks like this:\nsw\nfp, -4(sp) this pushes the caller's frame pointer, so we\ncan get it back later.\nsw\n\nra, -8(sp)\n\nmove fp, sp\naddi sp, sp, -n\n\nthis pushes the callee's return address.\n\nthis sets up the callee's frame pointer, so it\npoints to the first argument (if any).\nand finally, this sets up the callee's stack\npointer, so we have room for the locals.\n\nhere, n is the number of bytes needed for all the\nlocals, plus the two saved registers from above.\n34\n\n\fFunction Epilogue\n\u25cf finally, the epilogue does the opposite: it restores the stack and\nrequired registers to the way they were when the function began.\nlw\n\nra, -8(fp)\n\nthis restores our return address.\n\nlw\n\nfp, -4(fp)\n\nthis restores the caller's frame pointer.\n\naddi sp, sp, x\n\nthis completely cleans the stack, removing\nthe locals, saved regs, and all arguments.\n\njr\n\nand this returns!\n\nra\n\n35\n\n\fWhat about the juicy middles?\n\u25cf it seems like a lot of buildup to only a handful of instructions, but\u2026\no this shit is important okay\no we have to do this right or else our program falls apart!!\n\u25cf but by setting up our stack frame neatly like this, it will make\ngenerating the code inside the functions a lot more straightforward.\no and that's what we'll talk about next time!\n\n36", "label": [[0, 3, "Concept"], [8, 15, "Concept"], [133, 162, "Concept"], [164, 168, "Concept"], [180, 183, "Concept"], [219, 226, "Concept"], [309, 321, "Concept"], [328, 356, "Concept"], [407, 419, "Concept"], [454, 457, "Concept"], [543, 546, "Concept"], [671, 683, "Concept"], [684, 690, "Concept"], [691, 708, "Concept"], [736, 753, "Concept"], [776, 779, "Concept"], [794, 797, "Concept"], [1125, 1127, "Concept"], [1178, 1195, "Concept"], [1227, 1243, "Concept"], [1351, 1355, "Concept"], [1378, 1381, "Concept"], [1440, 1454, "Concept"], [1487, 1504, "Concept"], [1533, 1545, "Concept"], [1593, 1614, "Concept"], [1655, 1666, "Concept"], [1671, 1687, "Concept"], [1707, 1713, "Concept"], [1789, 1793, "Concept"], [1799, 1808, "Concept"], [1896, 1899, "Concept"], [1902, 1906, "Concept"], [1967, 1991, "Concept"], [2067, 2077, "Concept"], [2080, 2103, "Concept"], [2315, 2324, "Concept"], [2365, 2369, "Concept"], [2380, 2384, "Concept"], [2436, 2439, "Concept"], [2444, 2456, "Concept"], [2476, 2485, "Concept"], [2613, 2621, "Concept"], [2627, 2635, "Concept"], [2694, 2702, "Concept"], [3018, 3022, "Concept"], [3037, 3045, "Concept"], [3085, 3088, "Concept"], [3144, 3147, "Concept"], [3281, 3284, "Concept"], [3380, 3382, "Concept"], [3387, 3395, "Concept"], [3616, 3624, "Concept"], [3703, 3706, "Concept"], [3732, 3735, "Concept"], [3751, 3756, "Concept"], [3763, 3766, "Concept"], [3823, 3828, "Concept"], [3830, 3835, "Concept"], [3930, 3935, "Concept"], [3939, 3952, "Concept"], [4023, 4025, "Concept"], [4065, 4072, "Concept"], [4077, 4084, "Concept"], [4100, 4105, "Concept"], [4163, 4166, "Concept"], [4206, 4211, "Concept"], [4248, 4253, "Concept"], [4255, 4260, "Concept"], [4261, 4270, "Concept"], [4359, 4364, "Concept"], [4455, 4460, "Concept"], [4775, 4780, "Concept"], [4784, 4798, "Concept"], [4847, 4850, "Concept"], [4902, 4920, "Concept"], [5018, 5027, "Concept"], [5049, 5063, "Concept"], [5359, 5377, "Concept"], [5628, 5631, "Concept"], [5641, 5655, "Concept"], [5707, 5710, "Concept"], [5930, 5934, "Concept"], [6417, 6436, "Concept"], [6596, 6614, "Concept"], [6617, 6629, "Concept"], [6751, 6759, "Concept"], [6815, 6818, "Concept"], [6831, 6842, "Concept"], [6844, 6851, "Concept"], [6924, 6931, "Concept"], [7035, 7053, "Concept"], [7134, 7142, "Concept"], [7362, 7392, "Concept"], [7428, 7444, "Concept"], [7446, 7452, "Concept"], [7695, 7713, "Concept"], [7762, 7778, "Concept"], [7975, 7983, "Concept"], [8078, 8081, "Concept"], [8142, 8145, "Concept"], [8483, 8498, "Concept"], [8540, 8547, "Concept"], [8563, 8578, "Concept"], [8645, 8652, "Concept"], [8676, 8692, "Concept"], [8727, 8735, "Concept"], [8748, 8756, "Concept"], [8814, 8823, "Concept"], [8866, 8874, "Concept"], [8896, 8913, "Concept"], [9016, 9023, "Concept"], [9113, 9121, "Concept"], [9160, 9175, "Concept"], [9208, 9224, "Concept"], [9268, 9278, "Concept"], [9292, 9299, "Concept"], [9305, 9313, "Concept"], [9368, 9382, "Concept"], [9499, 9506, "Concept"], [9703, 9710, "Concept"], [9716, 9719, "Concept"], [9758, 9765, "Concept"], [9771, 9774, "Concept"], [9805, 9808, "Concept"], [9864, 9871, "Concept"], [10098, 10101, "Concept"], [10109, 10127, "Concept"], [10166, 10180, "Concept"], [10254, 10267, "Concept"], [10278, 10294, "Concept"], [10337, 10341, "Concept"], [10352, 10356, "Concept"], [10363, 10384, "Concept"], [10467, 10471, "Concept"], [10498, 10503, "Concept"], [10517, 10542, "Concept"], [10552, 10567, "Concept"], [10630, 10646, "Concept"], [10676, 10683, "Concept"], [11069, 11096, "Concept"], [11181, 11188, "Concept"], [11203, 11208, "Concept"], [11634, 11648, "Concept"], [11655, 11661, "Concept"], [11679, 11696, "Concept"], [11812, 11821, "Concept"], [11840, 11845, "Concept"], [11911, 11916, "Concept"], [11939, 11948, "Concept"], [11972, 11974, "Concept"], [11976, 11978, "Concept"], [12001, 12003, "Concept"], [12023, 12025, "Concept"], [12071, 12079, "Concept"], [12090, 12092, "Concept"], [12152, 12165, "Concept"], [12228, 12243, "Concept"], [12264, 12266, "Concept"], [12268, 12270, "Concept"], [12293, 12295, "Concept"], [12328, 12334, "Concept"], [12353, 12360, "Concept"], [12406, 12412, "Concept"], [12414, 12430, "Concept"], [12693, 12705, "Concept"], [12746, 12757, "Concept"], [12784, 12793, "Concept"], [12795, 12804, "Concept"], [12810, 12825, "Concept"], [12833, 12838, "Concept"], [12882, 12893, "Concept"], [12955, 12963, "Concept"], [12986, 12992, "Concept"], [13022, 13036, "Concept"], [13139, 13154, "Concept"], [13161, 13176, "Concept"], [13328, 13342, "Concept"], [13356, 13361, "Concept"], [13372, 13374, "Concept"], [13379, 13381, "Concept"], [13385, 13387, "Concept"], [13400, 13413, "Concept"], [13464, 13470, "Concept"], [13475, 13484, "Concept"], [13646, 13661, "Concept"], [13762, 13764, "Concept"], [13769, 13771, "Concept"], [13782, 13784, "Concept"], [13788, 13790, "Concept"], [13798, 13800, "Concept"], [13804, 13806, "Concept"], [13815, 13817, "Concept"], [13863, 13871, "Concept"], [13878, 13880, "Concept"], [13882, 13884, "Concept"], [13931, 13933, "Concept"], [13992, 13994, "Concept"], [14078, 14091, "Concept"], [14131, 14144, "Concept"], [14213, 14215, "Concept"], [14274, 14285, "Concept"], [14340, 14346, "Concept"], [14471, 14473, "Concept"], [14482, 14484, "Concept"], [14519, 14521, "Concept"], [14553, 14558, "Concept"], [14575, 14581, "Concept"], [14592, 14597, "Concept"], [14678, 14698, "Concept"], [14776, 14778, "Concept"], [14785, 14787, "Concept"], [14790, 14792, "Concept"], [14803, 14805, "Concept"], [14815, 14817, "Concept"], [14838, 14840, "Concept"], [14892, 14894, "Concept"], [14915, 14932, "Concept"], [14939, 14956, "Concept"], [14986, 14997, "Concept"], [15021, 15033, "Concept"], [15043, 15049, "Concept"], [15057, 15063, "Concept"], [15090, 15092, "Concept"], [15097, 15099, "Concept"], [15117, 15125, "Concept"], [15126, 15139, "Concept"], [15181, 15183, "Concept"], [15191, 15193, "Concept"], [15195, 15197, "Concept"], [15203, 15205, "Concept"], [15207, 15209, "Concept"], [15231, 15239, "Concept"], [15240, 15254, "Concept"], [15274, 15282, "Concept"], [15283, 15296, "Concept"], [15324, 15332, "Concept"], [15373, 15381, "Concept"], [15382, 15395, "Concept"], [15421, 15427, "Concept"], [15480, 15486, "Concept"], [15501, 15516, "Concept"], [15534, 15551, "Concept"], [15567, 15575, "Concept"], [15598, 15616, "Concept"], [15697, 15699, "Concept"], [15720, 15734, "Concept"], [15748, 15750, "Concept"], [15771, 15779, "Concept"], [15780, 15793, "Concept"], [15801, 15803, "Concept"], [15805, 15807, "Concept"], [15828, 15844, "Concept"], [15859, 15865, "Concept"], [15867, 15877, "Concept"], [15887, 15896, "Concept"], [16149, 16160, "Concept"], [16192, 16211, "Concept"]], "Comments": []}