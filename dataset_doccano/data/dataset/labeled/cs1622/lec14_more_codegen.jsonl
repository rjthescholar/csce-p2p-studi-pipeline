{"id": 106, "segment": ["train_set", "labeled"], "course": "cs1622", "lec": "lec14_more_codegen", "text": "More Codegen and Arrays\nCS 1622\nJarrett Billingsley\n\n\fClass Announcements\n\u25cf?\n\n2\n\n\fQuick Recap Our Calling Convention\n\n3\n\n\fCaller\n\u25cf remember that the caller passes all arguments on the stack.\nglob = f(1, 2);\naddi sp, sp, -8\nli\nt0, 1\nsw\nt0, 0(sp)\nli\nt0, 2\nsw\nt0, 4(sp)\njal f\nsw\nv0, glob\n\npush the two arguments\u2026\n\ncall the function\u2026\nv0 is the return value (if any).\n\nand remember the ATV rule: after a jal, a, t, v registers'\nvalues may differ, but s registers' values will be the same.\n4\n\n\fCallee\n\u25cf every function has a stack frame to hold the arguments, locals, and\nsaved registers for that call.\nfn f(x: int, y: int) {\nlet z = x + y;\nfor i in 0, z {\nprintln_i(i);\n}\n}\n\ny\n\n4(fp)\n\nx\n\n0(fp)\n\narguments are accessed with\npositive offsets from fp;\n\nfp\nra\n\ni\nz\nthese are the saved copies of\nthe caller's fp/ra registers.\n\n-12(fp) and locals are accessed with\n-16(fp) negative offsets from fp.\nsp always points at\nthe top of the stack.\n5\n\n\fPrologue and Epilogue\n\u25cf the stack frame is set up by the prologue and torn down by the\nepilogue; these will surround every function.\nf:\nsw\nfp, -4(sp)\nsw\nra, -8(sp)\nmove fp, sp\naddi sp, sp, -n\ncode goes here!\nlw\nra, -8(fp)\nlw\nfp, -4(fp)\naddi sp, sp, x\njr\nra\n\nhere, n represents the size (in bytes) of\nall locals and saved registers.\nand here, x represents the size (in bytes) of\nall locals, saved registers, and arguments.\nthis leaves the stack completely clean.\n6\n\n\fThe Code Inside Functions\n\n7\n\n\fNot a tutorial\n\u25cf this isn't going to be a point-by-point explanation of how to\ngenerate code for every statement and expression.\n\u25cf rather, I want to give you an idea of what generating code is like\u2026\no and to go over some of the trouble spots that come up.\n\u25cf so, this section might be a bit rambly and unfocused, and that's why:\nit's just a bunch of codegen-related ideas.\n\u25cf after all, project 4 is where you'll be generating code, and I don't wanna give too much away ;)\n\n8\n\n\fBlock statements\n\u25cf the body of a function is a { block }, which is just several statements.\n\u25cf this is easy to generate code for: you just concatenate the code.\n{\nstmt1;\nstmt2;\nstmt3;\n\ncode for stmt1\ncode for stmt2\ncode for stmt3\n\n}\nthis works because the runtime semantics of block statements are\na very good match for how code is naturally executed by the CPU.\nbut that's not the case for all statements\u2026\n9\n\n\fAccessing variables\n\u25cf HLLs hide how variables are accessed at the point of use.\nlet g = 10;\nfn main() {\nlet x = 1;\n\n}\n\nhere we store to a local variable:\nsw t0, -12(fp)\n\ng = 2;\n\nhere we store to a global variable:\nsw t0, g\n\nprint_i(x);\n\nhere we load from a local variable:\nlw t0, -12(fp)\n\nprint_i(g);\n\nhere we load from a global variable:\nlw t0, g\n10\n\n\fEvaluating expressions\n\u25cf things start to get really tricky here.\n\ng = x + y;\n\nlw\nlw\nadd\nsw\n\nt0, 0(fp)\nnow we have to come up\nt1, 4(fp)\nt0, t0, t1 with registers to use for each\npart of the expression.\nt0, g\n\nthe order we do things in can affect how many registers we need.\n\ng = x + y + z;\n\nlw\nlw\nadd\nlw\nadd\nsw\n\nt0, 0(fp)\nt1, 4(fp)\nt0, t0, t1\nt1, 8(fp)\nt0, t0, t1\nt0, g\n\nlw\nlw\nor? lw\nadd\nadd\nsw\n\nt0, 0(fp)\nt1, 4(fp)\nt2, 8(fp)\nt0, t0, t1\nt0, t0, t2\nt0, g\n11\n\n\fThe need for saved registers\n\u25cf once you mix function calls in, it gets all kinds of complicated.\n\ng = x + f();\n\nlw\njal\nadd\nsw\n\nt0, 0(fp)\nf\nt0, t0, v0\nt0, g\n\nthis is bad code! we are\nviolating the ATV rule.\n\nthis is because the value of t0 from before the call may not\nsurvive until its use after the call. f is allowed to change t0.\nso we have to use the saved (s) registers for some\ntemporaries, so their values will persist across calls.\nto make things simpler, we could use only the saved\nregisters, and ignore the t registers altogether.\n12\n\n\fA little detour\n\u25cf expressions are represented as trees, and trees \u2764\ufe0f stacks, so\u2026\n\u25cf let's first imagine evaluating an AST by pushing and popping things\non a stack, instead of dealing with registers.\ng = a + b;\n\n1. push a\n\n2. push b\n\n=\n\ng\n\n+\na\n\n3. pop them,\npush sum\n\nb\nb\n\nlet's evaluate the\nassignment's rhs.\n\na\n\na\n\na + b\n\nyou can use this strategy to evaluate\nany expression of any complexity.\n(let's do a few examples.)\n13\n\n\fOk? And? How does that help?\n\u25cf well\u2026 we can map that imaginary stack onto the registers.\ng = a + b;\n\ns1\n\n=\n\ns0\ng\n\na\n\ns0\n\nb\na\n\ns0\n\na + b\n\n+\na\n\nb\n\nthis tells us what register to put each value into!\n\nlw\nlw\nadd\nsw\n\ns0, 0(fp) # a\ns1, 4(fp) # b\ns0, s0, s1\ns0, g\n\nbut now we come to an important issue: to be allowed to use the\nsaved registers, we must save the caller's versions of them.\n14\n\n\fThe last piece of the calling convention\n\u25cf only after we have generated the code for a function, do we know\nhow many saved registers it needs.\n\u25cf so there is one more part of the stack frame:\ny\n\nx\n\nfp\n\nfp\nra\n\nin the prologue, we will have to store each of\nthese saved registers to the stack\u2026\n\n\u2026and in the epilogue, we will load them back.\n\ni\n\nz\ns1\ns0\n\nwe have to save the caller's values of any\nsaved registers this function uses.\n\nsp\n\nthis is how the saved register contract works.\nI taught it in 447 and it's just as relevant now.\n15\n\n\fSome last register allocation thoughts\n\u25cf can we use t registers at all?\no sure, as long as we can prove that there are no function calls\nfrom the time we put a value in it to the time we use that value.\no that might be pretty simple: look at the AST \"to the right\" and if\nthere are no \u201cfunction call\u201d nodes, we can use a t register instead.\no this is more complicated, but it will use fewer (or no) s registers,\nmeaning less time/space spent saving/restoring them.\n\u25cf there are only 8 saved registers (s0 .. s7). what if we need more?\no uhh \ud83d\udca6\no well, this register allocation scheme will work for simple code.\no we'll talk about a much more sophisticated algorithm at the end\nof the course, which will solve this problem (and others, like using\na registers for arguments instead of the stack).\n16\n\n\fControl flow statements\n\u25cf assuming we've got expressions worked out, another surprisingly\ntricky bit is control flow statements: conditionals and loops.\no specifically, the conditions for these statements can be hard to\ngenerate good code for. (but that's not a primary goal here.)\nif i < 10 {\n...\n}\n\nlw\nbge\n...\n_end:\n\ns0, -16(fp)\ns0, 10, _end\n\ngetting the condition that simple is hard to\ndo; we might do something like this instead:\nlw\nli\nslt\nbeq\n...\n_end:\n\ns0, -16(fp)\ns1, 10\ns0, s0, s1\ns0, zero, _end\n\n17\n\n\fLazy operators (\"short-circuiting\")\n\u25cf recall that like in most languages, logical and and or will only\nevaluate their rhs if they have to \u2013 making their codegen very\ndifferent from the other operators.\nif i < 10 or i > 20 {\n...\n}\nsee how it skips right to the code\nwhen the first condition is true?\n\nlw\ns0, -16(fp)\nli\ns1, 10\nslt s0, s0, s1\nbne s0, zero, _true\nlw\ns0, -16(fp)\nli\ns1, 20\nsgt s0, s0, s1\nbeq s0, zero, _end\n_true:\n...\n_end:\n\n18\n\n\fYou can assign comparison operators into variables\n\u25cf it seems like no one teaches you this but this is totally valid code in\nJava (and in lots of other languages too):\nboolean b = x < 10;\nboolean d = i < 10 || i > 20;\n\u25cf because of this, you may not be able to use the same codegen\nalgorithm for e.g. logical OR in all cases!\no you still have to do the short-circuiting\u2026\no but now you're producing a value to be put into a variable\no which, depending on how your codegen works, could be a very\ndifferent thing from \"writing a condition for a loop\"\n\n19\n\n\fArrays\n\n20\n\n\fAdding features is Fun\u2122\n\u25cf okay. now let's assume we've implemented lexing, parsing, semantic\nanalysis, and codegen for all the basic features of our language:\no variables, functions, ints, bools, strings. just the simple stuff.\n\u25cf let's now think about how we'd go about adding a new feature to\nthe language, from design all the way through to codegen.\no and along the way, this might give you an appreciation for how\nparts of the language interact with one another.\n\u25cf we'll be adding arrays, which will work very similarly to how they do\nin Java, but with some slightly different syntax.\n\n21\n\n\fMinimum Viable Product\n\u25cf a good place to start is by writing some code to get a feel for how\nwe want this feature to look and work.\n\u25cf let's focus on the absolute core features of arrays: allocating them,\naccessing their items, and getting their length.\nlet a = new [int; 10];\n\nthis syntax might look a bit odd, but it's meant to echo a similar\nsyntax used in Rust. it's also easier to parse than new int[10].\na[0] = 5;\n\nI think it's clear what's happening here.\nfor i in 0, a.length { println_i(a[i]); }\n\nand this is familiar too!\n22\n\n\fLexing and Parsing\n\u25cf for lexing, we only need to add two tokens to our lexer: [ and ].\n\u25cf for parsing, we've got a few new rules to add.\nnew [int; 10]\n\nNew:\n'new' (StructNew | ArrayNew)\nStructNew: Id '(' ')'\nArrayCtor: '[' Type ';' Exp ']'\n\na[0] = 5;\n\nPostfixOp: FuncCall | Field | Index\nIndex:\n'[' Exp ']'\n\none more important rule: we have to be able to write array\ntypes, for things like function arguments and struct fields.\nType:\n\nfn f(a: [int])\nArrayType:\n\nVoidType | 'bool' | 'int' |\n'string' | FuncType |\nStructType | ArrayType\n'[' Type ']'\n\n23\n\n\fSemantic analysis: typing rules\n\u25cf arrays don't interact with the naming rules at all, so let\u2019s skip to types.\nnew [T; n]\n\na[i]\n\na.length\n\n\u25aa n must be int\n\u25aa the type of the whole expression is [T]\n\u25aa a must be [T]\n\u25aa i must be int\n\u25aa the type of the whole expression is T\n\u25aa if a is [T]:\n\u25aa the only allowed field is length\n\u25aa the type of the whole expression is int\n\u25aa and this cannot be the lhs of =\n24\n\n\fMore semantics: evaluation rules\n\u25cf these explain what the code does, which can also require runtime\nerror checking.\nnew [T; n]\n\na[i]\n\na.length\n\n\u25aa dynamically allocates an array on the heap.\n\u25aa n must be >= 0.\n\u25aa if not, the program halts with an error.\n\u25aa gets the ith item in a, zero-based.\n\u25aa a is evaluated before i.\n\u25aa i must be >= 0 and < a.length.\n\u25aa if not, the program halts with an error.\n\u25aa gets the length of a.\n25\n\n\fRuntime representation: data\n\u25cf as you hopefully learned in 447, an array is represented in memory by\nplacing its items next to each other, equidistantly spaced.\n\u25cf consider an array of 3 ints which are 32 bits (4 Bytes) each:\n\nA[0]\nbyte offset:\n\n0\n\nA[1]\n1\n\n2\n\n3\n\n4\n\nA[2]\n5\n\n6\n\n7\n\n8\n\n9\n\n10 11\n\ngiven a pointer A that points to the beginning of the\narray, we can get the ith item with the formula A + S\u00b7i,\nwhere S is the size of one item.\n\nhere, S = 4, so A + 4\u00b7i gives us the byte offset of item i.\n26\n\n\fRuntime representation: length\n\u25cf each array also has to remember its length, because there's\nnothing to tell you where \"the end of the array\" is.\nlet a = new [int; 3];\n3\n\nthe length comes first\nand takes up 4 bytes.\n\n0\n\n0\n\n0\n\nso now our item access formula must be\noffset by 4 to skip the length: A + S\u00b7i + 4\n(different types use different values of S, so\nwe can't do A + S(i + 1) in general.)\n\nnow we have all we need to be able to implement\na[i] and a.length! but what about new[int; 3]?\n27\n\n\fRuntime library: allocating arrays\n\u25cf dynamic memory allocation is something the runtime library is\nresponsible for. so, we'll need a function to allocate arrays.\n\u25cf fn rt$new_array(item_size: int, len: int)\no this will allocate an array of len items, where each item is\nitem_size bytes; zero out the data; set its length field to len;\nand return a pointer to it.\no it will also crash the program if len is negative, as per the\nevaluation semantics.\n\u25cf the code generation will turn array allocations into calls to this\nfunction, using a constant for item_size based on the type.\no e.g. for an array of bool, item_size is 1; for int it's 4; etc.\n\n28\n\n\fCodegen\n\u25cf finally, code generation is fairly straightforward.\nnew [T; n]\na.length\na[i]\n\ngenerated as a call to rt$new_array(S, n)\nload an int from the memory a points to\nfirst, crash if i is negative or >= a.length. if not,\ncalculate address as a + Si + 4; then load/store\n\nand we're done! yay, our language has arrays now!\n\n29\n\n\fOr does it?\n\u25cf this is just the minimum viable version of this feature.\n\u25cf what about things like:\no array initializers/literals, for allocating and filling in arrays at the\nsame time like in Java: int[] a = new int[]{ 1, 2, 3 };\no better multi-dimensional array initialization, again like Java:\nint[][] a = new int[10][20];\n\u25aa remember, this is an array of arrays: each item in the outer array\n(the 10 dimension) is a reference to an array of 20 ints\no standard library functions for sorting, searching, filling,\nmodifying arrays?\n\u25cf such a simple-seeming feature, and yet so many things to consider\u2026\no but think about how each of these might be implemented on top\nof the basic features we talked about here.\n30\n\n\f", "label": [[5, 12, "Concept"], [17, 23, "Concept"], [98, 116, "Concept"], [122, 128, "Concept"], [149, 155, "Concept"], [167, 176, "Concept"], [184, 189, "Concept"], [212, 214, "Concept"], [216, 218, "Concept"], [241, 243, "Concept"], [263, 265, "Concept"], [286, 290, "Concept"], [299, 308, "Concept"], [311, 315, "Concept"], [340, 352, "Concept"], [381, 389, "Concept"], [488, 494, "Concept"], [518, 529, "Concept"], [542, 551, "Concept"], [553, 559, "Concept"], [565, 580, "Concept"], [674, 676, "Concept"], [684, 686, "Concept"], [689, 698, "Concept"], [739, 741, "Concept"], [744, 746, "Concept"], [789, 797, "Concept"], [798, 800, "Concept"], [820, 822, "Concept"], [828, 834, "Concept"], [857, 859, "Concept"], [883, 885, "Concept"], [887, 889, "Concept"], [922, 927, "Concept"], [933, 941, "Concept"], [946, 954, "Concept"], [961, 972, "Concept"], [990, 998, "Concept"], [1020, 1028, "Concept"], [1079, 1081, "Concept"], [1093, 1095, "Concept"], [1102, 1104, "Concept"], [1106, 1108, "Concept"], [1114, 1116, "Concept"], [1118, 1120, "Concept"], [1151, 1153, "Concept"], [1165, 1167, "Concept"], [1174, 1176, "Concept"], [1178, 1180, "Concept"], [1237, 1243, "Concept"], [1248, 1263, "Concept"], [1315, 1321, "Concept"], [1323, 1338, "Concept"], [1344, 1353, "Concept"], [1371, 1376, "Concept"], [1509, 1522, "Concept"], [1604, 1619, "Concept"], [1779, 1786, "Concept"], [1844, 1859, "Concept"], [1906, 1922, "Concept"], [1929, 1933, "Concept"], [1955, 1960, "Concept"], [2016, 2029, "Concept"], [2161, 2178, "Concept"], [2182, 2198, "Concept"], [2316, 2335, "Concept"], [2338, 2342, "Concept"], [2669, 2691, "Concept"], [2820, 2829, "Concept"], [2923, 2932, "Concept"], [3140, 3155, "Concept"], [3323, 3331, "Concept"], [3482, 3501, "Concept"], [3511, 3522, "Concept"], [3613, 3628, "Concept"], [3692, 3703, "Concept"], [3723, 3728, "Concept"], [3734, 3739, "Concept"], [3742, 3748, "Concept"], [3790, 3793, "Concept"], [3797, 3804, "Concept"], [3809, 3816, "Concept"], [3829, 3834, "Concept"], [3886, 3890, "Concept"], [3897, 3901, "Concept"], [3919, 3922, "Concept"], [3930, 3934, "Concept"], [4163, 4168, "Concept"], [4422, 4436, "Concept"], [4456, 4464, "Concept"], [4510, 4528, "Concept"], [4605, 4619, "Concept"], [4666, 4677, "Concept"], [4685, 4687, "Concept"], [4689, 4691, "Concept"], [4703, 4711, "Concept"], [4749, 4763, "Concept"], [4772, 4777, "Concept"], [4792, 4800, "Concept"], [4859, 4867, "Concept"], [4882, 4896, "Concept"], [4919, 4921, "Concept"], [4939, 4953, "Concept"], [5035, 5054, "Concept"], [5424, 5435, "Concept"], [5509, 5524, "Concept"], [5580, 5599, "Concept"], [5822, 5845, "Concept"], [5927, 5950, "Concept"], [6333, 6348, "Concept"], [6351, 6367, "Concept"], [6487, 6494, "Concept"], [7049, 7056, "Concept"], [7128, 7144, "Concept"], [7238, 7245, "Concept"], [7328, 7334, "Concept"], [7409, 7415, "Concept"], [7417, 7424, "Concept"], [7426, 7443, "Concept"], [7449, 7456, "Concept"], [7685, 7692, "Concept"], [7826, 7832, "Concept"], [8115, 8121, "Concept"], [8471, 8478, "Concept"], [8483, 8490, "Concept"], [8497, 8503, "Concept"], [8529, 8535, "Concept"], [8543, 8548, "Concept"], [8565, 8572, "Concept"], [8831, 8842, "Concept"], [9024, 9041, "Concept"], [9043, 9055, "Concept"], [9058, 9064, "Concept"], [9127, 9132, "Concept"], [9184, 9188, "Concept"], [9258, 9262, "Concept"], [9326, 9331, "Concept"], [9335, 9341, "Concept"], [9348, 9352, "Concept"], [9428, 9437, "Concept"], [9439, 9455, "Concept"], [9515, 9537, "Concept"], [9569, 9590, "Concept"], [9594, 9599, "Concept"], [9607, 9611, "Concept"], [9764, 9770, "Concept"], [9826, 9832, "Concept"], [9844, 9866, "Concept"], [9868, 9872, "Concept"], [10190, 10195, "Concept"], [10346, 10368, "Concept"], [10370, 10376, "Concept"], [10384, 10389, "Concept"], [10415, 10421, "Concept"], [10521, 10527, "Concept"], [10635, 10641, "Concept"], [10800, 10806, "Concept"], [10841, 10856, "Concept"], [10858, 10875, "Concept"], [10878, 10903, "Concept"], [10921, 10936, "Concept"], [10986, 11001, "Concept"], [11154, 11160, "Concept"], [11295, 11310, "Concept"], [11321, 11338, "Concept"], [11490, 11497, "Concept"], [11509, 11524, "Concept"], [11802, 11808, "Concept"], [11919, 11924, "Concept"], [11978, 11984, "Concept"], [12166, 12171, "Concept"], [12175, 12181, "Concept"], [12206, 12211, "Concept"], [12271, 12287, "Concept"], [12341, 12347, "Concept"]], "Comments": []}