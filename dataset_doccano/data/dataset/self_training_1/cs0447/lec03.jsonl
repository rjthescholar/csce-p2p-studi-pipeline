{"id": 147, "segment": "self_training_1", "course": "cs0447", "lec": "lec03", "text": "#3\n\nPrograms,\nInstructions, and\nRegisters\nOriginal slides by: Jarrett Billingsley\nModified with bits from: Bruce Childers,\nDavid Wilkinson\n\nCS 0447\nIntroduction to\nComputer Programming\n\nLu\u00eds Oliveira\n\nFall 2020\n\n\fWhat do I need to know now!\nThe classes will be recorded!\n\u25cf You will be able to access the videos online\no They are for your personal use only!\no Do not distribute them!\n\u25cf You don\u2019t need to turn on your camera\no If you do, you may be recorded\n\u25cf You can ask questions via text!\no Chat is great for that. If I don\u2019t stop and read your questions, ask them again\no But feel free to interrupt me at any point.\n\n2\n\n\fClass announcements\n\u25cf Don\u2019t forget!\no Use the MARS I have on the course website:\n\u25cf It has been modified!!\n\n3\n\n\fPrograms and Instructions\n\n4\n\n\fWhat are they?\n\u25cf An instruction is a single, simple operation for the computer to carry out, such as:\no \"add two numbers together\"\no \u201ccopy a number from one location to another\"\no \"go to a different place in the program\"\no \"search a string for a character\u201c\n\u25cf A program is a series of these tiny instructions\no How do we create these instructions?\no And how does the computer \"understand\" them?\n\u25aa does the computer understand anything?\n\n5\n\n\fMachine language and Assembly language\n\u25cf Machine language instructions are the patterns of bits that a processor\nreads to know what to do\n\u25cf Assembly language (or \"asm\") is a human-readable, textual\nrepresentation of machine language\nMIPS asm\n\nMIPS machine language\n\nlw t0, 1200(t1)\n\n100011 01001 01000 0000010010110000\nlw\nt1\nt0\n1200\n\nadd t2, s2, t0\n\n000000 10010 01000 01010 00000 100000\n<math>\ns2\nt0\nt2\nn/a\nadd\n\nsw t2, 1200(t1)\n\n101011 01001 01010 0000010010110000\nsw\nt1\nt2\n1200\n6\n\n\fWhat can a CPU do?\n\nMaths\n\nLoad/Store things\nfrom/to memory\n\nGo execute\nsomewhere else\n\nExample: Count up to 10\n1. Load variable from memory (memory)\n2. If value equals 10 stop (cond. Go execute)\n3. Add 1 to variable value (maths)\n4. Place new value in the variable (memory)\n5. Go back to the top (incond. Go execute)\n6. stop\n\n7\n\n\fIS THAT ENOUGH?\n\n8\n\n\fCPUs are WAY\nmore complex\n\nRemember the Turing machine?\n\n\u25cf Has infinite memory represented by a single tape.\no A head moves along the tape and can read and write values.\n\n\u25aa The movement (left or right) is based upon the value read and the state of the machine.\n\n\u25cf The machine:\n1. Reads/writes the memory (tape)\n2. Compares that data and decides where to move (execute) next\n\u25cf Everything that can be computed, is computed by a Turing machine\nRulebook 1\n\n\u2794\n\nRulebook 20\n\nRead\n\nWrite\n\nMove\n\nNext\n\nRead\n\nWrite\n\nMove\n\nNext\n\n0\n\n1\n\n\uf0df\n\n20\n\n0\n\n0\n\n\u2192\n\n15\n\n1\n\n0\n\n\u2192\n\n12\n\n1\n\n1\n\n\u2192\n\n15\n9\n\n\fHow a CPU runs a program\n\n1. read an instruction\n2. do what it says\n3. go to step 1\n\no ...okay there's a little more to it than that\n\n10\n\n\fHow a CPU runs a program\n\nProgram\n3\n\n5\n\n8\n\ninstruction\n\nControl\n\n\"C = A + B\"\n\nA\n\nB\n\nC\n\nRegisters\n\n+\nDatapath\n\nProgram\n\nPersistent\nStorage\n\nMemory\n\n\u2026and repeat!\n\nProcessor\n\n11\n\n\fISAs\n\n12\n\n\fInstruction Set Architecture (ISA)\n\u25cf An ISA is the interface that a CPU presents to the programmer\no When we say \u201carchitecture\u201d, this is what we mean\n\u25cf ISAs define:\no WHAT the CPU can do (add, subtract, call functions, etc.)\no WHAT registers it has (we'll get to those)\no WHAT the machine language is\n\u25aa Machine language: the bit patterns used to encode instructions\n\n\u25cf ISAs do not define:\no HOW the CPU does it\no HOW to design the hardware!\n\u25aa \u2026if there's any hardware at all\n\u2013 Java\n\nWHY? O.o\n13\n\n\fISAs example: x86\n\u25cf Descended from 16-bit 8086 CPU from 1978\no Implemented in a rush by intel\n\u25cf Extended to 32 bits, then 64\n\u25cf Each version can run all programs from the\nprevious version\no you can run programs written in 1978 on\na brand new CPU!\n\u25cf So why don't we learn x86 in this course?\no It can do a lot of things\no Its machine language is very complex\no Making an x86 CPU is\u2026 difficult\no Ultimately, we would waste a ton of time\n\n14\n\n\fAll three processors run the exact same programs\u2026\n\u25cf but they're TOTALLY different on the inside\n\nI\u2019m an x86\nCPU!\n\nIntel Core i7\n\nVIA Nano\n\nI\u2019m an\nx86\nCPU!\n\nAMD Zen\n\nI\u2019m an x86 CPU!\n15\n\n\fKinds of ISAs: CISC\n\u25cf CISC: \"Complex Instruction Set Computer\"\n\u25cf ISA designed for humans to write asm\no from the days before compilers!\n\u25cf lots of instructions and ways to use them\n\u25cf complex (multi-step) instructions to shorten\nand simplify programs\no \"search a string for a character\"\no \"copy memory blocks\"\no \"check the bounds of an array access\"\n\u25cf x86 is very CISCy\nprguitarman.com\n\n16\n\n\fKinds of ISAs: RISC\n\u25cf RISC: \"Reduced Instruction Set Computer\"\n\u25cf ISA designed to make it easy to:\no build the CPU hardware\no make that hardware run fast\no write compilers that make machine code\n\u25cf a small number of instructions\n\u25cf instructions are very simple\n\u25cf MIPS is very RISCy\n\u25cf MIPS and RISC were the original RISC architectures\ndeveloped at two universities in California\no the research leads were\u2026 Patterson and Hennessy\u2026\n\n17\n\n\fPopular ISAs today\n\u25cf x86 (these days, it\u2019s x86-64 or \u201camd64\u201d)\no most laptops/desktops/servers have one\no (modern x86 CPUs are just RISC CPUs that can read the weird x86 instructions)\n\u25aa (unless you ask Intel, they will say otherwise \u263a)\n\u25cf ARM\no almost everything else has one\no ARMv8 (AArch64) is pretty similar to MIPS!\n\u25aa More than to ARMv7: \u201cthe main similarity between ARMv7 and ARMv8 is the\nname\u201d \u2013 Comp. Org. & Design page 159\n\u25cf Everything else: Alpha, Sparc, POWER/PPC, z, z80, 29K, 68K, 8051, PIC, AVR, Xtensa,\nSH2/3/4, 68C05, 6502, SHARC, MIPS...\no microcontrollers, mainframes, some video game consoles, and historical/legacy\napplications\n\u25cf despite its limited use today, MIPS has been incredibly influential!\n18\n\n\fThe MIPS ISA:\nRegisters\n\n19\n\n\fThe registers\n\nGeneral Purpose\n#\n\nName\n\nErm\u2026\n\n0\n\nzero\n\nAvoid Totally\n\n1\n\nat\n\n2, 3\n\nv0, v1\n\n4..7\n\na0..a3\n\n8..15\n\nt0..t7\n\n16..23\n\ns0..s7\n\n24, 25\n\nt8, t9\n\nDon\u2019t need\nthese\n\n26, 27\n\nk0, k1\n\n28\n\ngp\n\nHI\n\nFor later ;)\n\n29\n\nsp\n\nLO\n\nDon\u2019t matter\n\n30\n\nfp\n\nPC\n\nAlso for later ;)\n\n31\n\nra\n\n\u25cf Registers are a small and fast temporary memory\ninside the CPU\n\u25cf The CPU can only operate (add, etc.) on data in\nregisters\n\u25cf MIPS has 32 registers, and each is 32 bits (one word)\n\u25cf The registers are numbered 0 to 31\u2026\no \u2026but they also have nice names\n\u25aa The MARS version on the course website is modified\n\u2013 so you don't have to use them $ signs in the registers\n\u2013 $s0, $t1 vs. s0, t1\nUsed for multiplication\n(more on that later)\nKeeps track of the next\ninstruction to be executed\n\nSpecial\npurpose\n\nUsed for\nfunctions\n\nUsed for almost\neverything else\n\n20\n\n\fThe juggler\n\u25cf Registers are\u2026 like\u2026.. hands\n\u25cf You have a limited number and they can only hold small things\n\u25cf Your program's variables primarily live in memory\n\u25cf The registers are just a temporary stopping point for those values\n\nIMPORTANT!\nless important\n3\n\n5\n\n8\n\nRegisters\n\nA\n\nB\n\nC\n\nMemory\n21\n\n\fReally, you don't have that many\n\u25cf You cannot write every program using only registers\no Don't try to\n\u25aa please.\n\u25cf Every piece of your program has to SHARE the registers.\no Unlike high-level languages\no Where everyone gets their own locals\no Not in assembly!\n\n22\n\n\fThe s (saved) and the t(temporary) registers\n\u25cf There are ten temporary registers, t0 through t9\no These are used for temporary values \u2013 values that are used briefly\n\nName\nt0..t9\n\u25cf There are 8 saved registers, s0 through s7\no These are kinda like\u2026 local variables inside a function\n\nName\ns0..s7\n23\n\n\fWhen to use each\n\u25cf We'll learn more about this in the coming weeks\n\u25cf Rule of thumb:\no Use t register\no Unless you need the value to persist when calling functions\n\u25aa ok that's not too clear yet\n\u25cf 90% (made up percentage) of your code will use s and t registers\n\n24\n\n\fThe MIPS ISA:\nWHAT can it do?\n\n25\n\n\fWe have a semester to learn ;)\n\nFor now:\nli\n\u2192 Loads a number (Immediate)\nadd \u2192 It adds 2 numbers\nsub \u2192 It subtracts 2 numbers\nmul \u2192 It multiplies 2 numbers\ndiv \u2192 It multiplies 2 numbers\nmove \u2192 It \u2026 ermmm\u2026 COPIES a number\n26\n\n\fExample: Loading immediates and adding them\n\ns0 = 3;\nli s0, 3\ns1 = 5;\nli s1, 5\ns2 = s0 + s1; add s2, s0, s1\n\u25cf li stands for \"load immediate.\" what does it look like it does?\no \"immediate\" means \"number inside the instruction\"\n\u25cf add, uh, makes coffee. \u00ac_\u00ac\n\u25cf Just like in Java, C, whatever: the destination is on the left\n\n27\n\n\fExample: Complex expression\n\u25cf We can re-use registers (t0 in the example) as a temporary\no For example, say we had a longer expression:\n\ns4 = (s0 + s1 \u2013 s2) * s3\n\n\u25cf What does algebra say about what order we should do this in?\n\nadd t0, s0, s1\nsub t0, t0, s2\nmul s4, t0, s3\n\n28\n\n\fYou will be thinking like a compiler\n\u25cf Writing ASM is a different way of programming than you're used to\n\u25cf To make the transition easier, try to reduce your cognitive load\no cognitive load is \"the set of ideas you have to keep in your mind to perform some\ntask.\"\no high-level languages (HLLs) reduce cognitive load by hiding the machine code,\nusing a compiler to write it for you\n\u25cf you can do the same thing: think about how to write a program in e.g. C, and then\nturn that into asm\n\nadd c, a, b\n\nc=a+b\nadd s2, s0, s1\n29\n\n\fThe other way around\n\u25cf going the other way is also useful\n\nmul t0, s2, 33\ndiv t1, s3, s4\nsub s1, t0, t1\n\nhow would we write this in C/Java?\n\nt0 = s2 * 33\nt1 = s3 / s4\ns1 = t0 \u2013 t1\n\nor, if we rolled it all together,\n\ns1 = (s2 * 33) \u2013 (s3 / s4)\nthat's what this asm does\n\n30\n\n\fWhy do you need to know this?\n\u25cf CS0447 is about building a mental model of how a computer works\n\n\u25cf Understanding what is happening when you write code or run programs gives you a\nmuch deeper understanding\no \"why should I avoid using this programming language feature in this speed-critical\npart of my code?\"\no \"why wouldn't this crazy idea be very fast on current architectures?\"\no \"this program is breaking in a really confusing way, I have to look at the asm to\ndebug it\"\n\u25cf This stuff is specialized but hey you're majoring/minoring in it right\n\n31\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}