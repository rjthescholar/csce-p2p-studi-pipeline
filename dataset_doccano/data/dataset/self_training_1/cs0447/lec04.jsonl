{"id": 193, "segment": "self_training_1", "course": "cs0447", "lec": "lec04", "text": "#4\n\nMemory and\nAddresses\nOriginal slides by: Jarrett Billingsley\nModified with bits from: Bruce\nChilders, David Wilkinson\n\nCS 0447\nIntroduction to\nComputer Programming\n\nLu\u00eds Oliveira\n\nFall 2020\n\n\fClass announcements\n\u25cf Add/Drop period ends ??!\n\u25cf Everyone joined slack? Links will/have? Expired\n\u25cf Repeat after me:\no Store copies from the CPU to memory\no Load copies from memory to CPU\n\n2\n\n\fVariables, Loads, Stores\n\n3\n\n\fMemory addresses\n\u25cf Everything in memory has an address\no the position in memory where it begins\n\u25aa where its first byte is\no this applies to variables, functions, objects, arrays etc.\n\u25cf A super important concept:\n\nevery piece of data really has two parts:\nan address and a value\n\n\u25cf If you want to put a variable in memory\u2026\no first you need to figure out what address to put it in\no this extremely tedious task is handled by assemblers\n\u25aa whew\n\n4\n\n\fPutting a variable in memory\n\u25cf we can declare a global variable like this:\n\n.data\nx: .word 4\nname\n\ntype\n\ninitial value\n\n\u25cf the Java/C equivalent would be static int x = 4;\n\u25cf .data says \"I'm gonna declare variables\"\no you can declare as many as you want!\no to go back to writing code, use .text\n\u25cf if we assemble this little program and make sure Tools > Show Labels\nWindow is checked, what do you see?\no the assembler gave the variable that address\no it'll do that for every variable\n5\n\n\fLoad-store architectures\n\u25cf In some architectures, many instructions can access memory\no x86-64: add [rsp-8], rcx\n\u25aa adds the contents of rcx to the value at address rsp-8\n\u25cf In a load-store architecture, all memory accesses are done with two kinds of\ninstructions: loads and stores (like in MIPS)\nloads copy data from memory\ninto CPU registers\n\nlw\nRegisters\n\nMemory\n\nsw\n\nstores copy data from CPU\nregisters into memory\n6\n\n\fOperating on variables in memory (animated)\n\u25cf we want to increment a variable that is in memory\no where do values have to be for the CPU to operate on them?\no what do we want the overall outcome to be?\n\u25cf so, what three steps are needed to increment that variable?\n1. load the value from memory into a register\n2. add 1 to the value in the register\n3. store the value back into memory\n\u25cf every variable access works like this!!!\no HLLs just hide this from you\n\n5\n4\n\n5\n4\n\nx\n\n7\n\n\fAccessing memory in MIPS\n\n8\n\n\fMIPS ISA: load and store instructions for words\n\u25cf you can load and store entire 32-bit words with lw and sw\n\u25cf the instructions look like this (variable names not important):\n\nlw t1, x # loads from variable x into t1\nsw t1, x # stores from t1 into variable x\n\u25cf Ermm\u2026 In MIPS, stores are written with the destination on the right. !?\no well, you can remember it with this diagram\u2026\no the memory is \"on the right\" for both\nlw\nloads and stores\nRegisters\n\nMemory\n\nsw\n9\n\n\fMIPS ISA: load and store instructions for words\n\u25cf You can also load the 32-bit address of a variable with la\n\nla t1, x # loads the ADDRESS of x into t1\nt1 \uf0df will now contain 4: The address of variable x\n\n\u25cf And then use that address to access memory, e.g.:\n\nla t2, 0(t1) # the contents of x into t2\nx\n\nAddr\n\nVal\n\n0\n\n04\n\n1\n\n00\n\n2\n\n00\n\n3\n\n00\n\n4\n\nDE\n\n5\n\nC0\n\n6\n\nEF\n\n7\n\nBE\n\n8\n\n6C\n\n9\n\n34\n\nA\n\n00\n\nB\n\n01\n\n10\n\n\fRead, modify, write\n\u25cf you now know enough to increment x!\n\u25cf But first, lets look at some assembly\n\u25cf first we load x into a register\n\u25cf then\u2026\n\u25cf and then\u2026\n\nlw t0, x\nadd t0, t0, 1\nsw t0, x\n\n\u25cf let's see what values are in t0 and memory after this program runs\n\n11\n\n\fIt really is that simple\n\u25cf variables in asm aren't THAT scary\n\u25cf please don't be afraid of them\n\u25cf you just gotta remember to store if you wanna change em\n\n12\n\n\fQuestions?\n\n\u2022 Just in case I prepared some for you:\no Does load word (lw) put or get data from memory?\no I already know the word is the most \u201ccomfortable\u201d size for the CPU, but are\nthey the only size it can work with?\n\n13\n\n\fSmaller values\n\n14\n\n\fSmaller numeric\n\u25cf MIPS also understands smaller and tiny datatypes\n\n.data\nx: .word 4\ny: .half 4\nz: .byte 4\n\n=>\n=>\n=>\n\n0x00000004\n0x0004\n0x04\n\n15\n\n\fMIPS ISA: loading and storing 8/16-bit values\n\u25cf to load/store bytes, we use lb/sb\n\u25cf to load/store 16-bit (half-word) values, we use lh/sh\n\u25cf these look and work just like lw/sw, like:\n\nlb t0, tiny # loads a byte into t0\nsb t0, tiny # stores a byte into tiny\n\no \u2026or DO THEY?!?!?!?\n\u25cf how big are registers?\no what should go in those extra 16/24 bits then?\n\u25aa ???\n\n16\n\n\fcan I get an extension?\n\n\u2026 no\n\n\u25cf sometimes you need to widen a number with fewer bits to more\n\u25cf zero extension is easy: put 0s at the beginning.\n\n10012 \u2794 to 8 bits \u2794 0000 10012\n\n\u25cf but there are also signed numbers which we didn't talk about yet\no the top bit (MSB) of signed numbers is the sign (+/-)\n\u25cf sign extension puts copies of the sign bit at the beginning\n\n10012 \u2794 to 8 bits \u2794 1111 10012\n00102 \u2794 to 8 bits \u2794 0000 00102\n\no like spreading peanut butter\n\u25aa we'll learn about why this is important later in the course\n\n17\n\n\fEXPAND VALUE\n\u25cf if you load a byte\u2026\n\n31\n0\n00000000 00000000 00000000 00000000\n\n10010000\n\nIf the byte is signed\u2026 what should it become?\n\n31\n0\n11111111 11111111 11111111 10010000\nIf the byte is unsigned\u2026 what should it become?\n\n31\n0\n00000000 00000000 00000000 10010000\n\nlb does\n\nsign extension.\n\nlbu does\n\nzero extension.\n18\n\n\fHow does the CPU know whether it's signed or unsigned\n\u2794 Everything\u2019s a number\n\u2794 Everything's in binary (and hex is convenient shorthand)\n\u2794 Numbers may not be numbers\n\u2794 So, how does the computer know a number is a number?\no How does it know that a number is signed?\no How does it know how to add two numbers?\no How does it know how to manipulate strings?\no How does it know if one pattern of bits is a string or a number or a video\nor a program or a file or an icon or\n\n19\n\n\fIT DOESN'T\n20\n\n\fHow does the CPU know whether it's signed or unsigned\n\n\u2022 Do YOU think the CPU knows this?\n\no no\n\u25aa it doesn't\n\u2013 you have to use the right instruction.\n\u2022 It\u2019s particularly easy to mess this up\no lbu is usually what you want for byte variables but lb is one character\nshorter and just looks so nice and consistent\u2026\no But don\u2019t!\n\n21\n\n\fTruncation\n\u25cf If we go the other way, the upper part of the value is cut off.\n\nsh\n31\n0 11111111 00000100\n10100010 00001110 11111111 00000100\n\u25cf The sign issue doesn't exist when storing, cause we're going from a larger\nnumber of bits to a smaller number\no therefore, there are no sbu/shu instructions\n\n22\n\n\fMemory\n\n23\n\n\fWhat is the memory?\n\n\u2022 The system memory is a piece of temporary storage hardware\n\no it's smaller and faster (more expensive!) than the persistent storage.\n\u25aa maybe in the future it won't be temporary\n\u25aa the line between system memory and persistent storage will fade away\u2026\n\u2022 It's where the programs and data that the computer is currently executing\nand using reside\no all the variables, all the functions, all the open files etc.\no the CPU can only run programs from system memory!\n\n24\n\n\fBytes, bytes, bytes\n\u25cf The memory is a big one-dimensional array of bytes\n\u25cf What do these bytes mean?\no \u00af\\_(\u30c4)_/\u00af\n\u25cf Every byte value has an address\no This is its \"array index\"\no Addresses start at 0, like arrays in C/Java\n\u25aa Gee wonder where they got the idea\n\u25aa Addresses are the offset from the beginning!\n\u25cf When each byte has its own address, we call it a byteaddressable machine\no not many non-byte-addressable machines these days\n\nAddr\n\nVal\n\n0\n\n00\n\n1\n\n30\n\n2\n\n04\n\n3\n\n00\n\n4\n\nDE\n\n5\n\nC0\n\n6\n\nEF\n\n7\n\nBE\n\n8\n\n6C\n\n9\n\n34\n\nA\n\n00\n\nB\n\n01\n\nC\n\n02\n\n25\n\n\fHow much memory?\n\u25cf Each address refers to one byte. if your addresses are n bits long\u2026\nhow many bytes can your memory have?\no 2n B\n\u25cf machines with 32-bit addresses can access 232 B = 4GiB of memory\no with 64-bit addresses\u2026 16EiB\n\u25cf Remember:\no kibi, Mebi, Gibi, Tebi, Pebi, Exbi are powers of 2\n\u25aa kiB = 210, MiB = 220, GiB = 230 etc.\no kilo, mega, giga, tera, peta, exa are ostensibly powers of 10\n\u25aa kB = 103, MB = 106, GB = 109 etc.\n\n26\n\n\fWords, words, words\n\u25cf For most things, we want to use words\no The \"comfortable\" integer size for the CPU\no On this version of MIPS, it's 32b (4B)\n\u25cf But our memory only holds bytes\u2026\n\u25cf Combine multiple bytes into larger values\no The CPU can handle this for us\no But importantly, the data is still just bytes\n\u25cf When we talk about values bigger than a byte\u2026\no The address is the address of their first byte\n\u25aa The byte at the smallest address\no So what are the addresses of the three words here?\n\nAddr\n\nVal\n\n0\n\n00\n\n1\n\n30\n\n2\n\n04\n\n3\n\n00\n\n4\n\nDE\n\n5\n\nC0\n\n6\n\nEF\n\n7\n\nBE\n\n8\n\n6C\n\n9\n\n34\n\nA\n\n00\n\nB\n\n01\n\nC\n\n02\n\n27\n\n\fEndianness\n\n28\n\n\fA matter of perspective\n\u25cf let's say there's a word at address 4\u2026 made of 4 bytes\n\u25cf wh\u2026what word do those 4 bytes represent?\n\n\u2026is it\n0xDEC0EFBE?\n\nAddr\n\nVal\n\n...\n\n...\n\n7\n\nDE\n\n6\n\nC0\n\n5\n\nEF\n\n4\n\nBE\n\n...\n\n...\n\n\u2026is it\n0xBEEFC0DE?\n\n29\n\n\fEndianness\n\n\u25cf when interpreting a sequence of bytes as larger values, endianness\nis the rule used to decide what order to put the bytes in\n\nlittle-endian means 0\nthe \u201cLITTLE address\u201c DE\ncontains the END-byte\n\n0xBEEFC0DE\n\n1 2 3 big-endian means the\n\u201cBIG address\"\nC0 EF BE\n\ncontains the END-byte\n\n0xDEC0EFBE\n\nnothing to do with value of bytes, only order\n\n30\n\n\fWhich is better: little or big?\n\u25cf it doesn't matter.* as long as you're consistent, it's fine\n\u25cf for political reasons, most computers today are little-endian\n\u25cf but endianness pops up whenever you have sequences of bytes:\no like in files\no or networks\no or hardware buses\no or\u2026 memory!\n\u25cf which one is MIPS?\no it's bi-endian, meaning it can be configured to work either way\no but MARS uses the endianness of the computer it's running on\n\u25aa so little-endian for virtually everyone\n\u2013 cause x86\n\u2013 Apple sillycone will use a bi-endien architecture: ARM architecture\n(x86)\n\n*big endian is better\n\n31\n\n\fWhat DOESN'T endianness affect?\n\u00d7 the arrangement of the bits within a byte\no it just changes meaning of order of the bytes\n\u25aa note the bytes are still DE, C0 etc.\n\u00d7 1-byte values, arrays of bytes, ASCII strings\u2026\no single bytes don\u2019t care about endianness at all\n\u00d7 the ordering of bytes inside the CPU\no there's no need for e.g. \"big-endian\" arithmetic\no the CPU works with whole words\n\u25cf endianness only affects moving/splitting data:\no larger than single bytes\no between the CPU and memory\no or between multiple computers\n\n0xBEEFC0DE\n0xED0CFEEB\n0xDEC0EFBE\n\nl l e H o\nH e l l o\n\n32\n\n\fSummary\n\n33\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}