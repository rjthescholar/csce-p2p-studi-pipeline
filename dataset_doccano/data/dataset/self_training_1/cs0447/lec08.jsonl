{"id": 182, "segment": "self_training_1", "course": "cs0447", "lec": "lec08", "text": "#8\n\nBitwise Operations\nand Bitfields\n\nCS 0447\nIntroduction to\nComputer Programming\n\nLu\u00eds Oliveira\n\nOriginal slides by: Jarrett Billingsley\nModified with bits from: Bruce Childers, David Wilkinson\nFall 2020\n\n\fAnnouncements\n\n2\n\n\fLogical, right?\nclass Main {\npublic static void main(String[] args) {\nboolean a = true;\nboolean b = true;\nSystem.out.println(a||b);\n}\n}\n\nclass Main {\npublic static void main(String[] args) {\nint a = 4;\nint b = 1;\nSystem.out.println( a|b );\n}\n}\n\n\u25cf What is the output?\n\ntrue\n\n\u25cf What is the output?\n\n5\n3\n\n\fWhat are \"bitwise\" operations?\n\u25cf The \"numbers\" we use on computers aren't really numbers right?\n\u25cf It's often useful to treat them instead as a pattern of bits\n\u25cf Bitwise operations treat a value as a pattern of bits\n\n0\n1\n\n0\n\n0\n\n0\n4\n\n\fThe simplest operation: NOT (logical negation)\n\u25cf If the light is off, turn it on\n\u25cf If the light is on, turn it off\n\nA\n\nQ\n\n0\n\n1\n\n1\n\n0\n\n\u25cf We can summarize this in a truth table\n\u0d25\n\u25cf We write NOT as ~A, or \u00acA, or A\n\n5\n\n\fApplying NOT to a whole bunch of bits\n\u25cf if we use the not instruction (or ~ in C/Java), this is what happens:\n\n~ 0 0 1 1 1 0 1 0\n\n= 1 1 0 0 0 1 0 1\nwe did 8 independent NOT operations\nthat's it it's super simple\nonly 8 bits shown cause 32 bits on a slide is too much\n\n6\n\n\fLet's add some switches\n\u25cf There are two switches in a row connecting the light to the battery\n\u25cf How do we make it light up?\n\n7\n\n\fAND (Logical product)\n\u25cf AND is a binary (two-operand) operation\n\u25cf it can be written a number of ways:\n\no A&B\n\nA\u2227B\n\nA\u22c5B\n\nAB\n\n\u25cf if we use the and instruction (or & in C/Java):\n\nA B Q\n0 0 0\n\n1 1 1 1 0 0 0 0\n& 0 0 1 1 1 0 1 0\n\n0 1 0\n\n= 0 0 1 1 0 0 0 0\n\n1 1 1\n\n1 0 0\n\nwe did 8 independent AND operations\n8\n\n\f\"Switching\" things up\n\u25cf NOW how can we make it light up?\n\n9\n\n\fOR (Logical sum\u2026?)\n\u25cf we might say \"and/or\" in English\n\u25cf it can be written a number of ways:\n\no A|B\n\nA\u2228B\n\nA+B\n\n\u25cf if we use the or instruction (or | in C/Java):\n\nA B Q\n0 0 0\n\n1 1 1 1 0 0 0 0\n| 0 0 1 1 1 0 1 0\n\n0 1 1\n\n= 1 1 1 1 1 0 1 0\n\n1 1 1\n\n1 0 1\n\nWe did 8 independent OR operations.\n10\n\n\flui, ori\u2026\n\u25cf If I write li t0, 0xDEADBEEF in MIPS, the assembler turns it into:\n\nlui at, 0xDEAD\nori t0, at, 0xBEEF\nNever use at!!\nNEVER!!\n\n\u25cf at is used by the assembler, sooooo\u2026\n\u25cf The reason it splits it up is that there's only enough space in each\ninstruction to fit half of 0xDEADBEEF\no As we\u2019ve seen in the lab, each immediate is 16 bits long\no We'll learn about instruction encoding later\n\u25cf What the heck are these instructions doing tho\n\n11\n\n\fBy your powers combined\u2026\n\u25cf lui means load upper immediate. it puts the immediate value into the\nupper 16 bits of the register, and zeroes out the rest\n\nlui at, 0xDEAD\n\u25cf then, ori does logical OR of at and its zero-extended immediate\n\nori t0, at, 0xBEEF\n11011110101011010000000000000000\n| 00000000000000001011111011101111\n\n11011110101011001011111011101111\n\nD\n\nE\n\nA\n\nD\n\nB\n\nE\n\nE\n\nF\n12\n\n\fBit shifting\n\n13\n\n\fBit shifting\n\u25cf besides AND, OR, and NOT, we can move bits around, too.\n1 1 0 0 1 1 1 1 if we shift these\nbits left by 1\u2026\n\n1 1 0 0 1 1 1 1 0 we stick a 0 at the bottom\n1 1 0 0 1 1 1 1 0 0 again!\n\n1 1 0 0 1 1 1 1 0 0 0 AGAIN!\n1 1 0 0 1 1 1 1 0 0 0 0 AGAIN!!!!\n14\n\n\fLeft-shifting in C/Java and MIPS (animated)\n\u25cf C and Java use the << operator for left shift\n\nB = A << 4; // B = A shifted left 4 bits\n\n\u25cf MIPS has the sll (Shift Left Logical) instruction\n\nsll t2, t0, 4 # t2 = t0 << 4\n\u25cf MIPS has the sllv (Shift Left Logical Variable) instruction\no No, registers are not variables!\n\nsllv t2, t0, t1 # t2 = t0 << t1\n\n\u25cf if the bottom 4 bits of the result are now 0s\u2026\no \u2026what happened to the top 4 bits?\n\n0011 0000 0000 1111 1100 1101 1100 1111\nBit\nBucket\n\nthe bit bucket is not a real place\nit's a programmer joke ok\n15\n\n\f<_< >_> <_<\n\u25cf we can shift right, too\n0 0 1 1 0 0 0 0 0 0 0 0 1 1 1 1 1 1 0 0 1 1 0 1 1 1 0 0 1 1 1 1\n0 0 0 1 1 0 0 0 0 0 0 0 0 1 1 1 1 1 1 0 0 1 1 0 1 1 1 0 0 1 1 1\n0 0 0 0 1 1 0 0 0 0 0 0 0 0 1 1 1 1 1 1 0 0 1 1 0 1 1 1 0 0 1 1\n0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 1 1 1 1 1 1 0 0 1 1 0 1 1 1 0 0 1\n0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 1 1 1 1 1 1 0 0 1 1 0 1 1 1 0 0\n\n\u25cf C/Java use >>, MIPS uses srl (Shift Right Logical)\n\n16\n\n\fNumbers they are a-changing\n\u25cf let's start with a value like 5 and shift left and see what happens\n\nBinary\n101\n1010\n10100\n101000\n1010000\n\nDecimal\n5\n10\n20\n40\n80\n\nwhy is this happening\nwell uh... what if I gave you\n\n49018853\n\nhow do you multiply that by 10?\nby 100?\nby 100000?\n\nsomething very similar is\nhappening here\n\n17\n\n\fa << n == a * 2n\n\u25cf shifting left by n is the same as multiplying by 2n\no you probably learned this as \"moving the decimal point\"\n\u25aa and moving the decimal point right is like shifting the digits left\n\u25cf shifting is fast and easy on most CPUs\no way faster than multiplication in any case\n\u25cf hey\u2026 if shifting left is the same as multiplying\u2026\n\n18\n\n\fa >> n == a / 2n, ish\n\u25cf You got it\n\u25cf Shifting right by n is like dividing by 2n\no sort of.\n\u25cf What\u2019s 510 (01012) shifted right by 1?\no 102, which is 2\u2026\n\u25aa It's like doing integer (or flooring) division\n\u25aa Which is a fancy way of saying we round to the smallest number\n\n\u25cf What if the number is signed?\n\u25cf What\u2019s -310 (next class: 11012) shifted right by 1?\no 01102, which is 610???\n\u25aa Ohhhhh\n\n19\n\n\f<_< >_> <_<\n\u25cf We can do sign-extension on shifts, too!!\n1 1 1 1 0 0 0 0 0 0 0 0 1 1 1 1 1 1 0 0 1 1 0 1 1 1 0 0 1 1 1 1\n1 1 1 1 1 0 0 0 0 0 0 0 0 1 1 1 1 1 1 0 0 1 1 0 1 1 1 0 0 1 1 1\n1 1 1 1 1 1 0 0 0 0 0 0 0 0 1 1 1 1 1 1 0 0 1 1 0 1 1 1 0 0 1 1\n1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 1 1 1 1 1 1 0 0 1 1 0 1 1 1 0 0 1\n1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 1 1 1 1 1 1 0 0 1 1 0 1 1 1 0 0\n\n\u25cf MIPS uses sra (Shift Right Arithmetic)\n\u25cf What\u2019s -310 (11012) shifted right by 1?\no 11102, which is -210\n\u25aa Why is this -2????? next class\n\n20\n\n\fMIPS ISA: Bitwise operations\n\u25cf Bitwise logical operators\n\nInstruction\n\nMeaning\n\nnot a, b\n\na = ~b\n\nor a, b, c\n\na = b|c\n\nori a, b, imm\n\na = b|imm\n\nand a, b, c\n\na = b&c\n\nandi a, b, imm\n\na = b&imm\n\n21\n\n\fMIPS ISA: Bitwise shifts\n\u25cf Bitwise logical operators\n\nInstruction\n\nMeaning\n\nsll a, b, imm\n\na = b<<imm\n\nsllv a, b, c\n\na = b<<c\n\nsrl a, b, imm\n\na = b>>imm (zero extension)\n\nsrlv a, b, c\n\na = b>>c\n\nsra a, b, imm\n\na = b>>imm (sign extension)\n\nsrav a, b, c\n\na = b>>c\n\n(zero extension)\n\n(sign extension)\n\n22\n\n\fBitfields\n\n23\n\n\fclicky clicky\n\u25cf In the LED Keypad plugin in MARS, input works like this:\ninput_get_keys returns a value in v0\u2026\n\n0 0 0 0 0 0 0 0 0 0 0 0\nB R L D U\n24\n\n\fWhy do we do this??\n\u25cf It lets us cram several booleans into a single value!\n\u25cf This technique is known as bit flags\n\n1 0 1 0 0\nB R L D U\n\n0 1 0 1 0\nB R L D U\n25\n\n\fThe masters of meaning\n\u25cf well what if we wanted to store multiple integers in one value?\n\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\n1 0 1 1 1 1 0 0 0 0 0 1 0 0 1 1\n\ndecimal?\n\nred\n\ngreen\n\nblue\n\n23\n\n32\n\n19\n\nThat's this color, in RGB565.\n\n26\n\n\fThe masters of meaning\n\u25cf This bitfield has 3 fields: red, green, and blue\n\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\n1 0 1 1 1 1 0 0 0 0 0 1 0 0 1 1\nred\n\ngreen\n\nblue\n\nPosition 11\n\nPosition 5\n\nPosition 0\n\n27\n\n\fWhyyyyy???\n\u25cf It's smaller\no really, that's it\no but that's super important in a lot of cases\n\u25cf Smaller data\u2026\no Takes up less space in memory\no Takes up less space in cache\n\n\u25aa extremely important thing in modern CPUs that we talk about in 1541\n\no Is faster to move between memory and the CPU\no Is faster to transfer across the internet and other networks\no It allows a MIPS instruction to contain references to multiple registers\n\n28\n\n\fI wanna turn the light on!!\n\u25cf I have a sequence of 0s. I wanna turn one of them into a 1.\n\u25cf what bitwise operation can I use to do that?\n\n0\n? 1\n1\n\n0\n0\n0\n\n0\n0\n0\n\n0\n0\n0\n\n29\n\n\fI wanna turn the light off!!\n\u25cf I wanna turn one of the 1s into a 0.\n\u25cf what bitwise operation can I use to do that?\n\n1\n? 1\n1\n\n0\n1\n0\n\n1\n0\n0\n\n1\n1\n1\n\n30\n\n\fTurning off the first three, leaving the others alone\n\u25cf more bits, but one of the same operations\u2026\n\n1\n? 0\n0\n\n0\n0\n0\n\n1\n0\n0\n\n0\n1\n0\n\n1\n1\n1\n\n1\n1\n1\n\n31\n\n\fRemember this?\n\nlui at, 0xDEAD\nori t0, at, 0xBEEF\n11011110101011010000000000000000\n| 00000000000000001011111011101111\n\n11011110101011011011111011101111\n\nD\n\nE\n\nA\n\nD\n\nB\n\nE\n\nE\n\nF\n\n32\n\n\fHow can we assemble on of these bitfields?\n15 14\n\n13\n\n12\n\n11 10\n\nred\n\n1 0 1 1 1\n\n9\n\n8\n\n7\n\ngreen\n\n6\n\n5 4\n\n3\n\n2\n\n1\n\n0\n\nblue\n\n1 0 1 1 1\n1 0 0 0 0 0\n1 0 0 0 0 0\n1 0 0 1 1\n\n33\n\n\f\u2026\n\u25cf hmm\n\n1 0 1 1 1\n\n0 0 0 0 0 0 0 0 0 0 0\n\n0 0 0 0 0\n0 0 0 0 0\n\n1 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 1 0 0 1 1\n\n1 0 1 1 1\n\n1 0 0 0 0 0 1 0 0 1 1\n\n34\n\n\fLeft-shifting and ORing\n\u25cf if you have the values of the fields\n\u25cf and you want to put them together into a bitfield\no shift each value left to the correct bit position\no OR the shifted values together\n\u25cf for RGB565,\no red is shifted left 11\no green is shifted left 5\no blue isn't shifted (shifted left 0\u2026)\n\ncolor = (red << 11) | (green << 5) | blue;\n\n35\n\n\fGoing the other way\n\u25cf let's go from the bitfield to three separate values.\n\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\n1 0 1 1 1 1 0 0 0 0 0 1 0 0 1 1\nlet's say we somehow set all the non-red bits to 0.\n\n1 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0\nwhat value is this?\nit's not 23, that's for sure.\nso how do we fix that?\n\n36\n\n\fIt's the exact opposite\n\u25cf we have to shift right to put the field at position 0\n\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\n1 0 1 1 1 1 0 0 0 0 0 1 0 0 1 1\nshift right by 11 and\u2026\n\n0 0 0 0 0 0 0 0 0 0 0 1 0 1 1 1\ncool. what about green? shift right by\u2026?\n\n0 0 0 0 0 1 0 1 1 1 1 0 0 0 0 0\nuh oh.\n\n37\n\n\fMasquerade\n\u25cf we need to get rid of (zero out) the bits that we don't care about\n\u25cf a mask is a specially-constructed value that has:\no 1s in the bits that we want to keep\no 0s in the bits that we want to discard\n\u25cf which bits do we want to keep? which do we want to discard?\n\n0 0 0 0 0 1 0 1 1 1 1 0 0 0 0 0\n&\n\n0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1\n0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0\nthis is the mask\n\n38\n\n\fComing up with the mask value\n\u25cf if you want to mask a 3 bit value, the mask is 1112\n\u25cf if you want to mask a 4 bit value, the mask is 11112\n\u25cf if you want to mask a 5 bit value, it's\u2026?\n\nSize(n) Mask\n1112\n3\n11112\n4\n111112\n5\n\n2n\n8\n16\n32\n\nMask in\ndecimal\n7\n15\n31\n2n-1\n39\n\n\fRight-shifting and ANDing\n\u25cf to extract one or more fields from a bitfield:\no shift the bitfield right to put the desired field at bit position 0\no AND that with 2n-1, where n is the number of bits in the field\n\u25cf so for RGB565\u2026\no the red and blue masks are 25-1 = 31 (or 0x1F)\no the green mask is 26-1 = 63 (or 0x3F)\n\nred = (color >> 11) & 0x1F;\ngreen = (color >> 5) & 0x3F;\nblue = color & 0x1F;\n\n40\n\n\fNOW it works\n\u25cf let's extract green\n\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\n1 0 1 1 1 1 0 0 0 0 0 1 0 0 1 1\nshift right by 5 and\u2026\n\n0 0 0 0 0 1 0 1 1 1 1 0 0 0 0 0\nand then AND with 0x3F\u2026\n\n0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0\n\n41\n\n\fCan't you AND then shift?\n\u25cf sure, but\u2026\n\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\n1 0 1 1 1 1 0 0 0 0 0 1 0 0 1 1\nAND with 0x7E0 (!)\u2026\n\n0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0\nshift right by 5\u2026\n\n0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0\nwhere did I get 0x7E0??\nit's 0x3F << 5.\n\nI feel like that's uglier.\n\nExperience shows me it leads to more mistakes\nSo don\u2019t do this: Keep the mask aligned to the right!!!\n42\n\n\fExercise!\n\u25cf This bitfield represents the following MIPS instruction:\naddi s0, zero, 0x1234\n\n3 30 29 28 27 2 2 24 23 22 2 2 19 18 17 1 1 14 13 12 11 10 9 8 7 6 5 4 3 2 1\n0\n1\n65\n10\n65\n00100000000100000001001000110100\nopcode\n\nrs\nIt\u2019s addi!\n\nrt\nzero\n\nimm\nLoad into this\nregister\n\nThis number\n\n\u25cf Using these operations: <<, >>, &, |, ~ write expressions to extract the value\nof each field\no E.g.: ( field << 3 )|( ~0xFFFF )\n43\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}