{"id": 165, "segment": "self_training_1", "course": "cs0447", "lec": "lec09", "text": "#9\n\nBinary arithmetic:\nAddition\nOriginal slides by: Jarrett Billingsley\nModified with bits from: Bruce\nChilders, David Wilkinson\n\nCS 0447\nIntroduction to\nComputer Programming\n\nLu\u00eds Oliveira\n\nFall 2020\n\n\fClass announcements\n\n\u2022 nope\n\n2\n\n\fBinary addition\n\n3\n\n\fAdding in binary\n\u25cf It works the same way as you learned in school\no Except instead of carrying at 1010, you carry at\u2026 102!\n\u25aa 1 + 1 = 102 (210)\n\u25aa 1 + 1 + 1 = 112 (310)\n\u25cf Let's try it. (what are these in decimal?)\n0 1 1 1\n\n1 1 0\n\n1011 0010\n+0010 1111\n1110 0001\n\n4\n\n\fFormalizing the algorithm\n\u25cf for each pair of bits starting at the LSB,\no add the two bits and the carry\no the low bit of the sum goes into the sum row\no the high bit of the sum is the carry for the next higher bit\n\u25cf this is the grade school algorithm\no cause it's how you learned to add in grade school\n\nBit\nBucket..?\n\n1 0 1 1 0 0 1 0\n+0 0 1 0 1 1 1 1\n5\n\n\fSigned Numbers\n\n6\n\n\fRemember this?\n\u25cf if you load a byte\u2026\n\n31\n0\n00000000 00000000 00000000 00000000\n\n10010000\n\nIf the byte is signed\u2026 what should it become?\n\n31\n0\n11111111 11111111 11111111 10010000\nIf the byte is unsigned\u2026 what should it become?\n\n31\n0\n00000000 00000000 00000000 10010000\n\nlb does\n\nsign extension.\n\nlbu does\n\nzero extension.\n7\n\n\fArbitrariness\u2026 Again\n\u25cf What does this mean?\n\n10001010\nIs it signed?\n\n\u00af\\_(\u30c4)_/\u00af\n\nIs it\nunsigned?\n\nWhat\u2019s the\ndifference?\n8\n\n\fUnsigned integers \u2013 they are all positive!\n\u25cf We have numbers, they are all positive!\no On a number line:\n\n000\n\n010\n100\n110\n001\n011\n101\n111\n\n0 1 2 3 4 5 6 7\n\n\u25cf What if we want to have negative numbers?\n\n9\n\n\fIf you wanted to implement signed integers\u2026\n\u25cf What would be the most intuitive way of doing it?\no You could have a \"sign bit\" where 0 means +, and 1 means \u25cf This is sign-magnitude representation. on a number line:\n\n111\n\n110\n\n000\n010\n101\n001\n011\n\n-3 -2 -1 0 +1 +2 +3\n100\n\n\u25cf What about the pattern 100?\no negative sign, 0 magnitude\no NEGATIVE ZERO??\n\u25cf Arithmetic is a bit awkward\n\n10\n\n\fSign-magnitude arithmetic\n\u25cf Negation\n\n-(3)\n\n0011\n\n-(-3)\n\n1011\n\nbit pattern for\npositive 3?\n\nbit pattern for\nnegative 3?\n\n1011\n\nFlip MSB!\n\n0011\n\nFlip MSB!\n\n11\n\n\fSign-magnitude arithmetic\n\u25cf Negation\n\n-(3)\n\n0011\n\n1011\n\n-(-3)\n\n1011\n\n0011\n\n\u25cf (wrong) Addition\n\n11\n0011\n+0011\n0110\n\nto binary?\n\n3\n+ 3\n6\n\nbit pattern for\n-3\u2026 positive 3?\n\n3\n+-3\n0\n\n11\n0011\n+1011\n1011\n1110\n\n-6\n\nto decimal?\n\n\u25cf It\u2019s not impossible\no But it is awkward\n\n12\n\n\fWell, what if\u2026\n\u25cf We use a technique borrowed from old accounting practices and\nmechanical calculators, we can flip all the bits to negate a number\n\u25cf This is ones' complement. on a number line:\n\u25cf We have the same problem with 111\nas sign-magnitude had with 100\n\n100\n\n101\n\n000\n010\n110\n001\n011\n\n-3 -2 -1 0 +1 +2 +3\n\u25cf This does make arithmetic easier\n\u25cf But it is not used in modern computers.\n\n111\n\n13\n\n\fSign-magnitude arithmetic\n\u25cf Negation\n\n-(3)\n\n0011\n\n-(-3)\n\n1100\n\nbit pattern for\npositive 3?\nbit pattern for\nnegative 3?\n\nflip!\n\nflip!\n\n1100\n\n0011\n\n14\n\n\fSign-magnitude arithmetic\n\u25cf Negation\n\n\u25cf Addition\n\nto binary?\n\n3\n+ 2\n5\n\n-(3)\n\n0011\n\n1100\n\n-(-3)\n\n1100\n\n0011\n\n0010\n0011\n+0010\n0101\n\nAdd the\ncarry back in\n\nbit pattern for\n-2\u2026 positive 2?\n\n3\n+-2\n1\n\n1111\n0011\n0010\nflip!\n+1101\n1101\n0000???\n+0001\n1\n0001\n\nthis is positive, so don\u2019t flip\n\nto decimal?\n\n15\n\n\fOne\u2019s complement arithmetic\n\u25cf Do you really want to write code like\n\nif( (my_var == 0) OR (my_var == -0) )\n{\n\u2026\n}\n\n\u25cf Just kidding\u2026 Compilers would handle that for you!\n\n16\n\n\fFinally, two's complement\n\u25cf First, we flip all the bits\no Just like with 1\u2019s complement\n\u25cf Then add 1.\n\u25cf The number line looks a little bit stranger\no But there is only one 0, and it is 0!\n\n100\n\n101\n\n110\n\n000\n010\n111\n001\n011\n\n-4 -3 -2 -1 0 +1 +2 +3\n\n17\n\n\fFinally, two's complement\n\u25cf First, we flip all the bits\no Just like with 1\u2019s complement\n\u25cf Then add 1.\n\u25cf The number line looks a little bit stranger\no But there is only one 0, and it is 0!\n\n100\n\n101\n\n110\n\n000\n010\n111\n001\n011\n\n-4 -3 -2 -1 0 +1 +2\n\u25cf It's lopsided: There is no +4!\no But arithmetic is easy!\no when someone says \"signed,\" 99% of the time they mean this\no When I say \u201csigned\u201d, I 100% of the time mean this\n\n+3\n\n18\n\n\fSign-magnitude arithmetic\n\u25cf Negation\n\n-(3)\n\n0011\n\n-(-3)\n\n1101\n\nbit pattern for\npositive 3?\nbit pattern for\nnegative 3?\n\nflip!\n\nflip!\n\n1100\n\n0010\n\n1101\n\nAdd 1!\n\n0011\n\nAdd 1!\n\n\u25cf You don\u2019t need to subtract!!\no flip(k)+1 == flip(k-1)\n\u25aa If you ignore the carry! \u263a\n\n19\n\n\fTwo's complement addition\n\u25cf the great thing is: you can add numbers of either sign without having to do\nIgnore the carry\nanything special!\nto binary? 0111\n\n3\n+ 7\n10\n\nbit pattern for\n-7\u2026 positive 7?\n\n0011\n3\n+0111 +-7\n1010 -4\n\n0011\n0011\n0111\n4\nflip!\n+1 +1001\nto decimal?\n1000\n1100 0100\nthis is negative, so\n\nwhat is it? flip!\nthe actual patterns of bits are the same.\nso how does the computer \"know\" whether it's\ndoing signed or unsigned addition?\n\n+1\n\n0011\n\n20\n\n\fIT DOESN'T\n21\n\n\fThis is how it looks\n\u25cf Interpreting bit patterns as (left) unsigned and (right) signed\n\n15 0\n\n1\n\n-1 0\n\n14 1111 0000 0001 2\n1110\n0010\n13 1101\n0011 3\n\n-2 1111\n1110\n-3 1101\n\n12 1100\n1011\n11 1010\n\n-4 1100\n1011\n-5 1010\n\n10\n\n1001\n\n9\n\n0100\n0101\n0110\n1000\n\n8\n\n0111\n\n7\n\n6\n\n4\n5\n\n-6\n\n1001\n\n0000\n\n1\n0001\n\n0010\n\n2\n\n0011\n0100\n0101\n\n0110\n1000\n\n0111\n\n-7 -8 7\n\n6\n\n3\n4\n5\n\n\fTwo's complement negation\n\u25cf (assuming 4 bits) What about??? -8?\no What happens if we negate -8?\n\u25aa i.e. -(-8)?\n\n-(-8)\n\n1000\n\nbit pattern for\nnegative 8?\n\nflip!\n\n0111\n\nWHAT DID YOU\nDO WRONG??????\n\n1000\n\nAdd 1!\n\n-8???\n-1 0\n\n-2 1111\n1110\n-3 1101\n\n0000\n\n-6\n\n0001\n0010\n\n2\n\n0011\n\n-4 1100\n1011\n-5 1010\n1001\n\n1\n\n0100\n0101\n0110\n\n1000\n\n0111\n\n-7 -8 7\n\n3\n4\n5\n\n6\n23\n\n\fAbsolutely Bonkers \u2013 Slide borrowed from wilkie (449)\npublic class AbsTest {\npublic static int abs(int x) {\nif (x < 0) {\nx = -x;\n}\nreturn x;\n}\npublic static void main(String[] args) {\nSystem.out.println(\nString.format(\"|%d| = %d\", Integer.MIN_VALUE, AbsTest.abs(Integer.MIN_VALUE))\n\n);\n}\n\n}\n\n// Outputs: |-2147483648| = -2147483648\nCS/COE 0449 \u2013 Spring 2019/2020\n\nQ: How many bits is a Java int? What happened here?\n\n24\n\n\fNeat properties\n\u25cf If we take a positive number and add zeros:\no 12010 = 0111 10002\no 0000 0000 0111 10002 = 12010\n\u25cf If we take a negative number and add ones:\no 1000 01112 = - 0111 10002 + 12\n= - 0111 10012 = -12110\n\no 1111 1111 1000 01112 = - 0000 0000 0111 10002+12\n= - 0000 0000 0111 10012\n= - 12110\n\n25\n\n\fA return to E X P A N D V A L U E\n\u25cf if you load a byte\u2026\n\n31\n0\n00000000 00000000 00000000 00000000\n\n10010000\n\nIf the byte is signed\u2026 what should it become?\n\n31\n0\n11111111 11111111 11111111 10010000\nIf the byte is unsigned\u2026 what should it become?\n\n31\n0\n00000000 00000000 00000000 10010000\n\nlb does\n\nsign extension.\n\nlbu does\n\nzero extension.\n26\n\n\fOverflow\n\n27\n\n\fOverflow\n\u25cf In computers, numbers are finite.\n\u25cf Let's say our 4-digit display was counting up:\n9997, 9998, 9999\u2026\n\u25cf What comes \"next\"?\no What does this \"0000\" really mean?\no It wrapped around.\n\u25cf This is overflow: the number you are trying\nto represent is too big to be represented.\n\u25cf Essentially, all arithmetic on the computer is modular arithmetic!\no This causes a lot of software bugs.\no https://en.wikipedia.org/wiki/Pac-Man#Level_256\n\n28\n\n\fNumber carrousel\n\u25cf Computers perform modulus arithmetic\no Meaning: it goes around!\no E.g. in a 4-bit computer\n15 0\n\n14 1111\n1110\n13 1101\n\n0000\n\n1001\n\n0001\n0010\n\n2\n\n0011\n\n12 1100\n1011\n11 1010\n10\n\n1\n\n0100\n0101\n0110\n0111\n\n3\n4\n5\n\n6\n\n0110\n8 7\n+0111\nwhat is 6 + 7? 1101\n9\n\n1000\n\n29\n\n\fUnsigned overflowing\n\n15 0\n\n14 1111\n1110\n13 1101\n\n0000\n\n1001\n\n9\n\n2\n0010\n0100\n0101\n\n0110\n1000\n\n8\n\nUhhhhh\n\n0001\n\n0011\n\n12 1100\n1011\n11 1010\n10\n\n1\n\n0111\n\n6\n\n7\n\nwhat is 14 + 7?\n\n3\n4\n5\n\n1110\n+0111\n10101\n\nIf the result is smaller\nthan either addend,\nthere is an overflow\n\n30\n\n\fSigned overflowing\n\u25cf It may also happen with signed numbers\n\nwhat is -6 - 7?\n1 0 0 0\n\nThis is OK!\n\n-1 0\n\n-2 1111\n1110\n-3 1101\n\n0000\n\nThe sign of\noverflow is the\nopposite sign\n\n-6\n\n1001\n\n0001\n0010\n\n0100\n0101\n0110\n1000\n\n4\n5\n\nwhat is 6 + 7?\n\n2\n\n0011\n\n-4 1100\n1011\n-5 1010\n\n1010\n+1001\n0011\n\n1\n\n0111\n\n-7 -8 7\n\n3\n\n6\n\nIf the result of adding two numbers with the\nsame sign results in the opposite sign,\nthere is overflow\n\n0 1 1 0\n\n0110\n+0111\n1101\n31\n\n\fSigned overflowing\n\nWhat about this?\nHow can we detect\nif operations with\ndifferent signs\noverflow?\n\n-1 0\n\n-2 1111\n1110\n-3 1101\n\n1001\n\n1\n0001\n0010\n\n2\n\n0011\n\n-4 1100\n1011\n-5 1010\n-6\n\nThis is impossible:\nMax positive = 7\n-1+7=6!\n\n0000\n\n0100\n0101\n0110\n1000\n\n0111\n\n-7 -8 7\n\n3\n4\n5\n\n6\n\n32\n\n\fHow many bits?\n\u25cf if you add two 2-digit decimal numbers, what's the\nlargest number you can get?\n\u25cf what about two 4-digit decimal numbers?\n\u25cf what about two 4-bit numbers?\n\u25cf what's the pattern of the number of digits?\no if you add two n-digit numbers in any base\u2026\no the result will have at most n + 1 digits\n\u25cf that means if we add two 32-bit numbers\u2026\no \u2026we might get a 33-bit result!\no if we have more bits than we can store in our\nnumber, that's overflow.\n\n99 9999\n+99 +9999\n198 19998\n1111\n+1111\n11110\n\nQ: How many bits do you need to represent -16 in 1s\u2019 complement?\nQ: How many bits do you need to represent -16 in 2\u2019s complement?\n\n33\n\n\fHandling overflow\n\u25cf we could ignore it\no in MIPS: addu, subu\no this is usually a bad idea\n\u25aa your program is broken\no it's also the default in most languages, thanks C\n\u25cf we could fall on the floor - i.e. crash\no in MIPS add, sub\no can be handled and recovered from\no but more complex\n\u25cf we could store that 33rd bit somewhere else\n\n34\n\n\fMaybe the bit bucket is a real place\u2026\n\u25cf many other architectures do this\no MIPS does not.\n\u25cf they have a \"carry bit\" register\no this can be checked by the program after an add/sub\n\u25cf this is very useful for arbitrary precision arithmetic\no if you want to add 2048-bit numbers, chain many 32-bit additions\n0 1 1 1\n\n0 0 0\n\n0 0 1 1 1\n\n1 0 0 0 0\n\n0010 1001\n+0001 1100\n0100 0101\n\n0010\n+0001\n0100\n\n1001\n+1100\n0101\n\nadd8bit\n\nadd4bit\n\nadd4bit\n\n35\n\n\fMore Bonkers\npublic class Main {\npublic static void main(String []args) {\nint w = Integer.MAX_VALUE;\nif (w + 1 > w) {\nSystem.out.println(\"This does not happen.\\n\");\n}\nint z = w + 1;\nif (z > w) {\nSystem.out.println(\"This does not happen.\\n\");\n}\nSystem.out.println(\"The end.\\n\");\n}\n}\nCS/COE 0449 \u2013 Spring 2019/2020\n\n36\n\n\fI have a book\n\n37\n\n\fWhat\u2019s the first page?\n\nHilarious,\nright?\n\n38\n\n\fThen\u2026\n\nWhat follows, chapter\n1?\n(it\u2019s not!)\n\nWhat number page\nnumber does it start at?\n(it\u2019s not \u201c2\u201d!)\n\n39\n\n\fIs it zero?\n\nWhere does it end?\n(nope!)\n40\n\n\fYikes\u2026.\n\nWhat can possible come\nafter zero?\n(How much is 0-1?)\n\n41\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}