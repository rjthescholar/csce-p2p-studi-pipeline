{"id": 141, "segment": "self_training_1", "course": "cs0447", "lec": "lec0B", "text": "#B\n\nMultiplication\nand Division\nOriginal slides by: Jarrett Billingsley\nModified with bits from: Bruce\nChilders, David Wilkinson\n\nCS 0447\nIntroduction to\nComputer Programming\n\nLu\u00eds Oliveira\n\nFall 2020\n\n\fClass announcements\n\n2\n\n\fMultiplication by repeated addition\n\u25cf in A \u00d7 B, the product (answer) is \u201cB copies of A, added together\"\n\n3 \u00d7 6 = 18\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9 10 11 12\n\n13 14 15 16 17 18\nhow many additions would it take to calculate\n\n2 x 500,000,000?\n\n3\n\n\fBack to grade school\n\n\u25cf remember your multiplication tables?\n\u25cf binary is so much easier\n\u25cf if we list 0 too, the product logic looks awfully familiar\u2026\n\u2715\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n1\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n2\n\n2\n\n4\n\n6\n\n8 10 12 14 16 18\n\n3\n\n3\n\n6\n\n9 12 15 18 21 24 27\n\n4\n\n4\n\n8 12 16 20 24 28 32 36\n\n5\n\n5 10 15 20 25 30 35 40 45\n\n6\n\n6 12 18 24 30 36 42 48 54\n\n7\n\n7 14 21 28 35 42 49 56 63\n\n8\n\n8 16 24 32 40 48 56 64 72\n\n9\n\n9 18 27 36 45 54 63 72 81\n\n\u2715\n\n1\n\n1\n\n1\n\nA\n0\n0\n1\n1\n\nB P\n0 0\n1 0\n0 0\n1 1\n4\n\n\fJust like you remember\n\u25cf you know how to multiply, riiiight?\n\nthese are partial\nproducts. how\nmany additions\nare we doing?\n\n0101 =\n\u00d7 0110 =\n0000\n01010\n010100\n000\n0000___\n0011110\n\n5 Multiplicand\n\u00d7 6 Multiplier\n30\nwait, what operation\nare we doing here...?\n\n5\n\n\fWait, why does this work?\n\u25cf what are we actually doing with this technique?\n\u25cf remember how positional numbers are really polynomials?\n\nFOIL\u2026\n\n78\u00d754 = 70\u00d750 + 70\u00d74 + 8\u00d750 + 8\u00d74\nwe're eliminating many addition\nsteps by grouping them together.\n\n= 78\u00d750 + 78\u00d74\nwe group them together by\npowers of the base.\n\n6\n\n\fHow many bits?\n\n\u25cf when we added two n-digit/bit numbers, how\nmany digits/bits was the sum?\n\u25cf how about for multiplication?\n\u25cf when you multiply two n-digit/bit numbers,\nthe product will be at most 2n digits/bits\n\u25cf so if we multiply two 32-bit numbers\u2026\no we could get a 64-bit result! AAAA!\no if we just ignored those extra 32 bits, or\ncrashed, we'd be losing a lot of info.\no so we have to store it.\n\n99\n\u00d7 99\n9801 9999\n\u00d7\n9999\n99980001\n1111\n\u00d7\n1111\n11100001\n7\n\n\fHow (and why) MIPS does it\n\u25cf MIPS has two more 32-bit registers, HI and LO. if you do this:\n\nmult t0, a0\n\n\u25cf then HI = upper 32 bits of the product and LO = lower 32 bits\n\u25cf to actually get the product, we use these:\n\nmfhi t0 # move From HI (t0 = HI)\nmflo t1 # move From LO (t1 = LO)\n\n\u25cf the mul pseudo-op does a mult followed by an mflo\n\u25cf MIPS does this for 2 reasons:\no multiplication can take longer than addition\no we'd otherwise have to change two different registers at once\n\u25cf if you wanted to check for 32-bit multiplication overflow, how could you do\nit?\n8\n\n\fSigned multiplication\n\n9\n\n\fGrade school (but like, 6th, instead of 3rd)\n\u25cf if you multiply two signed numbers, what's the rule?\n\nProduct\n\nA B\nP\n3\n5 15\n3 -5 -15\n-3\n5 -15\n-3 -5 15\n\nSign\n\nA\n+\n+\n-\n\nB\n+\n+\n-\n\nS\n+\n+\n\nif the signs of the\noperands differ, the\noutput is negative.\n\n10\n\n\fDon't repeat yourself\n\u25cf we already have an algorithm to multiply unsigned numbers\n\u25cf multiplying signed numbers is exactly the same (except for the signs)\n\u25cf so why not use what we already made?\n\nlong prod = unsigned_mult(abs(A), abs(B));\nif(sgn(A) == sgn(B))\nreturn prod;\nelse\nreturn \u2013prod;\n\n11\n\n\fDivision\nLike multiplication, except\u2026 not really\n\n12\n\n\fIf multiplication is repeated addition\u2026\n\u25cf \u2026is division repeated subtraction?\no yes. it is.\n\u25cf in A \u00f7 B, the quotient (answer) is \"how many times can you\nsubtract B from A until you can't anymore?\"\n\n20 \u00f7 3 = 6 R 2\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\nwhat about\nthese lil guys?\n\nhow many subtractions would it take to calculate\n\n1,000,000,000 \u00f7 2?\n\n13\n\n\fThat's not what you learned in school, was it\n\u25cf You learned something a tiiiiiny bit more complicated\n\n005 4 R51\n77 4209\n- 3 8 5 =77\u00d75\n359\n- 3 0 8=77\u00d74\n51\nFinally!!\n14\n\n\fWhat's going on?\n\u25cf division is multiplication backwards. it's like ctrl+z.\n\nfinding the partial products\n77 we're\nthat add up to a total product\n\u00d754\ndivision goes left-to-right because we find the\npartial products from biggest to smallest\n308\nand to make it even more interesting,\n3850\nthere might be a remainder\nand then there's division by 0.\n4158\n+R51 multiplication is multiplying polynomials.\ndivision is factoring polynomials.\n4209\n15\n\n\fAnother way of looking at it (animated)\n\u25cf let's say we want to do\u2026 (calculating random number)\u2026 696\u00f74\n\nfirst we ask how\nmany 400s fit\nthen how many 40s\nthen how many 4s\nso we're saving time\nby doing groups of\nsubtractions from\nbiggest to smallest\n\n1\n\n40\n\n40\n\n40\n\n7\n4\n\n40\n\n400\n\n40\n\n4\n4\n4\n4\n\n40\n40\n16\n\n\fThanks, tiny multiplication table. Thable.\n\u25cf at least multiplication in binary is easy, which simplifies division\n\n0 0 0 0 1 1 0R 1\n1100 1001001\n-1100\n1100\nin binary, each step becomes a\n1\n1\n0\n0\nyes-no choice: does the divisor fit\n01\ninto the remainder?\n17\n\n\fDivisor? Dividend? Remainder?\nthe divisor\ndivides the\ndividend\n\nthe dividend is\nthe number that is\nbeing divided\n\n1100 1001001\n-1100\nthe remainder is the\nnumber we're trying to\nthis is the new\n0\n1\n1\n1\n0\nfit the divisor into\nremainder.\nit starts off as the\ndividend\u2026\n\nbut really, when we\nsubtract something, we\nare making the\nremainder smaller.\n\n18\n\n\fFinding partial products, biggest to smallest (animated)\nessentially we're starting with the divisor shifted\nall the way left, and sliding it right\n\n0 0 0 0 1 1 0R 1\n1100 100\n11001\n1100000000\nso let's ALGORITHM-IZE IT\n\n19\n\n\fA few more odds and ends\n\n20\n\n\fDivide-and-conquer\u2026 in parallel\n\n\u25cf an n\u00d7n digit multiplication can be broken into n, n\u00d71 digit ones\n\u25cf the partial products can be summed in any order (thanks, commutativity)\n\n1011\u00d70101 =\n1011\u00d71\n+\n\n1011\u00d70\n\n+1011\u00d7100\n\n+\n\n1011\u00d70\n\nall operations in the same\ncolumn can be done in parallel.\n\n+\n+\n+\n\nnow our multiplication takes\nonly 3 steps instead of 4.\nbut this is a O(log(n))\nalgorithm! so for 32 bits\u2026\nit takes 6 steps instead of 32!\n21\n\n\fBut division\u2026\n\u25cf if we try to do something similar, well\u2026\nwhat's the difference between\naddition and subtraction?\nsubtraction is not commutative.\n\n1011\u00f7101 =\n1011\u00f7101000 = 0\nyou can do the steps in any\norder\u2026 but you can't do\n1011\u00f710100 = 0\nthem at the same time.\n1011\u00f71010 = 1 R 1\n1011\u00f7101 = 1 R 110??\n\nwe cannot know the\nanswer to this step\u2026 \u2026until we know the answer\nto the previous one.\n\n22\n\n\fDivision is fundamentally slower\n\u25cf each step depends on the previous one.\n\u25cf we cannot split it up into subproblems like with multiplication.\n\u25cf the only way to make division faster is to guess.\no SRT Division is a way of predicting quotient bits based on the next few bits\nof the dividend and divisor\no but it can make mistakes and they have to be corrected\no the original Pentium CPU in 1994 messed this up\n\u25aa and Intel pretended everything was OK\n\u25aa and people got mad\n\u25aa and they had to recall millions of them\n\u25aa and Intel lost half a billion dollars\n\u2013 lol\n\n23\n\n\fDoing modulo with AND\n\u25cf in decimal, dividing by powers of 10 is trivial.\n\n53884 \u00f7 1000 = 53 R 884\n\u25cf in binary, we can divide by powers of 2 easily with shifting\n\u25cf and we can get the remainder by masking!\n\n10010110 \u00f7 1000 = 10010 R 110\n10010110 >> 11 = 10010\n10010110 & 0111 = 110\nmore generally: a AND (2n-1) = a % 2n\nmore generally: a AND ((1<<n)-1) = a % 2n\n24\n\n\fSigned division\n\n25\n\n\fAll roads lead to Rome\u2026 er, the Dividend\n\u25cf how did we extend our multiplication algorithm to signed numbers?\n\u25cf but how exactly do the rules work when you have two results?\nthe four values are related as:\nDividend = (Divisor \u00d7 Quotient) + Remainder\nIf you do\u2026 Java says\u2026 Python says\u2026\n\n7 / 2\n7 / -2\n\n3 R\n-3 R\n\n1\n1\n\n3 R 1\n-4 R -1\n\n-7 / 2\n-7 / -2\n\n-3 R -1\n3 R -1\n\n-4 R 1\n3 R -1\n\nmathematicians would\nexpect the remainder\nto always be positive,\nso the last row would\nbe 4 R 1!\n\ncheck out https://en.wikipedia.org/wiki/Modulo_operation for this travesty\n\nIn Java -7/2 = -(7/2)\nIn Python -7/2 \u2260 -(7/2)\n26\n\n\fWhaaaaaaaaaaaaaaaat\n\u25cf no, really, it's not well-defined. there's no \"right\" answer.\n\u25cf watch out for this.\no I think I ran into it once because I was doing maths with angles in the\nrange [-pi, pi)\no most of the time, when you're dealing with modulo, you're dealing with\npositive values\no Most languages I had used did (-7 / 2) as -(7 / 2)\n\u25aa this is \"truncated division\" (rounds towards 0)\no but Python is gaining popularity and can sometimes be confusing\n\u25aa it uses \"flooring division\" (rounds towards -\u221e)\n\u25cf so which does arithmetic right shift do?\no it does flooring division.\n\n27\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}