{"id": 158, "segment": "self_training_1", "course": "cs0447", "lec": "lec0F", "text": "#F\n\nLatches\n\nCS 0447\nIntroduction to\nComputer Programming\n\nLu\u00eds Oliveira\nLuis Oliveira\nOriginal slides - wilkie\n(with content borrowed from: Jarrett Billingsley and Bruce Childers)\n\nFall 2020\n\n1\n\n\fAnnouncements\n\n2\n\n\fThe Latch\n\n3\n\n\fWhat the heck\n\u25cf Time to blow your mind.\n\u25cf Let\u2019s look at this circuit.\no Yes, you can do this.\n\nR\n\nS\n\nQ\n\nQ\n4\n\n\fWhat the actual heck\n\u25cf What is this in combinational logic??\n\no Q = R + (S + (R + (S + (R + (\u2026 oh gosh. Hmm\n\u25cf This makes no sense (from a combinational point of view)\n\nR\n\nS\n\nQ\n\nQ\n5\n\n\fS/R Latch\n\u25cf The feedback behavior allows it to \u201cstore\u201d a value.\n\no \u201c1\u201d on S will set Q to \u201c1\u201d, and \u201c1\u201d or R will reset Q to \u201c0\u201d\no It becomes stable at that value, hence, it is an S/R Latch.\no It\u2019s really heckin\u2019 neat.\n\nR\n(reset)\n\nQ\n\n(set)\nS\n\nQ\n6\n\n\fS/R Latch (animated)\n\u25cf Currently, the value is \u201c0\u201d, and we can change it to \u201c1\u201d by sending a \u201c1\u201d on S\n\nR\n(reset)\n\n0\n1\n\n1\n\n0 Q\n\nNOR\n\nStable Feedback\n\n(set)\nS 1\n\n0\n\n0\n\n0\n\n1 Q\n7\n\n\fS/R Latch (animated)\n\u25cf Currently, the value is \u201c1\u201d, and we can maintain it by having R and S be \u201c0\u201d\n\u25cf If the value was \u201c0\u201d, this would also maintain that value.\n\u25cf This is the \u201clatch\u201d operation. This is how an S/R Latch can \u201cstore\u201d a value.\n\nR\n(reset)\n\n0\n0\n\n1\n\nQ\n\nNOR\n\nStable Feedback\n\n(set)\nS 0\n\n1\n\n1\n\n0\n\nQ\n8\n\n\fS/R Latch (animated)\n\u25cf Currently, the value is \u201c1\u201d, and we can change it to \u201c0\u201d by sending a \u201c1\u201d on R\no And having S be \u201c0\u201d\n\nR 1\n(reset)\n\n0\n\n0\n\n1 Q\n\nNOR\n\nStable Feedback\n\n(set)\nS\n\n1\n0\n\n1\n\n0 Q\n9\n\n\fS/R Latch (animated)\n\u25cf Hmm, let\u2019s set R and S to \u201c1\u201d at the same time.\n\u25cf And then let\u2019s set them both to \u201c0\u201d afterward. (That should be stable\u2026 right?)\n\u25cf Oh no. Oscillation. Q is\u2026 both\u2026 0 and 1\u2026 ??? Kinda???\n\nR 0\n1\n(reset)\n\n1\n\n1\n0\n\nQ\n\nNOR\n\nStable Feedback\n(but illogical)\n\n(set)\nS 1\n0\n\n0\n\n0\n\n0\n1\n\nQ\n10\n\n\fS/R Latch: The Whole Truth\n\ntable\n\n\u25cf The state of this logic depends on the prior state.\no Q here is the current value of Q\no Qnext will be the new value.\n\u25cf This is an example of sequential logic.\no On your own: You can build it out of NANDs\nas well. Try to come up with that.\n\nR\n(reset)\n\nQ\n\n0\n0\n1\noh no\n\n1\n0\n1\n\n(set)\nS\n\nQ\n\naaaa\n11\n\n\fLet\u2019s look at some circuits\n\u25cf sr_latch.circ\n\n\u25cf Factorio latch\n0eNrtV8GOmzAQ/ZVqzlCB2ZANUvsFPbXHqkIOTJKRjEHGREUR/14bWjYb1iyhP\nWylPYTI2J558948AxfYiwYrRVJDcgHKSllD8v0CNR0lF/aebiuEBEhjAR5IXthRjhnlqP\nysLPYkuS4VdB6QzPEnJGH3wwOUmjThEK0ftKlsij0qs2CMY/NpLvV1IA+qsjZ7S2n\nTm3h+5EFr/kKTwmzQqhTpHk/8TGa1WXIgoVE5cJ9J6cbcGVMOK3yFOfTxGlt6eA\n1+SCMxsxhqGyu0l6NClNflUA4JM2tJZQ3pfmh3d503qZjNMTctOPi4eSo5JzVAGb\nK9QMDvmKmZy2kEfSBV63QxIUN5Q+29JpAEdlBUXPUwE/hkNpWNrpp1Yas27el\nOD6osUpImDiQHLmrsHJRbkW4Ij24J955Nx8+nmW3FF4W73RhNhfSALQPB5kG\n4miJa2RTsTTXF5xVNMZrvn7TE1IPeYrO6NWbzGm8coj481VpwIXzBi2oqZjh/ov1J\nPGq3QjouW30ieXxNPTPd1GhSidKeoVo1uJx6FwubEU2BOTWFj8JEU5T5VSnQyQ\ndbfQ7cyvPgABav81z4brl7zLFb6sjdXzjy9gTfzoNgjo7Y3tmqbGyIhVzF81yFgQPY4\n6q3JPYGX5J2y56Hu3XeZO/vSPMd57ZfPO+ox1k7xsv8FQZ3PBHZ//5A3PYsGL777\n6Xk6vPKA8H3aIDCV//bhy9cZydz72w82ZezjYJwE8X213W/ABNorVw=\n12\n\n\fLet\u2019s look at some circuits\n\u25cf Factorio power latch\n0eNrtWM2OmzAQfpVqzlBh8o+0K/XeQ+9VhRyYbCwZGxmTNop4gL5Hn6xPUh\nu6bBrCbyMlhz2EyMb+5ht/M2ObE2x5jqliQkNwAhZJkUHw9QQZexGU2z59TBEC\nYBoTcEDQxLZijFiMyo1ksmWCaqmgcICJGH9AQIpvDqDQTDOs0MrGMRR5skVlBt\nQ41p6mQp8DOZDKzMyVwpo3eO7MgaP9MybMBK0kD7e4pwdmRpshO8Y1qh\nbeB6Z0bnpqk9UI9xOUaLl1nHjeOfnKjMDIcsgsFrEPhfG5M8y0DLGIqShnumzauU\nXhNPz1u9at6S75uKgcJoZJzFRFpIS55v5fzNC8i1lNecdUpsOxy1GpAcFmY1tJSlXJ\nMYBnM0PmOs1HYL4oRFHhpsewXOtwp2QSMmFwINhRnmHxH6vt/PN61RTDAd\n9iVUS60fwLtPkwaWcTpfUfR9rfP39NENfqcztp/W5p+7T0L7W8LtZ8lFjeHdLwLGVe\n9fIu5Hp6gExcdMu1bsjhDNTN6TZTR0E/p0usZTfHtvxeTAsZ/6FC5vnu+d2spi0RM\nR8j+XxY2i9r3xKMWZ64yA1lxSI3lRybKvpvaT/NvcvY27QQW03bPO53LCDeTfaOW\n5ejvt3DG3cyWI+Dawu79aTSQd4rx5jUImRoZVmNBhpeeUgPWFuIbN7WLqGcu5\nwmaVs98lpuP6926lCYEAlUHPWeiZe+YDCv8wyNKS7tfUurHIcruWxZBJtPU8qg/z\nhl8P5pMvLysxoWn4RMqmH++4G5b0tpq1LrMVVofU1Fg1x+qwnOPu04wOkWje\nPwRX5H9eEz1dHe9B5QZaVEq5lHFrOl/RXFHz5GPCg=\n13\n\n\fKeeping Everything In Order\n\nThe Clock\n\n14\n\n\fPropagation Delay (Basics)\n\u25cf Ok. Q at t=0 is different than at t=1.\n\u25cf How long does it take for a change to occur?\no (How much time is really between t=0 and t=1)\n\u25cf This is bounded by propagation delay.\n\nR\n(reset)\n\nQ\n\n(set)\nS\n\nQ\n15\n\n\fPropagation Delay\n\u25cf Propagation delay is the time it takes for a signal to pass from the inputs\nto the outputs\n\u25cf During that delay, the outputs are invalid (they can fluctuate)\n\u25cf After that delay, the outputs are valid\n\u25cf If you try to use the output while it's invalid, things break\no stuff like 2 + 2 = 17??\n\n16\n\n\fThe Critical Path\n\u25cf The critical path is the path through a circuit that has the longest series of\nsequential operations\n\u25cf The longest propagation delay\no they depend on each other and can't be done in parallel!\n\n17\n\n\fS/R Latch (animated)\n\nR\n\nS1\n\nS 0\nQ\n\n1\n\nQ 0\ntime\n\n0\n1\n\n1\n\n1\n\nQ\n\n0\n0\n\n0\n\n0\n\nQ\n\n1\n0\n\n1\n18\n\n\fPropagation Delay (Basics)\n\u25cf If we have a component after this S/R latch that reacts to the data on Q\u2026 we\nneed it to synchronize.\no We need it to wait until the Q value is updated.\n\u25cf One method: something that periodically and predictably updates in an\ninterval that\u2019s a little longer than the propagation delay.\n\nR\n(reset)\n\nQ\n\n(set)\nS\n\nQ\n19\n\n\fTick Tock\n\u25cf Sequential logic is based on time, and time is continuous\n\u25cf Trying to build sequential circuits without anything to keep\ncircuit\ntrack of time is\u2026 possible, but very very difficult\nsymbol\n\u25cf This is why we use a clock signal: it goes 0, 1, 0, 1, 0, 1\u2026\no Oscillation\u2026 on purpose this time.\nEach period is called a clock cycle.\no We typically electrocute rocks to do this, as usual. (poor rocks \uf04c)\n\n1\nHigh\n\n0\n\ntime\n\nLow\n\nwe can synchronize our circuits to a clock state:\nwhen it is high (1) or low (0)\n\n20\n\n\fAdding a Clock\n\u25cf We need to augment our latch to wait for the clock before updating the\nvalue.\n\u25cf We need to account for the clock signal and only transmit a \u201c1\u201d on R or S if\nand only if the clock is high (or low).\n\u25cf Which leads us to something like this maybe\u2026\no But let\u2019s refine it a bit\u2026 (btw, how complex is this? How many transistors?)\n\nR\n\nR\n\nQ\n\nC\nS\n\nS\n\nQ\n21\n\n\fD(ata) Latch\n\u25cf If we do something like this, we simplify our S/R Latch into a nicer\nsynchronized latch called a D-Latch.\n\u25cf \u201cC\u201d is the clock. \u201cD\u201d is the data to latch when the clock is high.\n\u25cf Circuit only changes the value when the clock signal is 1\u2026\no Latches when clock is 0!\n\nC\n\nD\n\nR\n\nS\n\nQ\n\nQ\n22\n\n\fD Latch\n\u25cf When clock is low and D is \u2026 don\u2019t care!\no Nothing changes\n\nC\n\nD\n\nR\n\nS\n\nQ\n\nQ\n\n23\n\n\fD Latch\n\u25cf When clock is high and D is high\no It\u2019s a set operation\n\nC\n\nD\n\nR\n\nS\n\nQ\n\nQ\n\n24\n\n\fD Latch\n\u25cf When clock is high and D is low\no It\u2019s a reset operation\n\nC\n\nD\n\nR\n\nS\n\nQ\n\nQ\n\n25\n\n\fD Latch\n\u25cf We can abstract this away and start using this symbol:\n\nD\n\nQ\n\nC\n\nQ\n\n26\n\n\fD Latch\n\u25cf We often omit the \u201cC\u201d for the clock and use a triangle instead:\no Sometimes you\u2019ll see a square instead. Logisim uses triangles.\n\nD\n\nQ\nD Latch\nQ\n\n27\n\n\fTick Tock: D Latch\n\u25cf This diagram shows the behavior of the system over time.\no This is \u201chigh\u201d triggered.\no Note the propagation delay. And how Q depends on D AND clock.\n\nD\n\n1\n\n0\n\nC\n\n1\n\n0\n\nQ\n\n1\n0\n\ntime\n\n28\n\n\fProblems: Owner of a lonely (D) Latch\n\u25cf What if we don\u2019t want to change the value of Q.\no This means we have to constantly recharge the value, that is \u201cD\u201d has to be\nwhat we want Q to be every tick, limiting the usefulness.\n\u25cf We need a way to enable or disable the update.\n\nC\n\nD\n\nQ\n\nQ\n29\n\n\fProblems: Owner of a lonely (D) Latch\n\u25cf We could simply add a signal that we usually keep \u201c0\u201d and only allow the\nlatch when that \u2018write enable\u2019 (W) signal is \u201c1\u201d\n\nW\nC\n\nQ\n\nD\n\nQ\n30\n\n\fLet\u2019s look at some circuits\n\u25cf Weird behaviour when clock is used in logic!!\no Note: N-e-v-e-r, never ever, connect logic to a clock port.\n\u25aa It\u2019s hard to predict the behavior of circuits!\n\n\u25cf d_latch.circ\n\u25cf broken_latch.circ\n\n31\n\n\fAnd The Flip-Flop\n\n32\n\n\fThe New Problem\n\u25cf Remember propagation delay? Pesky thing, that.\n\u25cf Clocks don\u2019t always help.\no We sometimes need a clock cycle to compute a value\no \u2026and then another clock cycle to compute the next thing.\no \u2026but the next thing needs to be computing the CURRENT thing.\no \u2026but we would overwrite that input\u2026 so it would compute something else\no \u2026before it was done computing the first thing\u2026\n\u25cf AHHHHH!!!!!\n\n33\n\n\fWaiting for Godata\n\u25cf We want to record an intent to store (latch) a value.\no That is, to delay the latch by around a cycle.\n\u25cf (But only actually do it at an idle moment)\no When do we have an idle moment in the latch???\n\u25aa When the clock is low!!\n\u25cf If we cascade two D-Latches, and cleverly handle the clock\u2026\no We can create a register! (Specifically, a D Flip-Flop)\n\u25aa Yes, that\u2019s actually what it is called. \u263a\n\n\u25cf We will create a component that latches a value on the clock\u2019s falling edge.\no You can also make a rising edge D Flip-Flop by inverting the clock signal.\n34\n\n\fThe D Flip-Flop\n\u25cf While the clock is \u201c1\u201d (high), D\u2019 can be computed while Q remains unaffected.\no Q is being used, after all, by whatever component is after the flip-flop\no While D is not immediately known and is being computed by the\ncomponent before the flip-flop\n\u25cf Falling clock edge: value is copied from the first latch to the second.\no This handles data propagation within a sequential circuit.\n\nD\nC\n\nD\n\nQ\nD Latch\n\nQ\n\nD\u2019\n\nD\nD Latch\n\nQ\n\nQ\n\nQ\n\nQ\n35\n\n\fTick Tock\n\u25cf In this example, we are using the clock edges\no The circuit only updates its output in the instant the clock changes!\n\u25cf During the remaining time, other circuits\ncan compute the values\n\nrising edge\n\n1\n\n0\n\ntime\n\nfalling edge\n\nwe can synchronize our circuits to a clock edge:\nwhen it changes between 0 and 1\n\n36\n\n\fTick Tock: Falling Edge D Flip-Flop\n\u25cf This diagram shows the behavior of the system over time.\no This is \u201cfalling edge\u201d triggered.\no Note the propagation delay. And how Q depends on D && clock.\n\nD\n\n1\n\nA Flip-Flop doesn\u2019t race \u201cD\u201d\n\n0\n\nC\n\n1\n0\n\nQ\n\n1\n0\n\nQ remains stable while clock\nremains high and low\n\ntime\n\n37\n\n\fThe D Flip-Flop\u2026 Abstracted\n\u25cf We can of course reduce the flip-flop\u2026 it looks the same as the D Latch.\no This is effectively a 1-bit Register!\no That is, it is a simple 1-bit volatile memory cell.\n\nD\n\nQ\nD Flip-Flop\n\nQ\n38\n\n\fLet\u2019s look at some circuits\n\u25cf D_flip_flop.circ\n\u25cf broken_latch.circ \u2026 again\n\n39\n\n\fReal-world clocking issues\n\n40\n\n\fDetermining clock speed\n\nD\n0ns\n\nQ\nR\n\n2ns\n\nA\n1\n\nB\n\nS\n5ns\n\ntime\n\nR is\nclocked\n\nR\u2019s Q\nbecomes\nvalid\n\nthe adder has\nfinished; clock\nR to store\n41\n\n\fDetermining clock speed\n\u25cf It takes 5ns for a signal to propagate through our circuit\n\u25cf How fast can we clock it?\no if the time between clocks is less than 5ns, we'll clock the register too\nearly (while the adder's outputs are invalid)\no if the time between clocks is more than 5ns, no big deal\n\n\ud835\udfcf\n\ud835\udfd7\n=\n\ud835\udfce.\n\ud835\udfd0\n\u00d7\n\ud835\udfcf\ud835\udfce\n\ud835\udc07\ud835\udc33\n\u2212\ud835\udfd7\n\ud835\udfd3 \u00d7 \ud835\udfcf\ud835\udfce \ud835\udc94\n= \ud835\udfd0\ud835\udfce\ud835\udfce\ud835\udc0c\ud835\udc07\ud835\udc33\n\n\u25cf The fastest we can clock a sequential circuit is the reciprocal of the\ncritical path's propagation delay\n\n42\n\n\fClock Skew\n\u25cf The clock signal itself isn't immune to propagation delay!\n\nCLK\n\nwatch the input as the\nIN\nclock pulse travels down\n12\n??? the wire to B.\nD Q\nD Q\n???\n12\nEN\nEN\nB\nA\n\n\u25cf This is a race condition: the data and clock are having a race, and\nthe outcome depends on who wins\no the winner could change based on temperature, power, etc!\n43\n\n\fSummary\n\n44\n\n\fThe S/R Latch \u2026 Abstracted\n\u25cf We now know the S/R Latch!\no Allows you to store a value (1/0) but with a pit fall!\no It could turn into an oscillator if input an invalid combination\n\u25aa R=S=1 \u2794 R=S=0\n\nR\n\nS\n\nS/R latch\n\nQ\n\nQ\n\n45\n\n\fThe D Latch \u2026 Abstracted\n\u25cf We improved it by adding some input logic\no Creating the D Latch\no But it was transparent (active) during the high clock state\n\nD\n\nQ\nD Latch\n\nQ\n46\n\n\fThe D Flip-Flop\u2026 Abstracted\n\u25cf Lastly, we saw the heroic D Flip-Flop!\no This is effectively a 1-bit Register!\no That is, it is a simple 1-bit volatile memory cell.\n\nD\n\nQ\n\nQ\n\nD\nD Latch\n\nQ\n\nD Flip-Flop\n\nD\n\nQ\nD Latch\nQ\n\nQ\n47\n\n\fCircuits using Flip-Flops\n\n48\n\n\fCreating an Adder Circuit\n\u25cf Suppose we want to (for 1 bit):\no Have three 1-bit registers: A, B, C\no Compute: C = A + B\n\u25cf We would need:\no Three D Flip-flops (for A, B, and C)\no A 1-bit adder\no What is the circuit?\n\n49\n\n\fRegister-backed 1-bit Adder\nA Register\nD\n\nQ\n\nD Flip-Flop\nQ\nB Register\nD\n\n(assume clock is connected)\n\nQ\n\nA\n\nS\n\nHalf-Adder\nB\nC\n\nC Register\nQ\n\nD Flip-Flop\nQ\n\nD Flip-Flop\nQ\n50\n\n\fRegister-backed 1-bit Adder\n(assume clock is connected)\n\nD\n\nQ\n\nD Flip-Flop\nQ\n\nA Register\n\nB Register\nD\n\nQ\n\nD Flip-Flop\nQ\n\nA\n\nS\n\nHalf-Adder\nB\nCo\n\u25cf What is the difference here?\n\u25cfA=A+B\n\u25cf This is fairly conventional\nsequential logic, actually.\n\n51\n\n\f4-bit Counter\n\u25cf Another simple component we can now build is a counter.\n\u25cf This is a register that increments every clock tick.\no On the falling-edge, in this case. (assume clock is connected)\n0\n\nA\nCo\n\nAdder\n\nS\n\nB\n\n0\n\nA\n\nCi\n\nCo\n\nQ\n\nD\n\nD\n\nD Flip-Flop\n\n3rd bit\n\nAdder\n\nS\n\nB\n\n0\n\nA\n\nCi\n\nCo\n\nQ\n\nD\n\nD Flip-Flop\n\n2nd bit\n\nAdder\n\nS\n\nB\n\n0\n\nA\n\nCi\n\nCo\n\nQ\n\nD\n\nD Flip-Flop\n\n1st bit\n\nAdder\n\nS\n\nB\nCi\n\n1\n\nQ\n\nD Flip-Flop\n\n0th bit\n\n52\n\n\f4-bit Counter: Thoughts\n\u25cf Hmm, adding takes some time because it ripples\n\u25cf Hmm, how long does our clock cycle have to be?\no No shorter than the propagation delay.\no If you assume latches take 2ns and adders take 4ns\u2026\n0\n\nA\nCo\n\nD\n\nAdder\n\nS\n\nB\n\n0\n\nA\n\nCi\n\nCo\n\nQ\n\nD\n\nD Flip-Flop\n\nAdder\n\nS\n\nB\n\n0\n\nA\n\nCi\n\nCo\n\nQ\n\nD\n\nD Flip-Flop\n\nAdder\n\nS\n\nB\n\n0\n\nA\n\nCi\n\nCo\n\nQ\n\nD\n\nD Flip-Flop\n\nAdder\n\nS\n\nB\nCi\n\n1\n\nQ\n\nD Flip-Flop\n\n53\n\n\f4-bit Counter: Clocking\n\n0ns\n2ns\n\n1\n\n0\n0\n\nA\nCo\n\nD\n\nD B\n\nAdder\n\nS\n\n0\n\nCi\n\nQ\n\nD Flip-Flop\n\n0\nD\n\nA\nCo\n\nD Latch\n\nQ\nAdder\n\nS\nQ\n\nB\n\n0\n\nD\n\nQ\n\nD Flip-Flop\n\nA\nCo\n\nCi\n\nD Flip-Flop\nD\n\n0\n\nQ\n\nD Latch\n\nD\nQ\n\n0\n\nQ\n\nB\n\nS\n\nCi\n\nCo\n\nQ\n\nQ\n\nD\n\nAdder\n\n1\n\nD Flip-Flop\n\nA\n\nAdder\n\nS\n\n0\n\nB\nCi\n\n1\n\nQ\n\nD Flip-Flop\n54\n\n\f4-bit Counter: Clocking\n1\n\n12ns\n10ns\n14ns\n18ns\n16ns\n20ns\n2ns\n8ns\n6ns\n\n0\n0\n\nA\n\n0\n\nCo\n\nD\n\nAdder\n\nS\n\n0\n\n0\n\nB\nCi\n\nQ\n\nD Flip-Flop\n\n0\n\n0\n\nA\nCo\n\nD\n\nAdder\n\nS\n\n0\n\n0\n\nB\nCi\n\nQ\n\nD Flip-Flop\n\n0\n\n0\n\nA\nCo\n\nD\n\nAdder\n\nS\n\n1\n\n0\n1\n\nB\nCi\n\nQ\n\nD Flip-Flop\n\n0\n\n1\n\nA\nCo\n\nD\n\nAdder\n\nS\n\n1\n0\n\n0\n\nB\nCi\n\n1\n\nQ\n\nD Flip-Flop\n55\n\n\f4-bit Counter: Circuit Delay\nSerialized\n0\n\nA\nCo\n\nD\n\nAdder\n\nS\n\n4ns + 4ns + 4ns + 4ns\nB\n\n0\n\nA\n\nCi\n\nCo\n\nQ\n\nD\n\nD Flip-Flop\n\nParallelized\n\nAdder\n\nS\n\nB\n\n0\n\nA\n\nCi\n\nCo\n\nQ\n\nD\n\nD Flip-Flop\n\n2ns + 2ns\n\nAdder\n\nS\n\nB\n\n0\n\nA\n\nCi\n\nCo\n\nQ\n\nD\n\nD Flip-Flop\n\nAdder\n\nS\n\nB\nCi\n\n1\n\nQ\n\nD Flip-Flop\n\n20ns\n\n56\n\n\f4-bit Counter: Delay Explanation\n\u25cf Values of output bits must all be stable.\no That is, can\u2019t pulse clock until all 4 bits are computed\n\u25cf However, the adder is a ripple-carry: Each bit waits for previous.\no 4ns per adder\no 4-bit adder\no Thus: 4 * 4ns = 16ns for the 4-bit adder\n\u25cf Flip-Flops\no Must wait for 1st latch to stabilize Q (2ns in parallel)\no Must wait for 2nd latch to stabilize Q (2ns also in parallel)\no Thus: 2ns + 2ns = 4ns\n\u25cf Overall delay: 16ns + 4ns = 20ns. Clock pulse is 20ns.\n\n57\n\n\fDetermine Maximum Clock Speed\n\u25cf If this operation takes 20ns, this bounds our clock speed.\n\u25cf Our clock period must be 20ns.\no Which means our frequency is once every 20ns: 1s \u00f7 20ns\no What is that frequency in Hz? (Hertz is \u201ccycles per second\u201d)\n\no This would be the maximum clock speed for our circuit to work.\n\n1\ud835\udc60\n= 50,000,000 \ud835\udc3b\ud835\udc67 = 50 \ud835\udc40\ud835\udc3b\ud835\udc67\n20\ud835\udc5b\ud835\udc60\n\n58\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}