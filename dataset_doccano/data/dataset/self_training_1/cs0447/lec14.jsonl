{"id": 168, "segment": "self_training_1", "course": "cs0447", "lec": "lec14", "text": "#14\nCS 0447\nIntroduction to\nComputer Programming\n\nThe single-cycle CPU\nOriginal slides by: Jarrett Billingsley\nModified with bits from: Bruce\nChilders, David Wilkinson\n\nLu\u00eds Oliveira\n\nFall 2020\n\n\fClass announcements\n\u25cf OMETs don\u2019t forget them!\n\n2\n\n\fThe single-cycle machine\n\u25cf we\u2019ve been talking about a single-cycle machine and building one for project 3\n\u25cf this means each instruction takes one clock cycle to execute\n\nadd t0, t1, t2\n\nsb t0, 4(s0)\n\nstore sum in t0\ndo the addition...\n\ncalculate the\naddress...\n\nstore value\nin memory\n\nIn this example each instruction ends on the rising edge of the clock\n\nsince that's when the registers store their values\n\n3\n\n\fA global view\n0\nM\nu\nx\nALU\nAdd result\n\n+\n\n4\n\n4\n\nimmediate\n(jump target) PCSrc\n\nPC\n\n31-26\n\nAdd\n\n25-21\n\nPC\nInstruction [31 26]\n\nInstruction 32\nMemory\n\nRead\naddress\n\nControl\n\n15-11\n10-6\n\nInstruction [25 21]\n\n5-0\n\nInstruction [20 16]\n\n15-0\n\nInstruction\n[31\u2013 0]\nInstruction\nmemory\n\n20-16\n\n25-0\nM\n0\n\nInstruction [15 11]\n\nu\nx\n1\n\nopcode\n\nShift\nleft 2\n\nRegDst\nBranch\nrs\nMemRead\nMemtoReg\n\nPCSrc\n\nrt\n\nALUOp\nMemWrite\nrd\nALUSrc\nRegWrite\n\nData\n\nRegWrite\n\nshamt\n\nMemWrite\n\nData\nMemory\n\nRead\nfunct1\nregister\n\nRead\ndata 1\nRead\nimmediate\nregister\n2\nRegisters Read\nWrite\ndata 2\ntarget\nregister\n\nALU ALU\nRegister\n0\nresult\nM File\n\nWrite\ndata\n\nu\nx\n1\n\n\\\nInstruction [15 0]\n\n1\n\n16\n\nAddress\nZero\n\nALU\n\nWrite\ndata\n\nRegDataSrc\n32\n\nSign\nextend\n\nALU field\nimm\ncontrol\n\nRead\ndata\n\nAddress\n\nALUSrc\n\nData\nmemory\n\n1\nM\nu\nx\n0\n\nALUOp\n\nInstruction [5 0]\n\n4\n\n\fA global view\nHow big was an\ninstruction in MIPS?\n\n0\nM\nu\nx\nALU\nAdd result\n\nAdd\n\nInstruction [31 26]\n\nControl\n\nInstruction [25 21]\nPC\n\nRead\naddress\n\nInstruction\nmemory\n\nPC-in\ninstruction-out\n\nInstruction [15 11]\n\nPCSrc\n\nALUOp\nMemWrite\nALUSrc\nRegWrite\nRead\nregister 1\n\nInstruction [20 16]\nInstruction\n[31\u2013 0]\n\nShift\nleft 2\n\nRegDst\nBranch\nMemRead\nMemtoReg\n\n4\n\n1\n\n0\nM\nu\nx\n1\n\nRead\ndata 1\nRead\nregister 2\nRegisters Read\nWrite\ndata 2\nregister\n\n0\nM\nu\nx\n1\n\nWrite\ndata\n\nZero\nALU ALU\nresult\n\nAddress\n\nWrite\ndata\nInstruction [15 0]\n\nBit Fields being\ndecoded\n\n16\n\nSign\nextend\n\nRead\ndata\nData\nmemory\n\n1\nM\nu\nx\n0\n\n32\nALU\ncontrol\n\nInstruction [5 0]\n\n5\n\n\fA global view\n0\n\nThe brain!\n\nM\nu\nx\nALU\nAdd result\n\nAdd\n\nInstruction [31 26]\n\nControl\n\nInstruction [25 21]\nPC\n\nRead\naddress\n\nInstruction\nmemory\n\nInstruction [15 11]\n\nPCSrc\n\nALUOp\nMemWrite\nALUSrc\nRegWrite\nRead\nregister 1\n\nInstruction [20 16]\nInstruction\n[31\u2013 0]\n\nShift\nleft 2\n\nRegDst\nBranch\nMemRead\nMemtoReg\n\n4\n\n1\n\n0\nM\nu\nx\n1\n\nRead\ndata 1\nRead\nregister 2\nRegisters Read\nWrite\ndata 2\nregister\n\n0\nM\nu\nx\n1\n\nWrite\ndata\n\nWhy is this?\n\nZero\nALU ALU\nresult\n\nWrite\ndata\nInstruction [15 0]\n\n16\n\nInstruction [5 0]\n\nSign\nextend\n\nRead\ndata\n\nAddress\n\nData\nmemory\n\n1\nM\nu\nx\n0\n\n32\nALU\ncontrol\n\nSeparate ALU\ncontrol, why?\n6\n\n\fA global view\n0\nM\nu\nx\nALU\nAdd result\nAdd\n\nInstruction [31 26]\n\nControl\n\nInstruction [25 21]\nPC\n\nRead\naddress\n\nInstruction\nmemory\n\nInstruction [15 11]\n\nPCSrc\n\nALUOp\nMemWrite\nALUSrc\nRegWrite\nRead\nregister 1\n\nInstruction [20 16]\nInstruction\n[31\u2013 0]\n\nShift\nleft 2\n\nRegDst\nBranch\nMemRead\nMemtoReg\n\n4\n\n1\n\n0\nM\nu\nx\n1\n\nRead\ndata 1\nRead\nregister 2\nRegisters Read\nWrite\ndata 2\nregister\n\n0\nM\nu\nx\n1\n\nWrite\ndata\n\nZero\nALU ALU\nresult\n\nAddress\n\nWrite\ndata\nInstruction [15 0]\n\n16\n\nImmediates are\nInstruction [5 0]\nsigned\n\nSign\nextend\n\nRead\ndata\nData\nmemory\n\n1\nM\nu\nx\n0\n\n32\nALU\ncontrol\n\n7\n\n\fA global view\n0\nM\nu\nx\nALU\nAdd result\nAdd\n\nInstruction [31 26]\n\nControl\n\nInstruction [25 21]\nPC\n\nRead\naddress\n\nInstruction\nmemory\n\nInstruction [15 11]\n\nPCSrc\n\nALUOp\nMemWrite\nALUSrc\nRegWrite\n\nRecognise this?\n\nRead\nregister 1\n\nInstruction [20 16]\nInstruction\n[31\u2013 0]\n\nShift\nleft 2\n\nRegDst\nBranch\nMemRead\nMemtoReg\n\n4\n\n1\n\n0\nM\nu\nx\n1\n\nRead\ndata 1\nRead\nregister 2\nRegisters Read\nWrite\ndata 2\nregister\n\n0\nM\nu\nx\n1\n\nWrite\ndata\n\nZero\nALU ALU\nresult\n\nAddress\n\nWrite\ndata\nInstruction [15 0]\n\n16\n\nSign\nextend\n\nRead\ndata\nData\nmemory\n\n1\nM\nu\nx\n0\n\n32\nALU\ncontrol\n\nInstruction [5 0]\n\n8\n\n\fA global view\n0\nM\nu\nx\nALU\nAdd result\nAdd\n\nInstruction [31 26]\n\nControl\n\nInstruction [25 21]\nPC\n\nRead\naddress\n\nInstruction\nmemory\n\nInstruction [15 11]\n\nPCSrc\n\nHandling those\nbranches!\n\nALUOp\nMemWrite\nALUSrc\nRegWrite\nRead\nregister 1\n\nInstruction [20 16]\nInstruction\n[31\u2013 0]\n\nShift\nleft 2\n\nRegDst\nBranch\nMemRead\nMemtoReg\n\n4\n\n1\n\n0\nM\nu\nx\n1\n\nRead\ndata 1\nRead\nregister 2\nRegisters Read\nWrite\ndata 2\nregister\n\n0\nM\nu\nx\n1\n\nWrite\ndata\n\nZero\nALU ALU\nresult\n\nAddress\n\nWrite\ndata\nInstruction [15 0]\n\n16\n\nSign\nextend\n\nRead\ndata\nData\nmemory\n\n1\nM\nu\nx\n0\n\n32\nALU\ncontrol\n\nInstruction [5 0]\n\n9\n\n\fExecuting an r-type instruction\n\n10\n\n\fExecuting an r-type\n0\n\nThe instruction is read\nand PC is incremented\n\nM\nu\nx\nALU\nAdd result\n\nAdd\n\nInstruction [31 26]\n\nControl\n\nInstruction [25 21]\nPC\n\nRead\naddress\n\nInstruction\nmemory\n\nInstruction [15 11]\n\nPCSrc\n\nALUOp\nMemWrite\nALUSrc\nRegWrite\nRead\nregister 1\n\nInstruction [20 16]\nInstruction\n[31\u2013 0]\n\nShift\nleft 2\n\nRegDst\nBranch\nMemRead\nMemtoReg\n\n4\n\n1\n\n0\nM\nu\nx\n1\n\nRead\ndata 1\nRead\nregister 2\nRegisters Read\nWrite\ndata 2\nregister\n\n0\nM\nu\nx\n1\n\nWrite\ndata\n\nZero\nALU ALU\nresult\n\nAddress\n\nWrite\ndata\nInstruction [15 0]\n\n16\n\nSign\nextend\n\nRead\ndata\nData\nmemory\n\n1\nM\nu\nx\n0\n\n32\nALU\ncontrol\n\nInstruction [5 0]\n\n11\n\n\fExecuting an r-type\n0\nM\nu\nx\nALU\nAdd result\nAdd\n\nInstruction [31 26]\n\nControl\n\nInstruction [25 21]\nPC\n\nRead\naddress\n\nInstruction\nmemory\n\nInstruction [15 11]\n\nPCSrc\n\nALUOp\nMemWrite\nALUSrc\nRegWrite\nRead\nregister 1\n\nInstruction [20 16]\nInstruction\n[31\u2013 0]\n\nShift\nleft 2\n\nRegDst\nBranch\nMemRead\nMemtoReg\n\n4\n\n1\n\n0\nM\nu\nx\n1\n\nRead\ndata 1\nRead\nregister 2\nRegisters Read\nWrite\ndata 2\nregister\n\n0\nM\nu\nx\n1\n\nWrite\ndata\n\nZero\nALU ALU\nresult\n\nAddress\n\nWrite\ndata\nInstruction [15 0]\n\nTwo registers (rs, rt) are read, and the\ncontrol unit determines the signals\n\n16\n\nSign\nextend\n\nRead\ndata\nData\nmemory\n\n1\nM\nu\nx\n0\n\n32\nALU\ncontrol\n\nInstruction [5 0]\n\n12\n\n\fExecuting an r-type\n0\nM\nu\nx\nALU\nAdd result\nAdd\n\nInstruction [31 26]\n\nControl\n\nInstruction [25 21]\nPC\n\nRead\naddress\n\nInstruction\nmemory\n\nInstruction [15 11]\n\nPCSrc\n\nALUOp\nMemWrite\nALUSrc\nRegWrite\nRead\nregister 1\n\nInstruction [20 16]\nInstruction\n[31\u2013 0]\n\nShift\nleft 2\n\nRegDst\nBranch\nMemRead\nMemtoReg\n\n4\n\n1\n\n0\nM\nu\nx\n1\n\nRead\ndata 1\nRead\nregister 2\nRegisters Read\nWrite\ndata 2\nregister\n\n0\nM\nu\nx\n1\n\nWrite\ndata\n\nZero\nALU ALU\nresult\n\nAddress\n\nWrite\ndata\nInstruction [15 0]\n\nThe ALU performs the operation\naccording to the lower 6-bits of the\ninstruction (func)\n\n16\n\nSign\nextend\n\nRead\ndata\nData\nmemory\n\n1\nM\nu\nx\n0\n\n32\nALU\ncontrol\n\nInstruction [5 0]\n\n13\n\n\fExecuting an r-type\n0\nM\nu\nx\nALU\nAdd result\nAdd\n\nInstruction [31 26]\n\nControl\n\nInstruction [25 21]\nPC\n\nRead\naddress\n\nInstruction\nmemory\n\nInstruction [15 11]\n\nPCSrc\n\nALUOp\nMemWrite\nALUSrc\nRegWrite\nRead\nregister 1\n\nInstruction [20 16]\nInstruction\n[31\u2013 0]\n\nShift\nleft 2\n\nRegDst\nBranch\nMemRead\nMemtoReg\n\n4\n\n1\n\n0\nM\nu\nx\n1\n\nRead\ndata 1\nRead\nregister 2\nRegisters Read\nWrite\ndata 2\nregister\n\n0\nM\nu\nx\n1\n\nWrite\ndata\n\nZero\nALU ALU\nresult\n\nAddress\n\nWrite\ndata\nInstruction [15 0]\n\nThe result is written back to the\nregister file (rd)\n\n16\n\nSign\nextend\n\nRead\ndata\nData\nmemory\n\n1\nM\nu\nx\n0\n\n32\nALU\ncontrol\n\nInstruction [5 0]\n\n14\n\n\fExecuting a lw instruction\n\n15\n\n\fExecuting an i-type : e.g., lw\n0\n\nThe instruction is read\nand PC is incremented\n\nM\nu\nx\nALU\nAdd result\n\nAdd\n\nInstruction [31 26]\n\nControl\n\nInstruction [25 21]\nPC\n\nRead\naddress\n\nInstruction\nmemory\n\nInstruction [15 11]\n\nPCSrc\n\nALUOp\nMemWrite\nALUSrc\nRegWrite\nRead\nregister 1\n\nInstruction [20 16]\nInstruction\n[31\u2013 0]\n\nShift\nleft 2\n\nRegDst\nBranch\nMemRead\nMemtoReg\n\n4\n\n1\n\n0\nM\nu\nx\n1\n\nRead\ndata 1\nRead\nregister 2\nRegisters Read\nWrite\ndata 2\nregister\n\n0\nM\nu\nx\n1\n\nWrite\ndata\n\nZero\nALU ALU\nresult\n\nAddress\n\nWrite\ndata\nInstruction [15 0]\n\n16\n\nSign\nextend\n\nRead\ndata\nData\nmemory\n\n1\nM\nu\nx\n0\n\n32\nALU\ncontrol\n\nInstruction [5 0]\n\n16\n\n\fExecuting an i-type : e.g., lw\n0\nM\nu\nx\nALU\nAdd result\nAdd\n\nInstruction [31 26]\n\nControl\n\nInstruction [25 21]\nPC\n\nRead\naddress\n\nInstruction\nmemory\n\nInstruction [15 11]\n\nPCSrc\n\nALUOp\nMemWrite\nALUSrc\nRegWrite\nRead\nregister 1\n\nInstruction [20 16]\nInstruction\n[31\u2013 0]\n\nShift\nleft 2\n\nRegDst\nBranch\nMemRead\nMemtoReg\n\n4\n\n1\n\n0\nM\nu\nx\n1\n\nRead\ndata 1\nRead\nregister 2\nRegisters Read\nWrite\ndata 2\nregister\n\n0\nM\nu\nx\n1\n\nWrite\ndata\n\nZero\nALU ALU\nresult\n\nAddress\n\nWrite\ndata\nInstruction [15 0]\n\nOne register (rs) is read, and the\ncontrol unit determines the signals\n\n16\n\nSign\nextend\n\nRead\ndata\nData\nmemory\n\n1\nM\nu\nx\n0\n\n32\nALU\ncontrol\n\nInstruction [5 0]\n\n17\n\n\fExecuting an i-type : e.g., lw\n0\nM\nu\nx\nALU\nAdd result\nAdd\n\nInstruction [31 26]\n\nControl\n\nInstruction [25 21]\nPC\n\nRead\naddress\n\nInstruction\nmemory\n\nInstruction [15 11]\n\nPCSrc\n\nALUOp\nMemWrite\nALUSrc\nRegWrite\nRead\nregister 1\n\nInstruction [20 16]\nInstruction\n[31\u2013 0]\n\nShift\nleft 2\n\nRegDst\nBranch\nMemRead\nMemtoReg\n\n4\n\n1\n\n0\nM\nu\nx\n1\n\nRead\ndata 1\nRead\nregister 2\nRegisters Read\nWrite\ndata 2\nregister\n\n0\nM\nu\nx\n1\n\nWrite\ndata\n\nZero\nALU ALU\nresult\n\nAddress\n\nWrite\ndata\nInstruction [15 0]\n\nThe ALU adds the register value with\nthe immediate (offset) extended to\n32-bits.\n\n16\n\nSign\nextend\n\nRead\ndata\nData\nmemory\n\n1\nM\nu\nx\n0\n\n32\nALU\ncontrol\n\nInstruction [5 0]\n\n18\n\n\fExecuting an i-type : e.g., lw\n0\nM\nu\nx\nALU\nAdd result\nAdd\n\nInstruction [31 26]\n\nControl\n\nInstruction [25 21]\nPC\n\nRead\naddress\n\nInstruction\nmemory\n\nInstruction [15 11]\n\nPCSrc\n\nALUOp\nMemWrite\nALUSrc\nRegWrite\nRead\nregister 1\n\nInstruction [20 16]\nInstruction\n[31\u2013 0]\n\nShift\nleft 2\n\nRegDst\nBranch\nMemRead\nMemtoReg\n\n4\n\n1\n\n0\nM\nu\nx\n1\n\nRead\ndata 1\nRead\nregister 2\nRegisters Read\nWrite\ndata 2\nregister\n\n0\nM\nu\nx\n1\n\nWrite\ndata\n\nZero\nALU ALU\nresult\n\nAddress\n\nWrite\ndata\nInstruction [15 0]\n\nThe ALU result is the address we want\nto read. The memory is read in that\naddress.\n\n16\n\nSign\nextend\n\nRead\ndata\nData\nmemory\n\n1\nM\nu\nx\n0\n\n32\nALU\ncontrol\n\nInstruction [5 0]\n\n19\n\n\fExecuting an i-type : e.g., lw\n0\nM\nu\nx\nALU\nAdd result\nAdd\n\nInstruction [31 26]\n\nControl\n\nInstruction [25 21]\nPC\n\nRead\naddress\n\nInstruction\nmemory\n\nInstruction [15 11]\n\nPCSrc\n\nALUOp\nMemWrite\nALUSrc\nRegWrite\nRead\nregister 1\n\nInstruction [20 16]\nInstruction\n[31\u2013 0]\n\nShift\nleft 2\n\nRegDst\nBranch\nMemRead\nMemtoReg\n\n4\n\n1\n\n0\nM\nu\nx\n1\n\nRead\ndata 1\nRead\nregister 2\nRegisters Read\nWrite\ndata 2\nregister\n\n0\nM\nu\nx\n1\n\nWrite\ndata\n\nZero\nALU ALU\nresult\n\nAddress\n\nWrite\ndata\nInstruction [15 0]\n\nThe memory data is stored in the\nregister (rt)\n\n16\n\nSign\nextend\n\nRead\ndata\nData\nmemory\n\n1\nM\nu\nx\n0\n\n32\nALU\ncontrol\n\nInstruction [5 0]\n\n20\n\n\fExecuting a beq instruction\n\n21\n\n\fExecuting an i-type : e.g., beq\n0\n\nThe instruction is read\nand PC is incremented\n\nM\nu\nx\nALU\nAdd result\n\nAdd\n\nInstruction [31 26]\n\nControl\n\nInstruction [25 21]\nPC\n\nRead\naddress\n\nInstruction\nmemory\n\nInstruction [15 11]\n\nPCSrc\n\nALUOp\nMemWrite\nALUSrc\nRegWrite\nRead\nregister 1\n\nInstruction [20 16]\nInstruction\n[31\u2013 0]\n\nShift\nleft 2\n\nRegDst\nBranch\nMemRead\nMemtoReg\n\n4\n\n1\n\n0\nM\nu\nx\n1\n\nRead\ndata 1\nRead\nregister 2\nRegisters Read\nWrite\ndata 2\nregister\n\n0\nM\nu\nx\n1\n\nWrite\ndata\n\nZero\nALU ALU\nresult\n\nAddress\n\nWrite\ndata\nInstruction [15 0]\n\n16\n\nSign\nextend\n\nRead\ndata\nData\nmemory\n\n1\nM\nu\nx\n0\n\n32\nALU\ncontrol\n\nInstruction [5 0]\n\n22\n\n\fExecuting an i-type : e.g., beq\n0\nM\nu\nx\nALU\nAdd result\nAdd\n\nInstruction [31 26]\n\nControl\n\nInstruction [25 21]\nPC\n\nRead\naddress\n\nInstruction\nmemory\n\nInstruction [15 11]\n\nPCSrc\n\nALUOp\nMemWrite\nALUSrc\nRegWrite\nRead\nregister 1\n\nInstruction [20 16]\nInstruction\n[31\u2013 0]\n\nShift\nleft 2\n\nRegDst\nBranch\nMemRead\nMemtoReg\n\n4\n\n1\n\n0\nM\nu\nx\n1\n\nRead\ndata 1\nRead\nregister 2\nRegisters Read\nWrite\ndata 2\nregister\n\n0\nM\nu\nx\n1\n\nWrite\ndata\n\nZero\nALU ALU\nresult\n\nAddress\n\nWrite\ndata\nInstruction [15 0]\n\nTwo registers (rs, rt) are read, and the\ncontrol unit determines the signals. The\nimmediate is shifted and added to PC+4\n\n16\n\nSign\nextend\n\nRead\ndata\nData\nmemory\n\n1\nM\nu\nx\n0\n\n32\nALU\ncontrol\n\nInstruction [5 0]\n\n23\n\n\fExecuting an i-type : e.g., beq\n0\nM\nu\nx\nALU\nAdd result\nAdd\n\nInstruction [31 26]\n\nControl\n\nInstruction [25 21]\nPC\n\nRead\naddress\n\nInstruction\nmemory\n\nInstruction [15 11]\n\nPCSrc\n\nALUOp\nMemWrite\nALUSrc\nRegWrite\nRead\nregister 1\n\nInstruction [20 16]\nInstruction\n[31\u2013 0]\n\nShift\nleft 2\n\nRegDst\nBranch\nMemRead\nMemtoReg\n\n4\n\n1\n\n0\nM\nu\nx\n1\n\nRead\ndata 1\nRead\nregister 2\nRegisters Read\nWrite\ndata 2\nregister\n\n0\nM\nu\nx\n1\n\nWrite\ndata\n\nZero\nALU ALU\nresult\n\nAddress\n\nWrite\ndata\nInstruction [15 0]\n\nThe ALU subtracts the contents of\nboth registers. Depending on the\nresult, the value of PC is set.\n\n16\n\nSign\nextend\n\nRead\ndata\nData\nmemory\n\n1\nM\nu\nx\n0\n\n32\nALU\ncontrol\n\nInstruction [5 0]\n\n24\n\n\fExecuting a jump instruction\n\n25\n\n\fExtending the CPU\n\n26\n\n\fExecuting an j-type\n\nThe instruction is read and PC is\nincremented\n27\n\n\fExecuting an j-type\n\nThe new PC value is obtained by shifting\nthe target field of the instruction left by 2.\n28\n\n\fReal-world clocking issues\n\n29\n\n\fRemember the Critical Path?\n\u25cf the critical path is the path through a circuit that requires the longest series of\nsequential operations\no they depend on each other and can't be done in parallel!\n\n30\n\n\fHow fast can we clock it?\n\u25cf what's the thing that limits the clock speed?\no the critical path. in our case it happens to be...\no and here is the Achilles' heel of a single-cycle datapath:\n\nMemory is\nSLOW.\nA.\nF.\n\nrd\nrs\nrt\n\nData\nData\nMemory\n\nAddress\nRegister\nFile\n\nALU\n\nimm field\n\n31\n\n\fSingle-cycle CPU\nAny instruction executes during a single clock cycle\nLength of the clock cycle must accommodate the longest instruction\n\u25cf Faster instructions waste cycle time\n\nClock cycle\n\nlw t0,0(t1)\n\nadd t2,t2,t3\n\n0\n\nMem\n\nReg\n\n1\n\nMem\n\nReg\n\nMem\n\nReg\n\nReg\n\n32\n\n\fIt's bad.\n\u25cf typical access times for modern DDR4 RAM is 12-15 ns\no that's our single-cycle CPU's critical path time\n\u25cf the inverse of that is... 66-83 MHz\no YEESH\n\u25cf the lw and sw instructions are holding us back\n\u25cf all the other instructions are gonna be WAY faster\n\nadd\nor\n\nbeq\nlw/sw\n\n33\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}