{"id": 253, "segment": "self_training_2", "course": "cs1502", "lec": "lec03_finite_automata_02", "text": "Finite Automata 02\nThumrongsak Kosiyatrakul\ntkosiyat@cs.pitt.edu\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\n\fFinite Automata\nThe computational model called finite automata can be used\nto simulate a set of simple algorithms\nCheck whether a string starts with 010\nCheck whether a string ends with 111\nCheck whether a string contains 0101 as a substring\nCheck whether a string contains substrings 000 and 111 where\n000 comes before 111\n\nIt is a powerful tool in compiler\nAccept or reject your source code based on a programming\nsyntax\nExample: the for statement:\nstarts with for\nfollowed by (\nfollowed by assignment statement(s)\nfollowed by ;\nfollowed by conditional statement(s)\nfollowed by ;\nfollowed by assignment statement(s)\nfollowed by )\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\n\fFormal Definition of Computation\n\nLet M = (Q, \u03a3, \u03b4, q0 , F ) be a finite automaton and let\nw = w1 w2 . . . wn be a string where each wi is a member of\nthe alphabet \u03a3.\nM accepts w if a sequence of states r0 , r1 , . . . , rn in Q exists\nwith three conditions:\n1\n2\n3\n\nr0 = q 0\n\u03b4(ri , wi+1 ) = ri+1 , where i = 0, . . . , n \u2212 1\nrn \u2208 F\n\nThink in terms of processing the input string w\nw\n\nw\n\nw\n\nw\n\nw\n\nwn\u22121\n\nw\n\nr0 \u21921 r1 \u21922 r2 \u21923 r3 \u21924 r4 \u21925 . . . \u2192 rn\u22121 \u2192n rn\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\n\fRegular Languages\nA language L over an alphabet \u03a3 is said to be a regular\nlanguage if some finite-state automaton recognizes it.\nConsider the following machine M :\n0\n\n0\n1\n\nq0\n\nq1\n\n1\n\nWhat is the language of this machine?\nL(M ) = {w | w contains an odd number of 1s}\n\n\u201cThe set of all strings consisting of an odd number of 1s\u201d is a\nregular language\nL(M ) is a regular language\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\n\fRegular Languages\n\nWhy regular language is important in our discussion?\nDefinition: A language is regular if some finite-state machines\nrecognize it.\nIf we can prove that a language is regular\nWe must be able to construct a finite-state machine to\nrecognize it\nIt maybe hard to build but I know that it exists\n\nIf we can prove that a language is not regular\nWe cannot construct a finite-state machine to recognize it\n\nThis is an example of a limitation of this computational model\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\n\fProblem and Language\nIn theory of computation, a problem is represented as a\nlanguage\nA problem of determining whether a string contains 011 as a\nsubstring\nL(M ) = {x | x contains 011 as a substring}\nWe already see a Deterministic Finite Automaton (DFA) M\nthat accepts all strings that contains 011 as a substring and\nreject those that does not contain 011 as a substring\nIt means this problem is solvable by the algorithm captured by\nthe previous DFA\nIn case of algorithm in a form of DFA (not all algorithms)\nif L(M ) is regular, the problem represented by L(M ) is\nsolvable\nif L(M ) is not regular, no DFA exists, the problem\nrepresented by L(M ) is unsolvable\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\n\fProblems and Languages\nSolvable problems that we see so far\nThe problem of determining whether a string ends with a 1\n{x | x ends with a 1}\nThe problem of determining whether a string is an empty\nstring or ends in a 0\n{x | x is an empty string or ends in a 0}\nThe problem of determining whether a string starts and ends\nwith the same symbol\n{x | x starts and ends with the same symbol}\nThe problem of determining whether a string contains either\n11 or 00 as a substring\n{x | x contains either 11 or 00 as a substring}\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\n\fProblems and Languages\nSolvable problems that we see so far (continue)\nThe problem of determining whether a string contains 011 as a\nsubstring\n{x | x contains 011 as a substring}\nThe problem of determining whether a string ends with 0110\n{x | x ends with 0110}\nThe problem of determining whether a string contains an odd\nnumber of 1s\n{x | x contains an odd number of 1s}\n\nEach of the above languages is regular since we can construct\na DFA that recognizes it.\nBut if a language is very complicate, it will be difficult to\nconstruct a DFA that recognizes it\n\nWe need tools to help us to determine whether a language is\nregular or not\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\n\fThe Regular Operations\nIn arithmetic:\nObjects are numbers\nTools are operations for manipulating numbers (e.g., + and \u00d7)\n1 + 1 gives you a new number which is 2\n\nIn the theory of computation,\nObjects are languages (sets of strings)\nTools are operations for manipulating languages\n\nDefinition 1.23\nLet A and B be languages. We define the regular operations as\nfollows:\nUnion: A \u222a B = {x | x \u2208 A or x \u2208 B}\nConcatenation: A \u25e6 B = {xy | x \u2208 A and y \u2208 B}\nStar: A\u2217 = {x1 x2 . . . xk | k \u2265 0 and each xi \u2208 A}\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\n\fExamples (Union)\n\nLet \u03a3 = {0, 1}\nConsider the following languages A and B\nA = {00, 11}\nB = {010, 101}\n\nThe union operations is identical to the set\u2019s union operation:\nA \u222a B = {x | x \u2208 A or x \u2208 B}\nFrom the above definition:\nA \u222a B = {00, 11, 010, 101}\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\n\fExamples (Concatenation)\n\nLet \u03a3 = {0, 1}\nConsider the following languages A and B\nA = {00, 11}\nB = {010, 101}\n\nThe definition of concatenation is defined as\nA \u25e6 B = {xy | x \u2208 A and y \u2208 B}\nFrom the above definition:\nA \u25e6 B = {00010, 00101, 11010, 11101}\nFor simplicity, sometimes we write AB instead of A \u25e6 B\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\n\fExamples (Star)\nLet \u03a3 = {0, 1}\nConsider the following language A\nA = {00, 11}\n\nThe definition of start is defined as\nA\u2217 = {x1 x2 . . . xk | k \u2265 0 and xi \u2208 A}\nIf k = 0, the above definition becomes\n{ | 0 \u2265 0} = {\u03b5}\nIf k = 1, the above definition becomes\n{x1 | 1 \u2265 0 and xi \u2208 A} = {00, 11}\nIf k = 2, the above definition becomes\n{x1 x2 | 2 \u2265 0 and xi \u2208 A} = {0000, 0011, 1100, 1111}\nIf k = 3, the above definition becomes\n{x1 x2 x3 | 3 \u2265 0 and xi \u2208 A} = {000000, 000011, . . . , 111111}\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\n\fExamples (Star)\nLet \u03a3 = {0, 1}\nSuppose A = {00, 11}, what is A\u2217 ?\nA\u2217 = {\u03b5, 00, 11, 0000, 0011, 1100, 1111, 000000, . . . }\nSuppose A = {011}, what is A\u2217 ?\nA\u2217 = {\u03b5, 011, 011011, 011011011, 011011011011, . . . }\nSuppose A = {0, 1}, what is A\u2217 ?\nA\u2217 = {\u03b5, 0, 1, 00, 01, 10, 11, 000, 001, 010, 011, 100, . . . }\nThis is the set of all strings over {0, 1}\nSuppose A = \u2205, what is A\u2217 ?\nA\u2217 = {\u03b5}\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\n\fDefinition of Closed Under Operations\n\nLet A be a set of objects (a collection of object)\nWe say that A is closed under operation 4 if for any x \u2208 A\nand y \u2208 A, x4y is also in A.\nExample: Let N be the set of natural number\nN is closed under addition\nFor any two natural numbers x and y, x + y is a natural\nnumber\n\nN is closed under multiplication\nFor any two natural numbers x and y, x \u00d7 y is a natural\nnumber\n\nN is not closed under subtraction\n5 \u2212 7 is not a natural number\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\n\fDefinition of Closed Under Operations\n\nLet L be the set of all regular languages\nThis is a set of sets\n\nRecall that we have three operations, union, concatenation,\nand star\nIs L closed under union operation?\nFor any regular languages A and B, is A \u222a B a regular\nlanguage?\n\nIs L closed under concatenation operation?\nFor any regular languages A and B, is A \u25e6 B a regular\nlanguage?\n\nIs L closed under star operation?\nFor any regular language A, is A\u2217 a regular language?\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\n\fL is regular under union operation\nLet A be a set of strings over {0, 1} that contain a 00 as a\nsubstring\nIs A a regular language?\nCan you construct a DFA that recognizes the language A?\nOne of the machine that recognizes A can be as follows:\n1\n\n0,1\n\n0\n\nqa\n\n0\n\nqb\n\nqc\n\n1\n\nBecause there exists a DFA that recognizes A, A is a regular\nlanguage\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\n\fL is regular under union operation\n\nLet B be a set of strings over {0, 1} that end with a 1\nIs B a regular language?\nCan you construct a DFA that recognizes the language B?\nOne of the machine that recognizes B can be as follows:\n0\n\n1\n1\n\nq0\n\nq1\n0\n\nBecause there exists a DFA that recognizes B, B is a regular\nlanguage\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\n\fL is regular under union operation\nWe have A = {x | x contains 00 as a substring} is regular\nWe have B = {x | x ends with a 1} is regular\nHow about A \u222a B?\nA \u222a B = {x | x contains 00 as a substring or x ends with a 1}\nIt is quite straightforward to construct a machine that\nrecognizes A \u222a B (try to build one yourself)\n1\n\n0,1\n\n0\n1\n1\n0\n\n0\n\nThis does not prove that if A and B are regular, A \u222a B is\nregular\nThis is just one example out of infinite may instances of\nregular languages\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\n\fL is regular under union operation\nWe need to show that for any two regular languages A and B,\nA \u222a B is regular\nGiven a regular language A over a \u03a3, what do we know about\nthe language A?\nThere exists a DFA MA that recognizes A (L(MA ) = A)\nMA = (QA , \u03a3, \u03b4A , qA , FA ) for some QA , \u03b4A , qA , and FA\n\nSimilarly, given a regular language B over a \u03a3:\nThere exists a DFA MB that recognizes B (L(MB ) = B)\nMB = (QB , \u03a3, \u03b4B , qB , FB ) for some QB , \u03b4B , qB , and FB\n\nTo show that A \u222a B is regular for any regular languages A\nand B, we need to construct a DFA that recognizes A \u222a B\nfrom MA and MB\nTo understand the process, we are going to work on a specific\nexample\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\n\fL is regular under union operation\nRecall the previous two regular languages and its DFAs where\n\u03a3 = {0, 1}\nA = {x | x contains 00 as a substring}\n1\n\n0,1\n\n0\n\nqa\n\n0\n\nqb\n\nqc\n\n1\n\nMA = (QA , \u03a3, \u03b4A , qA , FA ) and L(MA ) = A\nB = {x | x ends with a 1}\n0\n\n1\n1\n\nq0\n\nq1\n0\n\nMB = (QB , \u03a3, \u03b4B , qB , FB ) and L(MB ) = B\n\nGiven a string w and these two DFAs, how to check whether\nw is in A \u222a B?\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\n\fL is regular under union operation\nRecall that A = L(MA ) and B = L(MB )\nThus, A \u222a B = L(MA ) \u222a L(MB )\n\nw \u2208A\u222aB\niff w \u2208 A or w \u2208 B\niff w \u2208 L(MA ) or w \u2208 L(MB )\niff MA accepts w or w \u2208 L(MB )\niff MA accepts w or MB accepts w\n\nIn other words,\nw \u2208 A \u222a B if and only if MA accepts w or MB accepts w\nTo check whether w \u2208 A \u222a B:\nRun both MA and MB on input w\nIf one of them or both accepts w, w \u2208 A \u222a B\nIf both reject w, w 6\u2208 A \u222a B\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\n\fL is regular under union operation\nWe can run both machines simultaneously\n1\n\n0,1\n\n0\n\n1\n1\n\n0\n\nqa\n\n0\n\nqb\n\nqc\n\nq0\n\nq1\n\n1\n0\n\nLet state (p, q) represents the situation where\nThe current state of MA is p\nThe current state of MB is q\n\nWith the new notion of states, we have\n0\n\n(qa , q0 )\n1\n1\n1\n\n(qa , q1 )\n\n0\n\n(qb , q0 )\n0\n\n0\n\n1\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\n(qb , q1 )\n\nFinite Automata 02\n\n(qc , q0 )\n0\n\n0\n1\n\n(qc , q1 )\n\n1\n\n\fL is regular under union operation\nLet MA recognizes A, where MA = (QA , \u03a3, \u03b4A , qA , FA )\nLet MB recognizes B, where MB = (QB , \u03a3, \u03b4B , qB , FB )\nMachine M = (Q, \u03a3, \u03b4, q0 , F ) that recognizes A \u222a B can be\nconstructed as follows:\n1\n2\n\nQ = {(r1 , r2 ) | r1 \u2208 QA and r2 \u2208 QB }\nFor each (r1 , r2 ) \u2208 Q and a \u2208 \u03a3\n\u03b4((r1 , r2 ), a) = (\u03b4A (r1 , a), \u03b4B (r2 , a))\n\n3\n4\n\nq0 = (qA , qB )\nF = {(r1 , r2 ) | r1 \u2208 FA or r2 \u2208 FB }\n\nTo recognize A \u2229 B, simply change the set of accept states to\nF = {(r1 , r2 ) | r1 \u2208 FA and r2 \u2208 FB }\nIf A and B are regular languages, A \u222a B is regular\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\n\fConclusions\n\nA language is regular if it is recognized by some finite-state\nmachines\nIf you can prove that a language is regular:\nthere exists a finite-state machine that recognizes it\n\nIf you can prove that a language is not regular:\nthere is no finite-state machine that recognizes it\n\nIn formally, we show that if A and B are regular languages,\nA \u222a B is a regular language\nTo prove the closure of concatenation and star operators, we\nneed a sightly different computational model\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}