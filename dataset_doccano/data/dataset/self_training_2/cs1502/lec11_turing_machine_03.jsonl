{"id": 262, "segment": "self_training_2", "course": "cs1502", "lec": "lec11_turing_machine_03", "text": "Turing Machine 03\nThumrongsak Kosiyatrakul\ntkosiyat@cs.pitt.edu\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 03\n\n\fCombining Turing Machines\n\nA Turing machine represents an algorithm\nGenerally an algorithm can be described as a number of\nsmaller algorithms working in combination\nSimilarly, we can combine several Turing machines into a\nlarger one\nExample, two Turing machines T1 and T2 sharing the same\ntape:\nWhen T1 finishes (either in the accept or reject state), T2\ntakes over\nThis new machine is represented by T1 T2\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 03\n\n\fCombining Turing Machines\nSuppose we have two Turing machines:\n1\n1\n1\n) and\nT1 = (Q1 , \u03a3, \u0393, \u03b41 , qstart\n, qaccept\n, qreject\n2\n2\n2\n)\nT2 = (Q2 , \u03a3, \u0393, \u03b42 , qstart , qaccept , qreject\n\nLet T = (Q, \u03a3, \u0393, \u03b4, qstart , qaccept , qreject ) be T1 T2 which can\nbe constructed as follows:\nQ = Q1 \u222a Q2 (states of T2 are relabeled if necessary)\n1\nInitial state of T is the initial state of T1 (qstart = qstart\n)\n1\n1\n\u03b4 = \u03b41 \u222a \u03b42 except those of T1 that go to qaccept and qreject\nq\n\nx \u2192 y, D\n\nq1\n\nq\n\nx \u2192 y, D\n\nq2\n\na\ns\nA transition\nin T1 becomes\n1\n2\nwhere qa is the accept state of T1 and qs is the start state of\nT2\n\nIf T1 enter its accept state, T2 takes over. The moves that\ncause T to accept are precisely those that case T2 to accept\nHowever, if T1 enter the reject state and halt, so does T\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 03\n\n\fExample\n\nSuppose we want to create a machine that recognize a\npalindrome (e.g., racecar)\nSuppose we have the following Turing machines:\nCopy: From tx to txtx\nNB : Moves tape head to the next blank symbol to the right\nPB : Moves tape head to the next blank symbol to the left\nR: Reverses the content of the tape from tx to txr\nxr is the reverse of a string x\n\nEqual : Compare two strings separated by a blank symbol\n\nFor simplicity, we put the blank symbol on the first square of\nthe tape to indicate the left-end of the tape.\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 03\n\n\fExample\nLet the content of a tape be tx where x is a string\nThe following machine will accept if x is a palindrome:\nCopy \u2192 NB \u2192 R \u2192 PB \u2192 Equal\nStep by Step:\nMachine\n\nTape\n\nStart\n\nt\n\n\u2193\n\u2193\n\nx\n\nCopy\n\nt\n\nNB\n\nt\n\nR\n\nt\n\nPB\n\nt\n\nEqual\n\nt\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nxtx\n\u2193\n\nxtx\n\u2193\n\nxtxr\n\n\u2193\n\nxtxr\n\u2193\n\nxtxr t\n\nTuring Machine 03\n\n\fMultitape Turing Machines\n\nA Turing machine can have multiple tape and tape heads:\n0\n\n1\n\n0\n\na\n\na\n\na\n\nb\n\na\n\n1\n\n0\n\nM\n\nAll tape heads can read then write and move in a single\nTuring machine step\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 03\n\n\fMultitape Turing Machines\nTransition function need to control/make decision based on\nsymbols read from all tapes\nExample: A transition function of a three-tape TM:\n\u03b4(q, x, y, z) \u2192 (r, a, b, c, R, L, R)\nCurrent state is q, the first tape reads x, the second tape reads\ny, and the third tape reads z\nChange the current state to r\nWrite a on to the first tape, write b onto the second tape, and\nwrite c onto the third tape\nMove the first tape head to the right direction, move the\nsecond tape head to the left direction, and move the third tape\nhead to the right direction\n\nMultitape TMs are suitable for algorithms in which several\nkinds of data are involved\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 03\n\n\fMultitape to One-Tape\nA multitape Turing machine from previous slide, can be\nconvert into one-tape Turing machine as shown below:\nS\n#\n\n0\n\n1\n\n0\n\n1\n\n0\n\n#\n\na\n\na\n\na\n\n#\n\nb\n\na\n\n#\n\nUse # symbol to separate content between tapes\n\u2022\nUse x to indicate the current position of each tape head\nOne move of multitape machine will be equal to several moves\nof one-tape machine\nFor example,\n\u03b4(q, 1, a, b) \u2192 (r, 0, b, a, L, L, R)\nwill be\n1\n\n2\n\n3\n\nMove to the next \u2022 on the right, write 0, move to the left\nsquare, write \u2022 over the symbol, and move to the right square\nMove to the next \u2022 on the right, write b, move to the left\nsquare, write \u2022 over the symbol, and move to the right square\nMove to the next \u2022 on the right, write b, move to the right\nsquare, write \u2022 over the symbol, and move to the left-end\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 03\n\n\fMultitape to One-Tape\nRecall that a tape will be filled with blank after the last\nsymbol of the string on the tape\n0\n\n1\n\n0\n\na\n\na\n\na\n\nb\n\na\n\n1\n\n0\n\n1\n\n0\n\na\n\na\n\nM\n\nS\n#\n\n0\n\n1\n\n0\n\n#\n\na\n\n#\n\nb\n\na\n\n#\n\nFrom the above multi-tape TM, if the second tape head needs\nto move tot he right direction, it should be on top of a blank\nsymbol\nBut on a single-tape TM, it will be on top of the # symbol\nSingle-tape TM must insert the blank symbol with a dot at\nthe #\n\nEvery multitape TM has an equivalent single-tape TM\n(slower)\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 03\n\n\fNondeterministic Turing Machine\nSimilar to Nondeterministic Finite Automata (NFA)\nProcessing one input symbol results in one or more machine.\n\u03b4 : Q \u00d7 \u0393 \u2192 P(Q \u00d7 \u0393 \u00d7 {L, R})\nComputation is a tree similar to NFA\n\nFor a nondeterministic Turing machine (NTM):\nIf a branch is in the accept state, the machine accepts the\ninput string\nIf all branches are in the reject state, the machine rejects the\ninput string\nIf no branch is in the accept state and at least one branch\nenter an infinite loop, the machine loops indefinitely on the\ninput string\n\nTheorem 3.16\nEvery nondeterministic Turing machine has an equivalent\ndeterministic Turing machine.\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 03\n\n\fProof Idea\n\nTheorem 3.16 Rewording\nFor every nondeterministic TM T = (Q, \u03a3, \u0393, \u03b4, qstart , qaccept , qreject ), there\n0\n0\n0\n)\nis an ordinary (deterministic) TM T 0 = (Q0 , \u03a3, \u03930 , \u03b4 0 , qstart\n, qaccept\n, qreject\n0\nwith L(T ) = L(T ).\n\nRecall that \u03b4 : Q \u00d7 \u0393 \u2192 P(Q \u00d7 \u0393 \u00d7 {L, R})\nProcessing a tape alphabet at a state may result in multiple\nmachines\nThe upper bound of the number of machines is\n|Q| \u00d7 |\u0393| \u00d7 |{L, R}|\nFor simplicity, assume that for every combination of nonhalting\nstate and tape symbol, there are exactly two moves (split to\ntwo machines)\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 03\n\n\fProof Idea\nComputational Tree of a TM on an input\n0\n\n0\n\n0\n\n0\n\n1\n\n1\n\n0\n\n1\n\n1\n\n1\n\n0\n\n0\n\n0\n\n1\n\n1\n\n0\n\n1\n\n0\n\n0\n\n1\n\n1\n\n0\n\n1\n\n1\n\n0\n\n0\n\n1\n\n1\n\n0\n\n1\n\nThe branch in blue behaves like a deterministic TM\nThe move follows the path in blue can be represented by 0110\nUse 0110 as a guideline to simulate a branch\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 03\n\n\fProof Idea\nSuppose a deterministic TM picks a branch and simulate it\nIf that branch ends in the accept state, the NTM accepts the\ninput string\nIf that branch ends in the reject state, no conclusion\nIf another branch is in the accept state, NTM accepts the\ninput string\nIf all other branches are in the reject state, NTM rejects the\ninput string\nIf no branch is in the accept state and at least one branch\nenter infinite loop, NTM loops indefinitely on the input string\n\nIf that branch enter infinite loop, the simulation will not end\nWe do not always know that a TM has enter an infinite loop\nEven if we know that it enters an infinite loop, we still cannot\nconclude whether NTM accepts or rejects the input string\n\nMachine T 0 that simulate an NTM will have to test all\npossible moves (level order, breadth first search)\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 03\n\n\fProof Idea\nMachine T 0 consists of four tapes\nTape 1 will be the input string and its contents never change\nTape 2 contain the binary string that represents the sequence\nof moves we are currently testing. (e.g., 0110t)\nTape 3 is the working tape of a copy of NTM\nTape 4 keeps track of all possible reject sequences\n\nIf a sequence of moves result in the accept state, T 0 accepts\nthe input string\nIf all possible sequence of the same length end in the reject\nstate, T 0 rejects the input string\nIf NTM loops indefinitely on the input string, the simulation\nwill also loop indefinitely\nSince T 0 is a multitape Turing machine, there is an equivalent\nsingle-tape Turing machine\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 03\n\n\fUniversal Turing Machine\nA universal TM is a TM that can run another TM on an input\nstring\nImagine a multi-tape TM:\nTape 1 contains the formal definition of a TM M , followed by\na # symbol, and an input string w\nTape 2 will be a working tape for TM M\nTape 3 will be used to keep track of the current state of TM M\n\nInitially:\nCopy input string w to tape 2\nPut the start state of TM M onto tape 3\n\nTo run a step, simply search for \u03b4(q, a) in the formal definition\nof TM M\nq is the current state of tape 3\na is the symbol under the second tape head\n\nand update tapes 2 and 3 until tape 3 contains qaccept or\nqreject\nA universal TM will loop indefinitely if the TM that it is\nrunning loop indefinitely\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 03\n\n\fThe Church-Turing Thesis\n\nTo say that the Turing machine is a general model of\ncomputation means that any algorithmic procedure that can\nbe carried out at all, by a human computer or a team of\nhumans or an electronic computer, can be carried out by a\nTuring machine.\nNote that a Turing machine depends on low-level operations\nA complex algorithm is simply a series of simple instruction\n(e.g., assembly) that involve\nsophisticated logic (state machine) or\ncomplex bookkeeping (tape/memory) strategies\n\nAn algorithm is a procedure that can be carried out by a\nTuring machine.\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 03\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}