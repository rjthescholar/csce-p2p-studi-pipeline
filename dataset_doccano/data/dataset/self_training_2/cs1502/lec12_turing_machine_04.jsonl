{"id": 259, "segment": "self_training_2", "course": "cs1502", "lec": "lec12_turing_machine_04", "text": "Turing Machine 04\nThumrongsak Kosiyatrakul\ntkosiyat@cs.pitt.edu\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 04\n\n\fRecognizable and Decidable\nGiven a language R, if some Turing machines accept every\nstrings s \u2208 R and does not accept (either reject or loop\nindefinitely) every string s 6\u2208 R, we say that \u201cR is\nrecognizable\u201d\nNote that these machines must accept on all input s \u2208 R\nHowever, if s 6\u2208 R, these machines either reject or loop\ninfinitely\n\nGiven a language D, if some Turing machine accept every\nstrings s \u2208 D and rejects every string s 6\u2208 D, we say that \u201cD\nis decidable\u201d\nNote that these Turing machines must be deciders\nThese machine either accept or reject on all input strings\nThese machine will not loop indefinitely on any strings\n\nIf D is decidable, D is also recognizable\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 04\n\n\fDecidable Language\n\nFollowing languages are examples of decidable languages:\nn\n\nA = {02 | n \u2265 0}\nB = {w#w | w \u2208 \u03a3\u2217 }\n\nWe already demonstrated that there exists Turing machines\n(deciders) that decide above languages\nThere are some languages that are recognizable but not\ndecidable\nSuppose R is recognizable but not decidable\nThere are TMs that accept all strings in R and does not\naccept all strings not in R\nNo TM can accept all strings in R and reject all strings not\nin R\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 04\n\n\fUndecidable Language\nConsider a polynomial:\n6x3 yz 2 + 3xy 2 \u2212 x3 \u2212 10\nA root of a polynomial is an assignment to its variables which\nresults in that value of polynomial is 0\nA polynomial has an integral root if all variables are assigned\ninteger values\nThe above polynomial has an integral root x = 5, y = 3, and\nz=0\n\nGiven a polynomial with an integral root, can you find out\nits root?\nYes, brute force\n\nGiven a polynomial, can you find out whether it has an\nintegral root?\nNot always\nHilbert\u2019s tenth problem stated that there is no algorithm that\ntests whether a polynomial has an integral root.\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 04\n\n\fUndecidable Language\nLet hxi be a string representation of the object x\nLet D be the set of all string representations of polynomials\nthat have integral root\nFormally\nD = {hpi | p is a polynomial with an integral root}\nGiven hpi (a string representation of a polynomial p), if a\nTuring machine can decide whether\nhpi \u2208 D (polynomial p has an integral root) or\nhpi 6\u2208 D (polynomial p does not have an integral root)\n\nD is decidable\nHilbert\u2019s tenth problem simply stated that D is not decidable.\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 04\n\n\fUndecidable Language\nConsider polynomials with one variable (e.g., 2x2 + x \u2212 7)\nLet\nD1 = {hpi | hpi is a polynomial over x with an integral root}\nIs D1 recognizable?\nYes, if there exists a Turing machine that accepts every\nhpi \u2208 D1 and does not accept every hpi 6\u2208 D1\n\nExample: M1 that recognizes D1 using a brute force\nalgorithm in high-level definition\nM1 =\u201cOn input hpi where p is a polynomial over the variable\nx:\n1\n\nEvaluate p with x set successively to the value 0, 1, -1, 2, -2, 3,\n-3, . . . . If at any point the polynomial evaluates to 0, accept\u201d\n\nNote that M1 accepts all hpi \u2208 D1 and loop indefinitely on all\nhpi 6\u2208 D1\nTherefore, D1 is recognizable.\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 04\n\n\fUndecidable Language\nConsider polynomials with one variable (e.g., 2x2 + x \u2212 7)\nLet\nD1 = {hpi | hpi is a polynomial over x with an integral root}\nIs D1 decidable?\nYes, if there exists a Turing machine that accepts every\nhpi \u2208 D1 and rejects every hpi 6\u2208 D1\n\nLuckily there is an upper/lower bound of the value of x that a\nmachine needs to test:\n\u00b1k cmax\nc1\nwhere k is the number of terms in the polynomial, cmax is the\ncoefficient with the largest absolute value, and c1 is the\ncoefficient of the highest order term\nChange M1 such that it rejects after testing value goes\nout-of-bound\nTherefore, D1 is decidable\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 04\n\n\fUndecidable Language\nLet D be the set of all polynomials that have integral root\nD = {hpi | hpi is a polynomial with an integral root}\nWe can create a machine that tries all possible assignment\nvalues starting from 0s\nFor example, in case of two variables x and y, try the following\nvalues [x, y]:\n[0, 0], [0, 1], [1, 0], [1, 1], [0, \u22121], [\u22121, 0], [\u22121, \u22121], [0, 2], . . .\nIf a polynomial p has an integral root, eventually it will be\nevaluated to 0\n\nTherefore, D is recognizable\nUnfortunately, there is no bound that we can check and\nmachine may loop infinitely\nIf the polynomial p does not have an integral root, we will keep\ntrying new values of [x, y] forever (loop indefinitely)\n\nD is not decidable\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 04\n\n\fDescribing Turing Machines\nA description of a Turing machine can be huge even for a very\nsimple algorithm\nExample, compare two strings {w#w | w \u2208 {0, 1}\u2217 }\n\n1\n\nx,\nR\n\nq1\n\n0\n\nR\nx,\n\n\u2192\n\n\u2192\n\n#\u2192R\n\n0, 1 \u2192 R\n\nx\u2192R\n\nx\u2192R\n\nq8\n\nq2\n#\u2192R\n\nt\n\n#\u2192R\n\nqaccept\n\nq4\n\n0, 1 \u2192 R\n\nq3\n\n\u2192R\nq5\n\n0\n1\n\nL\nx,\n\n\u2192\n\n\u2192\n\nx,\n\nL\n\nx\u2192R\n\n0, 1, x \u2192 L\n\nq6\n#\u2192L\nx\u2192R\n\nq7\n\n0, 1 \u2192 L\n\nThe above state diagram represents the formal description in\na form of state diagram of a Turing machine\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 04\n\n\fDescribing Turing Machines\n\nAn implementation description of the previous Turing\nmachine that decides {w#w | w \u2208 {0, 1}\u2217 } is shown below\nOn input string w:\n1\n\n2\n\nZig-zag across the tape to corresponding positions on either\nside of the # symbol to check whether those positions contain\nthe same symbol. If they do not, or if no # is found, reject.\nCross off symbols as they are checked to keep track of which\nsymbols correspond.\nWhen all symbols to the left of the # have been crossed off,\ncheck for any remaining symbols to the right of the #. If any\nsymbols remain, reject; otherwise, accept.\n\nNote that the above description describes the way the Turing\nmachine moves its head and store data (cross off symbols)\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 04\n\n\fDescribing Turing Machines\nAn high-level description of the previous Turing machine\nthat decides {w#w | w \u2208 {0, 1}\u2217 } is shown below:\nM =\u201cOn input s where s = x#y for some string x and y:\n1\n2\n\nCompare whether the string x is identical to the string y.\nIf they are identical, accept; otherwise, reject.\u201d\n\nNote that the where clause behaves like a filter\nAny string that does not satisfy the where clause will be\nrejected immediately\n\nWhat a TM can do?\nFrom the Church-Turing thesis, if there is an algorithm to do\nsomething, a TM can do the same thing\nExamples:\nCompare two strings\nCheck whether the length of a string is a power of 2\nAddition, subtraction, multiplication, division, modulo\nAny algorithms discussed in Chapter 1\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 04\n\n\fDescribing Turing Machines\n\nHigh-level description of a Turing machine is suitable for\ndescribing universal Turing machine\nConsider the following language:\nA = {x1 #x2 # . . . #xn | xi = xj for every i and j}\nThe following machine M 0 decides A using TM M as a\nsubroutine:\nM 0 =\u201cOn input s where s = x1 #x2 # . . . #xn :\n1\n2\n3\n4\n\nFor every i where 1 \u2264 i \u2264 n \u2212 1:\nRun M on input xi #xi+1 .\nIf M rejects, reject.\naccept\u201d\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 04\n\n\fConclusions\n\nAlgorithm and Turing Machine are consider equivalent\nAnything that an algorithm can do, there exists a TM that can\ndo the same thing\nSimply convert the algorithm to TM\n\nAnything that a Turing machine can do, there exists an\nalgorithm that can do the same thing\nSimply convert the TM to algorithm\n\nBecause of this, if there is a problem that a TM cannot solve,\nno algorithm can solve the same thing\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTuring Machine 04\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}