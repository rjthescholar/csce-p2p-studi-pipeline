{"id": 256, "segment": "self_training_2", "course": "cs1502", "lec": "lec13_decidability_01", "text": "Decidability 01\nThumrongsak Kosiyatrakul\ntkosiyat@cs.pitt.edu\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nDecidability 01\n\n\fDecidability\n\nA language is decidable if there is a decider decides it\nA language is a set of strings\nA decider is a Turing machine that halts on all inputs\nA Turing machine halts when it enters either the accept state\n(qaccept ) or the reject state (qreject )\nTo show that a language A is decidable:\nConstruct a TM M that you think it decides the language A\nand prove that\n1\n2\n\nFor every s \u2208 A, M must accept s and\nFor every s 6\u2208 A, M must reject s\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nDecidability 01\n\n\fDecidability\n\nWe constructed M and proved that\n1\n2\n\nFor every s \u2208 A, M must accept s and\nFor every s 6\u2208 A, M must reject s\n\nThis allows us to conclude the following:\n1\n\nL(M ) = A\nM accepts all strings in A and does not accept all strings not\nin A\n\n2\n\nM is a decider (always halts)\nGiven a string s, it is either in A or not in A\nIf s \u2208 A, M accepts s (halts)\nIf s 6\u2208 A, M rejects s (halts)\n\n3\n\nA is decidable\nThe decider M decides A\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nDecidability 01\n\n\fDecidable Languages\n\nProblem\nThe problem of determining whether a DFA accepts a string.\nLet hxi be a string representation of the object x\nThe above problem can be converted into a membership\nproblem (language) ADFA\nADFA = {hB, wi | B is a DFA that accepts input string w}\nNow, the problem whether DFA B accepts the string w\nbecomes the problem whether hB, wi is in ADFA\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nDecidability 01\n\n\fDecidable Languages\nThe language ADFA\nADFA = {hB, wi | B is a DFA that accepts input string w}\nAbout the above language:\nIf F is a DFA and it accepts 01101, hF, 01101i is in ADFA\nhF, 01101i can be the formal definition of DFA F , followed by\n#, and followed by 01101\nhF, 01101i = \"({q0 , . . . }, {0, 1}, . . . )#01101\"\n\nIf G is a DFA and it rejects \u03b5, hG, \u03b5i is not in ADFA\n\nRecall a set definition defined by a predicate:\nWhat can we conclude if hB, wi \u2208 ADFA ?\nB is a DFA that accepts input string w\n\nWhat can we conclude if hB, wi 6\u2208 ADFA ?\nB is not a DFA,\nw is not a string, or\nB is a DFA that rejects input string w\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nDecidability 01\n\n\fDecidable Languages\n\nThe language ADFA\nADFA = {hB, wi | B is a DFA that accepts input string w}\nTo show that ADFA is decidable, we must show that there\nexists a decider M that decides ADFA\nConstruct a TM M that we think it decides A and prove that\n1\n\n2\n\nIf hB, wi \u2208 ADFA (DFA B accepts the string w), M accepts\nhB, wi\nIf hB, wi 6\u2208 ADFA (DFA B rejects the string w), M rejects\nhB, wi\n\nWe learn an algorithm how to simulate a DFA on an input\nstring in Chapter 1\nTuring machine can do the same\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nDecidability 01\n\n\fDecidable Languages\nThe language ADFA\nADFA = {hB, wi | B is a DFA that accepts input string w}\nAn example of a Turing machine M is as follows:\nM =\u201cOn input hB, wi, where B is a DFA and w is a string:\n1\n2\n\nSimulate B on input w.\nIf the simulation ends in an accept state, accept. If it ends in a\nnonaccepting state, reject.\u201d\n\nNotes about the above TM\nInput format hB, wi is the same as format of strings in ADFA\nThe where clause filters out the following cases:\nB is not a DFA\nw is not a string\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nDecidability 01\n\n\fDecidable Languages\n\nAn example of a Turing machine M is as follows:\nM =\u201cOn input hB, wi, where B is a DFA and w is a string:\n1\n2\n\nSimulate B on input w.\nIf the simulation ends in an accept state, accept. If it ends in a\nnonaccepting state, reject.\u201d\n\nWe do not know whether M is a decider for ADFA yet\nWe need to show that M is a decider for the language ADFA\nby proving that\n1\n2\n\nIf hB, wi \u2208 ADFA , M accepts hB, wi\nIf hB, wi 6\u2208 ADFA , M rejects hB, wi\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nDecidability 01\n\n\fIs M a Decider for the Language ADFA\nAgain, to show that the Turing machine M is a decider for\nthe language ADFA , we have to show that\n1\n2\n\nIf hB, wi \u2208 ADFA , M accepts w\nIf hB, wi 6\u2208 ADFA , M rejects w\n\nProofs:\nCase 1: Assume that hB, wi \u2208 ADFA . Since hB, wi \u2208 ADFA ,\nby the definition of ADFA , B is a DFA that accepts the string\nw. Since B accepts w, by simulating B on input w in step 1,\nthe simulation will end in an accept state. Since the simulation\nends in an accept state, M accepts hB, wi.\nCase 2: Assume that hB, wi 6\u2208 ADFA . Since hB, wi 6\u2208 ADFA ,\nby the definition of ADFA , B is a DFA that rejects the string\nw. Since B rejects w, by simulating B on input w in step 1,\nthe simulation will end in a non-accept state. Since the\nsimulation ends in a non-accept state, M rejects hB, wi.\n\nWe just show that M accepts all strings in ADFA and rejects\nall strings not in ADFA\nM is a decider for ADFA . Therefore, ADFA is decidable\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nDecidability 01\n\n\fProve that ADFA is Decidable\nProve that\nADFA = {hB, wi | B is a DFA that accepts w}\nis decidable.\nSolution: Construct a TM M as follows:\nM =\u201cOn input hB, wi, where B is a DFA and w is a string:\n1\n\nSimulate B on input w.\n\n2\n\nIf the simulation ends in an accept state, accept. If it ends in a nonaccepting\nstate, reject.\u201d\n\nNext, we need to prove that M decides ADFA :\nCase 1: Assume that hB, wi \u2208 ADFA . Since hB, wi \u2208 ADFA , by the definition\nof ADFA , B is a DFA that accepts the string w. Since B accepts w, by\nsimulating B on input w in step 1, the simulation will end in an accept state.\nSince the simulation ends in an accept state, M accepts hB, wi.\nCase 2: Assume that hB, wi 6\u2208 ADFA . Since hB, wi 6\u2208 ADFA , by the definition\nof ADFA , B is a DFA that rejects the string w. Since B rejects w, by\nsimulating B on input w in step 1, the simulation will end in a non-accept state.\nSince the simulation ends in a non-accept state, M rejects hB, wi.\nThis shows that M is a decider for ADFA . Therefore, ADFA is decidable.\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nDecidability 01\n\n\fDecidable Languages\nANFA\nLet ANFA = {hB, wi | B is an NFA that accepts input string w}.\nShow that ANFA is decidable.\nAgain, to show that ANFA is decidable, we need to construct\na TM N and prove the following:\n1\n2\n\nIf hB, wi \u2208 ANFA , N accepts hB, wi\nIf hB, wi 6\u2208 ANFA , N rejects hB, wi\n\nAs discussed earlier in Chapter 1, there is an algorithm that\nallows us convert an NFA B into an equivalent DFA C\nSince there is an algorithm, a Turing machine that convert an\nNFA B into a equivalent DFA C where L(B) = L(C)\nIf NFA B accepts w, DFA C also accepts w\nIf DFA C accepts w, hC, wi \u2208 ADFA\nIf hC, wi \u2208 ADFA , TM M (decider for ADFA ) accept hC, wi\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nDecidability 01\n\n\fDecidable Languages\nTM N can be constructed as follows:\nN =\u201cOn input hB, wi, where B is a NFA and w is a string:\n1\n\n2\n3\n\nConvert NFA B to an equivalent DFA C, using the procedure\nfor this conversion given in Theorem 1.39.\nRun TM M from Theorem 4.1 on input hC, wi.\nIf M accepts, accept; otherwise, reject.\u201d\n\nNotes about TM N\nRecall that the language of TM M is ADFA :\nADFA = {hB, wi | B is a DFA that accepts w}\nTM N runs TM M on input hC, wi where\nC is a DFA that it just constructed from NFA B\nw is a string\nM will accept or reject hC, wi depending on whether hC, wi\nin ADFA\n\nTM N runs TM M on input hB, wi, M will always reject the\ninput since B is an NFA\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nDecidability 01\n\n\fProve that ANFA is Decidable\nProve that ANFA = {hB, wi | B is an NFA that accepts w} is decidable.\nSolution: Construct a TM N as follows:\nN =\u201cOn input hB, wi, where B is a NFA and w is a string:\n1\n\nConvert NFA B to an equivalent DFA C, using the procedure for this conversion\ngiven in Theorem 1.39.\n\n2\n\nRun TM M from Theorem 4.1 on input hC, wi.\n\n3\n\nIf M accepts hC, wi, accept; otherwise, reject.\u201d\n\nNext, we need to prove that N decides ANFA :\n1\n\nCase 1: Assume that hB, wi \u2208 ANFA . Since hB, wi \u2208 ANFA , by the definition\nof the language ANFA , B is an NFA that accepts the string w. By converting\nthe NFA B into an equivalent DFA C (L(B) = L(C)), C also accepts the string\nw. Since C is a DFA that accepts the string w, hC, wi \u2208 ADFA . Since M is a\ndecider for ADFA , by running M on input hC, wi, M will accept hC, wi which\nwill cause N to accept hB, wi.\n\n2\n\nCase 2: Assume that hB, wi 6\u2208 ANFA , Since hB, wi 6\u2208 ANFA , by the definition\nof the language ANFA , B is an NFA that rejects the string w. By converting\nthe NFA B into an equivalent DFA C (L(B) = L(C)), C also rejects the string\nw. Since C is a DFA that rejects the string w, hC, wi 6\u2208 ADFA . Since M is a\ndecider for ADFA , by running M on input hC, wi, M will reject hC, wi which\nwill cause N to reject hB, wi.\n\nThis shows that TM N is a decider for ANFA . Therefore, ANFA is decidable.\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nDecidability 01\n\n\fDecidable Language\nAREX\nLet\nAREX = {hR, wi | R is a regular expression that generates string w}.\n\nShow that AREX is decidable.\nAgain, to show that AREX is decidable, we need to construct\na TM P and prove the following:\n1\n2\n\nIf hR, wi \u2208 AREX , P accepts hR, wi\nIf hR, wi 6\u2208 AREX , P rejects hR, wi\n\nRecall that we have an algorithm that generates an NFA A\nfrom a regular expression R where the language of A is\nexpressed by R\nAgain, since there is an algorithm, we can have a Turing\nmachine that convert a regular expression R into an equivalent\nNFA A\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nDecidability 01\n\n\fProve that AREX is Decidable\nProve that AREX = {hR, wi | R is a regular expression that generates string w} is\ndecidable.\nSolution: Construct a TM P as follows:\nP =\u201cOn input hR, wi, where R is a regular express and w is a string:\n1 Convert regular expression R to an equivalent NFA A by using the procedure for\nthis conversion given in Theorem 1.54.\n2 Run TM N from Theorem 4.2 on input hA, wi.\n3 If N accepts hA, wi, accept; if N rejects hA, wi, reject.\u201d\nNext, we need to prove that P decides AREX :\n1 Case 1: Assume that hR, wi \u2208 AREX . Since hR, wi \u2208 AREX , from the\ndefinition of AREX , R is a regular expression that generates the string w. Since\nR is a regular expression that generates w, by converting R into an equivalent\nNFA A, A accepts w. Since NFA A accepts w, hA, wi \u2208 ANFA . Since TM N is\na decider for ANFA , by running N on input hA, wi, N will accept hA, wi which\ncauses P to accept hR, wi.\n2 Case 2: Assume that hR, wi 6\u2208 AREX . Since hR, wi 6\u2208 AREX , from the\ndefinition of AREX , R is a regular expression that does not generate the string\nw. Since R is a regular expression that does not generate w, by converting R\ninto an equivalent NFA A, A rejects w. Since NFA A rejects w,\nhA, wi 6\u2208 ANFA . Since TM N is a decider for ANFA , by running N on input\nhA, wi, N will reject hA, wi which causes P to reject hR, wi.\nThis shows that TM P is a decider for AREX . Therefore, AREX is decidable.\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nDecidability 01\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}