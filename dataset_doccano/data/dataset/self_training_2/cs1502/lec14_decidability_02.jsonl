{"id": 250, "segment": "self_training_2", "course": "cs1502", "lec": "lec14_decidability_02", "text": "Decidability 02\nThumrongsak Kosiyatrakul\ntkosiyat@cs.pitt.edu\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nDecidability 02\n\n\fDecidable Languages\n\nEDFA\nLet EDFA = {hAi | A is a DFA and L(A) = \u2205}. Show that EDFA\nis decidable.\nHow do we know a DFA accepts no string?\nThis machine has no accept state (F = \u2205) or\nThis machine has some accept states but are not reachable\nfrom the start state\n\nTo show that EDFA is decidable, we need a Turing machine T\nsuch that\nIf hAi \u2208 EDFA , T accepts hAi\nIf hAi 6\u2208 EDFA , T rejects hAi\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nDecidability 02\n\n\fNot a Decider Example\nConsider this TM S:\nS = \u201cOn input hAi where A is a DFA:\n1\n2\n3\n\nFor all strings w:\nRun TM M on input hA, wi\nIf M accepts hA, wi, reject\u201d\n\nDo you see the problem of TM S?\nTM S is not a decider\nGiven hAi where A is a DFA and L(A) = \u2205, S will run\nindefinitely\n\nFor this problem:\nWe may have to play around with its state diagram\nCreate a Turing machine that analyze a DFA by marking all\nstates reachable from the start state. If no accept state is\nmarked, the DFA accepts no string\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nDecidability 02\n\n\fDecidable Languages\n\nConsider the following TM T :\nT =\u201cOn input hAi, where A is a DFA:\n1\n2\n3\n\n4\n\nMark the start state of A.\nRepeat until no new states get marked:\nMark any state that has a transition coming into it from\nany state that is already marked.\nIf no accept state is marked, accept; otherwise, reject.\u201d\n\nWe should not need to go down to the state diagram of a\nDFA unless it is necessary\nRely on graph theory\nTo prove, it must be based on graph theory\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nDecidability 02\n\n\fDecidable Languages\nEQDFA\nLet EQDFA = {hA, Bi | A and B are DFAs and L(A) = L(B)}.\nShow that EQDFA is decidable.\nGiven two DFAs A and B, is there any algorithm to check\nwhether L(A) = L(B)?\nIn other words, can we have a Turing machine F such that\nIf hA, Bi \u2208 EQDFA (L(A) = L(B)), F will accept hA, Bi and\nIf hA, Bi 6\u2208 EQDFA (L(A) 6= L(B)), F will reject hA, Bi\n\nAgain, we cannot simply run both DFAs on all strings until\none accept but the other reject\nThis may loop indefinitely\n\nSince L(A) and L(B) are sets, we need to use the set theory\nL(A) = L(B) iff L(A) \u2286 L(B) and L(B) \u2286 L(A)\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nDecidability 02\n\n\fDecidable Languages\nL(A) \u2286 L(B)\nL(B)\nL(A)\nL(B)\n\nFrom the above diagram L(A) \u2229 L(B) = \u2205\nL(B) \u2286 L(A)\nL(A)\nL(B)\nL(A)\n\nFrom the above diagram L(A) \u2229 L(B) = \u2205\nL(A) = L(B) iff (L(A) \u2229 L(B)) \u222a (L(A) \u2229 L(B)) = \u2205.\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nDecidability 02\n\n\fThe set of regular languages\nClosed Under Complement:\nGiven a DFA A = (Q, \u03a3, \u03b4, q0 , F ) we can construct a DFA A0\nwhere L(A0 ) = L(A).\nA0 = (Q, \u03a3, \u03b4, q0 , Q \u2212 F )\n\nClosed Under Union:\nGiven two DFAs A = (QA , \u03a3, \u03b4A , qA , FA ) and\nB = (QB , \u03a3, \u03b4B , qB , FB ) we can construct a DFA\nC = (QC , \u03a3, \u03b4C , qC , FC ) where L(C) = L(A) \u222a L(B).\nQC = QA \u00d7 QB\n\u03b4C ((qi , qj ), x) = (\u03b4A (qi , x), \u03b4B (qj , x)) where qi \u2208 QA and\nqj \u2208 QB .\nqC = (qA , qB )\nFC = {(qi , qj ) | qi \u2208 FA or qj \u2208 FB }.\n\nClosed Under Intersection:\nSame as Closed Under Union except that\nFC = {(qi , qj ) | qi \u2208 FA and qj \u2208 FB }.\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nDecidability 02\n\n\fDecidable Language\nTo show that\n(L(A) \u2229 L(B)) \u222a (L(A) \u2229 L(B)) = \u2205\nWe need to construct a DFA C such that\nL(C) = (L(A) \u2229 L(B)) \u222a (L(A) \u2229 L(B))\nand check that L(C) = \u2205 (hCi \u2208 EDFA )\nThis can be done by:\n1\n2\n3\n4\n5\n6\n\nConstruct DFA D such that L(D) = L(B)\nConstruct DFA E such that L(E) = L(A) \u2229 L(D)\nConstruct DFA F such that L(F ) = L(A)\nConstruct DFA G such that L(G) = L(F ) \u2229 L(B)\nConstruct DFA C such that L(C) = L(E) \u222a L(G)\nRun T (a decider for EDFA ) on input hCi\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nDecidability 02\n\n\fDecidable Languages\n\nFor simplicity, we can simply construct a DFA C such that\nL(C) = (L(A) \u2229 L(B)) \u222a (L(A) \u2229 L(B))\nAgain, we need to show that C accepts no string (L(C) = \u2205)\nThis is an example of a TM:\nF =\u201cOn input hA, Bi, where A and B are DFAs:\n1\n\nConstruct DFA C such that\nL(C) = (L(A) \u2229 L(B)) \u222a (L(A) \u2229 L(B))\n\n2\n3\n\nRun TM T from Theorem 4.4 on input hCi.\nIf T accepts hCi, accept. If T rejects hCi, reject.\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nDecidability 02\n\n\fProve that EQ DFA is Decidable\nProve that EQ DFA = {hA, Bi | A and B are DFAs and L(A) = L(B)} is decidable.\nSolution: Construct a TM F as follows:\nF =\u201cOn input hA, Bi, where A and B are DFAs:\n1\n\nConstruct DFA C such that L(C) = (L(A) \u2229 L(B)) \u222a (L(A) \u2229 L(B))\n\n2\n\nRun TM T from Theorem 4.4 on input hCi.\n\n3\n\nIf T accepts hCi, accept. If T rejects hCi, reject.\n\nNow, we need to prove that F is a decider for EQ DFA .\n1\n\nAssume that hA, Bi \u2208 EQ DFA . Since hA, Bi \u2208 EQ DFA , A and B are DFAs\nand L(A) = L(B). Since L(A) = L(B), according to the definition of the\nlanguage of DFA C, L(C) = \u2205. Since L(C) = \u2205, hCi \u2208 EDFA . By running T\non input hCi, T will accept hCi. Since T accepts hCi, F accepts hA, Bi.\n\n2\n\nAssume that hA, Bi 6\u2208 EQ DFA . Since hA, Bi 6\u2208 EQ DFA , A and B are DFAs\nand L(A) 6= L(B). Since L(A) 6= L(B), according to the definition of the\nlanguage of DFA C, L(C) 6= \u2205. Since L(C) 6= \u2205, hCi 6\u2208 EDFA . By running T\non input hCi, T will reject hCi. Since T rejects hCi, F rejects hA, Bi.\n\nThis shows that F is a decider for EQ DFA . Therefore, EQ DFA is decidable.\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nDecidability 02\n\n\fDecidability\nSo far we have the following Turing machines:\n1\n\nTM M that decides ADFA where\nADFA = {hB, wi | B is a DFA that accepts w}\n\n2\n\nTM N that decides ANFA where\nANFA = {hB, wi | B is an NFA that accepts w}\n\n3\n\nTM P that decides AREX\nAREX = {hR, wi | R is a regular expression that generates w}\n\n4\n\nTM T that decides EDFA\nEDFA = {hAi | A is an DFA and L(A) = \u2205}\n\n5\n\nTM F that decides EQ DFA\nEQ DFA = {hA, Bi | A and B are DFAs and L(A) = L(B)}\n\nWe can use these TMs as helper machines\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nDecidability 02\n\n\fONE DFA\nHow do we know that a DFA accepts exactly one string?\nThis problem corresponds with the language ONE DFA as\nfollows:\nONE DFA = {hAi | A is a DFA and |L(A)| = 1}\nHow to show that ONE DFA is decidable?\nConstruct a TM M 0 such that\n1\n2\n\nIf hAi \u2208 ONE DFA , M 0 accepts hAi\nIf hAi 6\u2208 ONE DFA , M 0 rejects hAi\n\nNote that we cannot run a DFA A on all string until it\naccepts a string because it may loop indefinitely\nBut if L(A) 6= \u2205, it will not loop indefinitely\nSo, we need to check that the language of a given DFA is not\nempty first\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nDecidability 02\n\n\fONE DFA\n\nConstruct a TM M 0 as follows:\nM 0 = \u201cOn input hAi where A is a DFA:\n1\n2\n3\n\n4\n5\n6\n\nRun T on input hAi\nIf T accepts hAi, reject.\nIf T rejects hAi, run A on all inputs until it accepts an input\nstring w\nConstruct a DFA B such that L(B) = {w}\nRun F on input hA, Bi.\nIf F accepts hA, Bi, accept. Otherwise, reject.\u201d\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nDecidability 02\n\n\fONE DFA\nProve that if hAi \u2208 ONE DFA , M 0 accepts hAi:\nAssume that hAi \u2208 ONE DFA . Since hAi \u2208 ONE DFA , A is a DFA and\n|L(A)| = 1. Since |L(A)| = 1, L(A) 6= \u2205. Since L(A) 6= \u2205, hAi 6\u2208 EDFA . Since\nT is a decider for EDFA , by running T on input hAi, T will reject hAi. Since\n|L(A)| = 1, by running A on all strings, it will eventually accept a string w.\nSince |L(A)| = 1 and A accepts w, L(A) = {w} which is the same as the\nlanguage of B. Since L(A) = L(B), hA, Bi \u2208 EQ DFA . By running F on input\nhA, Bi, F will accept hA, Bi. Since F accepts hA, Bi, M 0 accepts hAi.\nProve that if hAi 6\u2208 ONE DFA , M 0 rejects hAi:\nAssume that hAi 6\u2208 ONE DFA . Since hAi 6\u2208 ONE DFA , A is a DFA and\n|L(A)| 6= 1. In other words, L(A) = \u2205 or |L(A)| > 1.\nIf L(A) = \u2205, hAi \u2208 EDFA . Since T is a decider for EDFA , by running T on\ninput hAi, T will accept hAi. Since T accepts hAi, M 0 rejects hAi.\nIf |L(A)| > 1, by running A on all strings, it will eventually accept a string w.\nSince |L(A)| > 1 and A accepts w, L(A) 6= {w} which is not the same as the\nlanguage of B. Since L(A) 6= L(B), hA, Bi 6\u2208 EQ DFA . By running F on input\nhA, Bi, F will reject hA, Bi. Since F rejects hA, Bi, M 0 rejects hAi.\nThis shows that M 0 is a decider for ONE DFA . Therefore, ONE DFA is decidable.\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nDecidability 02\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}