{"id": 252, "segment": "self_training_2", "course": "cs1502", "lec": "lec28_time_complexity_03", "text": "Time Complexity 03\nThumrongsak Kosiyatrakul\ntkosiyat@cs.pitt.edu\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 03\n\n\fHamiltonian Path\nA Hamiltonian path in a directed graph G is a directed path\nthat goes through each node exactly once\nFormally,\nHAMPATH = {hG, s, ti | G is a directed graph with a\nHamiltonian path from s to t}\n\ns\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nt\n\nTime Complexity 03\n\n\fVerifier\nSuppose a path is represented by a sequence of pairs of nodes\nFor example: ((s, a), (a, c), (c, d), (d, r), (r, t))\nGiven a path c, we can verify whether it is a Hamiltonian path\nof graph G from s to t in polynomial time\nGiven an input hhG, s, ti, ci, where G is a directed graph, s\nand t are nodes, and c is a path, a TM can verify whether c is\na Hamiltonian path of graph G from s to t in polynomial time\n\nSimilarly, given a natural number c, we can verify whether c is\na factor of a composite number x in polynomial time\nGiven an input hx, ci where x and c are natural numbers, a\nTM can verify whether c is a factor of x in polynomial time\n\nThis feature is called polynomial verifiability\nRecall that both problems need exponential time to solve\nVerifying is easier than finding\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 03\n\n\fVerifier\nRecall the language COMPOSITES :\nCOMPOSITES = {hxi | x = pq for natural numbers p, q > 1}\n\nWe can define the identical set using a different predicate\nCOMPOSITES = {hxi | x is divisible by c a natural number c > 1}\n\nCheck whether x is divisible by c can be easily done by this\nTM V :\nV = \u201cOn input hx, ci where x and c are natural numbers\ngreater than 1:\n1\n2\n\nCalculate y = x mod c\nIf y = 0, accept. If y 6= 0, reject.\u201d\n\nWith the TM V above, now we have\nCOMPOSITES = {hxi | V accepts hx, ci for some c}\n\nThis TM V is called a verifier\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 03\n\n\fVerifier\nA verifier for a language A is an algorithm V , where\nA = {w | V accepts hw, ci for some string c}\nIn our discussion, an algorithm V is a TM\nIf TM V runs in polynomial time, it is called a polynomial\ntime verifier\nA language A is polynomially verifiable if it has a polynomial\ntime verifier\n\nc is called a certificate or proof of membership in A\nExamples:\nA certificate of HAMPATH problem for hG, s, ti is simply a\nHamiltonian path from s to t\nA certificate of COMPOSITES problem for a number x is one\nof its divisors\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 03\n\n\fClass NP\n\nDefinition 7.19\nNP is the class of languages that have polynomial time verifiers.\nNP comes from Nondeterministic Polynomial time\nNP -Problems are set of problems in NP\nEvery problems in P also have polynomial time verifier\nTherefore, P \u2286 NP\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 03\n\n\fNondeterministic\nRecall that NP stands for Nondeterministic Polynomial\nThe word nondeterministic has been discussed int\nNondeterministic Finite Automaton (NFA)\nNondeterministic Turing Machine (NTM)\n\nWe have not yet seen a nondeterministic Turing machine yet\nExample:\nt\n\n\u2192 0, R\n\nq0\n\nt\n\n\u2192 0, R\n\nq1\nt\n\n\u2192 1, R\n\nt\n\n\u2192 0, R\n\nq2\nt\n\n\u2192 1, R\n\nq3\nt\n\n\u2192 1, R\n\nWhen it read the blank symbol, it splits to two copies, same\ncurrent state, but different tape contents\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 03\n\n\fNondeterministic\nt\n\n\u2192 0, R\n\nq0\n\nt\n\n\u2192 0, R\n\nq1\nt\n\n\u2192 1, R\n\nt\n\n\u2192 0, R\n\nq2\nt\n\n\u2192 1, R\n\nq3\nt\n\n\u2192 1, R\n\nWhat would happen if we run the above machine on input \u03b5\nfor three steps?\nConsists of 8 copies\nThey are all in state q3\nTape contents are unique:\n000, 001, 010, 011, 100, 101, 110, and 111\n\nThis is how we generate all possible strings over \u03a3 = {0, 1} of\nlength exactly 3\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 03\n\n\fNondeterministic\nt\n\n\u2192 0, R\n\nq0\n\nt\n\n\u2192 0, R\n\nq1\nt\n\n\u2192 1, R\n\nt\n\n\u2192 0, R\n\nq2\nt\n\n\u2192 1, R\n\nq3\nt\n\n\u2192 1, R\n\nBut how to express the above TM in a high-level description?\nM = \u201cOn input w:\n1\n\n2\n\nWrite a string of length 3 where each symbol on the string is\nnondeterministically selected to be either 0 or 1\n...\n\nThis type of NTM is suitable for describing brute-force\nalgorithm\nA brute-force algorithm generally generates all possible of\nsomething\nThen search for an element in the set of possibilities\nIf it finds an element that satisfies the criteria, done\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 03\n\n\fNondeterministic TM for HAMPATH\n\nA nondeterministic TM N1 that decides HAMPATH :\nN1 = \u201cOn input hG, s, ti, where G is a directed graph with\nnodes s and t:\n1\n\n2\n3\n4\n\nWrite a list of m numbers p1 , . . . pm , where m is the number\nof nodes in G. Each number in the list is nondeterministically\nselected to be between 1 and m.\nCheck for repetitions in the list. If any are found reject.\nCheck whether s = p1 and t = pm . If either fail, reject.\nFor each i between 1 and m \u2212 1, check whether (pi , pi+1 ) is\nan edge of G. If any are not, reject. Otherwise, all tests have\nbeen passed. so accept.\n\nThe nondeterministic part of N1 is in step 1\nIt generates all permutations of m nodes\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 03\n\n\fNondeterministic TM for HAMPATH\nWhat is the run-time of NTM N1 ?\nStep 1 takes only m steps to write m numbers\nCheck for repetition take O(m2 )\nGet the first number and compare with the rest is O(m)\nGet the second number and compare with the rest is O(m)\nand so on (m times)\n\nCheck whether the first number is s and the last number is t is\nO(m)\nStep 4 takes O(m2 )\nGet the first pair and scan for the edge is O(m)\nGet the second pair and scan for the edge is O(m)\nand so on (m \u2212 1 times)\n\nNote that all copies run steps 2, 3, and 4 simultaneously\nThe above TM runs in polynomial time\nFrom Theorem 7.11, this algorithm will run in exponential time\non a single-tape Turing machine\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 03\n\n\fLanguage in NP\n\nIs there a relation between problem in NP and NTM?\nYes:\nTheorem 7.20: A language is in NP iff it is decided by some\nnondeterministic polynomial time Turing machine.\nBut the NP is the class of languages that have polynomial\ntime verifiers\nProof Idea:\nShow how to convert a polynomial time verifier to an\nequivalent polynomial time nondeterministic Turing machine\n(decider)\nShow how to convert polynomial time nondeterministic Turing\nmachine (decider) to an equivalent polynomial time verifier\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 03\n\n\fVerifier to NTM\nAssume that A \u2208 NP\nBy definition, there exists a TM V (a polynomial time verifier)\nfor the language A that can verify an input of length n in nk\nsteps for some k\nRecall that a verifier for a language A is an algorithm V ,\nwhere\nA = {w | V accepts hw, ci for some string c}\n\nConstruct a NTM N as follows:\nN = \u201cOn input w of length n:\n1\n2\n3\n\nNondeterministically select string c of length at most nk .\nRun V on input hw, ci.\nIf V accepts, accept; otherwise, reject.\u201d\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 03\n\n\fNTM to Verifier\n\nAssume that A can be decided by NTM N in polynomial time\nConstruct a polynomial time verifier V as follows:\nV = \u201cOn input hw, ci, where w and c are strings:\n1\n\n2\n\nSimulate N on input w, treating each symbol of c as a\ndescription of the nondeterministic choice to make at each step\nIf this branch of N \u2019s computation accepts, accept; otherwise,\nreject.\u201d\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 03\n\n\fLanguage in NP\nDefinition 7.21\nNTIME(t(n)) = {L | L is a language decided by an O(t(n)) time\nnondeterministic Turing machine}.\nCorollary 7.22\nNP =\n\n[\n\nNTIME(nk )\n\nk\n\nTo show that a language A is in NP :\nConstruct a nondeterministic TM M that decides A\nVerify that M runs in polynomial time\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 03\n\n\fCLIQUE\nA clique in an undirected graph is a subgraph where every\ntwo nodes in the subgraph are connected by an edge\nA k-clique is a clique that contains k nodes\nA graph with 5-clique is shown below:\n\nFormally,\nCLIQUE = {hG, ki | G is an undirected graph with a k-clique}\n\nIs CLIQUE in NP ?\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 03\n\n\fCLIQUE \u2208 NP\n\nTo show that CLIQUE \u2208 NP , we can perform one of the\nfollowing:\nShow a polynomial time verifier V for CLIQUE or\nShow an NTM N that decides CLIQUE in polynomial time\n\nThe following TM V verifies CLIQUE in polynomial time:\nV = \u201cOn input hhG, ki, ci:\n1\n2\n3\n\nTest whether c is a subgraph with k nodes in G.\nTest whether G contains all edges connecting nodes in c.\nIf both pass, accept; otherwise, reject.\u201d\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 03\n\n\fCLIQUE \u2208 NP\n\nAnalysis of TM V :\nEach step will be executed only once\nStep 1: Need to go back and forth k times\nEach time is O(n) step\nThus step 1 is k \u00d7 O(n) = O(n)\n\nStep 2: for each node a \u2208 c, it needs to find either (a, b) or\n(b, a) for every b \u2208 c and b 6= a\nFor each node, it needs to scan back and forth k \u2212 1 times\nand each time is O(n)\nThere are k nodes in c. Thus, step 2 is k \u00d7 (k \u2212 1) \u00d7 O(n) =\nO(n)\n\nThus, V runs in polynomial time\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 03\n\n\fCLIQUE \u2208 NP\n\nThe following NTM N can decide CLIQUE in polynomial\ntime:\nN = \u201cOn input hG, ki, where G is a graph:\n1\n2\n3\n\nNondeterministically select a subset c of k nodes of G.\nTest whether G contains all edges connecting nodes in c.\nIf yes, accept; otherwise, reject.\u201d\n\nAnalysis of NTM N :\nEach step will be execute only once\nStep 1: To generate a subset c of k nodes of G requires k steps\nStep 2: This step is the same as Step 2 of V which is O(n)\nsteps\nStep 3: Simply O(1) or O(n) depending on implementations\nThus N can decides CLIQUE in polynomial time\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 03\n\n\fSUBSET \u2212SUM\nConsider a set of numbers S = {x1 , x2 , . . . , xk } and a target\nnumber t\nIs\nPthere exists a set Y = {y1 , y2 , . . . , yi } \u2286 S such that\ni yi = t?\nFormally:\nSUBSET \u2212SUM = {hS, ti | S = {x1 , x2 , . . . , xk }, and for some\n{y1 , y2 , . . . , yi } \u2286 {x1 , x2 , . . . , xk },\nX\nwe have\nyi = t}\ni\n\nFor example h{4, 11, 16, 21, 27}, 25i \u2208 SUBSET \u2212SUM\nbecause 4 + 11 = 25\nNote that for SUBSET \u2212SUM , S and Y are multisets which\nallow duplicate elements\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 03\n\n\fSUBSET \u2212SUM \u2208 N P\nTo show that SUBSET \u2212SUM \u2208 NP , we can perform one of\nthe following:\n1\n2\n\nShow a polynomial time verifier V for SUBSET \u2212SUM\nShow an NTM N that decide SUBSET \u2212SUM in polynomial\ntime\n\nThe following TM V verifies SUBSET \u2212SUM in polynomial\ntime:\nV = \u201cOn input hhS, ti, ci:\n1\n2\n3\n\nTest whether c is a collection of numbers that sum to t.\nTest whether S contains all the numbers in c.\nIf both pass, accept; otherwise, reject.\u201d\n\nThe following NTM N decides SUBSET \u2212SUM in\npolynomial time:\nN = \u201cOn input hS, ti:\n1\n2\n3\n\nNondeterministically select a subset c of the number in S.\nTest whether c is a collection of numbers that sum to t.\nIf the test passes, accept; otherwise, reject.\u201d\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 03\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}