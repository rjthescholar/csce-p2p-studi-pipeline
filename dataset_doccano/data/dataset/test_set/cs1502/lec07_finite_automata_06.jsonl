{"id": 11, "segment": ["test_set", "labeled"], "course": "cs1502", "lec": "lec07_finite_automata_06", "text": "Finite Automata 06\nThumrongsak Kosiyatrakul\ntkosiyat@cs.pitt.edu\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 06\n\n\fLanguage\nA language is a set of strings\nA set can be empty\nA set can have a finite number of elements\nA set can have an infinite number of elements\n\nRegular or not regular?\nIf L is the empty language,\nL is regular since we can express it using the regular\nexpression \u2205\n\nIf L is finite\nL = {s1 , s2 , s3 , . . . , sn }\nfor a number n > 0 and si is a string,\nL is regular since we can express it using the regular expression\ns1 \u222a s2 \u222a s3 \u222a \u00b7 \u00b7 \u00b7 \u222a sn\n\nSo, a non-regular language must be an infinite language\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 06\n\n\fRegular Infinite Languages\nBut an infinite language can be a regular language:\n{w | w starts with a 1}\n{w | w contains 011 as a substring}\n{w | w ends with 0110}\n\nTechnically, there are infinite number of regular languages\nthat contains infinite number of strings\nThere must be something that can be used to distinguish\nbetween regular languages and non-regular languages\nBy definition, a language is regular if there are some finite\nstate machines that recognize it\nRecall that the number of states of a finite state machine must\nbe finite\nBut a finite state machine can accept an infinite number of\nstrings\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 06\n\n\fRegular Infinite Languages\nWhat is the special property that makes a finite state machine\naccepts an infinite number of strings?\nA loop in a path to an accept state\n0\n\n1\n\n1\n0\n\n0\n\n0\n1\n\n1\n\n0\n\nLet L(M ) be the language of the above machine M :\n10\u2217 1 \u2286 L(M )\n10\u2217 1 = {11, 101, 1001, 10001, . . . } \u2286 L(M )\nIn other words, 10i 1 \u2208 L(M ) for any i \u2265 0\n00(1010)\u2217 0 \u2286 L(M )\n00(1010)\u2217 0 = {000, 0010100, 00101010100, . . . } \u2286 L(M )\nIn other words, 00(1010)i 0 \u2208 L(M ) for any i \u2265 0\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 06\n\n\fRegular Infinite Languages\nGiven a DFA M , how to detect that there is a loop in a path\nto an accept state?\nSuppose a DFA M has 5 states and it accepts the string\nw = w1 w2 w3 w4 w5 of length 5\nw1\n\nw2\n\nw3\n\nw4\n\nw5\n\nThere are the total of 6 current states but there are only 5\nstates\nAt least two of them must be the same (Pigeonhole principle)\n\nSuppose the third and the fifth are the same state\n\nw4\nw1\n\nw3\n\nw2\n\nw1 w2 (w3 w4 )i w5 \u2208 L(M ) for any i \u2265 0\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 06\n\nw5\n\n\fRegular Infinite Languages\nFrom previous example\nAny strings of length at least 5 that is accepted by M will go\nthrough a loop\nIf we let x = w1 w2 , y = w3 w4 , and z = w5 , we can say that\nxy i z \u2208 L(M ) for any i \u2265 0\n\nGiven an infinite regular language A, there is a finite state\nmachine M that recognizes it\nBut we have no idea how many states it has\nSuppose it has p states\nAny string s \u2208 A of length at least p will go through a loop\ns must be divided into s = xyz where y 6= \u03b5 such that\nxy i z \u2208 A for any i \u2265 0\nwhere y is the string that takes you around a loop\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 06\n\n\fExample\nConsider the following language\nA = {w | w contains 011 as a substring}\nWe need at least a 4-states DFA to recognize A\nLet\u2019s find a string s \u2208 A of length at least 4\nLet s = 0111\nx = 011, y = 1, z = \u03b5\nxy 0 z = xz = 011 \u2208 A\nxy 1 z = xyz = 0111 \u2208 A\nxy 2 z = xyyz = 01111 \u2208 A\n..\n.\nxy i z \u2208 A for i \u2265 0\n\nLet s = 0101011\nx = 0, y = 1, z = 01011 and xy i z \u2208 A for i \u2265 0\nxy 0 z = xz = 001011 \u2208 A\nxy 1 z = xyz = 0101011 \u2208 A\nxy 2 z = xyyz = 01101011 \u2208 A\n..\n.\nxy i z \u2208 A for i \u2265 0\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 06\n\n\fPumping Lemma\n\nThe pumping lemma states that all regular languages has a\nspecial property\nIf a language lack this property, it is not a regular language\nProperty\nAll strings in the language can be pumped if they are at least as\nlong as a certain special value, called the pumping length. Each\nsuch strings contains a section that can be repeated any number of\ntimes with the resulting string remaining in the language.\npumped: xy i z for any i \u2265 0\nWe can insert the string y in between x and z any number of\ntimes but the result string is still in the language\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 06\n\n\fPumping Lemma\nPumping Lemma\nIf A is a regular language, then there is a number p (the pumping\nlength) where if s is any string in A of length at least p, then s\nmust be divided into three pieces, s = xyz, satisfying the following\nconditions:\n1\n\nfor each i \u2265 0, xy i z \u2208 A,\n\n2\n\n|y| > 0, and\n\n3\n\n|xy| \u2264 p.\n\nwhere\n|s| represents the length of the string s\ny i means that i copies of y are concatenated together\ny 0 equals \u03b5 but it does not mean that y = \u03b5\n(010)0 = \u03b5 but 010 6= \u03b5\n\nxy 0 z = xz, xy 1 z = xyz, xy 2 z = xyyz, xy 3 z = xyyyz, and so\non\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 06\n\n\fProof of the Pumping Lemma\nLet M be a DFA recognizing A and p (the pumping length)\nbe the number of states of M .\nLet s be a string of length at least p.\ns = s1 s2 . . . sn where sx \u2208 \u03a3 and n \u2265 p.\n\nLet r1 , r2 , . . . , rn+1 be the sequence of states of M when\nprocessing s.\nr1 is the start state of M\nWhen s1 is processed, the state of M is changed to r2 , and so\non.\n\u03b4(r1 , s1 ) = r2\n\u03b4(r2 , s2 ) = r3\n..\n.\n\u03b4(ri , si ) = ri+1 for 1 \u2264 i \u2264 n.\n..\n.\n\u03b4(rn , sn ) = rn+1\n\nNote that there is no restriction that rx and ry cannot be the\nsame state.\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 06\n\n\fProof of the Pumping Lemma\nThe sequence r1 , r2 , . . . , rn+1 consists of n + 1 states\nSince n \u2265 p, the above sequence has at least p + 1 states.\n\nSince the machine M has only p states, in the first p + 1\nstates of the sequence, at least two states rj and rl must be\nthe same state.\nLet rj be the first occurrence of the repeated state\nLet rl be the second occurrence of the repeated state in the\nabove sequence.\nNote that j < l.\n\nSince rl is in the first p + 1 states of the sequence l \u2264 p + 1.\nLet\nx = s1 . . . sj\u22121\ny = sj . . . sl\u22121\nz = sl . . . sn\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 06\n\n\fProof of the Pumping Lemma\n\nIf M accepts s = s1 s2 . . . sn and s = xyz,\nx takes M from r1 to rj ,\ny takes M from rj to rl , and\nz takes M from rl to rn+1\n\nwhere rn+1 is an accept state.\nLet\u2019s check all conditions of the pumping lemma\n1\n2\n3\n\nThus M accept xy i z for i \u2265 0.\nSince j < l, |y| > 0.\nSince l \u2264 p + 1, |xy| \u2264 p.\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 06\n\n\fHow to use the Pumping Lemma\nTo check whether a language B is not regular using the\nPumping Lemma, we use prove by contradiction\nAssume that B is regular\nThere exists a machine M with p states that recognizes B\n\nSelect a string s \u2208 B of length at least p so that the conditions\n1, 2, and 3 of the pumping lemma lead to a contradiction\n\nNotes\nThe choice of s must involve p to ensure that s has length at\nleast p (e.g., s = 0p 011, s = ap ba2p or s = bp+1 ap b)\nIt is possible that some choices of s do not produce\ncontradiction. If we do not get a contradiction, we have\nnot proved anything yet\nOnce you pick an s, nothing tells us what x, y, and z should\nbe. We have to show that we must get a contradiction,\nno matter what x, y, and z are, as long as they satisfy\nconditions 1, 2, and 3.\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 06\n\n\fExample\nShow that B = {0n 1n | n \u2265 0} is not regular.\nAssume that B is regular. In other words, there exists a\nmachine M with p states that recognizes B.\nThere are infinite number of strings in B of length at least p\nJust pick one (for now)\n\nLet s = 0p 1p . Note that s \u2208 B and |s| = 2p \u2265 p.\nThe pumping lemma says there are strings x, y, and z such\nthat s = xyz satisfying the conditions 1, 2, and 3\n\nRecall that there are multiple ways to divide s into x, y, and z\nsuch that xyz = s = 0p 1p\nExamples:\nx = \u03b5, y = 0, and z = 0p\u22121 1p\nxyz = \u03b500p\u22121 1p = 0p 1p\n2\n3\np\u22125 p\nx = 0 , y = 0 , and z = 0\n1\nxyz = 02 03 0p\u22125 1p = 0p 1p\np\np\u22122\nx = 0 1, y = 1, and z = 1\nxyz = 0p 111p\u22122 = 0p 1p\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 06\n\n\fExample: B = {0n 1n | n \u2265 0}\nSince there are multiple ways to divide s, we are going to\nfocus on all possible way to divide s into x, y, and z satisfying\nonly conditions 2 and 3 first\nWe will try to get a contradiction from the first condition\n\nThe condition 3 says |xy| \u2264 p\nSince s starts with p 0s, to satisfy this condition, x and y must\nbe strings that contains only 0s\nIf x contains one 1, for s = 0p 1p = xyz, |x| is already p + 1\n|xy| = |x| + |y| = (p + 1) + |y| > p\nIf y contains one 1, for s = 0p 1p = xyz, |xy| is already p + 1\n\nFormally, to satisfy conditions 3\nx = 0j for some j \u2265 0\ny = 0k for some k > 0\nk > 0 makes |y| > 0 (satisfying condition 2)\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 06\n\n\fExample: B = {0n 1n | n \u2265 0}\nNow we have\nx = 0j for some j \u2265 0 and\ny = 0k for some k > 0\n\nTo make xyz = s = 0p 1p , z must be 0p\u2212(j+k) 1p\nxyz = 0j 0k 0p\u2212(j+k) 1p = 0j+k+p\u2212(j+k) 1p = 0p 1p\nCondition 1 says that xy i z \u2208 B for any i \u2265 0\nWe just need to find an i such that xy i z 6\u2208 B\nLet i = 0\nxy 0 z = 0j (0k )0 0p\u2212(j+k) 1p\n= 0j 0p\u2212(j+1) 1p\n= 0p\u2212k 1p\nFor 0p\u2212k 1p to be in B = {0n 1n | n \u2265 0}\np \u2212 k must be equal to p\nk must be 0 to make p \u2212 k = p but k cannot be 0\nContradiction\nB is not regular\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 06\n\n\fExample: B = {0n 1n | n \u2265 0}\nThere are multiple is that can lead to a contradiction\nBut i should not be 1 since xy 1 z = xyz = s \u2208 B\n\nLet i = 2\nxy 2 z = 0j (0k )2 0p\u2212(j+k) 1p\n= 0j 0k 0k 0p\u2212(j+1) 1p\n= 0p+k 1p\nFor 0p+k 1p to be in B\np + k must be equal to p\nk must be 0 to make p + k = p but k cannot be 0\nContradiction\nB is not regular\n\nIn this example, any i 6= 1 will give you a contradiction\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 06\n\n\fExample: B = {0n 1n | n \u2265 0}\nThere are multiple strings s of length at least p that work for\nthis example\nExample: s = 02p 12p\nThis this string s, use exact same proof where x = 0j for any\nj \u2265 0, y = 0k for any k > 0, and z = 02p\u2212(j+k) 12p\np\n\np\n\nExample: s = 0 2 1 2\n\nThis one is a little bit harder since condition 3 does not help\nmuch\nThere are three possibility for the string y\ny contains nothing but 0s (y = 0k for some k > 0)\ncontradiction because xy 2 z will have more 0s than 1s\ny contains some 0s and 1s (y = 0k 1m for some k, m > 0)\np\ncontradiction because xy 2 z = 0j 0k 1m 0k 1m 1 2 \u2212m 6\u2208 B\nk\ny contains nothing but 1s (y = 1 for some k > 0)\ncontradiction because xy 2 z will have more 1s than 0s\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 06\n\n\fRule of Thumb\n\nPick a string s in the language of length at least p such that\nit starts with at least p of the same symbol\n0p 1p\n02p 12p\nCondition 3 will help reducing the amount of proofs that you\nhave to do\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 06\n\n\fSome Incorrect Proofs: B = {0n 1n | n \u2265 0}\nLet s = 000111\ns does not have length at least p (p can be any positive\nnumber)\n\nLet s = 0p 12p\ns 6\u2208 B, cannot use the Pumping lemma\n\nLet s = 0p 1p and x = 0, y = 0p\u22121 , z = 1p\nThis only show one way of dividing s into x, y, and z such\nthat s = xyz\nThere are multiple ways\nNeed to show them all by using variable (e.g., 0j , 0k , etc)\n\nLet s = 0p 1p and x = 0j , y = 0k , and z = 1p\nxyz = 0j 0k 1p = 0j+k 1p 6= s = 0p 1p\nIf you say j + k = p, it is still incorrect\nYou only show all possible way such that s = xyz where\nz = 1p\nBut z can have some 0s as well\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 06\n\n\fShow that B = {0n 1n | n \u2265 0} is not regular\nAssume that B is regular. Since B is regular, the Pumping lemma says that for any\nstring s \u2208 B of length at least p, s can be divided into s = xyz satisfying the\nfollowing conditions:\n1\n\nxy i z \u2208 B for any i \u2265 0\n\n2\n\n|y| > 0\n\n3\n\n|xy| \u2264 p\n\nLet s = 0p 1p . Since s starts with p 0s, to satisfy the third condition, x and y are\nstrings that contain nothing but 0s. In other words, x = 0j for any j \u2265 0, and y = 0k\nfor any k > 0. Note that k must be greater than 0 because |y| = |0k | = k, and the\ncondition 2 says that |y| > 0. Since x = 0j and y = 0k , z = 0p\u2212(j+k) 1p . Let i = 0.\nWe have\nxy i z = xy 0 z\n= xz\n= 0j 0p\u2212(j+k) 1p\n= 0p\u2212k 1p\nFor the string 0p\u2212k 1p to be in B, the number of 0s must be equal to the number of\n1s. In other words, p \u2212 k must be equal to p. This requires k to be 0. But since k\nmust be greater than 0, xy 0 z 6\u2208 B \u2014 contradiction. Therefore, B is not regular.\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 06\n\n\f", "label": [[622, 639, "Concept"], [708, 734, "Concept"], [769, 785, "Concept"], [3638, 3651, "Concept"], [3657, 3670, "Concept"]], "Comments": []}