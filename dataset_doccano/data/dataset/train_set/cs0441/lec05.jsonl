{"id": 20, "segment": ["train_set", "labeled"], "course": "cs0441", "lec": "lec05", "text": "Discrete Structures for Computer\nScience\n\nWilliam Garrison\nbill@cs.pitt.edu\n6311 Sennott Square\nLecture #5: Logic Programming and Nested\nQuantifiers\nBased on materials developed by Dr. Adam Lee\n\n\fToday\u2019s topics\nn Applications of predicate logic\nn Nested quantifiers\n\n\fLogic programming enables automated reasoning\nProlog\nl Programming in logic\nl Developed in the 1970s for\nAI purposes\n\nDatalog\nl Logical formalization of\ndatabases\nl Developed in the 1980s\n\nFor our purposes, we can consider Prolog and Datalog to be the\nsame, though in reality they have very important differences.\n\nTwo main constructs:\n\nLower case = constant\n\nl Facts\n\u00b2 instructor(bill, cs441)\nUpper case = variable\n\u00b2 student(smith, cs441)\nl Rules\n\u00b2 teaches(P,S) :- instructor(P,C), student(S,C)\n\n\fRules and facts define predicates\nFacts define predicates by explicitly listing elements that\nsatisfy those predicates\nl \u201cDr. Garrison is the instructor for CS441\u201d\n\u00ba instructor(bill, cs441)\n\nRules define predicates by combining previously specified\npredicates\nl \u201cProfessors teach the students enrolled in the courses for\nwhich they are the instructor\u201d \u00ba\nteaches(P,S) :- instructor(P,C), student(S,C)\n\nProlog is an environment that lets us issue queries to\ndetermine which predicates are true!\n\n\fA Security Example\ngrant(U, projector) :- located(U, 105), role(U, presenter)\nlocated(U, R) :- owns(U, D), dev_loc(D, R)\nrole(bob, presenter) owns(alice, laptop12)\nrole(carol, presenter) owns(bob, tablet23)\nowns(carol, cell42)\n\ndev_loc(laptop12, 105)\ndev_loc(tablet23, 105)\ndev_loc(cell42, 105)\n\nCan Bob run the projector?\nl Query: ?grant(bob, projector)\nl Solution: true\nKnowledge base\n\nWho is in room 105?\nl Query: ?located(X, 105)\nl Solution: alice, bob, carol\n\n\fWrite and evaluate the following queries\ngrant(U, projector) :- located(U, 105), role(U, presenter)\nlocated(U, R) :- owns(U, D), dev_loc(D, R)\nrole(bob, presenter) owns(alice, laptop12)\nrole(carol, presenter) owns(bob, tablet23)\nowns(carol, cell42)\n\nn Can Alice use the projector?\nl ?grant(alice, projector)\nl false\n\nn Can Carol use the projector\nl ?grant(carol, projector)\nl true\n\ndev_loc(laptop12, 105)\ndev_loc(tablet23, 105)\ndev_loc(cell42, 105)\n\nn Which devices does Alice own?\nl ?owns(alice, X)\nl laptop12\n\n\fLogic programming is a useful tool!\nName\n\nAge\n\nPhone\n\nAlice\n\n19\n\n555-1234\n\nDanielle\n\n33\n\n555-5353\n\nZach\n\n27\n\n555-3217\n\nCharlie\n\n21\n\n555-2335\n\nArtificial Intelligence\n\nDatabases\n\nRoute\nplanning\n\nSecurity\n\n\fJust for grins\u2026\nIf you are interested in playing around with logic\nprogramming, download SWI-Prolog\nl URL: http://www.swi-prolog.org/\n\nThis (free) package is a runtime environment in which\nyou can write logic programs and evaluate queries.\nDave\n\nCharlie\nAlice\n\nElise\n\nBob\n\nBecky\n\nFrank\nSarah\n\nTommy\n\n\fNested quantifiers!?!?\nMany times, we need the ability to nest one quantifier\nwithin the scope of another quantifier\n\nExample: All integers have an additive inverse. That is,\nfor any integer x, we can choose an integer y such that\nthe sum of x and y is zero.\n\n\"x $y (x + y = 0)\nThere is no way to express this statement using only a\nsingle quantifier!\n\n\fDeciphering nested quantifiers isn\u2019t as scary as\nit looks\u2026\n\u2026 if you remember to read from left to right!\n\n\"x $y \"z [(x + y)\u00d7z = 0]\nFor all x\u2026\n\u2026 there exists a y such\nthat\u2026\n\u2026 for all z\u2026\n\nAnd think about scope of variables\nlike with programming!\n\n\u2026 (x + y)\u00d7 z = 0\n\n\fA few more examples\u2026\n\"x \"y (x + y = y + x)\n\nThis is the commutative\nlaw for addition!\n\nl For all integers x and for all integers y, x + y = y + x\n\n\"x \"y \"z [(x+y)+z = x+(y+z)]\n\nThis is the associative\nlaw for addition!\n\nl For all integers x, for all integers y, and for all integers z,\n(x+y)+z = x+(y+z)\n\n$x \"y (x\u00d7 y = 0)\nl There exists an x such that for all y, x\u00d7 y = 0\n\n\fSince we always read from left to right, the\norder of quantifiers matters!\nConsider: \"x $y (x + y = 0)\n\nClearly true!\nJust set y = -x\n\n\u27a3 Every integer has an additive inverse\nNot true\u2026\n\nTranspose: $y \"x (x + y = 0)\n\u27a3 There exists some integer y such that when added to\nany other integer x, the sum of x and y is 0\n\nRemember: As long as you read from left to right, you\nwon\u2019t have any problems!\n\n\fMany mathematical statements can be translated into\nlogical statements with nested quantifiers\nTranslating mathematical expressions is often easier\nthan translating English statements!\nSteps:\n1. Rewrite statement to make quantification and logical\noperators more explicit\n2. Determine the order in which quantifiers should appear\n3. Generate logical expression\n\n\fLet\u2019s try a translation\u2026\nUniversal quantifier\n\nStatement: Every real number except zero has a\nmultiplicative inverse\nx\u00d7y=1\n\nSingular\u2014suggestive of an\nexistential quantifier\n\n\"x\nRewrite: For every real number x, if x \u2260 0, then there\nexists a real number y such that x\u00d7y = 1.\n\u2026 $y (x \u00d7 y = 1)\n\n(x \u2260 0) \u2192 \u2026\n\nTranslation: \"x [(x \u2260 0) \u2192 $y (x \u00d7 y = 1)] OR\n\"x $y [(x \u2260 0) \u2192 (x \u00d7 y = 1)]\n\n\fMore examples\u2026\n\nStatement: The product of any two negative integers\nis always positive\nl For any integer x and any integer y, if x < 0 and y < 0, then\nx\u00d7 y > 0\nl \"x \"y [(x < 0 \u2227 y < 0) \u2192 (x\u00d7 y > 0)]\n\nStatement: For any real number a, it is possible to\nchoose real numbers b and c such that a2 + b2 = c2\nl For any real number a, there exist real numbers b and c\nsuch that a2 + b2 = c2\nl \"a $b $c (a2 + b2 = c2)\n\n\fTranslating quantified statements to English is\nas easy as reading a sentence!\nLet:\nl C(x) \u2261 x is enrolled in CS441\nl M(x) \u2261 x has an MP3 player\nl F(x, y) \u2261 x and y are friends\nl Domain of x and y is \u201call students\u201d\n\nStatement: \u2200x [C(x) \u2192 M(x) \u2228 (\u2203y (F(x,y) \u2227 M(y))]\nFor every student x\u2026\n\u2026 if x is enrolled in CS441, then\u2026\n\u2026 x has an MP3 player\u2026\n\u2026 or there exists another student y such that\u2026\n\u2026 x and y are friends\u2026\n\u2026 and y has an MP3 player.\n\n\fTranslate the following expressions into English\nLet:\nl O(x,y) \u2261 x is older than y\nl F(x,y) \u2261 x and y are friends\nl The domain for variables x and y is \u201call students\u201d\n\nStatement: \u2203x \u2200y O(x,y)\nl There exists a student x, such that for all students y, x is older\nthan y.\nl Alternatively: There exists an oldest student.\n\nStatement: \u2203x \u2203y [F(x,y) \u2227 \u2200z [(y\u2260z) \u2192 \u00acF(x,z)]]\nl There exists two students x and y such that x and y are friends\nand for all students z, if z \u2260 y, then x and z are not friends.\nl Alternatively: There exists a student with only one friend L\n\n\fIn-class exercises\nProblem 1: Translate the following mathematical\nstatement into predicate logic: Every even number is a\nmultiple of 2. Assume that the predicate E(x) means \u201cx\nis even.\u201d\nl\n\nHint: What does \u201cx is a multiple of 2\u201d mean algebraically? Try\nnot to use \u201cmod.\u201d\n\nProblem 2: Translate the following expressions into\nEnglish. Assume that C(x) means \u201cx has a car\u201d, F(x,y)\nmeans \u201cx and y are friends\u201d, and S(x) means \u201cx is a\nstudent.\u201d\nl\nl\n\n\u2200x (S(x) \u2192 C(x) \u2228 \u2203y [F(x,y) \u2227 C(y)])\n\u2200x \u2203y \u2203z [C(x) \u2228 (F(x,y) \u2227 C(y)) \u2228 (F(x,y) \u2227 F(y,z) \u2227 C(z))]\n\n\fTranslating from English to a logical expression with\nnested quantifiers is a little bit more work\u2026\n\nSteps:\n1. If necessary, rewrite the sentence to make quantifiers and\nlogical operations more explicit\n2. Create propositional functions to express the concepts in\nthe sentence\n3. State the domains of the variables in each propositional\nfunction\n4. Determine the order of quantifiers\n5. Generate logical expression\n\n\fLet\u2019s try an example\u2026\nUniversal quantifier\n\nStatement: Every student has asked at least one\nprofessor a question.\nExistential quantifier\n\nRewrite: For every person x, if x is a student, then there\nexists a professor whom x has asked a question.\n\nLet:\nl S(x) \u2261 x is a student\nl P(x) \u2261 x is a professor\nl Q(x,y) \u2261 x has asked y a question\n\nDomains for x and\ny are \u201call people\u201d\n\nTranslation: \u2200x (S(x) \u2192 \u2203y [P(y) \u2227 Q(x,y)])\n\n\fTranslate the following from English\nStatement: There is a man who has tasted every type of\nbeer.\n\nRewrite: There exists a person x such that x is man and\nfor all types of drink y, if y is a beer then x has tasted y.\nDomain: all people\n\nLet:\nl M(x) \u2261 x is a man\nl B(x) \u2261 x is a beer\nl T(x,y) \u2261 x has tasted y\n\nDomain: all drinks\nDomains: x = all people,\ny = all drinks\n\nTranslation: \u2203x (M(x) \u2227 \u2200y [B(y) \u2192 T(x,y)])\n\n\fNegating expression with nested quantifiers is\nactually pretty straightforward\u2026\n\u2026 you just repeatedly apply DeMorgan\u2019s laws!\n\u00ac[\u2203x (M(x) \u2227 \u2200y [B(y) \u2192 T(x,y)])]\n\u2261 \u2200x \u00ac(M(x) \u2227 \u2200y [B(y) \u2192 T(x,y)])\n\u2261 \u2200x (\u00acM(x) \u2228 \u00ac\u2200y [B(y) \u2192 T(x,y)])\n\u2261 \u2200x (\u00acM(x) \u2228 \u2203y \u00ac[B(y) \u2192 T(x,y)])\n\u2261 \u2200x (\u00acM(x) \u2228 \u2203y \u00ac[\u00acB(y) \u2228 T(x,y)])\n\u2261 \u2200x (\u00acM(x) \u2228 \u2203y [B(y) \u2227 \u00acT(x,y)])\n\u2261 \u2200x (M(x) \u2192 \u2203y [B(y) \u2227 \u00acT(x,y)])\n\na \u2192 b \u2261 \u00aca \u2228 b\n\nIn English: For all people x, if x is a man, then there\nexists some type beer that x has not tasted.\n\nAlternatively: No man has tasted every type of beer.\n\n\fA few stumbling blocks\u2026\nWhether the negation sign is on the inside or the outside of\na quantified statement makes a big difference!\n\nExample: Let T(x) \u2261 \u201cx is tall\u201d. Consider the following:\nl \u00ac\u2200x T(x)\n\u27a3\u201cIt is not the case that all people are tall.\u201d\n\nl \u2200x \u00acT(x)\n\u27a3\u201cFor all people x, it is not the case that x is tall.\u201d\n\nNote: \u00ac\u2200x T(x) = \u2203x \u00acT(x) \u2260 \u2200x \u00acT(x)\nRecall: When we push negation into a quantifier,\n\nDeMorgan\u2019s law says that we need to switch the quantifier!\n\n\fA few stumbling blocks\u2026\nLet:\n\nC(x) \u2261 \u201cx is enrolled in CS441\u201d\nS(x) \u2261 \u201cx is smart.\u201d\n\nQuestion: The following two statements look the same,\nwhat\u2019s the difference?\nl \u2203x [C(x) \u2227 S(x)]\nl \u2203x [C(x) \u2192 S(x)]\n\nThere is a smart\nstudent in CS441.\n\nThere exists a student x\nsuch that if x is in CS441,\nthen x is smart.\n\nSubtle note: The second statement is true if there exists\none person not in CS441, because F\u2192F or F\u2192T.\n\n\fNegate \u2200x (S(x) \u2192 \u2203y [P(y) \u2227 Q(x,y)])\n\u00ac\u2200x (S(x) \u2192 \u2203y [P(y) \u2227 Q(x,y)])\n\u2261 \u2203x \u00ac(S(x) \u2192 \u2203y [P(y) \u2227 Q(x,y)])\n\u2261 \u2203x \u00ac(\u00acS(x) \u2228 \u2203y [P(y) \u2227 Q(x,y)])\n\u2261 \u2203x (S(x) \u2227 \u00ac\u2203y [P(y) \u2227 Q(x,y)])\n\u2261 \u2203x (S(x) \u2227 \u2200y \u00ac[P(y) \u2227 Q(x,y)])\n\u2261 \u2203x (S(x) \u2227 \u2200y [\u00acP(y) \u2228 \u00acQ(x,y)])\n\u2261 \u2203x (S(x) \u2227 \u2200y [P(y) \u2192 \u00acQ(x,y)])\n\nIn English: There exists a student x such that for all people\ny, if y is a professor then x has not asked y a question.\n\nAlternatively: There exists a student that has never asked\nany professor a question.\n\n\fIn-class exercises\nProblem 3: Translate the following English sentences\ninto predicate logic.\na) Every student has at least one friend that is dating a\nSteelers fan.\nb) If a person is a parent and a man, then they are the\nfather of some child.\n\nProblem 4: Negate the results from Problem 3 and\ntranslate the negated expressions back into English.\n\n\fFinal Thoughts\nn Logic programming is an interesting application of\npredicate logic that is used throughout computer\nscience\nn Quantifiers can be nested\nl Nested quantifiers are read left to right\nl Order is important!\nl Translation and negation work the same as they did before!\n\nn Next lecture:\nl Rules of inference\nl Please read sections 1.6\u20131.7\n\n\f", "label": [[229, 244, "Concept"], [247, 265, "Concept"], [2746, 2764, "Concept"], [2804, 2808, "Concept"], [2813, 2823, "Concept"], [2852, 2862, "Concept"], [3112, 3130, "Concept"], [3420, 3435, "Concept"], [3553, 3568, "Concept"], [4210, 4228, "Concept"], [7284, 7304, "Concept"], [7376, 7398, "Concept"], [8208, 8223, "Concept"], [10371, 10388, "Concept"], [10481, 10492, "Concept"], [10500, 10506, "Concept"], [10509, 10527, "Concept"], [10575, 10586, "Concept"], [10591, 10599, "Concept"]], "Comments": []}