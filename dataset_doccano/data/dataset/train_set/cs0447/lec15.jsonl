{"id": 49, "segment": ["train_set", "labeled"], "course": "cs0447", "lec": "lec15", "text": "#15\nCS 0447\nIntroduction to\nComputer Programming\n\nMulticycle Design\nOriginal slides by: David Wilkinson\nModified with bits from: Bruce\nChilders, and Jarrett Billingsley\n\nLu\u00eds Oliveira\n\nFall 2020\n\n\fMulticycle\n\n2\n\n\fMulticycle Design\n\u25cf Simply put: let instructions take more than one clock cycle to complete.\n\nSingle-cycle\n\nPHOTO: https://www.straitstimes.com/asia/east-asia/china-scrambles-to-tame-rental-bike-chaos\n\nMulticycle?\n\n3\n\n\fChop chop\n\u25cf Not all instructions take the same amount of time, so\u2026\n\u25cf Make different instructions take different amounts of time!\no And by that, we mean different numbers of clock cycles\n\n3 cycles\n\nj\n\nj\n\n4 cycles\n\nor\n\nor or or\n\nor\n\n100 cycles\n\nlw\n\nlw\n\nlw\n\nj\n\nlw\n\nlw\n\nlw\n\nlw\nlw\n\nlw\n\nlw\n\nlw\n\nlw\n\nlw\n\nl\n\n4\n\n\fThe instructions' steps\n\u25cf Why would some instructions take less time?\n\u25cf Recall the five phases of execution?\n\u25cf All instructions have IF, ID, EX, but only some write to memory/regs\no We\u2019re managing their complexity with respect to time.\n\nbeq/j\n\nF\n\nD\n\nX\n\nadd/sub etc.\n\nF\n\nD\n\nX\n\nW\n\nlw\n\nF\n\nD\n\nX\n\nM\n\nM\n\n\u2026\u2026..\n\nM\n\nM\n\nW\n\nMemory is slooooooow\n5\n\n\fThe instructions' steps\n\u25cf Why would some instructions take less time?\n\u25cf Recall the five phases of execution?\n\u25cf All instructions have IF, ID, EX, but only some write to memory/regs\no We\u2019re managing their complexity with respect to time.\n\nbeq/j\n\nIF\n\nID\n\nEX\n\nadd/sub etc.\n\nIF\n\nID\n\nEX\n\nWB\n\nlw\n\nIF\n\nID\n\nEX\n\nM\n\nWB\n\n(let's just say lw is 5 cycles :)\n6\n\n\fMulti-cycle CPU\nCalculate clock to accommodate a single phase.\n\u25cf Chop instructions and make the clock faster\n\u25cf Less time wasted by faster instructions! \u2192 Reduces latency\n\nTime\n\n0\n\n1\n\nlw t0,0(t1)\n\nMem\n\nReg\n\nadd t2,t2,t3\n\n2\n\n3\n\n4\n\nMem\n\nReg\n\n5\n\n6\n\nMem\n\nReg\n\n7\n\n8\n\nReg\n\n7\n\n\fNot all stages are the same \uf04c\nIn the multi-cycle design:\nSlowest stage limits the rate\nBalanced stages are desired\nE.g. split the memory operation into multiple clock cycles\n\nTime\n\nlw t0,0(t1)\n\n0\n\n1\n\nMem\n\nReg\n\nMem\n\nReg\n\n2\n\n3\n\nMem\n\nMem\n\n4\n\nReg\n\nReg\n\n8\n\n\fThe multicycle datapath from a bird's-eye view\n\n\u25cf Each phase of execution has its own functional unit\n\u25cf between phases, we insert registers to hold onto the data for the next phase.\n(Recall registers \u2794 sequential logic)\n\nInstruction\nMemory\n\nD\n\nControl\n\nF\n\nX\n\nM\n\nRegister\nFile\n\nData\nMemory\n\nW\n9\n\n\fWatching an add (animated)\n\u25cf Let's watch an add instruction flow through the datapath!\nF\n\nClock!\n\nD\n\nClock!\n\nset all control\nsignals...\n\nX\n\nClock!\n\nM\n\nadd...\n\nInstruction\nMemory\n\nControl\n\nadd\nRegister\nFile\n\nData\nMemory\n\nClock!\n\nW\ndata flows back to registers...\n10\n\n\fWatching a lw (animated)\n\u25cf Let's watch a lw instruction flow through the datapath!\nF\n\nClock!\n\nD\n\nClock!\n\nset all control\nsignals...\n\nX\n\nClock!\n\nadd...\n\nM\n\nClock!\n\nload...\n\nInstruction\nMemory\n\nControl\n\nlw\nRegister\nFile\n\nData\nMemory\n\nW\ndata flows back to registers...\n11\n\n\fCPI (and IPC)\n\u25cf CPI (Cycles Per Instruction) measures the average number of cycles it takes\nto complete one instruction\n\u25cf IPC (instructions per cycle) is its reciprocal\no multi-issue CPUs can execute multiple instructions in one clock cycle!\nWOAH 8O\n\u25cf So, what's the CPI for the single-cycle implementation?\no uh, 1.\no By, yanno, definition.\n\u25cf What about for a multicycle implementation?\no \u2026\u2026????? hmmm\n\n12\n\n\fSo what the heck has this bought us?\n\u25cf Let's say our clock cycle time decreased from 5ns to 1ns!\no that's from 200 MHz to 1 GHz! :D\n\u25cf ...buuut our CPI (cycles per instruction) increased a lot.\no with the single-cycle datapath, CPI was always 1.\no now the CPI is... well... uh... variable?\n\nbeq/j\n\nIF\n\nID\n\nEX\n\nadd/sub etc.\n\nIF\n\nID\n\nEX\n\nWB\n\nlw\n\nIF\n\nID\n\nEX\n\nM\n\nif instructions vary in length,\nhow do we calculate CPI?\nWB\n\n13\n\n\fCalculating Average CPI\n\u25cf Every program is different, and every program has a different instruction\nmix \u2013 how many of each kind of instruction it uses\n\u25cf Let's say we have a program where 60% of the instructions are ALU, 20% are\nbranches, 15% are loads, and 5% are stores.\nALU\n\nBranches\n\nLoads\n\nStores\n\n%\n\n60%\n\n20%\n\n15%\n\n5%\n\nCycles\n\n4\n\n3\n\n5\n\n4\n\n2. Now sum\nthe CPIs\n\nCPI\n\n2.4\n\n0.2\n\n= 3.95\n\n+\n\n0.6\n\n+\n\n0.75\n\n1. for each category, multiply the proportion\n(percentage) by the number of cycles for that\ncategory to get the per-category CPI\n\n+\n\nthis is the Average\nCPI for THIS program.\ndifferent mixes give\ndifferent CPIs!\n14\n\n\fThe performance equation\n\u25cf If we have n instructions, and each instruction takes CPI cycles, and each\ncycle takes t seconds, how long does it take to execute all the instructions?\n\n\ud835\udc36\ud835\udc43\ud835\udc3c cycles \ud835\udc61 seconds\nTotal time = \ud835\udc5b instructions \u00d7\n\u00d7\ninstruction\ncycle\n= \ud835\udc5b \u00d7 \ud835\udc36\ud835\udc43\ud835\udc3c \u00d7 \ud835\udc61 seconds\nor in English, it's the product of the instruction count, the\nCPI, and the length of one clock cycle\n\n15\n\n\fSo how much better is it?!??!?\n\u25cf Say we execute 500 mega (500 \u00d7 106) instructions\n\u25cf For the single-cycle datapath:\no CPI = 1\no cycle time = 5ns (5 x 10-9 s)\no total time = n \u00d7 CPI \u00d7 cycle time\n\u25aa = (500 \u00d7 106) \u00d7 (1) \u00d7 (5 \u00d7 10-9)\n\u25aa = 2.5 seconds.\n\u25cf For the multicycle datapath:\no CPI = 3.95 (much higher!) (again, this CPI is only for this program)\no cycle time = 1ns (much lower!)\no total time = (500 \u00d7 106) \u00d7 (3.95) \u00d7 (1 \u00d7 10-9)\no = 1.975 seconds!\n\n16\n\n\fHow does it look like?\n\n17\n\n\fMulticycle Datapath + Control (no control flow)\n\u25cf A potential example of a multicycle control for MIPS:\n\no Additional registers and multiplexers hold and then direct temporary data.\n\nA single ALU\n\nA single Shared Memory\n\nFigure 5.26 in P&H 3e\n\n18\n\n\fMulticycle Datapath + Control (no control flow)\n\u25cf A potential example of a multicycle control for MIPS:\n\no Additional registers and multiplexers hold and then direct temporary data.\n\nRegisters are added between\nfunctional units to store data\nThat needs to be used in the\nfollowing clock cycle\n\nFigure 5.26 in P&H 3e\n\n19\n\n\fMulticycle Datapath + Control (no control flow)\n\u25cf A potential example of a multicycle control for MIPS:\n\no Additional registers and multiplexers hold and then direct temporary data.\nA MUX to connect either\nthe PC or the Register File\n\nUsing a single ALU requires a\nchange in the hardware\ndesign.\n\nA larger MUX to include PC\nincrement and adding\nthe branch offsets\n\nFigure 5.26 in P&H 3e\n\n20\n\n\fMulticycle Datapath + Control (with control flow)\n\nNow we support\njump instructions \u263a\n\nFigure 5.28 in P&H 3e\n\n21\n\n\fMulticycle Datapath + Control (with control flow)\n\nFigure 5.28 in P&H 3e\n\n22\n\n\fSignals\nSignal\n\nEffect\n\nMemRead\n\nRead from memory \u2794 0: Don\u2019t read; 1: Read\n\nMemWrite\n\nWrite to memory \u2794 0: Don\u2019t write; 1: Write\n\nALUSelA\n\nSelect input of ALU input A \u2794 0: $pc ; 1: register A\n\nRegDst\n\nSelect destination register \u2794 0: $rt (I-Type); 1: $rd (R-Type)\n\nRegWrite\n\nRegister-file write enable \u2794 0: Don\u2019t write; 1: Write\n\nMemToReg\n\nSelect data to write to the register-file\u2794 0: ALU; 1: Memory\n\nIorD\n\nSelect the source for the memory address to be accessed \u2794 0: PC (instruction);\n1: ALU (lw/sw/lh/lhu/sh/lb/lbu/sb)\n\nIRWrite\n\nInstruction register write enable \u2794 0: Don\u2019t write; 1: Write\n\nPCWrite\n\nPC unconditional write enable (jumps/PC=PC+4) \u2794 0: No effect; 1: Jump\n\nPCWriteCond\n\nPC conditional write enable (branches) \u2794 0: No effect; 1: Jump conditionally\n23\n\n\f(More) signals\nSignal\nALUSelB\n\nALUOp\n\nPCSource\n\nEffect\n00\n\nALU input B comes from $rt\n\n01\n\nALU input B is the constant 4\n\n10\n\nALU input B comes from the Immediate field\n\n11\n\nALU input B comes from the Immediate field shifted left 2 (branch)\n\n00\n\nALU does an addition\n\n01\n\nALU does an subtraction\n\n10\n\nALU behaviour depends on the function field (R-Type)\n\n00\n\nPC is updated with the result of the ALU (Fetch: PC+4)\n\n01\n\nPC is updated with the result of the ALU (PC = PC + branch offset)\n\n10\n\nPC is updated with the Jump target (jump)\n24\n\n\fFetch and decode\n\n25\n\n\fFetch Instruction\n\n00\n\nIncrement PC\nRead instruction\nfrom memory\n\n01\n\n00\n26\n\n\fDecode Instruction\nController does its thing\n\n00\n\nMaybe it\u2019s\na branch?\n\n11\n\nALU adds PC (incremented in IF)\nto potential branch offset.\nJust in case!\n\n00\n27\n\n\fR-Type\n\n28\n\n\fExecute Instruction\n\n00\n\nALU adds\nregisters A and B\n\n00\n\nadd\n\ns0, s1, s2\n\n10\n29\n\n\fWrite Back\n\n00\n\nALU result is written\nback into the\nRegister File\n\n00\n\nadd\n\ns0, s1, s2\n\n00\n30\n\n\fI-Type\nlw\n\n31\n\n\fExecute Instruction\n\n00\n\nALU adds registers A\nand Imm to calculate\neffective address\n\n10\n\nlw\n\ns0, 4(s1)\n\n00\n32\n\n\fMemory access\n\n00\n\nALU result is used\nas the address.\nMemory is read.\n\n00\n\nlw\n\ns0, 4(s1)\n\n00\n33\n\n\fWrite back\n\n00\n\nData read from memory\nis written into the\nRegister File\n\nlw\n\ns0, 4(s1)\n\n00\n\n00\n34\n\n\fI-Type\nbeq\n\n35\n\n\fExecute Instruction \u2013 Branch conclusion\n\n01\n\nALU subtracts registers\nA and B if the result is\nzero, then branch\n\n00\n\nbeq\n\ns0, s1, label\n\n01\n36\n\n\fJ-Type\njump\n\n37\n\n\fExecute Instruction \u2013 Jump\n\n10\n\nJump\n\n00\n\nj\n\ntarget\n\n00\n38\n\n\fMulticycle Control\n\u25cf How are control signals generated on each cycle?\no Single-cycle: Signals don\u2019t change during each instruction\n\u25aa Combinational circuit\no Multi-cycle: Signals change during each instruction\n\u25aa Different signals each clock cycle\nSequential circuit \u2192 Needs to remember what it did before\n\u25cf What are the transitions between cycles?\no (i.e., what happens next?)\n\u25cf How to describe this behaviour?\no State machine!\n\n39\n\n\fTick-tock\n\nD\n\nopcode\n\ntransition\nlogic\n\nRegWrite\n\u2026.\nIRWrite\n\nQ\n\nstate\nregister\n\nALUSrcA\noutput\nlogic\n\n40\n\n\fMulticycle Control\nFinite State Machine\nEach Cycle: Advance one state\nWhilst in a State:\n\u2022\nSet datapath control\n\u2022\nMake decision based on opcode\n\u2022\nControl is different after Decode\n\nDECODE\n/ REG.\nREAD\n\nFETCH\n\nR-Type\n\nload/store\nCALC.\nADDR.\nload\nREAD\nMEM\n\nWRITE\nBACK\nMEM\n\nEXEC.\nALU\n\nbranch\nBRANCH\nCOMPL.\n\njump\nJUMP\nCOMPL.\n\nstore\nWRITE\nMEM\n\nWRITE\nBACK\nALU\n\nMIPS has >100 instructions\nSome can take >20 clock cycles!!\nMaking the state machine a bit more complex \u263a\n\n41\n\n\fPerformance\n\n42\n\n\fThe layman's understanding\n\u25cf your ancient computer takes 30 seconds to open the browser\n\u25cf you get a new computer. it opens the browser in 3 seconds.\no which computer is faster?\n\nyeah but this is computer science, not computer guessing.\n43\n\n\fOld stuff!!\n\u25cf you wanna copy a CD as many times as you can in 12 minutes\n\u25cf both the PC and this... thing take 4 minutes to copy\n\u25cf which device will make more copies in 12 minutes? why?\no numbers usually mean we're getting more science-y, right?\n\n44\n\n\fResponse time and throughput\n\u25cf response time is the length of time from start to finish\n\u25cf throughput is the amount of work you can do in a span of time\n\nresponse time\n(time per task) 3s\n\n30 seconds\n\nthey're not quite\nreciprocals of each\nother; their\nrelationship is a\nlittle more complex\n\nthroughput\n(tasks per time)\n\n12 minutes\n45\n\n\fResponse time can improve throughput!\n\u25cf you put a brand new 52X CD burner in your sweet Dell. it burns a CD in only\n2 minutes.\n4min\n\n4min\n\n4min\n\n2min 2min 2min 2min 2min 2min\n\n\u25cf the response time for a single CD burn is improved, but this also\ncauses our throughput to double!\n\u25cf this is because the measurement period stayed the same (12min)\n\n46\n\n\fThroughput can improve response time!\n\u25cf someone wants you to make them 20 copies ASAP\n\u25cf how long would it take with one CD duplicator?\n\u25cf how long would it take with two?\n4min 4min 4min 4min 4min\n4min 4min 4min 4min 4min\n\n4min 4min 4min 4min 4min\n\nwith one:\n20min\n\n4min 4min 4min 4min 4min\n4min 4min\n\n4min 4min\n4min 4min\n4min 4min\n\nwith two:\n12min\n\nthis is because the\nworkload stayed the\nsame (20 copies)\n47\n\n\fApplying it to a CPU\n\u25cf the CPU's job is to run instructions. so we could\u2026\no do each instruction faster (i.e. reduce latency)\no do more instructions at once (i.e. increase throughput)\n\u25cf for a long time, we did the former\u2026\no clock speeds increased by 2 orders of magnitude since ~1990\n\u25aa I had a 33MHz! 80486 PC\n\u25cf but then we hit a wall.\no and that's when multi-core CPUs became common.\n\n48\n\n\fReducing latency\n\u25cf you put a new Pentium 4 in your sweet Dell. it executes a single instruction in\nonly 0.8 nanoseconds.\n1.6ns\n.8ns\n\n.8ns\n\nif each instruction takes only\n0.8ns, that means 0.8ns between\nclock pulses. How fast is the\nclock running?\n\n1.6ns\n\n.8ns\n\n.8ns\n\n1\n0.8 \u00d7 10\u22129 \ud835\udc60\n\n1.6ns\n.8ns\n\n.8ns\n\n= 1.25 \u00d7 109 \ud835\udc3b\ud835\udc67\n= 1.25 \ud835\udc3a\ud835\udc3b\ud835\udc67\n\n49\n\n\fBut is this efficient?\n\n50\n\n\fMulti-cycle lw (animated)\n\u25cf Let's watch a lw instruction flow through the datapath!\n\nlw\nInstruction\nMemory\n\nD\n\nClock!\n\nR\ne\ng\ni\ns\nt\ne\nr\ns\n\nset all control\nsignals...\n\nControl\n\nF\n\nRegister\nFile\n\nClock!\n\nR\ne\ng\ni\ns\nt\ne\nr\ns\n\nClock count: 3\n4\n5\n0\n1\n2\n\nX\n\nClock!\n\nCalculate\neff addr... R\n\nM\nload...\n\ne\ng\ni\ns\nt\ne\nr\ns\n\nData\nMemory\n\nClock!\n\nR\ne\ng\ni\ns\nt\ne\nr\ns\n\nW\n\ndata flows back to registers...\n51\n\n\fReal-World Analysis\n\n52\n\n\fAnother example\n.data\nA:\nB:\n.text\n\nloop:\n\n.word 10,20,30,40,50,60,70,80,90,100\n.word 0,0,0,0,0,0,0,0,0,0\nla\n$s0,A\nli\n$s1,10\nli\n$s2,10\nlw\n$t0,0($s0)\nmul $t0,$t0,$s1\nsw\n$t0,40($s0)\naddi $s0,$s0,4\naddi $s2,$s2,-1\nbne $s2,$0,loop\nli\n$v0,10\nsyscall\n\n# address of A\n# A[i] * 10\n# iteration\n# read A[i]\n# $t0=A[i]*10\n# update A[i]\n# next element\n# dec iteration\n# done?\n# exit syscall\n# syscall\n53\n\n\fAnother example\n.data\nA:\nB:\n.text\n\nloop:\n\n.word 10,20,30,40,50,60,70,80,90,100\n.word 0,0,0,0,0,0,0,0,0,0\n#\nla\n$s0,A\n# address of A\nli\n$s1,10\n# A[i] * 10\nli\n$s2,10\n# iteration\nlw\n$t0,0($s0)\n# read A[i]\nmul\n$t0,$t0,$s1\n# $t0=A[i]*10\nsw\n$t0,40($s0)\n# update A[i]\naddi $s0,$s0,4\n# next element\naddi $s2,$s2,-1\n# dec iteration\nbne\n$s2,$0,loop\n# done?\nli\n$v0,10\n# exit syscall\nsyscall\n# syscall\n\ninstr. count\n2\n1\n1\n10\n10\n10\n10\n10\n10\n1\n1\n54\n\n\fAnother example\n\u25cf Let\u2019s analyze the program.\n\u25cf How much time with a Single-Cycle design?\n1. What\u2019s the clock length?\n\u25aa Assume a clock speed of 100 MHz (cycle length is 1/100MHz, or 10ns)\n2. What\u2019s the cycles per instruction?\n\u25aa CPI: 1 (single-cycle! yay!)\n\n\u25cf Thus this program executes in this much time:\no 66 instructions * 1 CPI * 10 ns = 660ns\n\n55\n\n\fAnother example\n\u25cf How much time with a Multicycle design?\n1. We need to know the clock length (what is the clock speed?)\nLet\u2019s just assume the ideal efficiency: divide the clock length by 5.\n\u25aa (Because we said loads, the slowest, take 5 cycles while arithmetic takes 4)\n\u25aa AKA multiply the clock speed by 5 to 500 MHz\n\u25aa Either way, the clock length is 10ns / 5 = 2ns\n\n2. What\u2019s the CPI?\n\u25aa We need to know how many of each type there are. Look at the program.\n\u25aa Arithmetic: 36, Branches: 10, Loads: 10, Stores: 10\n\u25aa There\u2019s a different # of cycles per each type (4, 3, 5, and 4 respectively)\n\u25cf Thus this program executes in this much time:\no 36*4*2ns + 10*3*2ns + 10*5*2ns + 10*4*2ns = 528ns\n\u25cf Multicycle, here, let\u2019s us improve our program execution\nfrom 660ns to 528ns (20% reduction!)\n56\n\n\fdoo-doo-doo doo-doo-doo-doo-doo\n\u25cf not bad! I guess?\nI mean, we increased the clock speed by a factor of 5...\nand we only got 20% reduction on execution time\nif our CPI were also close to 1, it'd be 10 times as fast as the single-cycle\nmachine...\n\u25aa How do we increase throughput\u2026\n\u25aa HMMMMMMMMMMMMMMMMMMMMMM\u2026\n\n57\n\n\f", "label": [[50, 67, "Concept"], [197, 207, "Concept"], [213, 223, "Concept"], [307, 319, "Concept"], [415, 425, "Concept"], [1156, 1181, "Concept"], [1421, 1436, "Concept"], [1727, 1746, "Concept"], [2778, 2781, "Concept"], [2787, 2790, "Concept"], [2794, 2797, "Concept"], [2900, 2903, "Concept"], [3045, 3048, "Concept"], [3056, 3069, "Concept"], [3139, 3149, "Concept"], [3334, 3337, "Concept"], [3414, 3417, "Concept"], [3442, 3445, "Concept"], [3623, 3633, "Concept"], [3970, 3973, "Concept"], [3976, 3979, "Concept"], [4161, 4172, "Concept"], [4222, 4225, "Concept"], [4314, 4317, "Concept"], [4414, 4417, "Concept"], [4731, 4734, "Concept"], [4790, 4793, "Concept"], [4796, 4806, "Concept"], [5097, 5116, "Concept"], [5346, 5365, "Concept"], [5668, 5687, "Concept"], [6061, 6080, "Concept"], [6176, 6195, "Concept"], [14494, 14497, "Concept"], [14552, 14564, "Concept"]], "Comments": []}