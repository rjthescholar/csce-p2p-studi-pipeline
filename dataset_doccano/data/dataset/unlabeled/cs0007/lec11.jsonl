{"id": 153, "segment": "unlabeled", "course": "cs0007", "lec": "lec11", "text": "CS 0007: Introduction to Java\nLecture 11\nNathan Ong\nUniversity of Pittsburgh\nOctober 13, 2016\n\n\fAnnoucements\n\u2022 October 17 \u2013 Fall Break\n\u2022 October 18 \u2013 Monday Schedule\n\u2013 Those who are signed up for Monday Lab\nmust attend\n\u2013 Those who are signed up for Tuesday Lab\nare not required to attend, but must\ncomplete the lab\n\u2013 No lecture\n\n\fAnnoucements\n\u2022 Project 0 is updated, please download\nthe new version\n\u2022 Rubric will be released very soon\n\u2022 This project must be done by yourself\n\n\fAnnoucements\n\u2022 Project 1 will be released while Project 0\nis going on just to get you to start\nthinking about it, but the due date will\nbe far into the future\n\u2022 There will only be two projects\n\n\fARRAYS, LOOPS, AND\nRECURSION\n\n\fA Sudden Need\n\u2022 I need a function that returns the first\n100 terms of the harmonic series.\n\u2022 Harmonic series:\uf0a5 1\n1 1\n\n\uf0e5 n \uf03d1 \uf02b 2 \uf02b 3 \uf02b ...\nn \uf03d1\n\n\fThe Dumb Way\npublic static void main(String[] args)\n{\ndouble term0 = 1.0;\ndouble term1 = 1.0/2.0;\ndouble term2 = 1.0/3.0;\n\u2026\n}\n\n\fArrays\n\u2022 Arrays are ordered lists of things\ndepending on the type you specify\n\u2022 How do you make one?\n\n\fType[] name = new Type[size];\n\n\fint[] empty = new int[10];\n\n\fint[] list = {1,2,3,4};\n\n\fNow What?\n\u2022 I want the first element\n\u2022 list[0]\n\u2022 I want the last element\n\u2022 list[3]\n\u2022 I want the length\n\u2022 list.length == 4\n\u2022 All operations for int are allowed for an\nindividual element\n\u2022 list[0] + list[2] == list[3]\n\n\fHow do I get every element so I can\nprint it?\n\u2022 Reference every element\n\u2022 Many if statements!!!!!!\nYAAAAAAAAYYYY\n\u2022 No please don't\n\u2022 But what else can we do?\n\u2022 WILD KEYWORD APPEARS\n\n\fwhile(){\u2026}\n\u2022 While a condition is true, run the block\n\u2022 While not at the end of the list, print out\nthe next element\nwhile(not at end of list)\n{\nSystem.out.println(next element);\n}//end loop while(not at end of list)\n\n\fnot at end of list\n\u2022 How do we know we're at the end of the\nlist?\n\u2022 list.length\n\u2022 How do we know which one we're at?\n\u2013 We need to keep track\n\nint currElement = 0;\n\n\u2013 starts at 0\n\u2013 not equal to the end!\n\ncurrElement != list.length\n\n\fwhile(){\u2026}\n\u2022 While not at the end of the list, print out the next\nelement\nint currElement = 0;\nwhile(currElement != list.length)\n{\nSystem.out.println(<next element>);\n}//end loop while(currElement!=list.length)\n\n\fnext element\n\u2022 Do we really want to print out the next\nelement?\n\u2022 If we start at 0, and the list starts at 0, do\nwe?\n\u2022 No, we want it to print out the current\nelement and then move to the next one\n\u2022 How do we print out the current element?\nSystem.out.println(list[currElement]);\n\n\u2022 How do we move to the next one?\ncurrElement = currElement + 1;\n\n\fwhile(){\u2026}\n\u2022 While not at the end of the list, print out the next\nelement\nint currElement = 0;\nwhile(currElement != list.length)\n{\nSystem.out.println(list[currElement]);\ncurrElement = currElement + 1;\n}//end loop while(currElement!=list.length)\n\n\fTime to Optimize\n\u2022 currElement = currElement + 1;\n\u2022 This is really long. There must be a\nfaster way\n\u2022 There is! Use +=\n\n\f+=\n\u2022 Adds the right side to whatever was on the\nleft side\ncurrElement += 1;\nis equivalent to\ncurrElement = currElement + 1;\n\u2022 As it happens, people generally add one to\nmany things all the time, so there is a shortercut\n\n\f++\ncurrElement++;\nis equivalent to\ncurrElement = currElement + 1;\n\u2022 It is also common to subtract one from\nmany things all the time, so there is a\nsimilar shorter-cut\n\n\f-currElement\u2013\u2013;\nis equivalent to\ncurrElement = currElement \u2013 1;\n\u2022 Planning to add or subtract more than\none? Use += and \u2013=\n\n\fMathematical Combination\nOperators\n+=, -=, *=, /= (any numeric primitive)\n%=\n(int only)\n\u2022 Literally combines the operation and the\nassignment.\nvariable \u25ca= value \uf0e0 variable = variable \u25ca value;\nint x = 5;\nx %= 3; //x == ?\n\n\fwhile(){\u2026}\nint currElement = 0;\nwhile(currElement != list.length)\n{\nSystem.out.println(list[currElement]);\ncurrElement++;\n}//end loop while(currElement!\n=list.length)\n\n\fA Little Security\n\u2022 currElement != list.length\n\u2022 What happens if you accidentally added\nby three instead of one?\n\u2022 What happens if you accidentally\nchanged the value of currElement so\nit's past the list length?\n\u2022 Safer check:\ncurrElement < list.length\n\n\fwhile(){\u2026}\nint currElement = 0;\nwhile(currElement < list.length)\n{\nSystem.out.println(list[currElement]);\ncurrElement++;\n}//end loop\nwhile(currElement<list.length)\n\n\fSo Many Things We Have to\nRemember\u2026WHYYYYYYYYYY\nint counter = start;\nwhile(condition)\n{\n//Do stuff\ncounter increment\n}//end loop while(condition)\n\u2022 There must be a better way\n\u2022 WILD KEYWORD APPEARS\n\n\ffor(;;){\u2026}\n\u2022 The for loop allows us to put everything\ntogether for us!\n\u2022 for(counter = start; condition; counter\nincrement)\n\u2022 Now we don't have to worry about the\nplacement of the counter and\nincrementing it!\n\n\fEQUIVALENCE\nint counter = start;\nwhile(condition)\n{\n//Do stuff\ncounter\nincrement\n}//end loop\n//while(condition)\n\nfor(int counter = start;\ncondition; counter\nincrement)\n{\n//Do stuff\n}//end loop\nfor(condition)\n\n\ffor(;;){\u2026}\nfor(int currElement = 0; currElement <\nlist.length; currElement++)\n{\nSystem.out.println(list[currElement]);\n}//end loop for(currElement <\nlist.length)\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}