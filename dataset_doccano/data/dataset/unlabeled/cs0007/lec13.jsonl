{"id": 163, "segment": "unlabeled", "course": "cs0007", "lec": "lec13", "text": "CS 0007: Introduction to Java\nLecture 13\nNathan Ong\nUniversity of Pittsburgh\nOctober 25, 2016\n\n\fAnnouncements\n\u2022 Exam grades are posted on Courseweb\n\u2022 You can see your exam during office\nhours or make an appointment, but you\nmay not keep them\n\u2022 Project 0 due October 31, 2016 at 11:59\nPM via submission link on Courseweb\n\u2022 Project 1 released soon\n\n\fUsage\n\u2022 When do I use For Loops?\n\u2013 Iteration, or going through all of the\nelements of an array or other type of list.\n\u2013 When the number of times you need to\nloop is known, either explicitly with a value,\nor through a variable.\n\n\u2022 While loops are used otherwise\n\n\fMulti-dimension Arrays\n\u2022 Arrays don't just have to be lists\n\u2022 They can also be grids, cubes, hypercubes, \u2026\n\n\fType[]\u2026[] name = new Type[size1]\u2026\n[sizeN];\n\n\fType[]\u2026[] name = values\u2026s;\n\n\fint[][] listList = {{1,2,3},\n{4,5,6},{7,8,9}};\n\n\fThings to Remember\n\u2022 In 2-D Arrays, referencing an element\nrequires TWO PAIRS of square brackets\n\u2022 To get the #1 from listList\n\u2022 listList[0][0]\n\u2022 To get the #4 from listList\n\u2022 listList[1][0]\n\u2022 Remember: element \uf0e0 listList[row][col]\n\n\fHow Do We Go Through a 2-D\nArray?\n\u2022 If it took one for loop to go though a 1D array, then\u2026\n\u2022 It will take two for loops to go through a\n2-D array\n\u2022 It will take N for loops to go through an\nN-D array\n\u2022 If you don't have to go through\neverything, don't. It just wastes time\n\n\flistList[row][col]\n\n\fLet's Test It on listList\npublic class Test\n{\npublic static void main(String[] args)\n{\nint[][] list = {{1,2,3},{4,5,6},{7,8,9}};\nfor(int i = 0; i < list.length; i++)\n{\nfor(int j = 0; j < list[i].length; j++)\n{\nSystem.out.println(\"Counting...\nNow at \" + list[i][j]);\n}//end inner-loop for(j < list[i].length)\n}//end outer-loop for(i < list.length)\n}//end method main\n}//End class Test\n\nFor convenience sake, listList \uf0e0 list\nWhat is the output?\n\n\fGood Coding Practices\n\u2022 Whenever you make any variable or array,\nensure that you fill it with the appropriate\nvalues, or use some default non-important\nvalue.\n\u2022 Rule of thumb:\n\u2013 Numbers/char \uf0e0 0(.0)\n\u2013 boolean \uf0e0 false\n\u2013 Objects \uf0e0 null\n\u2013 Arrays \uf0e0 Depends on type, but every element\nshould be set to something explicitly\n\n\fMeaning of null\n\u2022 Null indicates the variable refers to nothing\n\u2022 There is no actual object with the given variable name\n\u2022 As expected, you cannot do anything useful with a variable\nset to null\n\u2022 Checking for null (in an if-statement or other boolean\nexpression) uses ==\nScanner myScan = new Scanner(System.in);\nif(myScan == null)\n{\nSystem.err.println(\"Something wrong happened\");\n}//clearly never executed\n\n\fRecursion\n\u2022 Recursion is the process of a function\n(or set of functions) that calls itself.\n\u2022 Recursion is really just a special name\nfor calling the same function within\nitself\n\u2022 Recursion ends at a base case.\n\n\fA Simple Example\n\u2022 I want to compute n! (factorial)\nn! = n * (n-1) * (n-2) * \u2026 * 1\n\u2022 I can easily do this with loops, but for\nthe sake of an easy example, we can\neasily break this down\n\n\fA Simple Example\n\u2022 I want to compute n! (factorial)\nn! = n * (n-1) * (n-2) * \u2026 * 1\n\u2022 Recursion is the breakdown of a\nproblem into smaller chunks, like\nMatryoshka dolls\n\nSource:\nhttps://upload.wikimedia.org/wikip\nedia/commons/7/71/RussianMatroshka.jpg\n\n\fRecursive Factorial\n\u2022 How can we take the large problem and\nbreak it up into something smaller?\n\u2022 Can we build up a solution?\n\u2022 With factorial, it is easy to see how to\nbreak this down by this equivalence:\nn! = n * ((n-1) * (n-2) * \u2026 * 2 * 1)\n= n * (n-1)!\n\u2022 To compute n!, we can rely on (n-1)!\n\n\fHow Do We Put This In Code?\n\u2022 We already know by the definition of\nrecursion that we have to call the function\ninside of itself.\npublic static int factorial(int n)\n{\nfactorial(<something>);\nreturn <something>;\n}//end function(int)\n\n\fRecursive Factorial\n\u2022 Let us use the knowledge that we know\nfrom the equivalence.\nn! = n * ((n-1) * (n-2) * \u2026 * 2 * 1)\n= n * (n-1)!\n\u2022 In order to return n!, we need to know\nthe value of (n-1)! and then multiply it\nwith n.\n\n\fHow Do We Put This In Code?\n\u2022 In order to return n!, we need to know\nthe value of (n-1)! and then multiply it\nwith n.\npublic static int factorial(int n)\n{\nfactorial(<something>);\nreturn <something>;\n}//end function(int)\n\n\fHow Do We Put This In Code?\n\u2022 In order to return n!, we need to know\nthe value of (n-1)! and then multiply it\nwith n.\npublic static int factorial(int n)\n{\nfactorial(<n-1>);\nreturn <n*(n-1)!>;\n}//end function(int)\n\n\fHow Do We Put This In Code?\n\u2022 In order to return n!, we need to know\nthe value of (n-1)! and then multiply it\nwith n.\npublic static int factorial(int n)\n{\nint prevFact = factorial(n1);\nreturn n*prevFact;\n}//end function(int)\n\n\fHow Do We Put This In Code?\n\u2022 In order to return n!, we need to know\nthe value of (n-1)! and then multiply it\nwith n.\npublic static int factorial(int n)\n{\nreturn n*factorial(n-1);\n}//end function(int)\n\n\fHow Do We Put This In Code?\n\u2022 If we just use this, we run into the\nproblem that this goes on forever.\n\u2022 When do we stop? When is the base\ncase?\n\npublic static int factorial(int n)\n{\nreturn n*factorial(n-1);\n}//end function(int)\n\n\fHow Do We Put This In Code?\n\u2022 When n <= 1, n! is just 1\npublic static int factorial(int n)\n{\nif(n <= 1)\n{\nreturn 1;\n}\nreturn n*factorial(n-1);\n}//end function(int)\n\n\fHow Do We Put This In Code?\npublic class FactorialTester\n{\n\u2026(Function)\npublic static void main(String[] args)\n{\nScanner scanner = new Scanner(System.in);\nSystem.out.println(\"Enter an integer\");\nint n = scanner.nextInt();\nSystem.out.println(n + \"! = \" +\nfactorial(n));\n}//end method main(String[])\n}//End class FactorialTester\n\n\fOBJECT ORIENTED\nPROGRAMMING\n\n\fRevisiting the History of\nLanguages\n\u2022 Assembly \u2013 Low-level hardware based\ncode\n\u2022 Structured \u2013 Introduces subroutines (i.e.\nfunctions) and well-defined looping\nstructures\n\u2022 Object-Oriented \u2013 Introduces classes\nand a philosophy about programming\n\n\fIt\u2019s In the Name\n\u2022 Object-Oriented Programming is as it\nsounds. Assume everything can be\nmodeled as an object.\n\n\fTerminology\n\u2022 A class is code that describes objects of\nthat type\n\u2022 An instance is a particular object of a\ngiven type\n\u2022 A field is a property of an object\n\u2022 A method is a function that is provided\nby the class for an object of the class\ntype\n\n\fStatic\n\u2022 Referenced by keyword static\n\u2022 Property or method is not dependent on\nthe individual instantiated object, but\nrather the class as a whole\n\u2022 The property/method exists between\ninstances; any change made to static fields\nare reflected through all instances of the\nclass\n\u2022 Static methods can only manipulate static\nfields\n\n\fMain Portions of OOP\n\u2022 Building a class\n\u2022 Determining inter-class relationships\n\u2013 Subclasses\n\u2013 Superclasses\n\u2013 Ownership\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}