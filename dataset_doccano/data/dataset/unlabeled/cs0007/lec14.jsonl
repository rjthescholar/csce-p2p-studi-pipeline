{"id": 192, "segment": "unlabeled", "course": "cs0007", "lec": "lec14", "text": "CS 0007: Introduction to Java\nLecture 14\nNathan Ong\nUniversity of Pittsburgh\nOctober 27, 2016\n\n\fOBJECT ORIENTED\nPROGRAMMING\n\n\fRevisiting the History of\nLanguages\n\u2022 Assembly \u2013 Low-level hardware based\ncode\n\u2022 Structured \u2013 Introduces subroutines (i.e.\nfunctions) and well-defined looping\nstructures\n\u2022 Object-Oriented \u2013 Introduces classes\nand a philosophy about programming\n\n\fIt\u2019s In the Name\n\u2022 Object-Oriented Programming is as it\nsounds. Assume everything can be\nmodeled as an object.\n\n\fTerminology\n\u2022 A class is code that describes objects of\nthat type\n\u2022 An instance is a particular object of a\ngiven type\n\u2022 A field is a property of an object\n\u2022 A method is a function that is provided\nby the class\n\n\fStatic\n\u2022 Referenced by keyword static\n\u2022 Property or method is not dependent on\nthe individual instantiated object, but\nrather the class as a whole\n\u2022 The property/method exists between\ninstances; any change made to static fields\nare reflected through all instances of the\nclass\n\u2022 Static methods can only manipulate static\nfields\n\n\fMain Portions of OOP\n\u2022 Building a class\n\u2022 Determining inter-class relationships\n\u2013 Subclasses\n\u2013 Superclasses\n\u2013 Ownership\n\n\fBuilding Classes\nThere are several parts of a class, much like\nthere are several parts of an object\n\u2022 Properties\n\u2013 Static: Class-level variables\n\u2013 Non-static: Instance variables\n\n\u2022 Methods (originally functions)\n\u2013 Static: Class methods\n\u2013 Non-static: Instance methods\n\u2013 Special: Constructor\n\n\fProperties\n\u2022 Inherent things (objects/primitives) describing the\nclass or instance\n\u2022 Placed within the class, but outside any method\n\u2022 Class-level variables\n\u2013 Static\n\u2013 Usually constants\n\u2013 Declared and assigned outside any object\n\n\u2022 Instance variables\n\u2013 Non-static\n\u2013 Declared by each object construction, which allows them\nto contain different values\n\n\fClass-level Variables\n\u2022 Constants (final keyword)\n\u2013 Usually refers to limits or specific values\n\u2013 Signified in ALL_CAPS_WITH_UNDERSCORES\n\u2013 Variable cannot be changed\n\u2013 Usually visible to anyone (public keyword)\npublic static final double PI = 3.14;\nint radius = 5;\ndouble area = Math.PI*radius*radius;\n\n\fClass-level Variables\n\u2022 Non-Constants\n\u2013 Usually performs bookkeeping (e.g. how\nmany objects did you instantiate?)\n\u2013 Usually visible only to the class (private\nkeyword)\n\nprivate static int nextID = 0;\n\n\fInstance Variables\n\u2022 Variables that are object instance\ndependent\n\u2022 All cars have a color, but not all cars are\nred\n\u2022 Possibly constant (final keyword)\n\u2013 Must be assigned at construction\n\u2013 Cannot change value for the lifetime of the\nobject\n\n\fExample\npublic class Car\n{\nprivate final int idNum;\nprivate Color color;\nprivate String\nlicensePlate;\n\u2026\n}\n\n\fHow to Determine?\n\u2022 Depends on your needs and\nrequirements of the scenario\n\u2022 A good rule of thumb: Restrict\neverything as much as possible. If a\nvariable does not need to change, make\nit final to prevent possible accidents.\nIf a variable does not need to be directly\nvisible to everyone, make it private.\n\n\fRemember\n\nSource: http://www.craveonline.com/images/stories/2011/Film/Captain%20Planet.jpg\n\n\fMethods\n\u2022 Functions that alter the object or operate\nusing the properties of the object\n\u2022 This allows further control over how the\nobject should be used, essentially\nproviding guidelines to programmers on\ncorrect usage\n\u2022 Three main types\n\u2013 Static: Class methods\n\u2013 Non-static: Instance methods\n\u2013 Special: Constructor\n\n\fConstructors\n\u2022 Essentially a method initializing the\nobject\n\u2022 Calling this special method requires the\nkeyword new\n\u2022 We have seen this before!!!\n\u2022 But how do I make one?\n\n\fFunction Review\n\n1.\n2.\n3.\nFunction 4.\nHeader 5.\n\nFunction\nBody 6.\n\nVisibility type (public/protected/private)\nstatic (For now, required)\nReturn Type\nfunctionName\nParentheses \u201c()\u201d\n\u2013\na)\nb)\nc)\n\nParameters\nType1 parameterName1\nType2 parameterName2\n\u2026\n\nCurly Brackets/Braces \u201c{}\u201d\n\u2013\n\nreturn a value\n\n\fConstructor\n\n1.\n2.\n3.\nFunction 4.\nHeader 5.\n\nFunction\nBody 6.\n\nVisibility type (public/protected/private)\nstatic (For now, required)\nReturn Type\nfunctionName Same name as the class\nParentheses \u201c()\u201d\n\u2013\na)\nb)\nc)\n\nParameters\nType1 parameterName1\nType2 parameterName2\n\u2026\n\nCurly Brackets/Braces \u201c{}\u201d\n\u2013\n\nreturn a value\n\n\fCar Example\npublic class Car\n{\nprivate final int idNum;\nprivate Color color;\nprivate String licensePlate;\npublic Car(Color color)\n{\n//initialize instance variables\n}//end constructor(Color)\n\u2026\n}//End class Car\n\n\fInstance Variable\nManipulation\n\u2022 To reference non-static objectdependent variables, use the keyword\nthis followed by the dot operator.\n\u2022 The keyword can distinguish these\nobject-dependent variables and\nparameters.\n\u2022 It can be used regularly, with no need to\ndeclare them.\n\n\fCar Example\npublic class Car\n{\nprivate final int idNum;\nprivate Color color;\nprivate String licensePlate;\npublic Car(Color color)\n{\nthis.color = color;\n\u2026\n}//end constructor(Color)\n\u2026\n}//End class Car\n\n\fControl Question\n\u2022 Should we allow the function caller (e.g.\nrandom user) to make the car\u2019s ID\nnumber? Probably not.\n\u2022 We want the ID number to be unique.\n\u2022 Simple solution: just count up by one\nevery time a new car is made.\n\u2022 We can do this via a class-level variable.\n\n\fCar Example\npublic class Car\n{\nprivate static int nextIDNum = 0;\nprivate final int idNum;\nprivate Color color;\nprivate String licensePlate;\npublic Car(Color color)\n{\nthis.color = color;\nthis.idNum = Car.nextIDNum;\nCar.nextIDNum++;\n\u2026\n}//end constructor(Color)\n\u2026\n}//End class Car\n\n\fCar Example\npublic Car(Color color)\n{\n\u2026\nthis.idNum = Car.nextIDNum;\nCar.nextIDNum++;\n\u2026\n}//end constructor(Color)\nBecause nextIDNum is static, and was initialized to 0, the\nfirst car has an ID number of 0. Then the static value is\nincreased by 1. The next time we construct a new car,\nits ID number will be 1.\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}