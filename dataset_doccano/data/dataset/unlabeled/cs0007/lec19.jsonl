{"id": 155, "segment": "unlabeled", "course": "cs0007", "lec": "lec19", "text": "CS 0007: Introduction to Java\nLecture 19\nNathan Ong\nUniversity of Pittsburgh\nNovember 15, 2016\n\n\fMain Portions of OOP\n\u2022 Building a class\n\u2022 Determining inter-class relationships\n\n\fClass Components\n\u2022 Class-level/Instance Variables\n\u2022 Methods\n\u2022 Constructor(s)\n\n\fInter-class Relationships\n\u2022 Building a single class is useless. It\nneeds to be used in context.\n\u2022 There are two main relationships\nbetween classes\n\u2013 Sub/Super class\n\u2013 Ownership\n\n\fModeling a Problem\n\u201cJoe\u2019s Automotive Shop services foreign cars, and\nspecializes in servicing cars made by Mercedes,\nPorsche, and BMW. When a customer brings a car to\nthe shop, the manager gets the customer\u2019s name,\naddress, and telephone number. Then the manager\ndetermines the make, model, and year of the car, and\ngives the customer a service quote. The service\nquote shows the estimated parts charges, estimated\nlabor charges, sales tax, and total estimated\ncharges.\u201d\nSource: Starting Out with Java: From Control Structures\nthrough Objects by Tony Gaddis\n\n\fClass Overview\naddress\nBMW\ncar\ncars\ncustomer\nestimated labor charges\ncharges\nestimated parts charges\n\nforeign cars\nJoe\u2019s Automotive Shop\nmake\nmanager\nMercedes\nmodel\n\nPorsche\nsales tax\nservice quote\nshop\ntelephone number\ntotal estimated\n\nname\n\nyear\n\n\fThe Object Class\n\u2022 Let us examine the API for the highest\nclass.\n\u2022 toString() looks interesting. \u201cIt is\nrecommended that all subclasses\noverride this method.\u201d\n\n\fWhat Is toString()?\n\u2022 It provides a String representation of\nan object\n\u2022 It should be descriptive, not just what\ntype it is, but what is contained within it.\n\n\fFunctional Responsibility\n\u2022 How do we determine which class(es)\nshould have which functions?\n\u2022 You need to ask: Who\u2019s state is needed\nor changing?\n\n\fHard example\n\u2022 Using the automotive shop example, we\nhave four classes, Shop, Customer, Car,\nand Service Quote.\n\u2022 Who deals with car alterations?\n\u2013 Shop?\n\u2013 Mechanic?\n\u2013 Car?\n\n\fADVANCED INPUT AND\nSIMPLE EXCEPTION\nHANDLING\n\n\fScanners\n\u2022 Scanners actually have an\ninconveniently annoying flaw\n\u2022 Some of you may have already\nencountered it\n\n\fScanner Issue\nimport java.util.Scanner;\npublic class ScannerAttempt\n{\npublic static void main(String[] args)\n{\nScanner scan = new Scanner(System.in);\nSystem.out.println(\"Enter your age\");\nint age = scan.nextInt();\nSystem.out.println(\"Enter your name\");\nString name = scan.nextLine();\nSystem.out.println(name + \" is \" + age +\n\" years old.\");\n}//end method main\n}//End class ScannerAttempt\n\n\fI couldn\u2019t\neven enter\nmy name\nbefore it\nfinished\n\n\fLong Story Short\n\u2022 Scanner has a buffering quirk. When\nscanning for a token (an item like\nboolean, int) that is not a line, the\nscanner reads up to the new line\ncharacter, but does not consume it.\n\u2022 When you call nextLine(), it sees the\nnew line, assumes it is done reading,\nand returns an empty String.\n\n\fWhat Should Happen Then?\nThere are two ways of dealing with it\n\u2022 Call nextLine() twice\n\u2022 Use the appropriate classes and parse\nthe input\n\n\fA Reminder\n\u2022 The act of receiving input is called\nreading\n\u2022 Relevant classes that do reading are\nReaders\n\n\fA Re-examination\n\u2022 System.in\n\u2022 An InputStream\n\u2022 If we examine the API, InputStreams\ncan only read bytes. Not very helpful.\n\u2022 What could we try?\n\n\fInputStreamReader\n\u2022 Now we can read characters, but having\nto combine all the characters is difficult\n\u2022 Why don\u2019t we use the suggestion from\nthe API?\n\n\fBufferedReader\n\u2022 This thankfully allows us to read full\nlines of input\n\u2022 The input needs to be processed\ndepending on your needs\n\u2022 Let us first learn how to use\nBufferedReader correctly\n\n\fExample\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\npublic class BRExample\n{\npublic static void main(String[] args)\n{\nBufferedReader reader = new\nBufferedReader(new\nInputStreamReader(System.in));\nString line = reader.readLine();\nSystem.out.println(line +\n\" is what you wrote.\");\n}//end method main\n}//End class BRExample\n\n\f\fExceptions\n\u2022 An exception is an event meant to disrupt the\nflow of execution\n\u2022 To throw an exception is to see an exception\nbeing raised\n\u2022 To catch an exception is to acknowledge a\nthrown exception\n\u2022 You probably have already encountered some\nwhile debugging your code\n\u2022 We will focus on two of three types, which are\nmore common\n\n\fException Types\n\u2022 Checked\n\n\u2013 Exceptions that need to have a contingency plan\nshould the exception arise\n\u2013 These stop the compiler from running\n\u2013 Example: IOException\n\n\u2022 Unchecked\n\n\u2013 Exceptions that tend to indicate the program has\na flaw during its execution\n\u2013 These stop the program in the middle of\nexecution\n\u2013 Example: ArrayIndexOutOfBoundsException\n\n\fDealing with Exceptions\n\u2022 Checked\n\u2013 try, catch, finally\n\n\u2022 Unchecked\n\u2013 Fix your program code\n\n\fExample\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class BRExample\n{\npublic static void main(String[] args)\n{\nString line = \"\";\nSystem.out.println(\"Type something!\");\ntry\n{\nBufferedReader reader = new\nBufferedReader(new\nInputStreamReader(System.in));\nline = reader.readLine();\n}\ncatch (IOException e)\n{\ne.printStackTrace();\n}\nSystem.out.println(line + \" is what you wrote.\");\n}//end method main\n}//End class BRExample\n\n\fKeywords in Context\n\u2022 Everything inside the try block\nindicates the section of code that may\nthrow exceptions\n\u2022 Inside the catch\u2019s parentheses is the\nexpected exception to process, and the\nname given to it (usually \u2018e\u2019)\n\u2022 Inside the catch block indicates the\nsection of code that should be executed\nif the exception is caught\n\n\fSome FAQ\n\u2022 How do I know when an exception is thrown?\n\u2013 Check the API for relevant methods\n\n\u2022 How do I know which exception is thrown?\n\u2013 Check the API\n\n\u2022 How much code should I surround with try?\n\u2013 Only as much as you need\n\u2013 Note that scope applies here as well\n\n\u2022 Can I catch multiple exceptions?\n\u2013 Yes, you can use several catch blocks\n\u2013 We\u2019ll see an example soon\n\n\fConverting Strings into Useful\nPrimitives\n\u2022 Scanner gave us useful methods like\nnextInt() or nextDouble(). We can\ndo the same with BufferedReader, but\nnot directly.\n\u2022 We need to take another trip to the API,\nspecifically for the classes that back the\nprimitives.\n\u2022 Let\u2019s look at Integer\n\n\fExample\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\npublic class Converter\n{\npublic static int convertToInt(String line)\n{\ntry\n{\nreturn Integer.parseInt(line);\n}\ncatch (NumberFormatException e)\n{\n//??\n}\n}//end method main\n}//End class BRExample\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}