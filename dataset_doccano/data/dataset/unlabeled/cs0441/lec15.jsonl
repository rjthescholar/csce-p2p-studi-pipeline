{"id": 148, "segment": "unlabeled", "course": "cs0441", "lec": "lec15", "text": "Discrete Structures for Computer\nScience\n\nWilliam Garrison\nbill@cs.pitt.edu\n6311 Sennott Square\nLecture #15: Recursion and Structural Induction\n\nBased on materials developed by Dr. Adam Lee\n\n\fThere are many uses of induction in computer\nscience!\nProof by induction is often used to reason about:\nl Algorithm properties (correctness, etc.)\nl Properties of data structures\nl Membership in certain sets\nl Determining whether certain expressions are well-formed\nl\u2026\n\nTo begin looking at how we can use induction to prove\nthe above types of statements, we first need to\nlearn about recursion\n\n\fSometimes, it is difficult or messy to define\nsome object explicitly\nRecursive objects are defined in terms of (other\ninstances of) themselves\nWe often see the recursive versions of the following\ntypes of objects:\nl Functions\nl Sequences\nl Sets\nl Data structures\n\nLet\u2019s look at some examples\u2026\n\n\fRecursive functions are useful\nWhen defining a recursive function whose domain is\nthe set of natural numbers, we have two steps:\n1. Basis step: Define the behavior of f(0)\n2. Recursive step: Compute f(n+1) using f(0), \u2026, f(n)\nDoesn\u2019t this look a little bit like strong induction?\n\nExample: Let f(0) = 3, f(n+1) = 2f(n) + 3\nl\nl\nl\nl\nl\n\nf(1) = 2f(0) + 3 = 2(3) + 3 = 9\nf(2) = 2f(1) + 3 = 2(9) + 3 = 21\nf(3) = 2f(2) + 3 = 2(21) + 3 = 45\nf(4) = 2f(3) + 3 = 2(45) + 3 = 93\n\u2026\n\n\fSome functions can be defined more precisely\nusing recursion\nExample: Define the factorial function F(n) recursively\n1. Basis step: F(0) = 1\n2. Recursive step: F(n+1) = (n+1) \u00d7 F(n)\n\nNote: F(4) = 4 \u00d7 F(3)\nThe recursive definition\n= 4 \u00d7 3 \u00d7 F(2)\navoids using the \u201c\u2026\u201d\nshorthand!\n= 4 \u00d7 3 \u00d7 2 \u00d7 F(1)\n= 4 \u00d7 3 \u00d7 2 \u00d7 1 \u00d7 F(0)\n= 4 \u00d7 3 \u00d7 2 \u00d7 1 \u00d7 1 = 24\nCompare the above definition our old definition:\nl\n\nF(n) = n \u00d7 (n-1) \u00d7 \u2026 \u00d7 2 \u00d7 1\n\n\fIt should be no surprise that we can also define\nrecursive sequences\nExample: The Fibonacci numbers, {fn}, are defined as follows:\nl f0 = 1\nl f1 = 1\nl fn = fn-1 + fn-2\n\nThis is like strong induction, since we need\nmore than fn-1 to compute fn.\n\nCalculate: f2, f3, f4, and f5\nl f2 = f1 + f0 = 1 + 1 = 2\nl f3 = f2 + f1 = 2 + 1 = 3\nl f4 = f3 + f2 = 3 + 2 = 5\nl f5 = f4 + f3 = 5 + 3 = 8\n\nThis gives us the sequence {fn} = 1, 1, 2, 3, 5, 8, 13, 21, 34, \u2026\n\n\fRecursion is used heavily in the study of strings\nLet: \u2211 be defined as an alphabet\nl Binary strings: \u2211 = {0, 1}\nl Lower case letters: \u2211 = {a, b, c, \u2026, z}\n\nWe can define the set \u2211* containing all strings over the\n\u03bb is the empty string\nalphabet \u2211 as follows:\ncontaining no characters\n1. Basis step: \u03bb \u2208 \u2211*\n2. Recursive step: If w \u2208 \u2211* and x \u2208 \u2211, then wx \u2208 \u2211*\n\nExample: If \u2211 = {0, 1}, then \u2211* = {\u03bb, 0, 1, 01, 11, \u2026}\n\n\fThis recursive definition allows us to easily\ndefine important string operations\nDefinition: The concatenation of two strings can be\ndefined as follows:\n1. Basis step: if w \u2208 \u2211*, then w\u22c4\u03bb = w\n2. Recursive step: if w1 \u2208 \u2211*, w2 \u2208 \u2211*, and x \u2208 \u2211, then\nw1\u22c4(w2x) = (w1\u22c4w2)x\n\nExample: Concatenate the strings \u201cHello\u201d and \u201cWorld\u201d\n1. Hello\u22c4World = (Hello\u22c4Worl)d\n2.\n= (Hello\u22c4Wor)ld\n3.\n= (Hello\u22c4Wo)rld\n4.\n= (Hello\u22c4W)orld\n5.\n= (Hello\u22c4\u03bb)World\n6.\n= HelloWorld\n\n\fThis recursive definition allows us to easily\ndefine important string operations\nDefinition: The length l(w) of a string can be defined\nas follows:\n1. Basis step: l(\u03bb) = 0\n2. Recursive step: l(wx) = l(w) + 1 if w \u2208 \u2211* and x \u2208 \u2211\n\nExample: l(1001) = l(100) + 1\n= l(10) + 1 + 1\n= l(1) + 1 + 1 + 1\n= l(\u03bb) + 1 + 1 + 1 + 1\n=0+1+1+1+1\n=4\n\n\fWe can define sets of well-formed formulae\nrecursively\nThis is often used to specify the operations permissible in\na given formal language (e.g., a programming language)\n\nExample: Defining propositional logic\n1. Basis step: \u27d9, \u27d8, and s are well-formed propositional logic\nstatements (where s is a propositional variable)\n2. Recursive step: If E and F are well-formed statements, so are\n\u27a3\n\u27a3\n\u27a3\n\u27a3\n\u27a3\n\n(\u00acE)\n(E \u2227 F)\n(E \u2228 F)\n(E \u2192 F)\n(E \u2194 F)\n\n\fExample\nQuestion: Is ((p \u2227 q) \u2192 (((\u00acr) \u2228 q) \u2227 t)) well-formed?\nl\nl\nl\nl\nl\n\nBasis tells us that p, q, r, t are well-formed\n1st application: (p \u2227 q), (\u00acr) are well-formed\n2nd application: ((\u00acr) \u2228 q) is well-formed\n3rd application: (((\u00acr) \u2228 q) \u2227 t)\n4th application: ((p \u2227 q) \u2192 (((\u00acr) \u2228 q) \u2227 t)) is well-formed\n\n\u2714\n\n\fIn-class exercises\nProblem 1: Construct a recursive definition of the\nsequence \ud835\udc4e# where the \ud835\udc5b$% term is a natural number\ncomputed by adding the \ud835\udc5b \u2212 1 $% term to the square\nof the \ud835\udc5b \u2212 3 $% term. Assume that the first three\nterms of this sequence are 1, 1, 1.\nProblem 2: Top Hat\n\n\fLike other forms of induction, structural induction\nrequires that we consider two cases\nBasis step: Show that the result holds for the objects\nspecified in the basis case of the recursive definition\nRecursive step: Show that if the result holds for the\nobjects used to construct new elements using the\nrecursive step of the definition, then it holds for the\nnew object as well.\nTo see how this works, let\u2019s revisit string length\u2026\n\n\fRecall from earlier\u2026\nDefinition: The length l(w) of a string can be defined\nas follows:\n1. Basis step: l(\u03bb) = 0\n2. Recursive step: l(wx) = l(w) + 1 if w \u2208 \u2211* and x \u2208 \u2211\n\nExample: l(1001) = l(100) + 1\n= l(10) + 1 + 1\n= l(1) + 1 + 1 + 1\n= l(\u03bb) + 1 + 1 + 1 + 1\n=0+1+1+1+1\n=4\n\n\fProve that l(x\u22c4y) = l(x) + l(y) for x,y \u2208 \u2211*\nP(n) \u2261 l(x\u22c4y) = l(x) + l(y) whenever x \u2208 \u2211* and l(y) = n\nBase case: P(0): l(x\u22c4\u03bb) = l(x) = l(x) + 0 = l(x) + l(\u03bb) \u2714\nI.H.: Assume that P(k) holds for an arbitrary integer k\nInductive step: We will now show that P(k) \u2192 P(k+1)\nn Consider the string x\u22c4ya, where x,y \u2208 \u2211*, a \u2208 \u2211 and l(y) = k\nn l(x\u22c4ya) = l(x\u22c4y) + 1 by the recursive definition of l()\nn\n= l(x) + l(y) + 1 by the I.H.\nn Since l(ya) = l(y) + 1 by the recursive defintion of l(), we have\nthat l(x\u22c4ya) = l(x) + l(ya), where ya is a string of size k+1\nConclusion: Since we have proved the base case and the inductive\ncase, the claim holds by structural induction \u274f\n\n\fMany common data structures used in computer\nscience have recursive definitions\nExample: Rooted Trees\n\nBase step: A single node is a rooted tree\nRecursive step: If T1, T2, \u2026, Tn are disjoint rooted trees\nwith roots r1, r2, \u2026, rn then introducing a new root r\nconnected to r1, r2, \u2026, rn forms a new rooted tree.\n\n\fExample Rooted Trees\nBase case:\nOne application:\n\n\u2026\n\nTwo applications:\n\n\u2026\n\n\u2026\n\n\fMany common data structures used in computer\nscience have recursive definitions\nExample: Extended binary trees\n\nBase step: The empty set is an extended binary tree\nRecursive step: If T1 and T2 are disjoint extended binary\ntrees with roots r1 and r2, then introducing a new root\nr connected to r1 and r2 forms a new extended binary\ntree.\n\n\fExample Extended Binary Trees\nBase case:\n\n\u2205\n\nStep 1:\n\nStep 2:\n\nStep 3:\n\n\u2026\n\n\u2026\n\n\fMany common data structures used in computer\nscience have recursive definitions\nExample: Full binary trees\n\nBase step: A single root node r is a full binary tree\nRecursive step: If T1 and T2 are disjoint full binary trees\nwith roots r1 and r2, then introducing a new root r\nconnected to r1 and r2 forms a new full binary tree.\n\n\fExample Full Binary Trees\nBase case:\nStep 1:\n\nStep 2:\n\n\u2026\n\n\fTrees are used to parse expressions\n\n456\n\n(((3 + 6) \u00d7 7) \u2013 (4 + 2)) \u00d7 8\n\n\u00d7\n57\n63\n\n-\n\n8\n\n\u00d7\n\n6\n\n+\n\n9\n+\n3\n\n7\n6\n\n4\n\n2\n\n\fTrees are used to enable fast searches\nConsider the set S = {56, 22, 34, 89, 99, 77, 16}\n34 < 56\n\n22\n\n34 > 22\n\n34\n\n16\n\n56\n\n262 > 56\n\n89\n77\n\n262 > 89\n\n99\n\nQuestion: Is 34 \u2208 S?\n\nQuestion: Is 262 \u2208 S?\n\nYES!\n\nNO!\n\n\fAs with other recursively defined objects, we can\ndefine many properties of trees recursively\nDefinition: Given a tree T, we can define the height of\nT recursively, as follows:\n1. Basis step: If T consists only of the root node r, then h(T) = 0\n2. Recursive step: If T consists of a root r that connects to\nsubtrees T1, \u2026, Tn, then h(T) = 1 + max(h(T1), \u2026, h(Tn))\n\nExample: What is the height of this tree T?\nh(T) = 1 + max(h(L), h(R)) = 3\nh(L) = 1 + h(L1) = 2\nh(L1) = 1 + max(h(L11), h(L12)) = 1\nh(L11) = 0\n\nh(R) = 1 + h(R1) = 1\nh(R1) = 0\nh(L12) = 0\n\n\fIf T is a full binary tree, then the number of nodes in T\n(denoted n(T)) is less than or equal to 2h(T)+1-1\nClaim: n(T) \u2264 2h(T)+1-1\nBase case: T contains only a root node. In this case n(T) = 1 and\nh(T) = 0. Note that 20+1-1 = 1, so the claim holds.\nI.H.: Assume that claim holds for a tree of height k\nInductive step: Show that the claim holds for trees of height k+1\nn Let T1 and T2 be disjoint full binary trees of height k\nn By the I.H., n(T1) \u2264 2h(T1)+1-1 and n(T2) \u2264 2h(T2)+1-1\nn Let r be a unique root element, and let T be the tree formed\nusing r as a root, T1 as the left subtree of r, and T2 as the right\nsubtree of r\n\nr\nT1\n\nT2\n\n\fIf T is a full binary tree, then the number of nodes in T\n(denoted n(T)) is less than or equal to 2h(T)+1-1\nr\nT1\n\nT2\n\nInductive step (cont.): We have that\nn n(T) = 1 + n(T1) + n(T2)\nn\n\u2264 1 + 2h(T1)+1 - 1 + 2h(T2)+1 - 1\nn\n\u2264 2h(T1)+1 + 2h(T2)+1 \u2013 1\nn\n\u2264 2 \u00d7max(2h(T1)+1, 2h(T2)+1) \u2013 1\nn\n\u2264 2 \u00d72max(h(T1), h(T2))+1 \u2013 1\nn\n\u2264 2 \u00d72h(T) \u2013 1\nn\n\u2264 2h(T)+1 \u2013 1\n\nby recursive formula of n(T)\nby I.H.\nsum of 2 terms \u2264 twice larger term\nmax(2x, 2y) = 2max(x,y)\nby recursive def\u2019n of h(T)\n\nConclusion: Since we have proved the base case and the inductive\ncase, the claim holds by structural induction \u274f\n\n\fIn-class exercises\nProblem 3: Use structural induction to prove that\nchecking whether some number is contained in a\nbinary search tree T involves at most h(T)+1\ncomparison operations.\n\n\fFinal Thoughts\nn Structural induction can be used to prove properties\nof recursive\nl Functions\nl Sequences\nl Sets\nl Data structures\n\nn Next time, we start learning about counting and\ncombinatorics (Section 6.1)\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}