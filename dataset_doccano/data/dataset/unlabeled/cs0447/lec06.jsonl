{"id": 150, "segment": "unlabeled", "course": "cs0447", "lec": "lec06", "text": "#6\n\nFlow, Conditionals,\nand Loops\nOriginal slides by: Jarrett Billingsley\nModified with bits from: Bruce\nChilders, David Wilkinson\n\nCS 0447\nIntroduction to\nComputer Programming\n\nLu\u00eds Oliveira\n\nFall 2020\n\n\fSo far\u2026\n\u25cf Putting numbers into registers\n\nli a0, 3\n\nla a0, x\n\nlabel\n\n.data\nx: .word 4\n\n\u25cf COPYing register contents\n\nmove a0, t0\n\nThese do zero\nUnsigned! \uf0e8\nextension\n\n\u25cf COPYing from/to memory\n\nlw/sw, lh/lhu/sh, lb/lbu/sb\nla t1, x\nlw t0, 0(t1)\nlw t0, x\n\nla t1, x\nsw t0, 0(t1)\nsw t0, x\n\nDo the\nsame thing\n2\n\n\fIn another perspective\nlw, lh, lhu, lb, lbu\nmove\nCPU\n\nMemory\nRegisters\n\nli, la\n\nsw, sh, sb\nOther operations\n\nDatatypes\n\nadd\n\nword\n\nsub\n\nhalf\n\nmul\n\nbyte\n\nsyscall\n\nasciiz\n\n\u2026\n\n\u2026\n\n3\n\n\fIntroduction to conditions\n\u25cf What distinguishes a computer from a calculator?\n\u25cf It can make decisions based on values that it calculates\no If the value of this register is this, do something.\no Otherwise, do something else.\n\u25cf The possible decisions make up the potential control flow of the program.\no When there is no possible route to a piece of code in your program, that is\ncalled dead code.\n\uf0a7 It\u2019s like procrastination!\n\nif(false) {\ndo_some_work()\n}\n4\n\n\fControl flow\n\n5\n\n\fWith great power\u2026\n\u25cf Control flow determines the order that your instructions run in\no What kinds of control flow statements do you know of?\no What about functions?\n\u25cf In asm, the only thing you get for free is that instructions run in order\n\u25cf You're responsible for coming up with everything else.\no If you screw up your control flow, the CPU doesn't care\no You'll just have a broken, malfunctioning program\n\uf0a7 And it'll be half an hour before the lab is due\n\u2013 And you'll be sad\n\u00bb This is like 90% of the bugs\n\n6\n\n\fGetting a little further from familiarity\n\u25cf all control flow is done with branches and jumps\no these are instructions which say \"go somewhere else\"\n\u25cf for example\u2026\n\nthis is an infinite loop,\nwhich is sometimes useful\nbut not too interesting\n\n_main_loop:\n# clear screen\n# draw one thing\n# sleep\n# draw another thing\nj stands for \u201djump\" \u2013 go\n# etc\nsomewhere else\nj _main_loop\n\n7\n\n\fBuilding blocks\n\u25cf A basic block is a chunk of code that has no control flow in it\n\u25cf Control flow statements separate basic blocks\n\nif(x == w - 1) {\ndo_thing()\n} else {\nother_thing()\n}\nthird_thing()\n\nx == w - 1?\n\nother_thing\n\ndo_thing\n\nthird_thing\n\nthinking about this is REAL HELPFUL\n8\n\n\fEssentially\u2026\n\u25cf The way control flow works in asm is you make basic blocks\no You gotta name (label) them\n\u25cf Then, you use special instructions to choose where to go\no Ask yourself \u201cWhich basic block runs next?\"\no Select the instruction you need!\n\uf0a7 Don\u2019t worry, we look into these instructions in a moment\n\u25cf And don\u2019t forget!\no Write pseudo-code (with comments) to keep track of control flow\no Or make a drawing of a flow-chart!\no Or \u2026 any other guide you think it\u2019s helpful\n\n9\n\n\fConditionals: if and if-else\n\n10\n\n\fMIPS ISA: conditional branch instructions\n\u25cf conditional branch instructions do one of two things:\no if the condition is met, we go to the label\no otherwise, nothing happens, and we go to the next instruction\n\nInstruction\n\nMeaning\n\nbeq a, b, label\n\nif(a == b) { goto label }\n\nbne a, b, label\n\nif(a != b) { goto label }\n\nabove, a must be a register, but b can be a register or immediate\n(by the powers of the pseudo-instruction)\n11\n\n\fHow do these work?\n\nPrevious\ninstruction\n\nThis is the branch\n\nbeq t0, t1, label\n# branch if equal\n\nt0==t1\n\nTrue\n\nFalse\n\nNext\ninstruction\n\nlabel:\n\nOther\ninstruction\n12\n\n\fHow do these work?\nlabel:\n\nbeq t0, t1, label\n# branch if equal\n\nOther\ninstruction\nPrevious\ninstruction\n\nTrue\n\nt0==t1\nThis is the branch\nFalse\n\nNext\ninstruction\n13\n\n\fHow to write asm (again!)\n\u25cf Remember:\n\nWRITE PSEUDOCODE\n\nALWAYS\n\nREALLY!!!\n\nif(x == w - 1) {\ndo_thing()\n} else {\nother_thing()\n}\n\n14\n\n\fLike mad libs, but for code\n\u25cf From now on, I\u2019ll use these 'blocks' to represent the basic blocks\no cause they don\u2019t matter\n\nif(some condition) {\nblock A\n} else {\nblock B\n}\nblock C\n\n15\n\n\fA simple conditional block (if)\n\u25cf If there is no else, it's pretty simple.\n\nif(s0 == 30) {\nblock A\n}\nblock B\n\nbne s0, 30, blockB\nblockA:\nblockB:\n\n16\n\n\fA simple conditional block (if)\n\u25cf If there is no else, it's pretty simple.\n\nif(s0 == 30) {\nblock A\n}\nblock B\n\nbne s0, 30, blockB\n\nIn Java/C what happens in an if?\nYou JUMP OVER when the condition is true or\nfalse?\n\nWhen its FALSE!!\n\n17\n\n\fA simple conditional block (if)\n\n\u25cfIn MIPS you jump when the condition is TRUE\nif(s0 == 30) {\nblock A\n}\nblock B\n\nbne s0, 30, blockB\nblockA:\nblock A\nblockB:\nblock B\n\n18\n\n\fAn if-else with a simple condition\n\u25cf more blocks now\u2026\n\nif(s0 == 30) {\nblock A\n}\nelse {\nblock B\n}\nblock C\n\nbne s0, 30, blockB\nblock A\nj blockC\nblockB:\nblock B\nblockC:\nblock C\n\nwe NEED THIS \u2013 the CPU doesn't\nsee/care about your labels!!\n\n19\n\n\fThe other way around\n\u25cf Because in HLL we \u201cexecute smth if\u201d and In assembly we \u201cjump over if\u201d\n\u25cf We usually negate the condition in the assembly to skip over code\no It\u2019s a preference.\no You can still invert the process\n\uf0a7 How?\nif(s0 == 30) {\n}\nelse {\n}\n\nblock A\nblock B\n\nblock C\n\nbeq s0, 30, blockA\nj blockElse\nblockA:\nblock A\nj blockExit # skip the else\nblockElse:\nblock B\nblockExit:\nblock C\n20\n\n\fMIPS ISA: conditional branch instructions\n\u25cf MIPS also supports instructions that compare to zero\n\nInstruction\n\nMeaning\n\nbltz a, label\n\nif(a < 0) { goto label }\n\nblez a, label\n\nif(a <= 0) { goto label }\n\nbgtz a, label\n\nif(a > 0)\n\nbgez a, label\n\nif(a >= 0) { goto label }\n\n{ goto label }\n\n21\n\n\fMIPS ISA: set if less than\n\u25cf And\u2026\n\nInstruction\nslt\n\nc, a, b\n\nMeaning\nif(a < b) { c = 1 } else { c = 0 }\n\nSet if Less Than: register c will be set to 1 if a<b.\nOtherwise, register c will be set to 0.\nUsing slt together with bne and beq all conditionals can be implemented!\na=b , a\u2260b, a>b, a\u2265b, a<b, a\u2264b\n\nThanks, De Morgan\n\n22\n\n\fMIPS ISA: conditional branch instructions\n\u25cf Or\u2026 we can just use the pseudo-instructions :D\n\nInstruction\n\nMeaning\n\nblt a, b, label\n\nif(a < b)\n\n{ goto label }\n\nble a, b, label\n\nif(a <= b) { goto label }\n\nbgt a, b, label\n\nif(a > b)\n\nbge a, b, label\n\nif(a >= b) { goto label }\n\n{ goto label }\n\nabove, a must be a register, but b can be a register or immediate\n\n23\n\n\fExamples\nExample 1: branch if a>b\nbgt a, b, label\n\n# Goto label if a>b\n\nSolution: branch if b<a\nslt t, b, a\nbne t, zero, label\n\n# t=1 if b<a\n# Goto label if t\u22600\n\nExample 2: branch if a\u2265b\nbge a, b, label\n\n# Goto label if a\u2265b\n\nSolution: branch if !(a<b)\nslt t, a, b\nbeq t, zero, label\n\n# t=1 if a<b\n# Goto label if t=0\n24\n\n\fComplex conditionals\n\n25\n\n\fIn this code\u2026\nif(dog_size < 10 || dog_name() == \"Fluffy\")\n\nif dog_size is 3, is dog_name() called?\n\nNO!\n\nthis is short circuit evaluation.\n\nfor || (logical OR), if the first condition is true, the\nsecond one is skipped. (cause there's no way for\nthe result of the OR to be false.)\nfor && (logical AND), if the first condition is\nfalse, the second one is skipped.\n\n26\n\n\fIn this code\u2026\nif(dog_size < 10)\nsmall();\nif dog_size is 3, is this\nelse if(dog_size < 20)\ncondition checked?\nmedium();\nNO!\nelse if(dog_size < 30)\nlarge();\nelse\nonce a true condition is found, no\nenormous();\nmore conditions are checked.\nafter small(), it comes down here.\n\n27\n\n\fAnd-and!\n\u25cf Block A is run if both conditions are true.\no to think of it another way\u2026 it's skipped if? What\u2019s the inverse?\no either condition is false\u2026\n\nif(s0 == 30 &&\ns1 > 1) {\nblock A\n}\n\nbne s0, 30, skipA\nble s1, 1, skipA\nblock A\nskipA:\n\n28\n\n\fOr-or!\n\u25cf We go to block A if either condition is true.\no to think of it another way\u2026 it's skipped if? What\u2019s the inverse?\no all conditions are false.\n\nif(s0 == 30 ||\ns1 > 1)\n{\nblock A\n}\n\nbeq s0, 30, blockA\nble s1, 1, skipA\nblockA:\nblock A\nskipA:\n29\n\n\fLooooops\no o\no\no\no\no\noo oo\n30\n\n\fDis-assembling a for-loop\n\u25cf How does a for loop work?\n\nWhat is the first thing a for does?\n\nInitialize: i=0\nfor(i=0; i<10; i++) And???\nCheck condition:\n{\nexecute while i<10\nblock A\nThen\u2026\n}\n// carry on\nblock A\nFinally?\n\nIncrement: i++\nGo back up to the top\n\n31\n\n\fLooping in MIPS assembly\nWhat\u2019s the first\nli\ns0,\n0\n__________ thing a for\nloop_top:\ndoes?\nfor(i=0; i<10; i++)\nwhich conditional branch?\n__________________\n{\nblock A\nblock A\n}\nHow do we\n// carry on\nincrement?\naddi s0, s0, 1\n_______________\nj loop_top\n____________\nLet\u2019s start with a\nHow do\nrecipe\ncarry_on:\nwe go up?\n# carry on\n\n\u25cf Let\u2019s use s0 to hold i\n\n32\n\n\fThat\u2019s bge, actually\nWe want to leave the loop\u2026\nwhen the opposite of i<10\nhappens!\n\u25cf In HLL we \u201cexecute smth if\u201d\n\u25cf In assembly we \u201cjump over if\u201d\n\u25cf Thus negate the condition in\nthe assembly to skip over\ncode\n\nli s0, 0\n__________\nloop_top:\nbge s0, 10, carry_on\n_____________________\ns0\nmove a0, ___\nli v0, 1\nsyscall\naddi s0, s0, 1\n_______________\nj loop_top\n____________\ncarry_on:\n# carry on\n33\n\n\fThe other way around\nli s0, 0\n__________\nloop_top:\nblt s0, 10, loop_code\nb carry_on\nloop_code:\ns0\nmove a0, ___\nli v0, 1\nsyscall\naddi s0, s0, 1\n_______________\nj loop_top\n____________\ncarry_on:\n# carry on\n\n34\n\n\fWhile looks the same, no initialization or increment\n\nwhile(s2 < 10)\n{\n// stuff!!\n}\n// more stuff\n\nloop_top:\nbge s2, 10, more_stuff\n________\nstuff:\n# stuff!!\nj loop_top\nmore_stuff:\n# more stuff\n\n35\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}