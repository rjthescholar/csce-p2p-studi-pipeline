{"id": 188, "segment": "unlabeled", "course": "cs0447", "lec": "lec07", "text": "#7\nCS 0447\nIntroduction to\nComputer Programming\n\nFunctions and the\nStack\nOriginal slides by: Jarrett Billingsley\nModified with bits from: Bruce\nChilders, David Wilkinson\n\nLu\u00eds Oliveira\n\nFall 2020\n\n\fWhat do I need to know now!\nThe classes will be recorded!\n\u25cf You will be able to access the videos online\no They are for your personal use only!\no Do not distribute them!\n\u25cf You don\u2019t need to turn on your camera\no If you do, you may be recorded\n\u25cf You can ask questions via text!\no Chat is great for that. If I don\u2019t stop and read your questions, ask them again\no But feel free to interrupt me at any point.\n\n2\n\n\fClass announcements\n\n\u2022 Project 1 is out soon!\no You have 3 weeks!\n\n\u2022 Don\u2019t forget!\n\no In the website (next to the slides) there are code examples\no Those code examples have extra exercises!\no Go and do them!\n\n\u2022 Have you been going to recitation?\no You should!\n\n3\n\n\fCalling conventions\n\n4\n\n\fWhat's a calling convention?\n\u25cf It ensures our programs don't trip over their own feet\n\u25cf It's how machine-language functions call one another\no How arguments are passed\no How return values are returned\no How control flows into/out of the function\no What contracts exist between the caller and the callee\n\nvoid fork() {\nknife();\n}\n\ncaller\n\nvoid knife() {\n...\n}\n\ncallee\n\n5\n\n\fThe program counter register\n\u25cf A program's instructions are in memory, so they have addresses\n\u25cf The PC (program counter) holds the address of the next instruction to run\no Is incremented by a word! Each instruction is a word\n\ntime\n\nPC\n0x8000\n0x8004\n\n0x8008\n0x800C\n0x8010\n0x8000\n\n? 0x8014\n\nAddress\ntop:\n\n0x8000 lw\n\nt0, (s0)\n\n0x8004 add t0, t0, 1\n0x8008 sw t0, (s0)\n0x800C add s0, s0, 4\n0x8010 blt s0, s1, top\nbtw what pattern do you notice\nabout these addresses?\n6\n\n\fMIPS ISA: conditional branch instructions\n\u25cf The conditional branch instructions we\u2019ve seen last class\no Actually interact with pc\n\nInstruction\n\nMeaning\n\nbeq a, b, label\n\nif(a == b) { goto label }\n\nbne a, b, label\n\nif(a != b) { goto label }\n\nblt a, b, label\n\nif(a < b)\n\nble a, b, label\n\nif(a <= b) { goto label }\n\nbgt a, b, label\n\nif(a > b)\n\nbge a, b, label\n\nif(a >= b) { goto label }\n\n{ goto label }\n\n{ goto label }\n\n7\n\n\fThe flow of control\n\u25cf When the caller calls a function, where do we go?\n\u25cf When the callee's code is finished, where do we go?\n\nvoid fork() {\nknife();\nspoon++;\n}\ncaller\n\nvoid knife() {\nspork++;\nspatula--;\n}\ncallee\n\n8\n\n\fMIPS ISA: The jump and link instruction\n\u25cf We call functions with jal: jump and link\n\nvoid main() {\nfunc();\n}\n\nmain:\nlabel\njal func\n\n9\n\n\fMIPS ISA: The jump and link instruction\n\u25cf We call functions with jal: jump and link\n\nPC 0x8004\nWhat address should\nPC 0x8C30\ngo into PC next?\nWhen func returns,\n0x8008\nra\nwhere will we go?\n\n0x8000 li a0, 10\n0x8004 jal func\n0x8008 li v0, 10\n... ...\n\nfunc: 0x8C30 li v0, 4\nThis is what jal does:\nit jumps to a new location, and\n... ...\nmakes a link back to the old one\nin the ra (return address) register\nand this is ALL it does.\n10\n\n\fMIPS ISA: The jump register instruction\n\u25cf We return from functions with jr: jump to address in register\n\nvoid main() {\nfunc();\n}\n\nmain:\nlabel\njal func\nlabel\n\nvoid func() {\nreturn;\n}\n\nfunc:\njr ra\n\nreturn\n\n11\n\n\fMIPS ISA: The jump register instruction\n\u25cf We return from functions with jr: jump to address in register\n\nNow we're at the end PC 0x8C38\nof func. ra still has the\nproper return address ra 0x8008\n\njr ra copies ra into pc. PC 0x8008\nand this is ALL it does.\n\n0x8000 li\n\na0, 10\n\n0x8004 jal func\n0x8008 li v0, 10\n... ...\n\nfunc: 0x8C30 li v0, 4\n0x8C34 syscall\n0x8C38 jr ra\n12\n\n\fArguments and\nReturn Values\n\n13\n\n\fIt's pretty simple, remember register names!!\n\u25cf if we have a function in a higher level language\u2026\n\nwe use particular registers\nv0\na0\na1\nto pass arguments and\nint gcd(int a, int b) {\nreturn values.\nwhile(a != b) {\nif(a > b)\na -= b;\nelse\nwe already know how to\nb -= a; return. How do syscalls do it?\n}\nfor this, just put the value you want\nreturn a;\nto return in v0 before jr ra.\n}\n14\n\n\fThe a and v registers\n\u25cf a0-a3 are the argument registers\n\u25cf v0-v1 are the return value registers\no This is just a convention, there's nothing special about them\n\u25aa Does that mean I can pass values in (e.g.) s-registers?\n\u2013 Yessssssss\u2026.????\u00ac.\u00ac\n\u25aa Will I lose any points in midterms/labs/projects if I do?\n\u2013 Yessssssss!!!!\u00ac.\u00ac\n\u25cf By convention! We never do that!\no ALWAYS pass arguments in a-registers\no ALWAYS return arguments in v-registers\n\n15\n\n\fTo call a function\u2026\n\u25cf You put its arguments in the a registers before doing a jal\n\u25cf Once control is inside the callee\u2026\no The arguments are just \"there\" in the a registers.\n\u25aa Cause they are.\n\u2013 They didn't go anywhere!\nadd_nums\n\n\u25cf Functions should be black boxes for the caller\no You don\u2019t need any information about\nthe implementation\no You only need to know inputs and outputs!\no \u2026 and conventions\n\nAmazing function that adds two\nnumbers. You do not need to\nknow how it is implemented!!!\nInputs:\n1. Number to add\n2. Number to add\nOutputs:\n1. Numbers added together\n\n16\n\n\fLet\u2019s call a function!\n\u25cf Let's make main do this:\n\nv0=add_nums(3, 8)\nprint(v0)\n\nli\na0, 3\nli\na1, 8\njal add_nums\nmove a0, v0\nli\nv0, 1\nsyscall Careful!\n\n\u25cf How do we set 3 and 8 as the arguments?\n\u25cf How do we call add_nums?\n\u25cf Afterwards, which register holds the sum?\n\u25cf So how can we print that value?\n\u25cf Why do syscalls put the number of the\nsyscall in v0?\no Well what do you get when you cross an elephant and a rhino?\n\u25aa Hell if I know \u00af\\_(\u30c4)_/\u00af\n\nIt\u2019s a rhinophant\n\n17\n\n\fInput, output\n\u25cf Now, let's write the function:\n\nint add_nums(int x, int y) {return x + y;}\n\u25cf inside of our add_nums asm function\u2026\no which register represents x?\no which register represents y?\no which register will hold the sum that we return?\n\nadd_nums:\nadd __, __, __\njr\n\nv0\nra\n\na0\n\na1\n\n18\n\n\fMore conventions:\nSaved and Unsaved registers\n\n19\n\n\fLet\u2019s try something\n\u25cf Let's make a variable and a function to change it\n\n.data\ncounter: .word 0\n.text\nincrement:\nla t0, counter\nlw t1, (t0)\nadd t1, t1, 1\nsw t1, (t0)\njr ra\n\nthen we can call it\n\nmain:\njal increment\njal increment\njal increment\n\n20\n\n\fEverything's just fine, right?\n\u25cf let's write a loop that calls it ten times in a row\n\u25cf so we need a loop counter ('i' in a for loop)\n\nli t0, 0 # our counter\nloop_begin:\njal increment\nadd t0, t0, 1\nblt t0, 10, loop_begin\nloop_end:\n(this is a do-while loop)\n\nif we run this, it only\nincrements the\nvariable once.\nwhy? let's put a\nbreakpoint on blt\nand see what it sees.\n\n21\n\n\fScribbling on someone else's notes\n\u25cf both functions are trying to use t0 for different purposes\no but there's only ONE t0!\n\u25cf the increment function is in the clear\no the problem is actually the loop\n\u25cf this is one of the contracts between the caller and the callee\u2026\n\na caller cannot depend on the t, a, or v registers\nto have the same values after a call as before it.\nor to put it another way, callees are\nallowed to trash those registers.\n\n22\n\n\fAnother piece of the calling convention puzzle\n\u25cf When you call a function, it's allowed to change some registers\n\u25cf But other registers must be left exactly as they were\n\nfunctions are\nrequired to put\nthese registers\nback the way they\nwere before they\nwere called.\n\nSaved\ns0-s7\nsp\nra*\n\nanyone can change\nUnsaved these. after you call a\nv0-v1 function, they might\na0-a3 have totally different\nvalues from before\nt0-t9 you called it.\n\n*ra is a little weird cause it's kinda \"out of\nsync\" with the other saved regs but you\nDO save and restore it like the others\n23\n\n\fWhenever you call a function\u2026\n\u25cf after a jal, you have no idea what's in these registers.\n\n...\njal\n...\n\nincrement\nUnsaved\nv0-v1\na0-a3\nt0-t9\n\n24\n\n\fWhy it broke\n\u25cf if we look at this code again\u2026\n\nt0 is our loop counter and\neverything's fiiiine.\n\nli t0, 0\nloop_begin:\nuh oh.\njal increment\nadd t0, t0, 1\nblt t0, 10, loop_begin WHAT IS IN t0 NOW??\nloop_end:\ninstead, this is a great place to use an s register.\n\n25\n\n\fUsing the convention\n\u25cf if we use an s register\u2026\n\ns0 is our loop counter and\neverything's fiiiine.\n\nli s0, 0\nloop_begin:\nuh oh.\njal increment\nadd s0, s0, 1\noh whew, we used an s\nblt s0, 10, loop_begin register, it's fine.\nloop_end:\n\nbut s registers aren't magic. they don't do this automatically.\n\n26\n\n\fDon't step on each others' toes\n\u25cf let's track PC and ra as we run this code.\n\nPC\n\nra\n\n0x8000 0x0000\nAfter jal fork: 0x8020 0x8004\n\nAfter jal spoon: 0x8040\nAfter jr ra: 0x8024\n\n0x8024 fork:\n0x8024\n\n0x8000 jal fork\n0x8004 li v0, 10\n... ...\n0x8020 jal spoon\n0x8024 jr ra\n\n... ...\nAfter jr ra: 0x8024 0x8024\nspoon: 0x8040 jr ra\nAfter jr ra: 0x8024 0x8024\nAfter jr ra: 0x8024\n\n0x8024\n\nAfter jr ra: 0x8024\n\n0x8024\n27\n\n\fWhat's the deal?\n\u25cf There's only one return address register\n\u25cf If we call more than one level deep, things go horribly wrong\n\u25cf Could we put it in another register?\no Then what about three levels deep? four?\n\u25aa We just don't have enough registers\u2026\n\u25cf So where do we put things when we don't have room in registers?\no Tip: NOT in other registers (obviously!)\n\u25aa So don\u2019t give into the urge of doing it\no Put things in memory!\n\n28\n\n\f(yes, memory)\n\nThe Stack\n\n29\n\n\fOne busy desk\n\u25cf there's a tiny desk that three people have to share\n\u25cf person 1 is working at the desk. it's covered in their stuff.\n\u25cf person 2 interrupts them and needs to do some important work\n\u25cf what does person 2 do with the stuff?\no throw it in the trash?\n\u25cf they put it somewhere else.\n\nP1\n\nP1\n\nTrash\n\n30\n\n\fOne busy desk\n\u25cf there's a tiny desk that three people have to share\n\u25cf person 1 is working at the desk. it's covered in their stuff.\n\u25cf person 2 interrupts them and needs to do some important work\n\u25cf what does person 2 do with the stuff?\no throw it in the trash?\n\u25cf they put it somewhere else.\n\u25cf And once they are done\no They put it back.\n\nP1\n\nP1\n\nTrash\n\n31\n\n\fOne busy desk\n\u25cf now person 2 is interrupted by person 3.\n\u25cf when person 3 is done, person 2 will come back.\n\u25cf where do we put person 2's stuff?\no on top of the stack of stuff.\n\u25cf the desk is the registers.\n\u25cf the people are functions.\n\u25cf the stack of stuff is\u2026 the stack.\n\nP2\n\nP2\nP1\n\n32\n\n\fWhat's the stack?\n\u25cf it's an area of memory provided to your program by the OS\no when your program starts, it's already there\n\u25cf the stack holds information about function calls:\no the return address to the caller\no copies of registers that we want to change\no local variables that can't fit in registers\n\u25cf how do we access the stack?\no through the stack pointer (sp) register\no this register is initialized for you by the OS too\n\nStack\n\nMemory\n\nProgram\n33\n\n\fThe stack pointer (animated)\n\u25cf let's say sp starts at the address 0xF000\n\u25cf we want to push something on the stack\n\u25cf the first thing we'll do is move sp to the next available slot\n\u25cf clearly, that's the previous address\n...\no subtract 4 from sp\n0xF008\n\u25cf then, we can store something in\nthe memory that sp points to.\n0xF004\n\nsp\n\n...\n0x00000000\n\n0x00000000\n0xF000 0x00000000\n0xEFFC 0xC0DEBEEF\n0x00000000\n\n34\n\n\fDoing that in MIPS (animated)\n\u25cf say ra = 0xC0DEBEEF\n\u25cf first: move the stack pointer down (up?):\n\nsub sp, sp, 4\n\n... ...\n0xF008 0x00000000\n\n\u25cf then, store ra at the address that sp holds.\n\nsw\n\nra, (sp)\n\n\u25cf now the value in ra is saved on the\nstack, and we can get it back later.\no and we can store as many return\naddresses as we want!\n\nsp\n\n0xF004 0x00000000\n0xF000 0x00000000\n0xEFFC 0xC0DEBEEF\n0x00000000\n\n35\n\n\fGoing the other direction (animated)\n\u25cf now we wanna pop the value off the stack and put it back in ra\n\u25cf we do the same things, but in reverse\nra 0xC0DEBEEF\n0xABAD1DEA\n\nlw\n\nra, (sp)\n\n...\n...\n0xF008 0x00000000\n0xF004 0x00000000\n0xF000 0x00000000\n\n\u25cf then, we move the stack pointer\u2026\nup? down? whatever\n\nadd sp, sp, 4\n\n\u25cf now we got back the old value of ra!\n\u25cf and sp is back where it was before!\n\nsp\n\n0xEFFC 0xC0DEBEEF\n\n36\n\n\fShortening the pushes and pops\n\u25cf the push and pop operations always look and work the same\n\u25cf since you'll be using them in most functions, we shortened em\n\u25cf if you write push ra or pop ra, it'll do these things for you!\n\npush ra\n\nsubi sp, sp, 4\nsw\nra, (sp)\n\npop\n\nlw\nra, (sp)\naddi sp, sp, 4\n\nra\n\nthese are pseudo-ops: fake instructions to shorten common tasks\nthese can be used with ANY register, not just ra!\n\n37\n\n\fToes = protected\nsp\n\n0x8004\nstuff\n\nPC\n\nra\n\n0x8000 0x0000\nAfter jal fork: 0x8020 0x8004\n\nThen we push ra on the stack!\nAfter jal spoon: 0x8040\n\n0x802C\n\nAfter spoon jr ra: 0x802C\n\n0x802C\n\nThen we pop ra off the stack!\n\nBefore fork jr ra: 0x8034\n\n0x8004\n\nAfter fork jr ra: 0x8004\n\n0x8004\n\n0x8000 jal\nfork:\n\nfork\n\n0x8020 push ra\n0x8028 jal spoon\n0x802C pop\n0x8034 jr\nspoon:\n\nra\nra\n\n0x8040 jr\n\nra\n\n38\n\n\fWriting a simple function\n\u25cf Function calling conventions follows a simple structure :\n\n1. Give it a name (label). spoon:\n2. Save ra to the stack.\n3. Do whatever.\n4. Load ra from the stack.\n5. Return!\n\npush ra\n\nyour code goes here\npop\njr\n\nra\nra\n\n\u25cf Push everything you need! Pop it back in reverse order at the end!\n\n39\n\n\fWhat about other registers?\n\u25cf Function calling conventions follows a simple structure :\n\n1. Give it a name (label). spoon:\n2a. Save ra to the stack.\n\n2b. Save s0 to the stack.\n3. Do whatever.\n4a. Load s0 from the stack.\n4b. Load ra from the stack.\n5. Return!\n\npush ra\npush s0\nyour code goes here\npop s0\npop ra\njr\nra\n\n\u25cf Push everything you need! Pop it back in reverse order at the end!\n40\n\n\fit's really simple\n\u25cf treat pushes and pops like the { braces } around a function\n\nspoon:\npushes come at the\npush ra # {\nbeginnings of functions\n# 800 instructions\n# so much stuff omg\npops come at the end\npop ra # }\njr\nra\nthat is it, seriously, don't\nmake it more complicated\n\nnever push or pop anywhere else please\n\n41\n\n\fThe s register contract\n\u25cf if you want to use an s register\u2026\n\u25cf you must save and restore it, just like ra.\n\nmy_func:\npush ra\npush s0\n\nmoving the papers off the desk\n\ncode that uses s0! it's fine! we saved it!\n\npop\npop\njr\n\ns0\nra\nra\n\nputting the papers back the pops happen\nin reverse order!\n\n42\n\n\fOh, and\u2026\n\u25cf You must always pop the same number of registers\nthat you push.\n\u25cf To make this simpler for yourself\u2026 make a label\nbefore the pops.\no then you can leave the function by\njumping/branching there.\n\u25cf Remember: These are the { braces }\no So\u2026 only push in the top and pop in the\nbottom of the function!\n\u25aa Only!\n\nmy_func:\npush ra\npush s0\n...\nbge ...\nb exit_func\n...\nexit_func:\npop s0\npop ra\njr\nra\n43\n\n\fSumming it up: Terminology\n\nmyFunction:\npush ra\n\nActivation Frame\n\npush s0\n\nContains:\n\u26ab Arguments (that\naren\u2019t in registers)\n\u26ab Saved Registers\n(ra, s0, etc)\n\u26ab Local Variables\n\n# my code\npop s0\n\nFunction Prologue\n\npop ra\njr\n\nra\n\nFunction Epilogue\n\n0xffff\n\nStack\n\nMemory\nHeap\n\nProgram\n0x0000\n44\n\n\fSide Stacking\n(on your own)\n\n45\n\n\fSooooo\u2026..\n\u25cf Why this mysterious behavior?\no \u201cAllocating\u201d on the stack (making room) has you subtract from its base address.\n\u25cf Let\u2019s visit this from a different direction.\n\u25cf Let\u2019s consider\u2026 the problem itself.\no And how we might solve it.\n\n46\n\n\fThe Problem\n\u25cf We have a program. It uses memory.\n\u25cf We don\u2019t know exactly how much memory we need.\no It may depend on how long the program runs.\no Or the size of the data it is working on (arbitrarily specified by a human being,\nperhaps)\no Maybe our program responds to the available memory by choosing a different\nalgorithm when it has more or less.\n\u25cf Either way, a program does not have a static allocation of memory.\n\u25cf How do we allow a program to allocate memory on-demand?\n\n47\n\n\fOur Example: Video Editor\n\u25cf Let\u2019s consider a video editing program.\no But thankfully ignore all of the actual video details!\n\u25cf Data is large, and the memory usage is relative to the size of our video.\n\u25cf We want memory to be continuous.\no Could you imagine if data were all broken up?\no Your program would be difficult to code if an array was broken up.\n\u25aa Our array addressing math would no longer be general and would\ncease to work\nMemory\nwell. (You\u2019d have multiple array base addresses)\n\nProgram\n48\n\n\fAllocating Memory\n\u25cf You\u2019ll learn a lot more about this in CS 449\no But it\u2019s worth sequence breaking and talking about it now\n\u25cf We will maintain a section of memory: the heap.\no The heap is a section of memory used for dynamic memory.\no Dynamic memory is memory that is allocated during the runtime of a program and\nmay be reclaimed later.\n\u25cf When we allocate memory, we add\nit to the end of the heap.\no It\u2019s like appending to an array.\no Look at it go!\n\n0x46f0\n\nMemory\n\n0x4100\n0x4000\n\nHeap\n\nProgram\n0x0000\n49\n\n\fRevisiting Functions: A Problem Arises\n\u25cf Now, consider functions.\n\n\u25cf When we call a function, we need to remember where we were.\no This is stored in the $ra register.\no But if we call a function twice, what happens to $ra?\n\u25aa It is overwritten, and our first value in $ra is lost.\n\u25aa This means after our second function is called, the first function will now be lost,\nand it will return to itself. (Refer to the previous slides)\n\u25cf What are our strategies for remembering ra?\n\n50\n\n\fRemembering RA\n\u25cf Bad Idea #1: Place it in another register\n\nmyFunction:\nmove t0, ra\n# overwrites ra!\njal myOtherFunction\n# it\u2019s ok though:\nmove ra, t0\njr ra\n\nHowever:\n\u2022 What if myOtherFunction uses t0?\n\u2022 Ok, t0 isn\u2019t preserved, so let\u2019s use s0.\n\u2022 Wait\u2026 we need to preserve s0\u2026\n\u2022 Where do we put that?? s1???\n\u2022 Wait\u2026 we need to preserve s1!!\n\u2022 We will run out of saved registers and\nwe cannot trust unsaved registers.\n(other functions may overwrite them)\n\u2022 Therefore, we need memory.\n51\n\n\fRemembering RA\n\u25cf We need memory. We have that heap thing.\n\n\u25cf So can\u2019t we just allocate some on the heap?\n\u25cf Sure can. But it is Bad Idea #2.\n\u25cf What happens if that function allocates memory?\n\u25cf And then calls another function.\n\u25cf And then we return\u2026\n\u25cf And return from the first function\u2026\n\u25cf Leaving gaps in our memory!\n\nMemory\n\n0x4000\n\nHeap\n\nProgram\n0x0000\n52\n\n\fLet\u2019s Design a Memory Layout (kinda)\n\u25cf Our video editing application wants to use large, continuous memory regions.\no Videos are big things! (Continuous memory makes things easier/faster\u2026 future\ncourses will convince you.)\n\u25cf We have very few registers, and need to remember ra\no So, we need to place ra in memory to recall it before we jr ra\n\u25cf However, placing it with other program memory creates gaps\no This is very very trash!!\n\n\u25cf How do we solve this.\no Occam\u2019s Razor to the rescue\u2026 and it will create a very weird situation.\no One that involves subtracting to allocate\u2026\n\n53\n\n\fSolving our Problem: Step 1\n\u25cf How can we use memory, but not create gaps?\n\n\u25cf Good [rational] Idea: Maintain two dynamic memory\nsections.\n\u25cf We call our function.\n\u25cf What happens if that function allocates\nmemory?\n\u25cf And then calls another function.\n\u25cf And then we return\u2026\n\u25cf And return from the first function\u2026 WHEW!\nNo gaps.\n\u25cf (Ok, but now we start editing a LARGE video\u2026)\no Uh oh! We\u2019ve lost our $ra\n\nStack\n0x8000\n\nMemory\n\n0x4000\n\nHeap\n\nProgram\n0x0000\n54\n\n\fSolving our Problem: Step 2\n\u25cf Good [weird] Idea: Maintain two dynamic memory sections. One of which starts at the\nhighest memory address. Allocate via subtraction (append to bottom)\n0xfffc\n\u25cf We call our function.\n0xfff0\nStack\n\u25cf What happens if that function allocates memory?\n\u25cf And then calls another function.\n\u25cf And then we return\u2026\n\u25cf And return from the first function\u2026 No gaps.\n\u25cf As for our large memory case\u2026\n\u25cf It\u2019s fine! (only problem: running out of memory)\no But, my goodness, you have a bigger problem, then.\n\nMemory\n\n0x4000\n\nHeap\n\nProgram\n0x0000\n55\n\n\fSolving our Problem: Step 2\n\u25cf Good [weird] Idea: Maintain two dynamic memory sections. One of which starts at the\nhighest memory address. Allocate via subtraction (append to bottom)\n0xfffc\n\u25cf We call our function. (subtract $sp, store)\n0xfff0\nStack\n\u25cf What happens if that function allocates memory?\n\u25cf And then calls another function. (sub, store)\n\u25cf And then we return\u2026 (load, add to $sp)\n\u25cf And return from the first function\u2026 (load, add $sp)\n\u25cf Refer to the previous slides on the Stack with this knowledge in your Memory\nmind.\n\n0x4000\n\nHeap\n\nProgram\n0x0000\n56\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}