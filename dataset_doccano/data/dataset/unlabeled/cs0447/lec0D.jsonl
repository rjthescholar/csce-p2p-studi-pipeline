{"id": 136, "segment": "unlabeled", "course": "cs0447", "lec": "lec0D", "text": "#D\nCS 0447\nIntroduction to\nComputer Programming\n\nAdding circuits and\nPlexers\nOriginal slides by: Jarrett Billingsley\nModified with bits from: Bruce\nChilders, David Wilkinson\n\nLu\u00eds Oliveira\n\nFall 2020\n\n\fClass announcements\n\u25cf none\n\n2\n\n\fCan I add with transistors?\n\n3\n\n\fSolving a problem\n\u25cf Let\u2019s say we want to create a circuit to add two bits.\no How do we do that?\n\u25cf In 3 very simple steps:\no Create a truth table that accurately represents the problem\no Interpret the truth table into a logic function\no Translate the function into a circuit\n\n4\n\n\fThe Tables of Truth\n\u25cf let's try to come up with a truth table for adding two bits\n\u25cf each column will hold 1 bit\nlet's name the\n\nA B\n0 0\nfor the input values, 0 1\nwe count up in\n1 0\nbinary\n1 1\nlet's name the\ninputs A and B\n\nC S\n0 0\n0 1\n0 1\n1 0\n\noutputs C and S,\nfor Carry and Sum\n\nnow let's fill in the\noutput values\nhey, this C column\nlooks familiar\u2026 so\ndoes the S column\ngreat! But\nthis is wrong.\n5\n\n\fHalf-truth tables\n\u25cf what we just made was a half-adder\n\u25cf it has a carry output but not a carry input\no (which might be useful for the lowest bit)\n\n\u25cf to make a full adder, we need 3 input bits\n\nCo C i\n\n00111 110\nA\n1011 0010\nB\n+0010 1111\n1110 0001\nS\n\nCi A B Co S\n0 0 0 0 0\n0\n0\n0\n1\n\n0\n1\n1\n0\n\n1\n0\n1\n0\n\n0 1\n0 1\n1 0\n\n0\n1 0 1 1\n1 1 0 1\n1 1 1 1\n\n1\n0\n0\n1\n6\n\n\fThe logic of it all\n\u25cf it looks a little messy, but it kinda makes\nsense if you think of it like this:\no it counts how many input bits are \"1\"\no Co and S are a 2-bit number!\n\u25cf if we look at the outputs in isolation:\no S is 1 if we have an odd number of \"1s\"\no Co is 1 if we have 2 or 3 \"1s\"\n\u25cf it's a little weird, but we can build this out of\nAND, OR, and XOR gates\n\nCi A B Co S\n0 0 0 0 0\n0\n0\n0\n1\n\n0\n1\n1\n0\n\n1\n0\n1\n0\n\n0 1\n0 1\n1 0\n\n0\n1 0 1 1\n1 1 0 1\n1 1 1 1\n\n1\n0\n0\n1\n7\n\n\fLet\u2019s build the adder Co circuit\n\nA B Ci Co S \ud835\udc02\ud835\udc28\ud835\udc2e\ud835\udc2d = \ud835\udc00\n\u0d25 \ud835\udc01\ud835\udc02\ud835\udc22\ud835\udc27 + \ud835\udc00\ud835\udc69\n\u0d25 \ud835\udc02\ud835\udc22\ud835\udc27 + \ud835\udc00\ud835\udc01\ud835\udc02\ud835\udc22\ud835\udc27 + \ud835\udc00\ud835\udc01\ud835\udc02\ud835\udc22\ud835\udc27\n0 0 0 0 0\n0\n0\n0\n1\n\n0\n1\n1\n0\n\n1\n0\n1\n0\n\n0 1\n0 1\n1 0\n\n\u0d25 \ud835\udc01\ud835\udc02\ud835\udc22\ud835\udc27\n\ud835\udc00\n\n1\n0\n0\n1\n\n\u0d25 \ud835\udc02\ud835\udc22\ud835\udc27\n\ud835\udc00\ud835\udc69\n\ud835\udc00\ud835\udc01\ud835\udc02\ud835\udc22\ud835\udc27\n\ud835\udc00\ud835\udc01\ud835\udc02\ud835\udc22\ud835\udc27\n\n0\n1 0 1 1\n1 1 0 1\n1 1 1 1\n\n8\n\n\fSweeping that under the rug\u2026\n\u25cf in programming, we use functions to be able to reuse code\n\u25cf in hardware, we can group gates into a component\n\u25cf here's the symbol for a one-bit full adder\n\nCo\nA\nB\nthe inputs are\nlike arguments\n\n+\nCi\n\nthe outputs are like\nreturn values\n\nS\nnow we don't have to care how\nit adds, just that it does\n\n9\n\n\fAdding longer numbers\n\n10\n\n\fWhere do the carries go?\n\u25cf when you add one place, you might get a carry out\n\u25cf that becomes the carry in for the next higher place\n\nBit\nBucket..?\n\n1 0 1 1 0 0 1 0\n+0 0 1 0 1 1 1 1\n11\n\n\fRipple Carry Adder\n\u25cf if we want to add two three-bit numbers, we'll\nneed three one-bit adders\n\u25cf we chain the carries from each place to the next\nhigher place, like we do on paper\n\u25cf we have to split the numbers up like so:\n\nA2 A1 A 0\n\n+ B2 B1 B0\nS2 S1 S0\n\nA2\n\nB2\nA1\nB1\nA0\nB0\n\n+\n\nS2\n\n+\n\nS1\n\n+\n\nS0\n\n12\n\n\fFlip side\n\u25cf We could come up with a separate subtraction circuit, but\u2026\n\u25cf Since algebra tells us that x - y = x + (-y)\no Negation meaning flip the bits and add 1\nA1\n\u25cf Flipping the bits uses NOT gates\n\u25cf How do we add 1 without any extra circuitry?\n~B1\no we use a full adder for the LSB, and when\nwe're subtracting, set the \"carry in\" to 1\n\nA0\n\n~B0\n\n+\n\nS1\n\n+\n\nS0\n\n1\n\n13\n\n\fWhat makes a good word size?\n\u25cf can you think of an example of\u2026\no 100 of something?\no a million of something? One thousand million?\no One billion? more?\n\u25cf 28 = 256, 216 \u2245 65,000, 232 \u2245 4000 million, 264 \u2245 lots-of-a-lot\n\u25cf for a given word size, all the circuitry has to be built to support it\no 64 1-bit adders\no 128 wires going in\no 64 wires coming out\n\n14\n\n\fGate Delay\n\u25cf electrical signals can't move infinitely fast\n\u25cf transistors can't turn on and off infinitely fast\n\u25cf since each digit must wait for the next smaller digit to\ncompute its carry\u2026\no ripple carry is linear in the number of digits\n\u25cf this is a diagram of how the outputs of a 16-bit ripple\ncarry adder change over time\no it's measured in picoseconds! so ~100ps total\n\u25cf but if we went to 32 bits, it'd take 200ps\no and 64 bits, 400ps...\n\u25cf there are more efficient ways of adding\n\n(courtesy of Kate Temkin)\n\n15\n\n\fWhat about overflow?\n\u25cf For unsigned addition, it's easy\no For an n-bit adder:\n\u25aa just look at the Co of the MSB\n\u25aa if it's 1, it's an overflow.\no what about subtraction?\n\u25cf For signed, is a bit strange\no Compare the last 2 carry bits\no If they are different\n\u25aa Then there is overflow\n\nOVF\nA2\nB2\n\nA1\nB1\nA0\n\nB0\n\n+\n\nS2\n\n+\n\nS1\n\n+\n\nS0\n16\n\n\fBut why?\n\u25cf When does signed addition overflow?\no If:\n\u25aa Both addends have the same sign\n\u25aa The result has a different sign\n\u25cf How can we detect that?\no Looking at the last bit!\n\u25cf Where is the overflow?\n\nThere is overflow in signed addition if:\n\nOn the last bit, the carry-in and carryout have different bit values.\n\nThe last bit:\nCi A B Co S\n0 0 0 0 0\n\n0\n0\n0\n1\n\n0\n1\n1\n0\n\n1\n0\n1\n0\n\n0 1\n0 1\n1 0\n\n0\n1 0 1 1\n1 1 0 1\n1 1 1 1\n\n1\n0\n0\n1\n\n17\n\n\fMuxes and demuxes, encoders and\ndecoders\n\n18\n\n\fHardware that makes decisions\n\u25cf a multiplexer (mux) outputs one of its inputs based on a select.\n\nA\n\nA\n\nQ\n\nQ\n\nB\n\nB\nS\n\nA\n\nQ\n\nB\nS=0\n\nS=1\n\nThis is the select input.\n\n19\n\n\fMultiplexer truth table\n\u25cf let's make a truth table for a two-input 1-bit multiplexer.\n\nA\n\n0 0 0 0\n\nA\nQ\n\nB\n\nQ\nB\n\nS=0\n\nS A B Q\n\n0 0 1 0\n0 1 0 1\n0 1 1 1\n\nS=1\n\n1 0 0 0\n1 0 1 1\n1 1 0 0\n1 1 1 1\n20\n\n\fDoing everything and throwing most of it away\n\u25cf I want a circuit that does this:\n\nif(select == 1)\noutput = A \u2013 B\nelse\noutput = A + B\n\n\u25cf let's see what that looks like\n\u25cf a mux is like a hardware if-else statement\n\u25cf but unlike in software\u2026\no the \"condition\" comes at the \"end\" (the output)\no instead of doing one or the other, we do both, choose the one that we care\nabout, and ignore the rest!\n\n21\n\n\fAmusing muxes\n\u25cf Let\u2019s go to Logisim!\n\n22\n\n\fWhat's that enable input?\n\u25cf if you don't understand tristate buses or high\nimpedance states, do not turn on the enable input.\n\u25cf if you ever see blue wires, you are in weird,\nconfusing territory.\n\u25cf if you know this stuff, fine, but otherwise\u2026\n\n23\n\n\fDemultipliexers\n\u25cf a demux does the opposite: it sends its input to one of its outputs\n\u25cf the rest of the outputs are 0s\n\nIn\n\nIn\nS\n\nIn\nS=0\n\nS=1\n\n24\n\n\fLooking in a mirror\n\u25cf it can be confusing if all you see is this:\n\nwhich is which???\n\nLogisim distinguishes these with names\nI\u2019ll do it with arrows\n\n25\n\n\fEncoders\n\u25cf They encode 2n inputs into n outputs. Specifically\u2026\n\u25cf you give it several 1-bit inputs, and it tells you which one is 1.\n\n1\n\n0\n\n0\n\n1\n\n0\n\n2\n\n0\n\n0\n\n0\n\n0\n\n1\n\n1\n\n0\n\n0\n\n2\n\n3\n\n0\n\n3\n\n0\n\n0\n\n0\n\n0\n\n0\n\n1\n\n1\n\n2\n\n0\n\n3\n\n0\n\nEnc 1\n\nEnc\n\n0\n\n0\n\n0\n\n1\n\n1\n\n1\n\n0\n\n2\n\n1\n\n3\n\n0\n\nEnc 1\n\nEnc\n\n1\n0\n\n0\n\n1\n\n1\n\n1\n\nI0 I1 I2 I3 Out\n1 0 0 0 00\n0 1 0 0 01\n0 0 1 0 10\n0 0 0 1 11\n\n26\n\n\fEncoder issues\n\u25cf That table seems VERY incomplete!!!\no What about the other entries???\n\nThe output is not valid!\n\n0\n\n0\n\n0\n\n1\n\n0\n\n2\n\n0\n\n3\n\nEnc\n\n0\n\n1\n\nvalid\n\n???\n\n???\n0\n\nI0\n0\n0\n1\n1\n\u2026\n\nI1\n0\n1\n1\n1\n\u2026\n\nI2\n0\n1\n1\n1\n\u2026\n\nI3 Out Valid\n0 ??\n0\n0 ??\n0\n0 ??\n0\n1 ??\n0\n\u2026 \u2026\n\u2026\n27\n\n\fEnter: Priority Encoders\n\u25cf In a priority encoder \u2026 you give it several 1-bit inputs, and it tells you the highest\ninput with a 1.\n\n1\n\n0\n\n0\n\n1\n\n0\n\n2\n\n0\n\n1\n\n0\n\n0\n\n1\n\n1\n\n0\n\n0\n\n2\n\n3\n\n0\n\n3\n\n1\n\n0\n\n1\n\n0\n\n0\n\n1\n\n1\n\n2\n\n0\n\n3\n\n0\n\nPri 1\n\nPri\n\n0\n\n0\n\n0\n\n1\n\n1\n\n1\n\n0\n\n2\n\n1\n\n3\n\n0\n\nPri 1\n\nPri\n\n1\n0\n\n0\n\n1\n\n1\n\n1\n\nI0 I1 I2 I3 Out\n1 0 0 0 00\nX 1 0 0 01\nX X 1 0 10\nX X X 1 11\nWhat are\nthese?\n28\n\n\fidc\n\u25cf we don't even care about the that input\n\u25cf we can put X in the inputs we don't care about\n\u25cf we call these don't cares\no yep, really\n\u25cf what these mean is:\no when we make this into a boolean function, we can ignore those inputs\n\u25aa we won't even need to write em\n\nI0 I1 I2 I3 Out\n1 0 0 0 00\nX 1 0 0 01\nX X 1 0 10\nX X X 1 11\n29\n\n\fStill\u2026\n\u25cf All zeros is still an invalid input :(\n\nif none of the inputs is 1,\nthen logisim gives you X\u2026\nThese are not don\u2019t cares :\u2019)\n0\n\n0\n\n0\n\n1\n\n0\n\n2\n\n0\n\n3\n\n0\n\nPri 1\nvalid\n\nX\nX\n0\n\n30\n\n\fDecoders\n\u25cf a decoder is like a 1-bit demux whose input is always 1\n\u25cf It does pretty much the opposite of an encoder \u263a\n\n1\nS\n\nS\n\nexactly one output is 1,\nand the rest are 0s\n31\n\n\fUses for encoders, decoders and demuxes\n\u25cf uhhhhhhhhhhh\no Ummmmmmmmm\u2026 for now \u2026\n\u25aa unless you're using tristate (blue) wires, they're not too useful\u2026\n\u25cf most of the time, you don't have to \"direct\" a signal to a location\no instead, you hook up the inputs to everything that needs them\n\u25cf we'll use them more when we get to sequential logic\n\n32\n\n\fCombinational vs Sequential\n\u25cf combinational logic: the outputs of a circuit depend entirely on their current inputs\no AND, OR, NOT, XOR gates\no adders\no muxes, demuxes, encoders, and decoders\n\u25cf sequential logic is coming up soon\no the outputs can depend on the current and previous inputs\no it remembers\n\u25cf logic minimization techniques only work on combinational logic!\no \u2026or combinational pieces of a larger sequential circuit\n\n33\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}