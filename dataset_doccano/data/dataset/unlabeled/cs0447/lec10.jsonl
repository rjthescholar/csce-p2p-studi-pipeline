{"id": 146, "segment": "unlabeled", "course": "cs0447", "lec": "lec10", "text": "#10\n\nThe Register File\nand Building an\nALU\n\nCS 0447\nIntroduction to\nComputer Programming\n\nLu\u00eds Oliveira\n\nOriginal slides by: Jarrett Billingsley\nModified with bits from: Bruce\nChilders, David Wilkinson\n\n1\n\nFall 2020\n\n\fThe Register File\nAbstracting out the flip-flops.\n\n2\n\n\fRemember this?\n\nProgram\n\ninstruction\n\nControl\n\n3\n\n5\n\n8\n\nRegisters\n\n+\n\nA\n\nB\n\nC\n\nMemory\n\nUnresolved questions:\n\u25cf What's the control?\n\u25cf What's the datapath?\n\u25cf How does it know what\ninstruction to get next?\n\u25cf How does it know what\nregisters to access?\n\u25cf How does it know to add,\nsubtract, etc.?\n\nDatapath\nProcessor\n\n3\n\n\fZooming in\n\nif(add)\ndo this\nelse if...\n\nfp\ns4\nat\nsp\neax?\n\nControl\n\nt0\n\nRegisters\n\nregisters hold the\nvalues being computed\n\ncontrol signals!\n\nvalues move\nbetween them\n\n...oh yeah, memory too\n\nthe control tells\neverything else what\nto do, and when\n\n+ -\u00f7 \u00d7\n\u2295\u222b \u2603\n\n&\n\n\u25cf There are a few major parts of any CPU:\n\nDatapath\n\nthe datapath computes\nnew values\n4\n\n\fA bit less abstract\n\nControl\n\n\u25cf The registers are grouped together into the register file\n\u25cf The ALU (arithmetic and logic unit) is the main part of the datapath\n\u25cf The control is doing its thing, somehow\u2026? (we\u2019ll see)\n\nRegister\nFile\n\nALU\n\nwe can get the values of two\nregisters at once\n\n5\n\n\fIt doesn't have to be this way\nCISC CPUs usually have small\nsets of registers, and many have\nspecial purposes or behaviors\n\n8086\n\nz80\n\n6502\n\nPDP8\n\nax\nbx\ncx\ndx\nsi\ndi\nsp\nbp\n\na f\nb c\nd e\nh l\nix\niy\nsp\n\nA\nX\nY\n\nAC\n\n16 bits\n\n12 bits\n\nRISC CPUs usually have 32* mostlyinterchangeable registers: MIPS,\nRISC, SPARC, ARMv8, RISC-V\u2026\nr0 r1 r2 r3 r4 r5 r6 r7\nr8 r9 r10 r11 r12 r13 r14 r15 32/64\n\nr16 r17 r18 r19 r20 r21 r22 r23 bits\nr24 r25 r26 r27 r28 r29 r30 r31\n\n8 bits\n\nwhy is this? well, what do you\nremember about the differences\nbetween RISC and CISC?\n*or 32 at a time\n\n6\n\n\fTug-of-war\n\u25cf Register file design is constrained by many competing factors\n\ncompilers love lots of\nISA says instructions identical registers! \u2026but there are diminishing returns.\nhave 2 operands\nand 1 destination\nfast L1 cache? not as\n\u2026except for this one\nmany regs needed\nD\nQ\ninstruction that has\nD QQ\nD\n2 destinations.\nmulti-issue CPU: need to\nhumans like intuitive\nassembly language!\nwith lots of registers,\nfunction calls are faster! \u2026but context switches\nare slower.\n\nread 4 regs and write 2\n\nmore registers means\nmore silicon\u2026\n7\n\n\fA word of advice\n\u25cf You will see many imperfect designs in your life\n\u25cf But in problem-solving, perfection isn't always the goal\no everyone has to work within the constraints they're given\n\u25cf and if everyone does something the same way\u2026\no there are probably problems/constraints you don't know about\no don't waste your time reinventing the wheel.\n\u25aa find out why it's done that way first.\n\u25cf When it comes to register files, 32 registers is just a nice number\no not too many, not too few, a nice middle-ground\n\n\u25cf also don't be a judgmental ass about someone else's design because one, it's shitty, and two, they know more about why\nit was designed that way, so you're just being presumptuous\n\n8\n\n\fSoooo registers\u2026 How do we create a register?\n\u25cf If we create a 32-bit register out of D Flip-Flops:\n\nD\n\nQ\n\nD\n\nQ\n\nD\n\nQ\n\nD\n\nQ\n\nD Flip-Flop\n\nD Flip-Flop\n\nD Flip-Flop\n\nD Flip-Flop\n\n3rd bit\n\n2nd bit\n\n1st bit\n\n0th bit\n\nWe abstract\naway to this:\n\n32\n\nD\n\nQ\n\n32\n\nRegister\n\nThankfully, so does\nLogisim!\n9\n\n\fCombined into\u2026\n\u25cf Then, we can combine many of those together:\n\nRegister File\n32\n\nD\n\nQ\n\n32\n\nRegister\n\n32\n\nD\n\nQ\n\n32\n\nRegister\n\n\u2026\n32\n\nD\n\nQ\n\n32\n\nRegister\n10\n\n\fThe MIPS register file\n\u25cf In the instruction add t0, t1, t2, how many registers are read?\no how many are written?\no how many different registers are accessed?\n\nthere's one input or\nwrite port\nit needs a clock signal.\nwhat other control\nsignals does it need?\n\nRegister\nFile\nWE\n\nhow about a\nwrite enable?\n\nrd\n\nrs\n\nrt\n\nthere are two output\nor read ports\neach port can read a\ndifferent register\n\nand inputs to select\nthe registers?\n\n11\n\n\fReading from one register\n\u25cf You have two registers, and you want to choose one to read\n\nwhat kind of component chooses?\nD\n\nA WE83\n\nQ\n\n29\n83\n\nB\n\nD\n\nreading from a register is\ntechnically combinational\n\nQ\n\n29\n\nWE\n\n0\n1\n\na read port is made of a\nselect signal, a MUX, and a\ndata output\n12\n\n\fWriting\n\u25cf For the write port, we only want to write to one register at a time\n\u25cf We'll have a select signal again\u2026\n\nwhen should we write to A?\nselect = 0\nDo we ALWAYS write to a\nregister?\nWE = 1\nHow about in\nbeq A, 3, top?\n\nD\n\nQ\n\n83\n\nWE\n\nwhen should we write to B? D\nselect = 1\n\nWE = 1\n\nQ\n\n29\n\nWE\n\nA\nB\n13\n\n\fClose the door\n\u25cf when a register's write enable is 0, what happens to the data?\n\u25cf so we can hook up the data input to all registers at once.\n\nData\n\nD\n\nQ\n\n83\n\nWE\n\nA\nonly the register with\nWE=1 will store the data\n\nD\n\nQ\n\n29\n\nWE\n\nB\n14\n\n\fChekhov's Gun\n\u25cf there's a component we haven't seen in a while which only sends an input value to\none of its outputs (demux)\nD\n\nWE\n0\nWE\n\n1\n0\n\nQ\n\n83\n\nWE\n\nD\n\nWE\n0\n\na write port is made of a select signal, a data\ninput, a write enable, and some kinda logic to\nsend the write enable to one register\n\nQ\n\n29\n\nWE\n\nA\nB\n\n15\n\n\fThe Register File\n\u25cf And then, we can abstract our subcircuit to the following:\no This presumes we have 32 registers which are 32-bits in size\no (like MIPS!)\n\nWriteEnable\nWriteData\nRegister1\nRegister2\n\n32\n\n32\n5\n5\n\nRegister File\n\n32\n\nReadData1\nReadData2\n\n5\n\n16\n\n\fDiving in\n\nControl\n\n\u25cf We have a complete register file!\n\u25cf Now\u2026 let\u2019s look more closely at building an ALU.\n\nRegister\nFile\n\nALU\n\n17\n\n\fBuilding Out a Basic ALU\nDoing the stuff.\n\n18\n\n\fStarting small, the one-bit adder\n\u25cf Who remembers how to use an adder to subtract?\n\nCarry in\nA\nB\n\n+\n\nResult\n\nCarry out\n\n19\n\n\fStarting small, the one-bit adder\n\u25cf Here is a simple ALU. It can Add A and B together.\no There are a few control signals leading into it and several outputs.\no Consider how this ALU subcircuit, as it is, can perform \u201cA \u2013 B\u201d\nA\nBinvert\nCarry in\nB\n\n0\n1\n\n+\n\nResult\n\nCarry out\n\nThis is a\nMUX\n20\n\n\fA basic 1-bit ALU \u2013 Addition\nBinvert\n\nCarry in\n\n0\n\n0\n\nPut it in a\nbox\n\nA\n\nResult\nB\n\n0\n1\n\n+\nCarry out\n21\n\n\fA basic 1-bit ALU \u2013 Subtraction\n2s Complement\n1- Invert\n\nBinvert\n\nCarry in\n\n1\n\n1\n\n2-Add one\n\nA\n\nResult\nB\n\n0\n1\n\n+\nCarry out\n22\n\n\fA basic 1-bit ALU \u2013 Expanding the adder\nALU \u2013 Arithmetic and Logic Unit\n\u25cf This ALU can perform the\narithmetic operations add,\nand subtract.\n\u25cf And the logic operations\nAND, OR, and NOT\n\u25cf Operation is selected by\nthe signal Operation:\n\n(2-bits)\n00 \u2013 AND; 01 \u2013 OR;\n10 \u2013 ADD; 11 \u2013 SLT\n\nBinvert\n\nCarry in Operation\n2\n\nA\n0\n\n1\nB\n\n0\n1\n\n+\n\nLess\n\nResult\n\n2\n\n3\nCarry out\n23\n\n\fA basic 1-bit ALU \u2013 Addition\nBinvert\n\nCarry in Operation\n\n0\n\n0\n\n2 10\n\nA\n\nThe other\noutputs are\nbeing\ncalculated.\n\n0\n\n1\nB\n\n0\n1\n\n+\n\nLess\n\n2\n\nResult\n\nBut not\npropagated\n\n3\nCarry out\n24\n\n\fA basic 1-bit ALU \u2013 Subtraction\nBinvert\n\nCarry in Operation\n\n1\n\n1\n\n2 10\n\nA\n0\n\n1\nB\n\n0\n1\n\n+\n\nLess\n\nResult\n\n2\n\n3\nCarry out\n25\n\n\fA basic 1-bit ALU \u2013 AND\nBinvert\n\nCarry in Operation\n\n0\n\nX\n\n2 00\n\nA\n0\n\n1\nB\n\n0\n1\n\n+\n\nLess\n\nResult\n\n2\n\n3\nCarry out\n26\n\n\fA basic 1-bit ALU \u2013 OR\nBinvert\n\nCarry in Operation\n\n0\n\nX\n\n2 01\n\nA\n0\n\n1\nB\n\n0\n1\n\n+\n\nLess\n\nResult\n\n2\n\n3\nCarry out\n27\n\n\fA basic 1-bit ALU \u2013 NAND and NOR?\nRemember Boolean algebra?\n\n\ud835\udc34 + \ud835\udc35 = \ud835\udc34. \ud835\udc35\n\n\ud835\udc34\ud835\udc35 = \ud835\udc34 + \ud835\udc35\n\n\ud835\udc34 \ud835\udc35 \ud835\udc34 + \ud835\udc35 \ud835\udc34 \ud835\udc35 \ud835\udc34. \ud835\udc35\n0 0 1\n1 1 1\n0 1 0\n1 0 0\n1 0 0\n0 1 0\n1 1 0\n0 0 0\n\n\ud835\udc34 \ud835\udc35 \ud835\udc34\ud835\udc35 \ud835\udc34 \ud835\udc35 \ud835\udc34 + \ud835\udc35\n0 0 1 1 1 1\n0 1 1 1 0 1\n1 0 1 0 1 1\n1 1 0 0 0 0\n28\n\n\fA basic 1-bit ALU \u2013 NAND\nWe need to\nadd another\ninverter and\nmutex\n\nAinvert Binvert\n1\n\nA\n\nCarry in Operation\n\n1\n\nX\n\n0\n\n2 01\n\n0\n\n1\n1\nB\n\n0\n1\n\n+\n\nLess\n\nResult\n\n2\n\n3\nCarry out\n29\n\n\fA basic 1-bit ALU \u2013 NOR\nAinvert Binvert\n1\n\nA\n\nCarry in Operation\n\n1\n\nX\n\n0\n\n2 00\n\n0\n\n1\n1\nB\n\n0\n1\n\n+\n\nLess\n\nResult\n\n2\n\n3\nCarry out\n30\n\n\fA basic 1-bit ALU, with overflow detection\n\u25cf This ALU can detect overflow\n\nAinvert\n\n\u25cf Also allows to perform the SLT operation!\n\u25cf Remember the slt instruction?\nblt t0, t1, label\no It\u2019s equivalent to\nslt at, t0, t1\nbnq at, zero, label\n\nA\n\nBinvert\n\n0\n\nOperation\n2\n0\n\n1\n1\nB\n\n\u25cf SLT \u2013 Set if Less Then\n\no \u201cSet\u201d = 1 if a<b\n\nCarry in\n\n0\n1\n\n+\n\nLess\n\n2\n3\n\no \u201cSet\u201d = 0 if a>=b\n\nResult\n\nSet\n\nOverflow\nCarry out\n31\n\n\fA basic 1-bit ALU, with overflow detection\n\u25cf This ALU can detect overflow\n\nAinvert\n\n\u25cf Also allows to perform the SLT operation!\n\u25cf Remember the slt instruction?\nblt t0, t1, label\no It\u2019s equivalent to\nslt at, t0, t1\nbnq at, zero, label\n\nA\n\nBinvert\n\nOperation\n2\n\n0\n\n0\n\n1\n1\nB\n\n\u25cf SLT \u2013 Set if Less Then\n\no \u201cSet\u201d = 1 if a<b\n\nCarry in\n\n0\n1\n\n+\n\nResult\n\n2\n\nLess\n\n3\n\no \u201cSet\u201d = 0 if a>=b\n\nSet\n\n\u25cf What is the propagation delay?\nOverflow\nCarry out\nAssume: Not: 2ns, Mux: 6ns,\nAdder: 10ns, AND/OR/XOR: 4ns\n\n(26ns)\n\n32\n\n\fBuilding it up!\n\u25cf Combine multiple 1-bit ALUs\n\n\u25cf We can combine the Binvert and\nCarry in signals\no They are used simultaneously\nfor subtractions\no Otherwise, we don\u2019t care about\nthe Carry in\n\nAinvert Bnegate\n1\n0\n\nCarry in can be\nconnected to\nBinvert\n\nA0\nB0\n\nCarry in\n\nLess\n\nCarry out\n\nA1\nB1\n\nCarry in\n\n0\n\nALU 0\n\nALU 1\n\nLess\n\nCarry out\n\nA2\nB2\n\nCarry in\n\n0\n\nALU 2\n\nLess\n\nCarry out\n\nA31\nB31\n\nCarry in\n\n0\n\nLess\n\nALU 31\nCarry out\n\n2\n\nOperation\n10\n\nResult0\n\n1\n\nResult1\n\n0\n\nResult2\n\n0\n\nResult31\nSet\n\n0\n\nOverflow\n\n1\n\n33\n\n\fImplementing SLT\n\u25cf SLT uses subtraction\nslt at, t0, t1\nt0<t1: t0-t1<0\no Set is 1\n\u25cf Note how Set is connected to\nALU0\u2019s Less input\n\nAinvert Bnegate\n1\n0\nA0\nB0\n\nCarry in\n\nLess\n\nCarry out\n\nA1\nB1\n\nCarry in\n\n0\n\n\u25cf Could we use Result31 instead?\no No, note how the output is 0,\nnot 1\n\n2\n\nALU 0\n\nALU 1\n\nLess\n\nCarry out\n\nA2\nB2\n\nCarry in\n\n0\n\nALU 2\n\nLess\n\nCarry out\n\nA31\nB31\n\nCarry in\n\n0\n\nLess\n\nALU 31\nCarry out\n\nOperation\n11\n\nResult0\n\n1\n\nResult1\n\n0\n\nResult2\n\n0\n\nResult31\nSet\n\n0\n\nOverflow\n\n1\n\n34\n\n\fA 32-bit ALU\nAinvert Bnegate\n\n4 ALU operation\nA\n\n32\n\n32\nALU\n\nB\n\n32\n\n2\n\nA0\nB0\n\nCarry in\n\nLess\n\nCarry out\n\nOperation\n\nResult0\n\nALU 0\n\nZero detection is so\ncommon that is usually\nsupported by ALUs\nE.g. beq, bne\n\nA1\nB1\n\nCarry in\n\nResult\nZero\n\n0\n\nLess\n\nCarry out\n\nOverflow\n\nA2\nB2\n\nCarry in\n\n0\n\nLess\n\nA31\nB31\n0\n\nLess\n\nResult1\n\nALU 1\n\nZero\n\nResult2\n\nALU 2\nCarry out\n\nCarry in\n\nALU 31\nCarry out\n\nResult31\nSet\n\nOverflow\n\nAs we saw when we\ntalked about overflow.\nIt can be detected in\nthe MSB\n35\n\n\fA basic 32-bit ALU?\n\u25cf ALUs are many times in the\nreal world built as multiple\n1-bit ALUs.\no Called bit-slicing\n\u25cf However, we can happily\nlive in our ideal world for a\nbit longer!\n\u25cf We can build it much like\nthe 1-bit model, but just tell\nLogisim to make the\ncomponents\u2019 \u201cData Size\u201d\n32-bits.\no i.e., for your project.\n\u25cf Whew!\n\nAinvert Bnegate\n1\nA\n\nOperation\n\n1\n\n2 00\n\n0\n\n0\n\n1\n1\nB\n\n+\n\n0\n1\n\nResult\n\n2\n\n<\n\n3\n\nCarry out\nOverflow\n\n36\n\n\fZooming Out Again\n\u25cf Now, how to we wire up the Register File with the ALU??\no How do we know which registers to use?\no How do we pull in instructions?\n\u25cf Tune in next time for\u2026\no Control and Datapath\n4 ALU operation\nA\n\nWriteEnable\nWriteData\nRegister1\nRegister2\nWriteRegister\n\n32\n\n32\n\n5\n5\n\nRegister File\n\n32\n\n32\n\n32\nALU\n\nReadData1\n\nB\n\n32\n\nResult\nZero\nOverflow\n\nReadData2\n\n5\n37\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}