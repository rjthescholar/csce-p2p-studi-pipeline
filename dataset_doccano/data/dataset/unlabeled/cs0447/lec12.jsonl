{"id": 189, "segment": "unlabeled", "course": "cs0447", "lec": "lec12", "text": "#12\n\nControlling\nthe PC\nOriginal slides by: Jarrett Billingsley\nModified with bits from: Bruce\nChilders, David Wilkinson\n\nCS 0447\nIntroduction to\nComputer Programming\n\nLu\u00eds Oliveira\n\nFall 2020\n\n\fClass announcements\n\u25cf If you had a negative grade in the project\no You should talk to me\n\n2\n\n\fAssemblers and Compilers\nHow the machine-code sausage is made\n\n3\n\n\fWhat is machine code?\n\n4\n\n\fSomething denser\n\u25cf text is human-oriented and informationally\u2026 sparse.\n\u25cf instead, we encode each instruction as a bitfield.\no this encoding is specified by the ISA.\nMIPS has three\ninstruction formats.\n\nR opcode\n31\n\n26 25\n\nI opcode\n31\n\nrs\n\n26 25\n\nJ opcode\n31\n\n21 20\n\n16 15\n\nrt\n21 20\n\nrs\n\nthe opcode (and funct) field\nidentifies which instruction it is.\n11 10\n\nrd\n\n6 5\n\nshamt funct\n\n16 15\n\nrt\n\n0\n\nadd rd,rs,rt\nsll rd,rs,shamt\n\n0\n\nbeq rs,rt,offset\n\nimmediate\n\n26 25\n\n0\n\ntarget\n\njal target\n5\n\n\fHow does it\u2026 do the thing?\n\u25cf well this is mostly next lecture, but\u2026\nthe fields are used\nas the control\nsignals to the CPU's\ncomponents.\n\nRegister File\nWE\n\nadd t0, t1, t2\n\nALU\n\nrd\n\nrs\n\nrt\n\n1\n\n\"add\"\n\ngets encoded as\u2026\n31\n\n26 25\n\n21 20\n\n16 15\n\n11 10\n\n6 5\n\n0\n\n000000 01001 01010 01000 00000 100000\n6\n\n\fHow It's Made\n\n7\n\n\fSo we know the assembler\nli\n\ntop:\n\ns0, 0\n\nAddress\n\nInstruction\n\n0x00400000\n\n0x24100000\n\n0x00400004\n\n0x00102021\n\nmove a0, s0\nassembler!\n0x00400008\njal print_int\n0x0040000C\naddi s0, s0, 1\n0x00400010\nblt s0, 5, top\n0x00400014\nli\nv0, 10\nbut, there's clearly\n0x00400018\nsyscall\na little more\n0x0040001C\nprint_int:\ngoing on under\n0x00400020\nli v0, 1\nthe hood\u2026\nsyscall\n0x00400024\njr ra\n0x00400028\n\n0x0C100008\n0x22100001\n0x2A010005\n0x1420FFFB\n0x2402000A\n0x0000000C\n0x24020001\n0x0000000C\n0x03E00008\n8\n\n\fHow it works\n\u25cf An assembler is a pretty simple program\n\u25cf See an instruction, output its encoding\n\naddi s0, s0, 1\n\nsplut\n\nopcode\n\nrs\n\nrt\n\nimm\n\n8\n\n16\n\n16\n\n1\n\n0x22100001\nBut what about\nlabels and the\ndata segment\n\n9\n\n\fHow it actually works (animated)\n.data\nLabels\n.text\nx: .word 0xDEADBEEF\n0: 24100000\nx:\n.data:0\ny: .word 5\n4: 00102021\ny:\n.data:4\nz: .word 0x12345678\nz:\n.data:8\n8: 0c000008\n0c000000\n.text\ntop: .text:4\nC: 22100001\nprint_int:\nli\ns0, 0\n10: 2A010005\n.text:20\n14: 1420FFFB\ntop:\n18: 2402000A\nmove a0, s0\n1C: 0000000C\njal print_int\n20: 24020001\naddi s0, s0, 1\nFixups\n24: 0000000C\nblt s0, 5, top\n28: 03E00008\n8:\nprint_int\nli\nv0, 10\nsyscall\nprint_int:\nli v0, 1\nsyscall\nthen, run through the fixups!\njr ra\n\n.data\n0: DEADBEEF\n4: 00000005\n8: 12345678\n\n10\n\n\fYum yum\n\u25cf if a label doesn't exist, it's an error.\n\u25cf now we have machine code!\n\u25cf it's packaged up into a casing: an object file\n\u25cf then the object files are linked\n\u25cf and then you get an executable program\no this is CS0449 stuff!\n\n11\n\n\fWhat about compilers?\n\u25cf ahahaha oh they're a lot more complicated\nint main(int argc, char** argv) {\nif(argc < 2)\nfatal(\"gimme arguments\");\nelse {\nTokens\n...\nKEYWORD(\"int\"),\n}\nID(\"main\"),\n}\nLPAREN,\n\nAST (Abstract Syntax Tree)\nFunction\nret_type: int\nname: \"main\"\nargs: [\n{type: int, name: \"argc\"},\n{type: ptr(ptr(char)),\nname: \"argv\"}\n]\n\nif\n\nKEYWORD(\"int\"),...\n<\nargc\n\n\u2026\n2\nfatal\n\ncall\n\"gimme arguments\"\n\n12\n\n\fIt's just a grinder.\n\u25cf all that really matters:\nsome compilers output\nassembly and rely on an\nassembler to produce\nmachine code\n\n/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\\n/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\\n/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\\n/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\\n/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\\n/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\\n/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\\n/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\\n/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\\n/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\\n/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\\n\nhello.c\n\ncode goes in, sausage object\nfiles come out\n\nthese days, it's common\nfor the compiler itself to\nproduce machine code,\nor some kind of\nplatform-independent\nassembly code\n\n13\n\n\fJumps and Branches\n\n14\n\n\fMaybe you never noticed\u2026\n\u25cf the control flow instructions are divided into two groups.\n\njumps make execution go\nto one specific place\n\nbranches make execution\ngo to one of two places\n\nj end\n\nbne s1, t0, top\n\nbut.. why?\nwell, notice the operands of each.\n\n15\n\n\fA matter of practicality\n\u25cf Each jump or branch has a target: where it goes to\n\u25cf We'd like to be able to encode any target address\u2026\n\u25cf But we have a fixed number of bits to encode our instructions.\nthink about the cases\nwhere jumps are used.\n\nnow think about the cases\nwhere branches are used.\n\nhow far away is a jump\ntarget likely to be?\n\nhow far away is a branch\ntarget likely to be?\n16\n\n\fAbsolute versus Relative\n\u25cf we say that jumps are absolute and branches are relative.\n\ntop:\nmove a0, s0\njal print_int\nadd s0, s0, 1\nblt s0, 5, top\n...\n\njumps just set the\nPC to a new value.\n\nPC = 0x800400B0\n\nPC += (-16)\nbranches either add an offset\nto the PC or do nothing.\n\njumps need a long address, but branches only need a\nsmall offset. so we can fit them into J and I instructions!\n\n17\n\n\fMore bang for your buck\n\u25cf every MIPS instruction is 4 bytes\n\u25cf what's memory alignment again?\nAddress in hex\n\nand in binary\n\n0x78000000\n0x78000004\n\n0111 1000 0000 0000 0000 0000 0000 0000\n0111 1000 0000 0000 0000 0000 0000 0100\n\n0x78000008\n0x7800000C\n\n0111 1000 0000 0000 0000 0000 0000 1000\n0111 1000 0000 0000 0000 0000 0000 1100\nwhat do you notice about these low 2 bits?\nin binary, multiples of 4 always end in 00\n\nsince every instruction's address ends in 00, do we need to store it?\n18\n\n\fInstruction Fetching\nWhat do we do next, boss?\n\n19\n\n\fRemember this?\n\u25cf what order do these instructions run?\n\nmost instructions\nchange the PC to the\nprint_int:\nnext address\nli v0, 1\n\nli\ns0, 0\ntop:\nsyscall\nmove a0, s0\ncontrol flow\njr ra\njal print_int\ninstructions can\naddi s0, s0, 1\nchange the PC\nblt s0, 5, top\nto a constant\u2026\nli\nv0, 10\n\u2026or the value from a register\u2026\nsyscall\n\u2026or one of two choices,\nconditionally\n\n20\n\n\fForwarrrrrrrrd MARCH\n\n+\n\n\u25cf moving ahead by 1 instruction each cycle is easy enough\no This is a FSD, the next state is the current state + 1 :D\n\nsize of one instruction\n\n00100004\nPC\n\nhow big are instructions in MIPS?\n\n21\n\n\fArbitrary locatiooooon MARCH\n\n4\n\n+\n\n\u25cf jumps (j, jal, jr) put a constant value into the PC\no we call this the jump target.\n\u25cf well now we have two choices of where to go. how do we choose?\n\njump target\nPC Source\n\n00100004\nPC\n\nPC Source (PCSrc for short) is a control signal.\nmany control signals are just MUX selectors\n22\n\n\fMIPS jump targets\n\u25cf in MIPS, j and jal use the J-type instruction format:\n\n31\n\n26 25\n\n0\n\nopcode\n\ntarget\n00100004\n\nthis is 26 bits\u2026\n\u2026but the PC is 32 bits.\n\nWHAT DO??\n\n23\n\n\fDo we really need a full 32-bit address (no)\n\u25cf we don't need to store the lower 2 bits because of alignment.\n\u25cf most programs are nowhere near big enough to need 32-bit addrs.\n\u25cf so in MIPS, jumps only change the lower 28 bits of the PC.\nhere's a j.\n\n31\n\n0\n\n26 25\n\n000010\n\n0x243C007\n<< 2\n\n0x90F001C\n\nwhat does this mean if the thing\nyou're jumping to is too far away?\n\n78000008\n790F001C\nPC\nput that into the\nlow 28 bits of the PC\n24\n\n\fDo we really need a full 32-bit address (no) (cntd.)\n\u25cf If a jump instruction is in address\n\nYXXXXXXX\n\u25cf It can reach from address:\n\n31\n\n26 25\n\n000010\n\u25cf To address:\n\n31\n\nY0000000\n0x0000000\n<< 2\n0x0000000\n\n26 25\n\n000010\n\n0\n\n0\n\nYFFFFFFC\n0x3FFFFFF\n<< 2\n0xFFFFFFC\n\n25\n\n\fIf jumping REALLY far, far away\u2026\n\u25cf What if we want to jump too far?\nbeq t0, zero, a_label_far_far_away\n\nj\n\na_label_far_far_away\n\n\u25cf There is one instruction that can jump into a 32-bit address\no What is that?\n\u25aa How big is register ra?\njr\n\nra\n\n26\n\n\fIf jumping REALLY far, far away\u2026\nj\n\na_label_far_far_away\n\nla\njr\nbeq\n\nt0, a_label_far_far_away\nt0\n\nt0, zero, a_label_far_far_away\n\nbne t0, zero, _skip_jump\nla\nt0, a_label_far_far_away\njr\nt0\n_skip_jump:\n\n27\n\n\fIf jumping REALLY far, far away\u2026\njal\n\na_label_far_far_away\n\nla\njalr\n\nt0, a_label_far_far_away\nt0\n\n28\n\n\fRelative branches\n\u25cf think about a number line.\n\n0\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\nyou\nare\nhere\n\n8\n\nif you want to get here, what\ndo you have to add to 10?\nwhat's the pattern?\n\n9 10 11 12 13 14 15 16 17\n\nhow about here?\n\ndestination - source\n\n29\n\n\fMIPS branch offsets\n\u25cf In MIPS the PC points to the next instruction to run.\n\u25cf let's say we're running the beq here. it's at address 00\u2026\n\n00: beq a0, 10, else\n\u2026but the PC is here. PC 04: li v0, 0\n08: b\nend\nwe want to get to address 0C. else: 0C: li v0, 1\nend: 10: ...\nhow do we get there?\n\nPC += 8\nthe branch offset for this beq is:\ntarget \u2013 (branch address + 4) = 12 \u2013 (0 + 4) = 8\n30\n\n\fEncoding it\n\u25cf Since the branch's immediate is only 16 bits\u2026\n\n31\n\n26 25\n\n4\n\n21 20\n\n4\n\n16 15\n\n1\n\n0\n\n0x0002\n\n0x0008 >> 2\nif the branch offset is negative like 0xFFFFFFE8, no big deal \u2013\nchop off the top 16 bits. 0xFFE8 is still a negative number.\n\n31\n\n\fThe number stored is the number of instructions\n\u25cf To go to else, from the updated value of PC: Jump 2 instructions down\n00: beq a0, 10, else\nPC\n04: li v0, 0\n08: b\nend\nelse: 0C: li v0, 1\nend: 10: ...\n\nthe branch offset for this beq\nis:\ntarget \u2013 (branch address + 4)\n=\n12 \u2013 (0 + 4) = 8\n\n31\n\n26 25\n\n4\n\n21 20\n\n4\n\n16 15\n\n1\n\n0\n\n0x0002\n\n0x0008 >> 2\n\n32\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}