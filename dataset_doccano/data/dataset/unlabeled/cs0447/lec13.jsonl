{"id": 154, "segment": "unlabeled", "course": "cs0447", "lec": "lec13", "text": "#13\n\nThe Interconnect,\nControl, and\nInstruction\nDecoding\nOriginal slides by: Jarrett Billingsley\nModified with bits from: Bruce\nChilders, David Wilkinson\n\nCS 0447\nIntroduction to\nComputer Programming\n\nLu\u00eds Oliveira\n\nFall 2020\n\n\fInstruction Execution\n\n2\n\n\fPhases of instruction execution\n\nF\n\nD X M W\n\n1. Fetch (IF or F)\no use PC to get the next instruction from memory\n2. Decode (ID or D)\no look at the fetched instruction and set control signals\n3. Execute (EX or X)\no wait for data to flow through the datapath\n4. Memory Access (MEM or M)\no if it's a load or store, do that\n5. Write-back (WB or W)\no if there's a destination register, write the result to it\noften we can do multiple phases \"at the same time\"\n3\n\n\fWhich parts do what\n\nMemory\n\nControl\n\nPC\n\nRegister\nFile\n\nF\n\nD\n\nW\n\nALU\n\nX\n\nMemory\nagain\n\nM\n\nHow does lw work?\nlw t0, 12(s0)\n\n4\n\n\fA Thing about memory\n\n5\n\n\f\u2622\ufe0f Structural Hazards \u2622\ufe0f\n\u25cf how many RAMs does your computer have? one or two?\n\u25cf if we try to do lw t0, (s0) with one memory in a single cycle\u2026\n\nPC\n\nInstruction\nAddress\n\nLoad word\naddress\u2026?\n\nInstruction\nControl\n\nMemory\nLoaded\nword\u2026??\nwhat about sw?!?\n\nwe can't really do this\u2026 memory hardware can't read\nfrom two addresses at the same time\n6\n\n\fVon Neumann vs Harvard\n\u25cf one way to solve this problem is to have two memories\nthis is a Harvard\nArchitecture\n\nInstruction\nMemory\n\nControl\n\nPC\n\nRegister\nFile\n\nALU\n\nData\nMemory\n\na Von Neumann Architecture has one memory for both things\n\"Von Neumann\" is 2 words for 1 memory\u2026\n\"Harvard\" is 1 word for 2 memories\u2026\n7\n\n\fMulti-cycle\n\u25cf a Von Neumann machine has one memory, but uses multiple\nclock cycles to execute each instruction\nCycle 1: Instruction\nAddress\n\nPC\n\nlw t0, (s0)\nInstruction\nControl\n\nMemory\nLoaded\nword\n\nCycle 2:\nLoad word\naddress\nmulti-cycle machines are by\nfar the most common today\n\nbut they're more complex\u2026\n8\n\n\fThe Interconnect\n\n9\n\n\fGotta keep em separated interconnected\n\u25cf we've got pieces of a CPU, but they don't operate in isolation\n\u25cf we gotta hook em together. but which parts hook to which?\n\u25cf the instructions in the ISA tell you what has to connect to what.\nPC that\ncan branch\nand jump\n\nALU\n\nInstruction\nMemory\n\nRegister\nFile\n\nData\nMemory\n\n10\n\n\fSlowly coming together\n\u25cf if we look at all the different instructions we want to support, we'll\nstart to get an idea of what data goes where\n\nsub v0, t0, t1\nt0\n\ns0\n\nt1\n\nRegister\nFile\nt3\n\nv0 Register\n\nFile\n\nsw s0, 4(t3)\n\n-\n\nALU\n\nData\nData\nMemory\n\n+\n\n4\n\njal move_ball\naddress of\nmove_ball\n\nPC\n\n+ ra\n\n4\n\nALU?\n\nRegister\nFile\n\nALU\n\nAddress\n\nhow do we make all\nthese different things\nhappen with one set\nof hardware\u2026?\n11\n\n\fPC to the left of me, ALU to the right, here I am\n\u25cf the interconnect lets the CPU parts combine in many ways\n\u25cf it's like the CPU's \"circulatory system\" \u2013 it moves data around\nPC\n\nInstruction\nMemory\n\njal\njr\n\nstores\n\nRegister\nFile\n\nli (immediate)\n\nloads\n\nData\nMemory\n\nadd, sub, etc.\n\naddi, ori etc.\n\nALU\n\nit's starting to take shape\u2026\n\n12\n\n\fA little technique: an interconnect matrix\n\u25cf you can make a table to keep track of what things connect to what.\nDoes the data\nflow from\nhere\u2026\nALU\n\n\u2026to here?\nPC\n\nALU\nPC\n\nRegs\nIM\nDM\n\n\u221a\n\n\u221a\n\u221a\n\nRegs\n\n\u221a\n\u221a\n\u221a\n\u221a\n\nIM\n\nDM\n\n\u221a\n\nnow consider all the\ninstructions your CPU\nshould support, and mark\nthe cells accordingly.\n\nlw sw j beq\nadd, sub, and, or\njr li? jal\nany component (column) with\nmultiple things coming\ninto it will need a MUX.\n(huh? next slide.)\n\n13\n\n\fConjunction junction\n\u25cf the interconnect makes choices about which things go where\nonly one of these is written\nto the register file\n\nALU results\n\nso how do we choooooose\nwhich thing to write?\n\ndata from memory\n\nnow we have a select pin.\nthis is a control signal!\n\nRegister\nFile\n\ninstruction immediates\n\nsaved PC for jal\n\nthere will be several MUXes in the\ninterconnect, and each needs a control signal\n\n2\n\nRegDataSrc\n\nthe book calls this \"MemToReg\u201c.\nBecause in its model the value is 1 when\nthe memory is read into a register\n\n14\n\n\fInterconnected (MIPS, not your project)\n\u25cf if we want to make a suuuuper simple version of MIPS, we can\nconnect the pieces together into a datapath like this\nData\n(this version doesn't\nRegWrite\nMemWrite\nData\nsupport jal, and \u2026\nMemory\nbut that's fiiiine)\nrd\nrs\nrt\n\nAddress\n\nRegister\nFile\n\nALU\n\nRegDataSrc\nimm field\n\nALUSrc\n\nALUOp\n\nhow can we use this\nto implement add?\nsub? addi? lw? sw?\nli?\nbut now we need\nto, uh, control the\ncontrol signals.\n15\n\n\fThe Forgotten Phase:\nOperand Fetch\n\n16\n\n\fA little extra step\n\u25cf operand fetch is a phase of instruction execution you might see\n\u25cf it fetches the values to be operated on\n\nF\n\nD X M W\n\nit happens after the\ninstruction is decoded.\nwhere do values have to be for\nthe CPU to operate on them?\n\nin the registers\u2026?\n\n17\n\n\fVestigial\n\u25cf in MIPS (and your project), operand fetch is super simple:\nthis is by design: load-store\narchitectures have very simple\noperand fetch phases.\n\nRegister\nFile\n\nALU\n\nimm field\n\nwhy? well\u2026\n\nhere it is!\n\n18\n\n\fOperand Fetch in x86\n\u25cf as a CISC, x86 has some\u2026 crazy instructions.\n\ninc [eax + ecx*4 + 12]\nthis is an effective\naddress calculation.\n(the brackets mean \"access memory.\")\n\nthis is operand fetch.\nbe very glad you won't have\nto do this for your project.\n\nhere's what the CPU has to\ndo for this instruction:\n1. multiply ecx by 4\n2. add eax to that\n3. add 12 to that\n4. load a word from\nthat address\n5. add 1 to that value\n6. store that value back\ninto the address\n19\n\n\fThe Control\n\n20\n\n\fFeeling nervous\n\u25cf the control is what sets the write enables and selects to the\nappropriate values to make each instruction happen\n\u25cf it's like the CPU's brain and nervous system\n\nit does this by reading\nthe instructions.\n\nc'mon you\nlazy bums\nawwwww we\ndon't wannaaaa\n\nsub v0, t0, t1 \ud83d\udc40Control\nRegister file, read t0 and t1, and write to\nv0. ALU, do subtraction. Interconnect,\nroute the data from the two registers into\nthe ALU and from the ALU into the register\nfile. Data memory, you get to take a break.\n\nALU\n\nRegister\nFile\n\nData\nMemory\n\nyissssss\n\n21\n\n\fTwo kinds of control signals\n\u25cf first there are the selects\no these go into the select pins of\nmuxes, demuxes, or decoders\no they can be any number of bits\n\u25cf then there are the write enables\no these tell registers and memory\nwhen to store data\no they're Booleans - 0 or 1\n\u25cf they often come in pairs!\no like RegWrite and RegDataSrc.\no they decide what to write and\nwhen to write it.\n\nRegWrite\nrd\n\n5\n\nRegister\nFile\n\nRegDataSrc\nMemWrite\n\nData\nMemory\n\n22\n\n\fGotta write it down\n\u25cf write enables are kind of the basis of \"things happening in a CPU\"\n\u25cf almost every instruction writes something somewhere!\n\nadd t0, t1, t2\nwrites to t0\n\nbeq s0, 10, end\n\nmight write to the PC\n\nsw s0, (t0)\nwrites to memory\n\njal func1\nwrites to the PC and ra!\n\nif an instruction doesn't write anything, it's a no-op (nop).\n(if an instruction does not change anything, did it ever happen?)\n\nwhat changes when a conditional branch isn't taken?\n\n23\n\n\fThe control hardware\n\n4\n\n+\n\n\u25cf we connected the datapath together; now for the control bits\n\nimmediate\n(jump target) PCSrc\n\nPC\n\nrt\n\nrd\n\nimmediate\n\naddress goes in\u2026 Instruction\n\u2026instruction\nMemory\ncomes out.\n\nPCSrc\n\nrs\n\nControl\n\nRegWrite\nMemWrite\n\ninstruction\ngoes in\u2026\n\u2026control signals\ncome out.\nsomehow.\n\nALUSrc\nALUOp\n\nRegDataSrc\n\n24\n\n\fInstruction Decoding\n\n25\n\n\fPull 'n' peel\n\u25cf the first step is to split the encoded instruction up\n\u25cf but which instruction format is it? actually, it doesn't matter.\n\nR opcode\n31\n\n31\n\n26 25\n\nrs\n\n26 25\n\nI opcode\n31\n\n21 20\n\n16 15\n\nrt\n21 20\n\nrs\n\n0\n\n31-26\n\nshamt funct\n\n25-21\n\n0\n\n20-16\n\n11 10\n\nrd\n\n6 5\n\n16 15\n\nrt\n\nimmediate\n\n26 25\n\nJ opcode\n\n15-11\n0\n\ntarget\n\n\"do everything at once, but\n32\nuse only what you need.\" instruction\n\n10-6\n5-0\n15-0\n25-0\n\nopcode\nrs\nrt\nrd\nshamt\nfunct\nimmediate\ntarget\n26\n\n\fNo, really, it's fine, don't worry about it\n\u25cf suppose the encoded instruction was addi s0, s0, -1.\nop\n\nput it through\nthe splitter and\u2026\naddi s0,s0,-1 32\n\n0x2210FFFF\n\n\u2026out come a\nbunch of values.\n\n31\n\n26 25\n\n21 20\n\n16 15\n\n0\n\nrt\nimmediate\n0x08 opcode rs\nrs\naddi is an I-type instruction.\n0x10\nrt\n0x10\nopcode, rs, rt, and immediate\nrd\nwill be used.\n0x1F\nshamt\nthe rest are bogus and will be\n0x1F\nfunct\nignored. see? it's fiiiiiine\n0x3F\nimm\n0xFFFF\ntarget\n0x210FFFF\n\n27\n\n\fMaking the control work\n\u25cf the control is a boolean function that takes the instruction\nopcode as its input and outputs the control signals.\n\u25cf in other words, it's a big fat truth table.\nopcode\n\nPCSrc\n\nRegDataSrc\n\nRegWrite\n\nALUOp\n\n\u2026\n\n000000\n000001\n000010\n000011\n000100\n000101\n\u2026\n\n0\n0\n0\n1\n1\n0\n\u2026\n\n00\n01\n00\n00\n11\n10\n\u2026\n\n0\n1\n1\n0\n1\n1\n\u2026\n\n000\n110\n010\n011\n000\n010\n\u2026\n\n\u2026\n\u2026\n\u2026\n\u2026\n\u2026\n\u2026\n\u2026\n\nThis is not the only way of\nmaking your control unit.\nit's time-consuming,\nconfusing, hard to debug,\nand hard to change.\nyou will go insane.\n\nThese are made up numbers. Please don't try to use them!\n\n28\n\n\fA more approachable approach\n\u25cf Here's a great use for a decoder: decoding. (huh.)\nopcode\n\n<r-type>\nexactly one of these will\nbe on at a time.\n<uhh random crap>\nj\njal\nnow it's just a matter of coming up with\nthe logic for each of the control signals.\nbeq\nbne\nblez\nfor that, it's good to focus on one\ncontrol signal at a time.\nbgtz\naddi\naddiu\nslti\nsltiu\n\n29\n\n\f<the sound a seal makes>\n\u25cf let's say we want to come up with the MemWrite control signal\n\u25cf which MIPS instructions write to memory?\nsw\nsh\n\nMemWrite\n\npretty straightforward, huh?\n\nsb\nwhat about multi-bit control signals,\nlike your ALU operation?\nthere are a few approaches\u2026\n\n30\n\n\fThe brute-force approach: the MUXtipede\n\u25cf in this approach, you use enormous MUXes to select constants.\nopcode\nALUOp for opcode 0\nALUOp for opcode 1\nALUOp for opcode 2\nALUOp for opcode 3\nALUOp for opcode 4\nALUOp for opcode 5\nALUOp for opcode 6\nALUOp for opcode 7\nALUOp for opcode 8\nALUOp for opcode 9\nALUOp for opcode A\nALUOp for opcode B\n\nit\u2026 works, but it's hard to follow.\nit's hard to tell which constant\nis used for which instruction.\nit's also hard to add new\ninstructions.\nALUOp\nwe can make this a tiny\nbit MUCH MORE\nelegant!\n31\n\n\fPriority Encoders\n\u25cf a priority encoder is kind of the opposite of a decoder.\n\u25cf you give it several 1-bit inputs, and it tells you which one is 1.\n1\n\n0\n\n0\n\n1\n\n0\n\nPri\n\n0\n\n0\n\n0\n\n0\n\n0\n\n0\n\n0\n\n0\n\n1\n0\n\nPri\n\n2\n\n0\n1\n\nPri\n\nif none of the inputs is 1,\nthen it gives you X\u2026\n1\n\n0\n0\n\n0\n\nPri\n\nX\n\n0\n\nPri\n\n3\n\nto avoid this, put a constant\n1 as the first input.\n32\n\n\fMulti-bit control signals\n\u25cf let's say we have these instructions, and these ALU operations.\n\u25cf for each input, ask: which instructions need this ALU operation?\n\nadd\naddi\nsub\nsubi\nand\nor\n\n0: &\n1: |\n2: +\n3: -\n\nALUOp 0 is the default,\nso and is handled.\n\n1\n\nwhich instruction(s)\nneed OR (1)?\n\nor\n\nwhat about + (2)?\nwhat about - (3)?\n\nadd\naddi\nsub\nsubi\n\nPri\n\nALUOp\n\nthink of it like an\nupside-down if-else-if\u2026\n\n33\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}