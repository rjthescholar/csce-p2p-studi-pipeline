{"id": 170, "segment": "unlabeled", "course": "cs0447", "lec": "lec16", "text": "#16\nCS 0447\nIntroduction to\nComputer Programming\n\nPipelining\n\nLu\u00eds Oliveira\n\nFall 2020\n\n\fAnnouncements\n\u25cf OMETS!!!!!!!!11!!!!!!!!!1!!!1eleven!!!!\n\n2\n\n\fHow can we make the CPU\nmore efficient? \u2026\n\nP\n\n3\n\n\fDoing the laundry\nLuis (me), Artur, Stephen, and Ray have one load of clothes to\no Wash\nWasher takes 60 minutes\n\no Dry\no Fold\n\nDryer takes 60 minutes\n\nFolding takes 60 minutes\n\nWhere we live, we can only do laundry Saturday from 9:00 to 18:00!\n4\n\n\fSequential laundry\n\u25cf We have four loads of laundry to do (Luis, Artur, Stephen, and Ray)\n\nFirst, I wash\n\n9:00\n\n10:00 11:00 12:00 13:00 14:00 15:00 16:00 17:00\n\nThen, I dry\n\nFinally, I fold\n\nIt took me 3:00, we\nstill have three\nloads remaining!\nYikes!\n\nIt\u2019s 15:00, we still\nhave two loads to go\n\nIt\u2019s 18:00, and Ray\ncannot do his laundry!\n5\n\n\fHow can we solve this?\n\u25cf Buy more machines!!!\n\n\u25cf Or\u2026\n6\n\n\fPipelined laundry\n\u25cf We have four loads of laundry to do (Luis, Artur, Stephen, and Ray)\n9:00\n\n10:00 11:00 12:00 13:00 14:00 15:00 16:00 17:00\n\nBut did the time it\ntakes to wash the\nclothes change?\n\nThe washer is now\nfree!!\n\nWe can start the\nnext load!\n\nEveryone can do\ntheir laundry\n\nRinse and\nrepeat\n7\n\n\fUpgrading the multi-cycle CPU\nLet\u2019s apply the same concept to a multi-cycle CPU!\nKeep the same clock\n\u25cf Reuse resources with \u2026\n\nTime\n\n0\n\n1\n\nadd t2,t2,t3\n\nMem\n\nReg\n\nlw t0,0(t1)\n\n2\n\n3\n\n4\n\n5\n\nMem\n\nReg\n\n6\n\n7\n\nReg\n\nMem\n\nReg\n\n8\n\n\fLighting up the silicon (animated)\nExecuting instructions in a pipeline\nF\nD\n\nX\n\nM\n\nMemory\n\nControl\n\nsub\nadd\nsw\nRegister\nFile\n\nMemory\nagain\n\nW\nUses\nmemory\n\nUses decoder/registers\n\nUses ALU\n\nUses\nmemory\n9\n\n\fPipeline vs Multi-cycle\nPipelining doesn\u2019t help latency of a single instruction!\nIt helps throughput of the entire workload!\nDifferent tasks operating different resources\ncan execute simultaneously\nMore stages, more potential speedup (too many stages is not good!)\nTime\n\n0\n\n1\n\nadd t2,t2,t3\n\nMem\n\nReg\n\nlw t0,0(t1)\n\nMem\n\n2\n\n3\n\n4\n\n5\n\nMem\n\nReg\n\n6\n\n7\n\nReg\n\nReg\n\n10\n\n\fSo how did we improve performance?\n\u25cf Did we make any individual instruction faster?\no No, the add still took 4 cycles\u2026 the lw took 5 cycles\n\u25cf But the whole thing finished faster. right?\nYes, by overlapping the instructions,\nwe increased the throughput.\nIn any given clock cycle, we're\nnow doing more work.\nWith this we can get the CPI\ndown closer to 1.\n11\n\n\fThe average CPI\n\u25cf It\u2019s the average number of Cycles Per Instruction\no For any program, we count the # of cycles\n\u25aa and divide by the # of instructions\nTime\n\n0\n\n1\n\nadd t0,t1,t2\n\nMem\n\nReg\n\nadd t3,t4,t5\n\nMem\n\n2\n\n3\n\nReg\n\n5\n\n6\n\n7\n\nCPI = 7 \u00f7 4\n= 1.75\n\nReg\n\nReg\n\nMem\n\nReg\n\nWhat\nhappens when we have an\nadd s3,s4,s5\ninfinite number of instructions?\n\nMem\n\nadd s0,s1,s2\n\n4\n\nReg\n\nReg\n\nReg\n\n12\n\n\fPipeline (real-world) issues\n\n13\n\n\fInstructions are co-dependent \uf04c\n\u25cf Sometimes, the next instruction cannot execute in the next cycle\no We call those pipeline hazards.\n\u25cf Hazards happen when for any reason an instruction is unable to advance\n(execute) in the pipeline\n\u25cf We\u2019ll look at three types of hazards\no Structural hazards\no Data hazards\no Control hazards\n\n14\n\n\fStructural hazards\nAttempting to use the same resource two different ways simultaneously. E.g.:\n\u25cf You get home soaking wet and need to dry your clothes while someone is\nusing the dryer\nIn a CPU with a single memory:\n\u25cf Can we fetch a new instruction while reading a word from memory?\no NOPe: structural hazard\n\n15\n\n\fStructural hazards\n\u25cf Two instructions using the same hardware at the same time\nTime\n\n0\n\n1\n\nlw t0,0($0)\n\nMem\n\nReg\n\nlw t1,4($0)\n\nlw t2,8($0)\n\nlw t3,12($0)\n\nMem\n\n2\n\n3\n\n4\n\nMem\n\nReg\n\nMem\n\nReg\n\nMem\n\nReg\n\n6\n\n7\n\nReg\n\nMem\n\nReg\n\nMem\n\n5\n\nReg\n\nMem\n\nReg\n\n16\n\n\fStructural hazards \u2013 What can I do???\n\u25cf Structural hazards arise from lack of resources\n\u25cf So\u2026 We can eliminate the hazard by adding more resources!\no Add a second memory?\n\u25aa The Harvard architecture!\n\u25cf Another solution:\no Stall the instruction until the resource is available\nTime\n\nlw t3,12($0)\n\n0\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\nNOP\n\nNOP\n\nNOP\n\nNOP\n\nNOP\n\nMem\n\nReg\n\nMem\n\nReg\n17\n\n\fStructural hazards \u2013 What can I do???\n\u25cf You may need more than one stall!\nTime\n\n0\n\n1\n\nlw t0,0($0)\n\nMem\n\nReg\n\nlw t1,4($0)\n\nlw t2,8($0)\n\nlw t3,12($0)\n\nMem\n\n2\n\n3\n\n4\n\nMem\n\nReg\n\nMem\n\nReg\n\nMem\n\nReg\n\n5\n\n6\n\n7\n\nReg\n\nMem\n\nReg\n\nNOP\n\nNOP\n\nNOP\n\nNOP\n\nNOP\n\nNOP\n\nNOP\nNOP\n\nNOP\nNOP\n\nNOP\n\nNOP\nNOP\n\nNOP\n\nNOP\n\nNOP\n\nNOP\n\nNOP\n\nMem\n\nReg\n\nMem\n\nReg\n\n18\n\n\fData hazards\nAttempting to use an item before it is ready. E.g.:\n\u25cf Only one sock of a pair is found during folding\n\u25cf It\u2019s in the dryer! Folding has to wait!\n\nIn a CPU:\n\u25cf Instruction depends on result of prior instruction still in the pipeline\nadd s0, t0, t1\nsub t2, t2, s0\n\ns0 must be produced before it can\nbe used\n\n19\n\n\fData hazards \u2013 What can I do???\n\u25cf Are these common?\no Yup! You bet!\ni=i+1\narray[i]\n\n\u25cf Solution 1: Stall until value is written back to the register file\no Penalty is high with this solution.\nTime\n\n0\n\n1\n\nadd s0,t0,t1\n\nMem\n\nReg\n\nsub t2,t2,s0\n\nNOP\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\nReg\n\nNOP\n\nMem\n\nReg\n\nReg\n20\n\n\fData hazards \u2013 What can I do???\n\u25cf Solution 2: What if we improve the register file?\n\nWrite to the register on\nthe falling edge\n\nTime\n\n0\n\n1\n\nadd s0,t0,t1\n\nMem\n\nReg\n\nsub t2,t2,s0\n\nNOP\n\n2\n\nRead register during\nthe second half\n\nRegister\nFile\n\n3\n\n4\n\n5\n\n6\n\n7\n\nW\nReg\n\nMem\n\nRegR\n\nReg\n21\n\n\fData hazards \u2013 What can I do???\n\u25cf Solution 3: Can we forward the ALU output?\no Add path from ALU output to one of its inputs\nForwarding: Passing the result from a\nlater stage to an earlier one\n\nTime\n\n0\n\n1\n\nadd s0,t0,t1\n\nMem\n\nReg\n\nsub t2,t2,s0\n\nMem\n\n2\n\n3\n\n4\n\nReg\n\nReg\n\nReg\n\n5\n\n6\n\n7\n\nThe value needed by the\nsub isn\u2019t read from the reg\nfile - it comes directly from\nthe result output from\ndoing the add operation\n22\n\n\fControl hazards\nAttempting to make a decision before condition is evaluated\n\u25cf If the dirty clothes are not clean after washing!\n\u25cf Then I must wash them again\nIn a CPU:\n\u25cf Branches\nblt s0, s1, DONE\nadd t0, t1, t2\nor t0, t1, t2\nDONE:\nsub t0, t1, t2\n\nWhich path will the\nprogram take?\nWhich instruction do\nwe fetch next?\n\n23\n\n\fControl hazards\nAttempting to make a decision before condition is evaluated\n\u25cf If the dirty clothes are not clean after washing!\n\u25cf Then I must wash them again\nIn a CPU:\n\u25cf Branches\nif s0 < s1 goto DONE\nadd t0, t1, t2\nor t0, t1, t2\nDONE:\nsub t0, t1, t2\n\nWhich path will the\nprogram take?\nWhich instruction do\nwe fetch next?\n\n24\n\n\fControl hazards \u2013 What can I do???\n\u25cf We can stall\u2026 until the outcome is known!\nTime\n\n0\n\n1\n\nblt s0,s1,DONE\n\nMem\n\nReg\n\nsub t0,t1,t2\n\nNOP\n\n2\n\n3\n\n4\n\nNOP\n\nMem\n\nReg\n\n5\n\n6\n\n7\n\nReg\n\n\u25cf This is a bit wasteful! We really don\u2019t like stalls! \u263a\n\u25cf We want the pipeline always full and doing useful work!\n25\n\n\fControl hazards \u2013 What can I do???\n\u25cf Sooo\u2026 we can predict that the branch is never taken! (na\u00efve)\nTime\n\n0\n\n1\n\nblt s0,s1,DONE\n\nMem\n\nReg\n\nadd t0,t1,t2\n\nMem\n\n2\n\nReg\n\n3\n\n4\n\n5\n\n6\n\n7\n\nReg\n\n\u25cf We attempt to execute the next sequential instruction!\n\u25cf It is a gamble! that the branch will never be taken.\n\u25cf But if we are right, there is no stall!!! \u263a\n26\n\n\fControl hazards \u2013 What if we are wrong?????!!!\n\u25cf Ok, what if we are wrong???!!\nTime\n\n0\n\n1\n\nblt s0,s1,DONE\n\nMem\n\nReg\n\nadd t0,t1,t2\n\nor t0,t1,t2\n\nsub t0,t1,t2\n\nMem\n\n2\n\n3\n\n4\n\nReg\n\nNOP\n\nNOP\n\nMem\n\nNOP\n\nNOP\n\nMem\n\nReg\n\n5\n\n6\n\n7\n\nNOP\n\nReg\n\n\u25cf Just abort (stall the remaining steps) to fix it! Nothing was actually changed!\n\u25cf Read the correct instruction!\n\n27\n\n\fFun facts!\n\u25cf How often do you think a (less-na\u00efve) branch predictor is correct?\nUsing 128 Bytes all these predictors\nhave an accuracy of >90%!!!\n\nMcFarling, Scott. Combining branch predictors. Vol. 49. Technical\nReport TN-36, Digital Western Research Laboratory, 1993.\n\n28\n\n\fWhat to know more?\n\u25cf CS 1541 \u2013 Introduction to Computer Architecture\no Learn more about hazards.\no Learn more about branch predictors.\no Learn about memory hierarchies.\no And more\u2026\n\n29\n\n\fPerformance and\nThe Law of Diminishing Returns\n\n30\n\n\fDon't waste your time...\n\u25cf suppose you're trying to get better at time management\n\u25cf you got an app that lets you time how long you do stuff\nif you wanted to get\nmore free time by\nhalving the amount of\ntime it takes to do one\ntask, which task would\nyou choose?\n\nCommuting\n\nHygiene\n\nWatching\nYoutube\n\nMeals\n\nWorking\n31\n\n\fIf you cut Youtube by half...\n\u25cf look at all the extra free time you have!\nHygiene\nCommuting\n\nFree time!\n\nMeals\n\nWatching\nYoutube\n\nWorking\n\n32\n\n\fIf you cut commuting by half...\n\u25cf look at ... all the extra free time... you have.\nFree time!\nHygiene\nCommuting\n\nWatching\nYoutube\n\nMeals\n\nWorking\n\n33\n\n\fThe tale of two multipliers\n\u25cf The tale starts with a simple program\nli\n\n$1, 100\n\nlw\nlw\nmult\nmflo\nsw\naddi\nbne\n\n$2, A[i]\n$3, B[i]\n$3, $2\n$4\n$4, C[i]\n$1, $1, -1\n$1, $0, L0\n\nL0:\n; pseudo-code to load A[i]\n; pseudo-code to load B[i]\n\n; pseudo-code to store C[i]\n\n\u25cf How many times does the loop execute?\n\nRuns 100 times\n\n34\n\n\fThe tale of two multipliers\n\u25cf You measure how long it takes to execute.\no It took 102010ns\nli\n\n$1, 100\n\n10ns\n\nL0:\nlw\nlw\nmult\nmflo\nsw\naddi\nbne\n\nThat\u2019s too long!\n\n$2, A[i]\n$3, B[i]\n$3, $2\n$4\n$4, C[i]\n$1, $1, -1\n$1, $0, L0\n\n10ns\n10ns\n960ns\n10ns\n10ns\n10ns\n10ns\n\nI need to improve this,\nwhat should I do?\n\nLet me check what is\ngoing on here!\n\n96000ns!!!\n\ud835\udc61\ud835\udc56\ud835\udc5a\ud835\udc52 = 1 \u00d7 10\ud835\udc5b\ud835\udc60 +\n6 \u00d7 100 \u00d7 10\ud835\udc5b\ud835\udc60 +\n1 \u00d7 100 \u00d7 960\ud835\udc5b\ud835\udc60 = 102010\ud835\udc5b\ud835\udc60\n35\n\n\fThe tale of two multipliers\n\u25cf It seems this CPU implements a slow multiplier\no It needs to execute 3 distinct steps:\n(1) add, (2) shift left, and (3) shift right\no Multiplication takes 32-bit numbers\n\u25aa The ALU and the adder are 64-bits!\no The 64-bit addition takes 10ns\no Shifts also take 10ns\no The multiplication takes 96 steps \u2192 3 \u00d7 32bits\n\nWhat if I used another\nmultiplier design?\n\n\u25aa total = 96 steps \u00d7 10\ud835\udc5b\ud835\udc60 = 960\ud835\udc5b\ud835\udc60\n\n36\n\n\fThe tale of two multipliers\n\u25cf I know, let\u2019s use a Fast multiplier design I have\n1. It combines some registers\n2. And we can make it do the 3 steps simultaneously\n3. And the ALU only needs to be 32-bits!\n\no Assuming a linear relationship between bits and adder speed:\n\u25aa The 32-bit addition takes 5ns\no The multiplication takes 32 steps \u2192 1(\ud835\udc50\ud835\udc5c\ud835\udc5a\ud835\udc4f\ud835\udc56\ud835\udc5b\ud835\udc52\ud835\udc51) \u00d7 32bits\n\u25aa total = 32 steps \u00d7 5\ud835\udc5b\ud835\udc60 = 160\ud835\udc5b\ud835\udc60\nCool! That\u2019s a lot\nfaster!!\n\n37\n\n\fThe tale of two multipliers\n\u25cf Let\u2019s calculate how much faster it is:\no Let\u2019s calculate the speedup ratio:\n\u25aa The factor by which the new version is faster than the old one\n\nslow multiplier time 960\ud835\udc5b\ud835\udc60\nspeedup =\n=\n=6\u00d7\n\ud835\udc53\ud835\udc4e\ud835\udc60\ud835\udc61 \ud835\udc5a\ud835\udc62\ud835\udc59\ud835\udc61\ud835\udc56\ud835\udc5d\ud835\udc59\ud835\udc56\ud835\udc52\ud835\udc5f \ud835\udc61\ud835\udc56\ud835\udc5a\ud835\udc52 160\ud835\udc5b\ud835\udc60\nBut will the program\nimprove that much?\n\n38\n\n\fThe tale of two multipliers\n\ud835\udc61\ud835\udc56\ud835\udc5a\ud835\udc52 = 1 \u00d7 10\ud835\udc5b\ud835\udc60 +\n6 \u00d7 100 \u00d7 10\ud835\udc5b\ud835\udc60 +\n1 \u00d7 100 \u00d7 160\ud835\udc5b\ud835\udc60 = 22010\ud835\udc5b\ud835\udc60\n\nslow program 102010\ud835\udc5b\ud835\udc60\n\ud835\udc2c\ud835\udc29\ud835\udc1e\ud835\udc1e\ud835\udc1d\ud835\udc2e\ud835\udc29 =\n=\n\ud835\udc53\ud835\udc4e\ud835\udc60\ud835\udc61 \ud835\udc5d\ud835\udc5f\ud835\udc5c\ud835\udc54\ud835\udc5f\ud835\udc4e\ud835\udc5a\n22010\ud835\udc5b\ud835\udc60\n= \ud835\udfd2. \ud835\udfd4\ud835\udfd1 \u00d7\n\nIt still an improvement!\nBut not 6x. Why?\n\n\u25cf The multiplier is only used once!\n\n39\n\n\fThe tale of two multipliers\n\u25cf What happens if we decrease the proportion of execution time?\nSuppose 101 instructions: 100 non-multiply, 1 multiply\n\ud835\udc61\ud835\udc56\ud835\udc5a\ud835\udc52 \ud835\udc60\ud835\udc59\ud835\udc5c\ud835\udc64 = 100 \u00d7 10\ud835\udc5b\ud835\udc60 + 960\ud835\udc5b\ud835\udc60 = 1960\ud835\udc5b\ud835\udc60\n\ud835\udc61\ud835\udc56\ud835\udc5a\ud835\udc52 \ud835\udc53\ud835\udc4e\ud835\udc60\ud835\udc61 = 100 \u00d7 10\ud835\udc5b\ud835\udc60 + 160\ud835\udc5b\ud835\udc60 = 1160\ud835\udc5b\ud835\udc60\n1960\ud835\udc5b\ud835\udc60\n\ud835\udc60\ud835\udc5d\ud835\udc52\ud835\udc52\ud835\udc51\ud835\udc62\ud835\udc5d =\n= 1.7 \u00d7\n1160\ud835\udc5b\ud835\udc60\nSuppose 1001 instructions: 1000 non-multiply, 1 multiply\n\ud835\udc61\ud835\udc56\ud835\udc5a\ud835\udc52 \ud835\udc60\ud835\udc59\ud835\udc5c\ud835\udc64 = 1000 \u00d7 10\ud835\udc5b\ud835\udc60 + 960\ud835\udc5b\ud835\udc60 = 10960\ud835\udc5b\ud835\udc60\n\ud835\udc61\ud835\udc56\ud835\udc5a\ud835\udc52 \ud835\udc53\ud835\udc4e\ud835\udc60\ud835\udc61 = 1000 \u00d7 10\ud835\udc5b\ud835\udc60 + 160\ud835\udc5b\ud835\udc60 = 10160\ud835\udc5b\ud835\udc60\n10960\ud835\udc5b\ud835\udc60\n\ud835\udc60\ud835\udc5d\ud835\udc52\ud835\udc52\ud835\udc51\ud835\udc62\ud835\udc5d =\n= 1.08 \u00d7\n10160\ud835\udc5b\ud835\udc60\n\n40\n\n\fDecreasing gains\n\u25cf 6 \u00d7\u2192 4.63 \u00d7\u2192 1.7 \u00d7\u2192 1.08 \u00d7\n\n\u25cf What happened?\no Proportion of time spent multiplying was not enough to have gains\n\u25cf Optimization is a balancing act.\no As you solve a bottleneck, a new one will appear.\no Improve things to a point, then there are diminishing returns!\n5s\n\n4s\n\n3s\n\n2s\n\n4s\n\n3s\n\n2s\n\n3s\n\n3s\n41\n\n\fWhat about pipelining?\n\u25cf How much faster (and why) is a pipelined implementation of MIPS?\n\u25cf As we saw last class, we compute the speedup for this:\n\nslow time\nspeedup =\n\ud835\udc53\ud835\udc4e\ud835\udc60\ud835\udc61 \ud835\udc61\ud835\udc56\ud835\udc5a\ud835\udc52\n\u25cf And how do we compute \u201ctime\u201d?\nCPU time = \ud835\udc5b \u00d7 \ud835\udc36\ud835\udc43\ud835\udc3c \u00d7 \ud835\udc61 seconds\n\n42\n\n\fAverage Instruction CPI\n\u25cf What is an \u201caverage instruction\u201d CPI?\no Remember how we calculated the average CPI of a program?\n\u25cf Given a program, how many cycles does an instruction typically take?\no It depends on the program!\no How many instructions, and what types?\n\u25aa E.g.: all adds vs. all loads for multi-cycle implementation\n\n\u25cf The average instruction CPI is the average cycle count per instruction\n\n43\n\n\fInstruction Mix\n\u25cf Instruction mix: Is the % total instruction count (n) corresponding to each\ninstruction class\n\u25cf Program A: 100 adds, 100 subtracts, 50 loads, 25 stores, 50 branches, and 10\njumps. Total 335 instructions.\n\n\u25cf What is the mix?\nArithmetic\n\n(100+100) / 335 =\n\n0.597 =\n\n59.7%\n\nLoad\n\n50 / 335 =\n\n0.149 =\n\n14.9%\n\nStore\n\n25/335 =\n\n0.075 =\n\n7.5%\n\nBranch\n\n50/335 =\n\n0.149 =\n\n14.9%\n\nJump\n\n10/335 =\n\n0.03 =\n\n3.0%\n\n44\n\n\fCPI \u2013 Multi-cycle\n\u25cf Given this mix, what is the Average Cycles Per Instruction (CPI)?\no E.g., with a multi-cycle CPU.\n\u25cf We compute the weighted average\nCPI= \u03a3\ud835\udc4e\ud835\udc59\ud835\udc59 \ud835\udc50\ud835\udc59\ud835\udc4e\ud835\udc60\ud835\udc60\ud835\udc52\ud835\udc60 \ud835\udc53\ud835\udc5f\ud835\udc52\ud835\udc5e \u00d7 \ud835\udc50\ud835\udc66\ud835\udc50\ud835\udc59\ud835\udc52\ud835\udc60\nClass\n\nFrequency\n\nCycles\n\nContribution\n\nArithmetic\n\n59.7%\n\n4\n\n2.388\n\nLoad\n\n14.9%\n\n5\n\n0.745\n\nStore\n\n7.5%\n\n4\n\n0.3\n\nBranch\n\n14.9%\n\n3\n\n0.447\n\nJump\n\n3.0%\n\n3\n\n0.09\n\nTotal\n\n3.97 CPI\n45\n\n\fCPU time\n\u25cf And now we can calculate the CPU time\no Assuming a cycle length of 2ns\nCPU time = 335 \u00d7 3.97 \u00d7 2\ud835\udc5b\ud835\udc60\n= 2660\ud835\udc5b\ud835\udc60\nClass\n\nFrequency\n\nCycles\n\nContribution\n\nArithmetic\n\n59.7%\n\n4\n\n2.388\n\nLoad\n\n14.9%\n\n5\n\n0.745\n\nStore\n\n7.5%\n\n4\n\n0.3\n\nBranch\n\n14.9%\n\n3\n\n0.447\n\nJump\n\n3.0%\n\n3\n\n0.09\n\nTotal\n\n3.97 CPI\n46\n\n\fWhat about in the pipeline implementation?\n\u25cf In the best case, what is the CPI?\no How many instructions are we starting every clock cycle?\n\u25cf What about the typical case, what is the CPI?\no We have to consider hazards.\no Say, 20% of branches are predicted correctly.\no 60% of loads do not conflict with other memory accesses.\n\n\u25cf Assume the same program and clock cycle.\n\n47\n\n\fInstruction Mix \u2013 Pipeline\n\u25cf Instruction mix: Treat the delayed load and branch instructions as a separate\nclass\nClass\nArithmetic\n\nFrequency\n\nCycles\n\n59.7%\n\n1\n\n0.6*14.9%=8.94%\n\n1\n\nLoad \u2013 delay\n\n5.96%\n\n2\n\nStore\n\n7.5%\n\n1\n\n0.2*14.9%=2.98%\n\n1\n\n11.92%\n\n3\n\n3.0%\n\n1\n\nLoad \u2013 no delay\n\nBranch predicted\nBranch not predicted\nJump\n\n48\n\n\fCPI \u2013 Pipeline\n\u25cf We compute the weighted average\nCPI= \u03a3\ud835\udc4e\ud835\udc59\ud835\udc59 \ud835\udc50\ud835\udc59\ud835\udc4e\ud835\udc60\ud835\udc60\ud835\udc52\ud835\udc60 \ud835\udc53\ud835\udc5f\ud835\udc52\ud835\udc5e \u00d7 \ud835\udc50\ud835\udc66\ud835\udc50\ud835\udc59\ud835\udc52\ud835\udc60\nClass\n\nCycles\n\nContribution\n\n59.7%\n\n1\n\n0.597\n\n0.6*14.9%=8.94%\n\n1\n\n0.0894\n\nLoad \u2013 delay\n\n5.96%\n\n2\n\n0.1192\n\nStore\n\n7.5%\n\n1\n\n.075\n\n0.2*14.9%=2.98%\n\n1\n\n.0298\n\n11.92%\n\n3\n\n0.3576\n\n3.0%\n\n1\n\n0.03\n\nArithmetic\nLoad \u2013 no delay\n\nBranch predicted\nBranch not predicted\nJump\n\nFrequency\n\nTotal\n\n1.30 CPI\n\n49\n\n\fThe speedup\n\u25cf Compute CPU execution time of pipelined implementation\no Every value except CPI is the same as in the multi-cycle\n\u25aa n \u2013 is a property of the program\n\nPipeline CPU time = 335 \u00d7 1.30 \u00d7 2\ud835\udc5b\ud835\udc60\n= 871\ud835\udc5b\ud835\udc60\n\n2660\ud835\udc5b\ud835\udc60\nspeedup =\n= 3.05 \u00d7\n871\ud835\udc5b\ud835\udc60\n\n50\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}