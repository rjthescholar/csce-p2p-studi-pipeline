{"id": 195, "segment": "unlabeled", "course": "cs0449", "lec": "final_review", "text": "Intro to Systems Software\n\nCS 449\n\nFinal Review\n\nBryant and O\u2019Hallaron, Computer Systems: A Programmer\u2019s Perspective, Third Edition\n\n1\n\n\fTopics\n\n\u2022 Buffer overflow\n\u2022 Linking (high level understanding)\n\u2022 Cache memories\n\u2022 Virtual Memory\n\u2022 Memory Allocation\n\u2022 Processes\n\n2\n\n\fJust for fun #1: What does this code print?\n#include <stdio.h>\n#include <stddef.h>\nint foo(int x, int y) {\nstruct s {\nchar a[x];\nchar b[y];\nchar c;\n};\nreturn offsetof(struct s , c);\n}\nint main(void)\n{\nprintf(\"%d\\n\", foo(2,3));\n}\n\nOnly works with \u201cgcc\u201d J\n\n\fJust for fun #2: What does this code print?\n#include <stdio.h>\n#include <stddef.h>\nint bar(int x, int y) {\nstruct s {\nchar a[x][y];\n};\nreturn sizeof(struct s);\n}\nint main(void)\n{\nprintf(\"%d\\n\", bar(2,3));\n}\n\nOnly works with \u201cgcc\u201d J\n\n\fBuffer Overflow\n\n\fStack Discipline\n\n\u2022 This kind of problem covers a wide range of\ntopics, such as stack frames, string\nrepresentations, ASCII code, and byte\nordering\n\u2022 It demonstrates the dangers of out-of-bounds\nmemory references and the basic ideas behind\nbuffer overflow\n\n\fReference\n\n\u2022 Read: CSAPP3e 3.10.3 (\u201cOut-of-Bounds\nMemory References and Buffer Overflow\u201d)\n\u2022 Exercise: CSAPP practice problem 3.46\n\n\fPractice problem 3.46\n\u2022 Below is a (low-quality) implementation of a function that\nreads a line from standard input, copies the string to newly\nallocated storage, and returns a pointer to the result\n/* This is very low-quality code. It is intended to illustrate\nbad programming practices. See Practice Problem 3.46. */\nchar *get_line()\n{\nchar buf[4];\nchar *result;\ngets(buf);\nresult = malloc(strlen(buf));\nstrcpy(result, buf);\nreturn result;\n}\n\n\fPractice problem 3.46\n\u2022 Disassembly up through call to gets\n\n1\n2\n3\n4\n5\n\nchar *get_line()\n0000000000400720 <get_line>:\n400720:53\npush\n%rbx\n400721:48 83 ec 10\nsub\n$0x10,%rsp\nSee diagram stack at this point\n400725:48 89 e7\nmov\n%rsp,%rdi\n400728:e8 73 ff ff ff\ncallq 4006a0 <gets>\nModify diagram to show stack contents at this point\n\n\fPractice problem 3.46\nConsider the following scenario. Procedure get_line is called with\nthe return address equal to 0x400776 and register %rbx equal\nto 0x0123456789ABCDEF. You type in the string:\n\n0123456789012345678901234\nThe program terminates with a segmentation fault. You run GDB and\ndetermine that the error occurs during the execution of\nthe ret instruction of get_line.\n\n\fPractice problem 3.46\n\u2022 Question A: Fill in the diagram that follows, indicating as much as you\ncan about the stack just after executing the instruction at line 3 in\nthe disassembly. Label the quantities stored on the stack (e.g., \"Return\naddress\") on the right, and their hexadecimal values (if known) within\nthe box. Each box represents 8 bytes. Indicate the position of %rsp.\nRecall that the ASCII codes for characters 0\u20139 are 0x30\u20130x39.\n\n\fPractice problem 3.46\n\u2022 Question A: Fill in the diagram that follows, indicating as much as you\ncan about the stack just after executing the instruction at line 3 in\nthe disassembly. Label the quantities stored on the stack (e.g., \"Return\naddress\") on the right, and their hexadecimal values (if known) within\nthe box. Each box represents 8 bytes. Indicate the position of %rsp.\nRecall that the ASCII codes for characters 0\u20139 are 0x30\u20130x39.\n\nStack after line 3:\n\n\fPractice problem 3.46\n\u2022 Question B: Modify your diagram to show the effect of\nthe call to gets (line 5)\n\n\fPractice problem 3.46\n\u2022 Question B: Modify your diagram to show the effect of\nthe call to gets (line 5)\nStack after line 5:\n\n\fPractice problem 3.46\n\u2022 Question C: To what address does the program\nattempt to return?\nThe program is attempting to return to address 0x040034.\nThe low-order 2 bytes were overwritten by the code for\ncharacter \u20184\u2019 and the terminating null character.\n\n\fPractice problem 3.46\n\u2022 Question D: What register(s) have corrupted value(s)\nwhen get_line returns?\n\nThe saved value of register %rbx was set to 0x3332313039383736.\nThis value will be loaded into the register before get_line returns.\n\n\fPractice problem 3.46\n\u2022 Question E: Besides the potential for buffer overflow,\nwhat two other things are wrong with the code for\nfunction get_line?\n\nThe call to malloc should have had strlen(buf)+1 as its argument, and\nthe code should also check that the returned value is not equal to NULL.\n\n\fCache Memories\n\n18\n\n\fPractice Cache Problem\n\u2022 We have a 64 KiB address space\n\u2022 The cache is a 1 KiB, direct-mapped cache using 256-byte blocks\nwith write-back and write-allocate policies\n\u2022 write-allocate: memory is read after a cache-miss-on-write\n\u2022 write-back: dirty data is written back to memory on eviction\na) Calculate the TIO address breakdown:\n\n\fPractice Cache Problem\n\u2022 We have a 64 KiB address space\n\u2022 The cache is a 1 KiB, direct-mapped cache using 256-byte blocks\nwith write-back and write-allocate policies\n\u2022 write-allocate: memory is read after a cache-miss-on-write\n\u2022 write-back: dirty data is written back to memory on eviction\na) Calculate the TIO address breakdown:\n\n\fPractice Cache Problem\nb) During some part of a running program, the cache\u2019s\nmanagement bits are as shown below.\n\nFour options for the next two memory accesses are\ngiven (R = read, W = write). Circle the option that results\nin data from the cache being written to memory\n\n\fPractice Cache Problem\n\n(1) R 0x4C00, W 0x5C00\n\n(3) W 0x2300, R 0x0F00\n\n(2) W 0x5500, W 0x7A00\n\n(4) R 0x3000, R 0x3000\n\n\fPractice Cache Problem\n\n(1) R 0x4C00, W 0x5C00\n\n(3) W 0x2300, R 0x0F00\n\nR 0b0100 1100\u2026 , W 0b0101 1100\u2026\n\nW 0b0010 0011\u2026 , R 0000 1111\u2026\n\n(2) W 0x5500, W 0x7A00\n\n(4) R 0x3000, R 0x3000\n\nW 0b0101 0101\u2026 , W 0b0111 1010\u2026\n\nR 0b0011 0000\u2026 , R 0011 0000\u2026\n\n\fPractice Cache Problem\n\n(1) R 0x4C00, W 0x5C00\n\n(3) W 0x2300, R 0x0F00\n\nR 0b0100 1100\u2026 , W 0b0101 1100\u2026\n\nW 0b0010 0011\u2026 , R 0000 1111\u2026\n\nThe read evicts line 0, but the dirty bit was not set so\nnothing is written (also, line 0 was initially invalid). The\nwrite overwrites line 0 again but since the cache is writeback nothing is written to memory.\n\nThe write evicts line 3 which was invalid and not\ndirty, so nothing is written to memory. The read,\nhowever, also maps to line 3 so it must write the\nvalue changed in the write back to memory before\nit can update the cache.\n\n(2) W 0x5500, W 0x7A00\n\n(4) R 0x3000, R 0x3000\n\nW 0b0101 0101\u2026 , W 0b0111 1010\u2026\n\nR 0b0011 0000\u2026 , R 0011 0000\u2026\n\nThe first write doesn\u2019t evict anything because the tags match.\nThe second write evicts the old data, but the dirty bit was not\nset so the old data doesn\u2019t need to be written back to memory.\n\nLine 0 is initially not dirty (and invalid) so nothing is\nwritten back to memory from either of these reads\n(which both read from the same line).\n\n\fImplementing LRU (Least Recently Used)\nBlock\n\nTag\n\nA\nE\nB\nC\nD\nBlock requests:\n\nValid LRU\n3\n0\n2\n\n\u00df least recent used\n\n1\n0\n2\n1\n3\n2\n3\n\nE\n\nD\n\nHow large (in bits) should the LRU counter be on\nan N-way set-associative cache?\n25\n\n\fVirtual Memory\n\n\fEnd-to-End Address Translation\n\n\u2022 Consider the following memory system:\n\n\u2013 The memory is byte addressable\n\u2013 Virtual addresses are 14 bits wide (n = 14)\n\u2013 Physical addresses are 12 bits wide (m = 12)\n\u2013 The page size is 64 Bytes (P = 64)\n\u2013 The L1 d-cache is physically addressed and direct\nmapped, with a 4-Byte line size and 16 total sets\n\n\fVirtual and physical addresses\n\n\u2022 14-bit virtual addresses (n = 14)\n\u2022 12-bit physical addresses (m = 12)\n\u2022 64-byte pages (P = 64)\n\n\fSnapshot of the page table\n\n\fSnapshot of the L1 d-cache\n\n4B-block\n\n\fPractice Problem 9.4 (CSAPP:3e)\n\n\u2022 Show how the example memory system\ntranslates a virtual address into a physical\naddress and accesses the cache\n\u2022 Given virtual address: 0x03d7\nWhat is the virtual address format?\n0 0\n\n0 0 1\n\n1\n\n1 1\n\n0 1\n\n0 1 1\n\n1\n\n\fAddress Translation\n\n0x0f\nN\n0x0d\n\n0x03d7\n\n0 | 0 | 0 | 0| 1 | 1 | 1 | 1 | 0 | 1 | 0 | 1 | 1 | 1\n0x0f\n\n0x17\n\n32\n\n\fPhysical Memory Access\n\n0x03\n0x05\n0x0d\nY\n0x1d\n\n0x0d\n\n0x03d7\n\n0x05\n\n0x03\n\n0 | 0 | 1 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 1 | 1\n0x0d\n\n0x17\n\n\fMemory Allocation\n\n\fDynamic storage allocation\n\u2022 Consider an allocator that uses an list. The layout of each\nallocated AND free memory block is as follows:\n\u2022 Each memory block, either allocated or free, has a size.\n\u2022 The size doesn\u2019t include the header.\n\u2022 The size is negative if the block is free, positive otherwise\n\u2022 It\u2019s a 32-bit machine, addresses and ints are both 32-bits\nHeader\n\nData\n\n____________________________\n| (int) Block size (Bytes) |\n|_ _ _ _ _ _ _ _ _ _ _ _ _ _ |\n| (int) Previous address\n|\n|____________________________|\n|\n|\n|\n|\n|\n|\n|\n|\n|\n|\n|\n|\n|____________________________|\n\n\f\u2022\n\nGiven the contents of the heap\nshown on the left, show the new\ncontents of the heap (in the\nright table) after a call to\nfree(0x400b014) is executed\n\n\u2022\n\nYour answers should be given as\nhex values\n\n\u2022\n\nNote that the address grows\nfrom bottom up\n\n\u2022\n\nAssume that the allocator uses\nimmediate coalescing, that is,\nadjacent free blocks are merged\nimmediately each time a block is\nfreed\n\nBefore\n\nAfter\n\n0x0400b00c\n\n0x0400affc\n\n0x00000002\n\n0x00000002\n\n0x0400affc\n\n0x0400affc\n\n0x00000002\n\n0xFFFFFFFFE\n\n0x0400aff8\n\n0x0400aff8\n\n0xFFFFFFFFE\n\n0xFFFFFFFFA\n\n\fProcesses\n\n\fProcesses\n\n\u2022 Consider this code using Linux\u2019s fork:\nint x = 7;\nif ( fork() ) {\nx++;\nprintf(\" %d \", x);\nfork();\nx++;\nprintf(\" %d \", x);\n} else {\nprintf(\" %d \", x);\n}\n\nWhat are all the different\npossible outputs (i.e. order of\nthings printed) for this code?\n(Hint: there are 4 of them.)\n\nTip: try drawing a process graph for this program\n\n\fProcesses\n\n\u2022 Consider this code using Linux\u2019s fork:\nint x = 7;\nif ( fork() ) {\nx++;\nprintf(\" %d \", x);\nfork();\nx++;\nprintf(\" %d \", x);\n} else {\nprintf(\" %d \", x);\n}\n\n\fProcesses\n\u2022 Consider this code using Linux\u2019s\nfork:\nint x = 7;\nif ( fork() ) {\nx++;\nprintf(\" %d \", x);\nfork();\nx++;\nprintf(\" %d \", x);\n} else {\nprintf(\" %d \", x);\n}\n\nPossible orderings:\n7 8 9 9\n8 7 9 9\n8 9 7 9\n8 9 9 7\n\n\fMore stuff\n\n\fDynamic storage allocation\n\u2022 Five helper routines are defined to facilitate the\nimplementation of free(void *p)\n\u2022 The functionality of each routine is explained in the\ncomment above the function definition\n\u2022 Fill in the body of the helper routines the code\nsection label that implement the corresponding\nfunctionality correctly\n\u2022 Important notice: Block sizes are 4 bytes in this\nproblem\n\n\fDynamic storage allocation\n\n\u2022 Code 1:\n/* given a pointer p to an allocated block, i.e., p is a\npointer returned by some previous malloc()/realloc() call;\nreturns the pointer to the header of the block*/\nvoid * header(void* p)\n{\nvoid *ptr;\n_______;\nreturn ptr;\n}\nA. ptr = p-2\nB. ptr = (void *)((int *)p-2)\nC. ptr = (void *)((int *)p+2)\n\n\fDynamic storage allocation\n\n\u2022 Code 2:\n/* given a pointer to a valid block header or footer,\nreturns the size of the block */\nint size(void *hp)\n{\nint result;\n_______;\nreturn result;\n}\nA. result = (*hp>0)?*hp:-*hp;\nB. result = *(int *)hp;\nC. result = (*(int *)hp > 0)?(*(int *)hp):(-*(int *)hp);\n\n\fDynamic storage allocation\n\n\u2022 Code 3:\n/* given a pointer p to an allocated block, i.e. p is\na pointer returned by some previous malloc()/realloc() call;\nreturns the pointer to the next of the block*/\nvoid * next(void *p)\n{\nvoid *ptr;\n_______;\nreturn ptr;\n}\nA. ptr = p+size(header(p))\nB. ptr = p+size(header(p))-8\nC. ptr = (int *)p+size(header(p))-2\n\n\fDynamic storage allocation\n\n\u2022 Code 4:\n/* given a pointer to a valid block header or footer,\nreturns the usage of the current block,\n1 for allocated, 0 for free */\nint allocated(void *hp)\n{\nint result;\n______;\nreturn result;\n}\nA. result=(*(int *)hp)>0\nB. result=(*(int *)hp)==0\nC. result=(*(int *)hp)<0\n\n\fDynamic storage allocation\n\n\u2022 Code 5:\n/* given a pointer to a valid block header,\nreturns the pointer to the header of previous block in\nmemory */\nvoid * prev(void *hp)\n{\nvoid *ptr;\n______;\nreturn ptr;\n}\nA. ptr = hp \u2013 *((int*)hp + 1)\nB. ptr = (void*)*((int*)hp + 1)\nC. ptr = (void*)((int*)hp + 1)\n\n\fCache Puzzle\n\u2022 Given the following sequence of access results\n(addresses are given in decimal) on a cold/empty cache\nof size 16 bytes, what can we deduce about its\nproperties? Assume an LRU replacement policy\n(0, Miss), (8, Miss), (0, Hit), (16, Miss), (8, Miss)\n\nWhat can we say about the block size?\n\n\fCache Puzzle\n\u2022 Given the following sequence of access results\n(addresses are given in decimal) on a cold/empty cache\nof size 16 bytes, what can we deduce about its\nproperties? Assume an LRU replacement policy\n(0, Miss), (8, Miss), (0, Hit), (16, Miss), (8, Miss)\n\nWhat can we say about the block size?\nThe block size must be \u2264 8 because access (2) to address\n8 is a miss after access (1) to address 0 is a hit.\n\n\fCache Puzzle\n(0, Miss), (8, Miss), (0, Hit), (16, Miss), (8, Miss)\n\nAssuming that the block size is 8 bytes, can this\ncache be\u2026 (Hint: draw the cache and simulate it)\na. Direct-mapped?\nDoes this cache work for the access\nresults? Yes, Yes, Yes, Yes (evict 0), No (8\nwould still be in cache)\n\n\fCache Puzzle\n(0, Miss), (8, Miss), (0, Hit), (16, Miss), (8, Miss)\n\nAssuming that the block size is 8 bytes, can this\ncache be\u2026 (Hint: draw the cache and simulate it)\nb. 2-way set associative?\nDoes this cache work for the access\nresults? Yes, Yes, Yes, Yes (evict 8 b/c\nit\u2019s the least recently used), Yes (8 is no\nlonger in cache)\n\n\fCache Puzzle\n(0, Miss), (8, Miss), (0, Hit), (16, Miss), (8, Miss)\n\nAssuming that the block size is 8 bytes, can this\ncache be\u2026 (Hint: draw the cache and simulate it)\nc. 4-way set associative?\nNo, because the block size is 8, multiplied\nby 4 lines per set, and that\u2019s 32B, which\nis already bigger than the entire cache.\n\n\fCode Analysis Problem\n\u2022Assuming the cache starts cold (all blocks invalid) and sum, i, and j\nare stored in registers, calculate the miss rate:\n\ud835\udc5a = 12 bits (addr. range), \ud835\udc36\ud835\udc4e\ud835\udc50\u210e\ud835\udc52 = 256 B, \ud835\udc35\ud835\udc59\ud835\udc5c\ud835\udc50\ud835\udc58 = 32 B, \ud835\udc34\ud835\udc60\ud835\udc60 = 2\n\n#define SIZE 8\nlong ar[SIZE][SIZE], sum = 0; // &ar=0x800\nfor (int i = 0; i < SIZE; i++)\nfor (int j = 0; j < SIZE; j++)\nsum += ar[i][j];\n\u2022 Code employs a row-wise access pattern\n\u2022 Cache block (of 32 bytes) holds 4 long\u2019s\n\u2022 There is a miss followed by 3 hits (MR=25%)\n53\n\n\fCode Analysis Problem\n\n\u2022 How would the following changes change the\nmiss rate?\n\u2013 Increasing the block size?\n\u2013 Doubling the cache size\n\u2013 Reducing/increasing the associativity\n\n54\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}