{"id": 151, "segment": "unlabeled", "course": "cs0449", "lec": "lec02", "text": "1\n\nData\nRepresentation\n\nCS/COE 0449\nIntroduction to\nSystems Software\n\nLuis Oliveira\n(with content borrowed from wilkie and Vinicius Petrucci)\n\n\fBinary Encoding\ni\nBits, Bytes, and Nybbles\n\n2\n\n\fPositional number systems\n\n\u2022 The numbers we use are written positionally: the position of a digit\nwithin the number has a meaning.\n\n3\n2 x 10\n\n2000\n2\n0 0 0 0 x 10\n=\n2021=\n1\n2 0 2 x 10\n0\n+\n1 1 x 10\n3\n\n\fPositional number systems\n\u25cf The numbers we use are written positionally: the position of a digit within\nthe number has a meaning.\n\n2021\n\nMost Significant\n\nLeast Significant\n\n1000s\n\n100s\n\n10s\n\n1s\n\n103\n\n102\n\n101\n\n100\n\n\u25cf How many (digits) symbols do we have in our number system?\n\u25cb 10: 0, 1, 2, 3, 4, 5 ,6 ,7, 8, 9\n4\n\n\fRange of numbers\n\nSuppose we have a 4-digit numeric display.\n\u2022 What is the smallest number it can show?\n\n\u2022 What is the biggest number it can show?\n\u2022 How many different numbers can it show?\n\u2022 9999 - 0 + 1 = 10,000\n\u2022 What power of 10 is 10,000?\n\u2022 104\n\n5\n\n\fSo\u2026 with the numbers we use every day\u2026\n\u2022 A number represented by the digits\n\u2022 Has the value\n\n\ud835\udc51\ud835\udc5b \ud835\udc51\ud835\udc5b\u22121 \u2026 \ud835\udc511 \ud835\udc510\n\n\ud835\udc51\ud835\udc5b \u00d7 10\ud835\udc5b + \ud835\udc51\ud835\udc5b\u22121 \u00d7 10\ud835\udc5b\u22121 + \u22ef + \ud835\udc511 \u00d7 101 + \ud835\udc510 \u00d7 100\n\u2022 Using \ud835\udc5b digits we can represent 10\ud835\udc5b different numbers\n\u2022 The smallest non-negative number representable with \ud835\udc5b digits is 0\n\n\u2022 The largest number representable with \ud835\udc5b digits is 10\ud835\udc5b \u2212 1\n\u2022 Using 10 symbols: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n\n6\n\n\fNumeric Bases\n\u2022 These 10s keep popping up\u2026 and for good reason\n\u2022 We use a base-10 (decimal) numbering system\n\u2022 10 different symbols, and each place is a power of 10\n\n\u2022 But we can use (almost) any number as a base!\n\u2022 The most common bases when dealing with computers are base-2 (binary),\nbase-16 (hexadecimal), and (rarely) base-8 (octal)\n\u2022 When dealing with multiple bases, you can write the base as a subscript to be\nexplicit about it:\n\n510 = 1012\n7\n\n\fMaking a number system\nUsing base B\n\u2022 A number represented by the digits\n\ud835\udc51\ud835\udc5b \ud835\udc51\ud835\udc5b\u22121 \u2026 \ud835\udc511 \ud835\udc510\n\n\u2022 Has the value\n\n\ud835\udc51\ud835\udc5b \u00d7 B \ud835\udc5b + \ud835\udc51\ud835\udc5b\u22121 \u00d7 B \ud835\udc5b\u22121 + \u22ef + \ud835\udc511 \u00d7 B1 + \ud835\udc510 \u00d7 B 0\n\u2022 Using \ud835\udc5b digits we can represent B \ud835\udc5b different numbers\n\u2022 The smallest non-negative number representable with \ud835\udc5b digits is 0\n\u2022 The largest number representable with \ud835\udc5b digits is B \ud835\udc5b \u2212 1\n\u2022 Using B symbols\n\nIf you use base 0 you\ndon\u2019t need to remember\n8\nany symbols\n\n\fBinary \u2013 Base 2\n\n9\n\n\fLet's make a base-2 number system\nUsing base 2\n\u2022 A number represented by the digits\n\u2022 Has the value\n\n\ud835\udc51\ud835\udc5b \ud835\udc51\ud835\udc5b\u22121 \u2026 \ud835\udc511 \ud835\udc510\n\n\ud835\udc51\ud835\udc5b \u00d7 2\ud835\udc5b + \ud835\udc51\ud835\udc5b\u22121 \u00d7 2\ud835\udc5b\u22121 + \u22ef + \ud835\udc511 \u00d7 21 + \ud835\udc510 \u00d7 20\n\u2022 Using \ud835\udc5b digits we can represent 2\ud835\udc5b different numbers\n\u2022 The smallest non-negative number representable with \ud835\udc5b digits is 0\n\u2022 The largest number representable with \ud835\udc5b digits is 2\ud835\udc5b \u2212 1\n\u2022 Using 2 symbols: 0, 1\n\n10\n\n\fBinary (base-2)\n\n\u2022 We call a Binary digIT a bit \u2013 a single 1 or 0\n\u2022 When we say an n-bit number, we mean one with n binary digits 1 \u00d7 128 +\nMSB\n\nLSB\n\n1001 0110 =\n27 2 6\n25 24\n128s 64s 32s 16s\n\n23\n8s\n\n22\n4s\n\n21\n2s\n\n20\n1s\n\nTo convert binary to decimal: ignore 0s, add up\nIt\u2019s the\nplace values wherever you see a 1.\nonly odd\n\n0 \u00d7 64 +\n0 \u00d7 32 +\n1 \u00d7 16 +\n0\u00d78+\n1\u00d74+\n1\u00d72+\n0\u00d71\n\n= 15010\n\nnumber!\n\n11\n\n\fConverting the other way around\n\n\u2022 Ok! then. Let\u2019s go back to decimal for a bit\n\n2021\n\nHow would you\nextract this\nnumber???\n\nHow I like to think of it:\n\nWhen you divide by the BASE\nyou are moving the decimal\npoint in that BASE\nJust divide by\n10!\n\n10\n10\n\n10\n\n2\n\nR0\n\n20\n\nR2\n\n202 R1\n2 0 21\n12\n\n\fWhat happens when you divide by 10?\n\n\u2022 Turns out that dividing by 10 in any base has the same outcome\n\n0b10\n\n210\n\n110012\n\n1\n\nR1\n\n210\n210\n\n3\n\nR0\n\n6\n\n210\n\n12\n\nR0\nR1\n\n210\n\n25\n\n13\n\n\fBits, bytes, nibbles, and words\n\u2022 A bit is one binary digit, and its unit is lowercase b.\n\u2022 A byte is an 8-bit value, and its unit is UPPERCASE B.\n\n\u2022 This is (partially) why your 30 megabit (Mbps) internet connection can only give you\nat most 3.57 megabytes (MB) per second!\n\n\u2022 A nibble (also nybble) is 4 bits \u2013 half of a byte\n\u2022 Corresponds nicely to a single hex digit.\n\n\u2022 A word is the \"most comfortable size\" of number for a CPU.\n\u2022 When we say \"32-bit CPU,\" we mean its word size is 32 bits.\n\u2022 This means it can, for example, add two 32-bit numbers at once.\n\n\u2022 BUT WATCH OUT:\n\n\u2022 Some things (Windows, x86) use word to mean 16 bits and double word (or dword)\nto mean 32 bits.\n14\n\n\fWhy binary? Whynary?\n\u2022 Why indeed?\n0\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n\u2022 What color is this?\n\n15\n\n\fWhy binary? Whynary?\n\u2022 Why indeed?\n0\n\n1\n\n\u2022 What color is this?\n\n16\n\n\fBinary Representation\n\u2022 Computers translate\nelectrical signals to\neither 0 or 1.\n\n\u2022 It is relatively easy to\ndevise electronics\nthat operate this way.\n\u2022 In reality, there is no\nsuch thing as\n\u201cbinary\u201d so we often\nhave to approximate\nand mitigate error.\nOscilloscope visualization of several digital wires. From @computerfact on Twitter.\n\n17\n\n\fEverything in a computer is a number\n\u2022 So, everything on a computer is represented in binary.\n\u2022 everything.\n01100101 01110110 01100101 01110010 01111001 01110100 01101000 01101001 01101110\n01100111 00001010 00000000\n\n\u2022 Java strings are encoded using UTF-16\n\u2022 Most letters and numbers in the English alphabet are < 128.\n\u2022 \u201cStrings are numbers\u201d\n\u2022 83 116 114 105 110 103 115 32 97 114 101 32 110 117 109 98 101 114 115 0\n\n\u2022 ASCII is also pretty common (the best kind of common)\n\u2022 That\u2019s what we will be using \u2192 8 bit numbers represent characters\n\u2022 Letters and numbers (and most/all ascii characters) have the same value as UTF16\nDo try this at home: what does this mean?\n\u2022 71 111 111 100 32 74 111 98 0\n18\n\n\fHexadecimal \u2013 Base 16\nThe binary shorthand\n\n19\n\n\fHexadecimal\n\u2022 Binary numbers can get really long, quickly.\n\u25aa 3,927,66410 = 11 1011 1110 1110 0111 00002\n\n\u2022 But nice \"round\" numbers in binary look\narbitrary in decimal.\n\u25aa 10000000000000002 = 32,76810\n\n\u2022 This is because 10 is not a power of 2!\n\u2022 We could use base-4, base-8,\nbase-16, base-32, etc.\n\u25aa Base-4 is not much denser than binary\n\u2022 e.g. 3,927,66410 = 120 3331 2323 00004\n\n\u25aa Base-32 would require 32 digit symbols. Yeesh.\n\u2022 They do, oddly, have their place\u2026 but not really in this\ncontext.\n\n\u25aa Base-8 and base-16 look promising!\n20\n\n\fHexadecimal or \u201chex\u201d (base-16)\n\u2022 Digit symbols after 9 are A-F, meaning 10-15 respectively.\n\u2022 Usually we call one hexadecimal digit a hex digit. No fancy name :(\n\n003B EE70 =\n167 166 165 164\n\n163 162 161 160\n\nTo convert hex to decimal: use a dang calculator\nlol\n\n0 \u00d7 167 +\n0 \u00d7 166 +\n3 \u00d7 165 +\n11 \u00d7 164 +\n14 \u00d7 163 +\n14 \u00d7 162 +\n7 \u00d7 161 +\n0 \u00d7 160 =\n\n3,927,66410\n21\n\n\fBinary to Hex\n\n(animated)\n\n0100 1100 1010 0010 0000 0010 0110 0001\n\n4 C A 2 0 2 6 1\n0x4CA20261\n32-bits! (Not so bad\u2026)\nQ: Create a random binary string and practice! 22\n\n\fLet's make a base-16 number system\nUsing base 16\n\u2022 A number represented by the digits\n\u2022 Has the value\n\n\ud835\udc51\ud835\udc5b \ud835\udc51\ud835\udc5b\u22121 \u2026 \ud835\udc511 \ud835\udc510\n\n\ud835\udc51\ud835\udc5b \u00d7 16\ud835\udc5b + \ud835\udc51\ud835\udc5b\u22121 \u00d7 16\ud835\udc5b\u22121 + \u22ef + \ud835\udc511 \u00d7 161 + \ud835\udc510 \u00d7 160\n\u2022 Using \ud835\udc5b digits we can represent \ud835\udfcf\ud835\udfd4\ud835\udc5b different numbers\n\u2022 The smallest non-negative number representable with \ud835\udc5b digits is 0\n\u2022 The largest number representable with \ud835\udc5b digits is 16\ud835\udc5b \u2212 1\n\u2022 Using 16 symbols: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F\n23\n\n\fWhy?\n\n1111 1111\n1 \u00d7 27 + 1 \u00d7 26 + 1 \u00d7 25 + 1 \u00d7 24 + 1 \u00d7 23 + 1 \u00d7 22 + 1 \u00d7 21 + 1 \u00d7 20\n\n1 \u00d7 23 + 1 \u00d7 22 + 1 \u00d7 21 + 1 \u00d7 20 =\n8+4+2+1=\n15\n1 \u00d7 23 + 1 \u00d7 22 + 1 \u00d7 21 + 1 \u00d7 20 \u00d7 24 + 15\nThis works with any\nbase that is a power\nof 2\n\n15 \u00d7 161 + 15 \u00d7 160\n\nE.g. Base 4=22\nSplit into groups of 2\nbits\n\nF\n\nF\n\nFactoring\n\n24 = 16\n24\n\n\fInteger Encoding\nCasting is Not Just a Witch or Wizard Thing\n\n25\n\n\fFinite numbers\n\u2022 In computers, numbers are finite.\n\u2022 Let's say our 4-digit display was counting up:\n9997, 9998, 9999\u2026\n\u2022 What comes \"next\"?\n\u2022 What does this \"0000\" really mean?\n\u2022 It wrapped around.\n\n\u2022 This is overflow: the number you are trying\nto represent is too big to be represented.\n\u2022 Essentially, all arithmetic on the computer is modular arithmetic!\n\u2022 This causes a lot of software bugs.\n\u2022 https://en.wikipedia.org/wiki/Pac-Man#Level_256\n26\n\n\fNumber carrousel\n\u2022 Computers perform modulus arithmetic\n\u2022 Meaning: it goes around!\n\u2022 E.g. in a 4-bit computer\n\n15 0\n\n14 1111\n1110\n13 1101\n\n0000\n\n1001\n\n0001\n0010\n\n2\n\n0011\n\n12 1100\n1011\n11 1010\n10\n\n1\n\n0100\n0101\n0110\n0111\n\n3\n4\n5\n\n6\n\n0000\n8 7\n-0001\nwhat is 0 - 1?\n1111\n9\n\n1000\n\n27\n\n\fWhat about negative carrousels?\n\u2022 How much is 0 \u2013 1?\n\u2022 -1\n\n-1 0\n\n-2 1111\n1110\n-3 1101\n\n0000\n\n1001\n\n0001\n0010\n\n2\n\n0011\n\n-4 1100\n1011\n-5 1010\n-6\n\n1\n\n0100\n0101\n0110\n1000\n\n0111\n\n-7 -8 7\n\n3\n4\n5\n\n6\nWhy did we\nstop here?\n\n28\n\n\fSigned Numbers (2\u2019s Complement)\n\u2022 Representing negative numbers.\n\u2022 But it\u2019s a little strange!\n\n\u2022 Hmm, it\u2019s a little lopsided: -4 doesn\u2019t have a valid positive number.\n\n100\n\n101\n\n110\n\n000\n010\n111\n001\n011\n\n-4 -3 -2 -1 0 +1 +2 +3\n2\u2019s Complement\n\n\u2022 I can tell it\u2019s negative if it starts with a 1 \u263a\n\u2022 And if it\u2019s positive, then I can clearly see how much it\u2019s worth!\n\n\u2022 But how exactly\u2026 can we tell the value of a negative number?\n\u2022 We need to negate (flip the sign) negative numbers\n\u2022 But HOW????\n\n29\n\n\fTwo\u2019s complement arithmetic\n\u2022 Negation\n\n-(3)\n\n0011\n\n-(-3)\n\n1101\n\nbit pattern for\npositive 3?\nbit pattern for\nnegative 3?\n\nflip!\n\nflip!\n\n1100\n\n0010\n\n1101\n\nAdd 1!\n\n0011\n\nAdd 1!\n\n\u2022 You don\u2019t need to subtract!!\n\u2022 flip(k)+1 == flip(k-1)\n\u2022 If you ignore the carry! \u263a\n\n30\n\n\fTwo's complement addition\n\u2022 the great thing is: you can add numbers of either sign without having to do\nanything special!\nto binary? 0111\n\n3\n+ 7\n10\n\nIgnore the carry\n\nbit pattern for\n-7\u2026 positive 7?\n\n0011\n3\n+0111 +-7\n1010 -4\n\n0011\n0011\n0111\n4\nflip!\n+1 +1001\nto decimal?\n1000\n1100 0100\nthis is negative, so\nwhat is it? flip!\n\nthe actual patterns of bits are the same.\nso how does the computer \"know\" whether it's\ndoing signed or unsigned addition?\n\n+1\n\n0011\n31\n\n\fSigned Numbers (2\u2019s Complement)\n\u2022 Let\u2019s look some examples:\n\n11010100\u2794-(00101011+1)\u2794-(43+1)=-44\n00100110 = 00100110 = 38\n\n00000000 = 00000000= 0\n11111111= -00000000=-(0+1) =-1\n\u2022 If the MSB is 1: Flip! Add one!\n\u2022 Otherwise: Do nothing! It\u2019s the same!\n\n32\n\n\fSigned Numbers (2\u2019s Complement)\n\u2022 What happens when we add zeros to a positive number:\n\n10100110 = ?\n00100110 = 38\n-(01011001+1) = ?\n0000000000100110 = 38?\n-01011010 = -90\n?\n\u2022 What happens when we add ones to a negative number:\n\n10100110 = -90\n?\n11111111110100110 =\n-00000000001011001 = -90\n?\n\n33\n\n\fCan I Get an Extension?\n\u2022 Sometimes you need to widen a number with fewer bits to\nmore\n\u2022 zero extension is easy: put 0s at the beginning.\n\n10012 \u2794 to 8 bits \u2794 0000 10012\n\u2022 But there are also signed numbers\u2026 what about those?\n\u2022 The top bit (MSB) of signed numbers determines the sign (+/-)\n\n\u2022 sign extension puts copies of the sign bit at the beginning\n\n10012 \u2794 to 8 bits \u2794 1111 10012\n00102 \u2794 to 8 bits \u2794 0000 00102\nQ: What happens when you sign extend the largest unsigned value? 34\n\n\fAbsolutely Bonkers\n\nQ: How many bits is a Java\n\n? What happened here? 35\n\n\fInteger Ranges\n\u2022 Recall:\n\u2022 The range of an unsigned integer is 0 to 2n \u2013 1\n\u2022 Q: Why do we subtract 1?\n\n\u2022 What is the range of a 2\u2019s complement number?\n\u2022 Consider the sign bit, how many negative integers?\n\u2022 Consider, now, the positive integers.\n\u2022 Remember 0.\n\n-2n-1 to 2n-1 \u2013 1\nQ: What if you needed CS/COE\na range\nwith\nfar more negatives than positives? 36\n0449 \u2013 Spring\n2019/2020\n\n\fIntegers in Java C\n\u2022 C allows for variables to be declared as either signed or unsigned.\n\n\u2022 Remember: \u201csigned\u201d does not mean \u201cnegative\u201d just that it can be negative.\n\n\u2022 An unsigned integer variable has a range from 0 to 2n \u2013 1\n\u2022 And signed integers are usually 2\u2019s complement: 2n-1 to 2n-1 \u2013 1\n\u2022 Where \u201cn\u201d is determined by the variable\u2019s size in bits.\n\n\u2022 Integer Types: (signed by default, their sizes are arbitrary!!)\n\u2022\n\u2022\n\u2022\n\u2022\n\n\u2022 Usually no strong reason to use anything other than (un)signed int.\nQ: What is the range of a\n\n? 37\n\n\fIntegers in C: Limits\n\u2022 Since sizes of integers are technically arbitrary\u2026\n\n\u2022 They are usually based on the underlying architecture.\n\n\u2022 \u2026 C provides standard library constants defining the ranges.\n\n\u2022 https://pubs.opengroup.org/onlinepubs/009695399/basedefs/limits.h.html\n\nQ: Experiment\nusing\nCS/COEwith\n0449 \u2013 Spring\n2019/2020\n\nfor both. What is the result? 38\n\n\fCasting\n\u2022 C lets you move a value from an unsigned integer variable to a signed\ninteger variable. (and vice versa)\n\u2022 However, this is not always valid! Yet, it will do it anyway.\n\u2022 The binary value is the same, its interpretation is not!\n\u2022 This is called coercion, and this is a relatively simple case of it.\n\n\u2022 Since it ignores obvious invalid operations this is sometimes referred to as \u201cweak\u201d\ntyping.\n\u2022 The strong/weak terminology has had very fragile definitions over the years and\nare arguably useless in our context. Let\u2019s ignore them.\n\n\u2022 Moving values between different types is called casting\n\u2022 Which sounds magical and it sometimes is.\nQ: What is true of the result\nthe value -1 to an unsigned type? 39\nCS/COE of\n0449casting\n\u2013 Spring 2019/2020\n\n\fFractional Binary\n\n40\n\n\fFractional numbers\n\u2022 Up to this point we have been working with integer numbers.\n\n2019\n2 0 1 9.320\n\n\u2022 Unsigned and signed!\n\n\u2022 However, Real world numbers are\u2026 Real numbers. Like so:\n\n\u2022 That create new challenges!\n\n\u2022 Let\u2019s start by taking a look at them.\n41\n\n\fJust a fraction of a number\n\u2022 The numbers we use are written positionally: the position of a digit\nwithin the number has a meaning.\n\u2022 What about when the numbers go over the decimal point?\n\n?\n2 0 1 9. 3 2 0\n\n1000s\n\n100s\n\n10s\n\n1s\n\n10ths 100ths 1000ths\n\n103\n\n102\n\n101\n\n100\n\n10-1\n\n10-2\n\n10-3\n\n42\n\n\fA fraction of a bit?\n\u2022 Binary is the same!\n\u2022 Just replace 10s with 2s.\n\n0 1 1 0 .1 1 0 1\n23\n8s\n\n22\n4s\n\n21\n2s\n\n20\n1s\n\n2-1\n2ths\n\n?\n\n2-2\n4ths\n\n2-3\n8ths\n\n2-4\n16ths\n\n43\n\n\fTo convert into decimal, just add stuff\n\n0 1 1 0 .1 1 0 1=\n23\n\n22\n\n21\n\n20\n0\u00d78+\n1\u00d74+\n1\u00d72+\n0\u00d71+\n1 \u00d7 .5 +\n1 \u00d7 .25 +\n0 \u00d7 .125 +\n1 \u00d7 .0625\n\n2-1\n\n2-2\n\n2-3\n\n2-4\n\n= 6.812510\n44\n\n\fFrom decimal to binary? Tricky?\n\n6.8125 10\n6\u00f7210 = 3R0\n3\u00f7210 = 1R1\n\n1 1 0.1101\n\n0.812510\nx\n2\n1.6250\n\nMSB\n\n0.625010\nx\n2\n1.2500\n0.250010\nx\n2\n0.5000\n0.500010\nx\n2\n1.0000\n\nLSB\n\n45\n\n\fSo, it\u2019s easy right? Well\u2026\n\nWhat about: 0.1 10\n\n0.110\nx 2\n0.2\n0.210\nx2\n0.4\n\n0.0001\n\n0.410\nx 2\n0.8\n\n0.810\nx 2\n1.6\n\n46\n\n\fSo, it\u2019s easy right? Well\u2026\u2026\n\nWhat about: 0.1 10\n\n0.0001\n1001\n\n0.610\nx 2\n1.2\n\n0.110\nx 2\n0.2\n\n0.210\nx2\n0.4\n\n0.210\nx2\n0.4\n\n0.410\nx 2\n0.8\n\n0.410\nx 2\n0.8\n\n0.810\nx 2\n1.6\n\n0.810\nx 2\n1.6\n\n47\n\n\fSo, it\u2019s easy right? Well\u2026\u2026\u2026\n\nWhat about: 0.1 10\n\n0.0001\n1001\n10\n0\n1\n...\n\n0.610\nx 2\n1.2\n\n0.610\nx 2\n1.2\n\n0.110\nx 2\n0.2\n\n0.210\nx2\n0.4\n\n0.210\nx2\n0.4\n\n0.210\nx2\n0.4\n\n0.410\nx 2\n0.8\n\n0.410\nx 2\n0.8\n\n0.410\nx 2\n0.8\n\n0.810\nx 2\n1.6\n\n0.810\nx 2\n1.6\n\n0.810\nx 2\n1.6\n\n48\n\n\fHow much is it worth?\n\n\u2022Well, it depends on where you stop!\n\n0.0001 2\n\n= 0.0625\n\n0.00011001 2\n\n= 0.0976\u2026\n\n0.000110011001 2 = 0.0998\u2026\n49\n\n\fLimited space!\n\u2022 How much should we store?\n\u2022 We have 32-bit registers, so 32-bits?\n\u2022 Let\u2019s say we do!\n\n\u2022 How many bits are used to store the integer part?\n\u2022 How many bits are used to store the fractional part?\n\n\u2022 What are the tradeoffs?\n50\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}