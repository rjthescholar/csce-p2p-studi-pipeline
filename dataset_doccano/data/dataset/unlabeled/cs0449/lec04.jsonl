{"id": 162, "segment": "unlabeled", "course": "cs0449", "lec": "lec04", "text": "3\n\nIntroduction\nto C\n\nCS/COE 0449\nIntroduction to\nSystems Software\n\nLuis Oliveira\n(with content borrowed from wilkie and Vinicius Petrucci)\n\n\fOverview of C\nWhat You C is What You Get\n\n2\n\n\fC: The Universal Assembly Language\nC is not a \u201cvery high-level\u201d language, nor\na \u201cbig\u201d one, and is not specialized to any\nparticular area of application. But its\nabsence of restrictions and its generality\nmake it more convenient and effective\nfor many tasks than supposedly more\npowerful languages.\n\u2014 Kernighan and Ritchie\n\n\u2022 Allows writing programs to exploit\nunderlying features of the architecture\n\u2013 memory management, special\ninstructions, parallelism.\n3\n\n\fC: Relevance\n\u2022 From IEEE Spectrum:\n\u2022 https://spectrum.ieee.org/static/interacti\nve-the-top-programming-languages-2019\n\n\u2022 Still relatively popular\u2026\n\u2022 Lots of legacy code.\n\u2022 Lots of embedded devices.\n\u2022 Python, Java, R, JS are all written in C.\n\n4\n\n\fTIOBE index\nTIOBE Programming Community index is an indicator of the popularity of programming languages\n\nhttps://www.tiobe.com/tiobe-index/\n\n\fCompilation\n\u2022 C is a compiled language.\n\u2022 Code is generally converted into machine code.\n\u2022 Java, by contrast, indirectly converts to machine code using a byte-code.\n\u2022 Python, by contrast to both, interprets the code.\n\n\u2022 The difference is in a trade-off about when and how to create a machine-level\nrepresentation of the source code.\n\u2022 A general C compiler will typically convert *.c source files into an intermediate *.o\nobject file. Then, it will link these together to form an executable.\n\u2022 Assembly is also part of this process, but it is done behind the scenes.\n\u2022 You can have gcc (a common C compiler) spit out the assembly if you want!\n\n6\n\n\fCompilation: Simple Overview \u2013 Step 1\n\u2022 The compiler takes source code (*.c\nfiles) and translates them into machine\ncode.\n\nhello.c\n\nhello.o\n\n\u2022 This file is called an \u201cobject file\u201d and is\njust potentially one part of your overall\nproject.\n\u2022 The machine code is not quite an\nexecutable.\n\u2022 This object file is JUST representing the\ncode for that particular source file.\n\u2022 You may require extra stuff provided by\nthe system elsewhere.\n\n7\n\n\fCompilation: Simple Overview \u2013 Step 2\n\u2022 You may have multiple files.\n\u2022 They may reference each other.\n\u2022 For instance, one file may contain certain\ncommon functionality and then this is\ninvoked by your program elsewhere.\nhello.c\n\nhello.o\n\n\u2022 You break your project up into pieces\nsimilarly to your Java programs.\n\u2022 The compiler treats them\nindependently.\nutil.c\nCS/COE 0449 \u2013 Spring 2019/2020\n\nutil.o\n8\n\n\fCompilation: Simple Overview \u2013 Step 3\n\u2022 Then, each piece is\nmerged together to form\nthe executable.\n\u2022 This process is called\nlinking.\nhello.c\n\nhello.o\n\nutil.c\n\nutil.o\n\nhello\n\nstdio.o\nExternal Libraries\n\n\u2022 The name refers to how\nthe references to\nfunctions, etc, between\nfiles are now filled in.\n\u2022 Before this step\u2026 it is\nunclear where functions\nwill end up in the final\nexecutable.\n\u2022 Keep this in mind as we\nlook at memory and\npointers later!\n9\n\n\fIt's just a grinder.\n\u2022 In summary:\n\nhello.c\n\ncode goes in, sausage object\nfiles come out\n\nSome compilers output\nassembly and rely on an\nassembler to produce\nmachine code\nThese days, it's common\nfor the compiler itself to\nproduce machine code,\nor some kind of\nplatform-independent\nassembly code\n(typically: a bytecode)\n10\n\n\fCompilation vs. Interpretation\nC (compiled)\n\nPython (interpreted)\n\n\u2022 Compiler + Linker translates code\ninto machine code.\n\n\u2022 Interpreter is written in some\nlanguage (e.g. C) that is itself\ntranslated into machine code.\n\n\u2022 Machine code can be directly\nloaded by the OS and executed by\nthe hardware. Fast!!\n\u2022 New hardware targets require\nrecompilation in order to execute\non those new systems.\n\n\u2022 The Python source code is then\nexecuted as it is read by the\ninterpreter. Usually slower.\n\n\u2022 Very portable! No reliance on\nhardware beyond the interpreter.\n11\n\n\fCompilation vs. Virtual Targets (bytecode)\n\u2022 Java translates source to a \u201cbyte code\u201d which is a made-up architecture, but it\nresembles machine code somewhat.\n\u2022 Technically, architectures could execute this byte code directly.\n\u2022 But these were never successful or practical.\n\n\u2022 Instead, a type of virtual machine simulates that pseudo-architecture. (interpretation)\n\u2022 Periodically, the fake byte code is translated into machine code.\n\u2022 This is a type of delayed compilation! Just-In-Time (JIT) compilation.\n\n\u2022 This is a compromise to either approach.\n\u2022 Surprisingly very competitive in speed.\n\u2022 I don\u2019t think the JVM-style JIT is going away any time soon.\n\n12\n\n\fC vs. Java\nC (C99)\n\nJava\n\nType of\nLanguage\n\nFunction Oriented\n\nObject Oriented\n\nProgramming\nUnit\n\nFunction\n\nClass = Abstract Data Type\n\nCompilation\n\ngcc hello.c - creates machine\nlanguage code\n\njavac Hello.java - creates Java virtual machine\nlanguage bytecode\n\nExecution\n\na.out - loads and executes\nprogram\n\njava Hello - interprets bytecodes\n\nManual (malloc, free)\n\nAutomatic (garbage collection)\n\nhello, world\n\nStorage\n\nFrom http://www.cs.princeton.edu/introcs/faq/c2java.html\n\n13\n\n\fC vs. Java\nC (C99)\nor\n\nComments\n\nJava\n\n\u2026 end of line\n\nor\n\n\u2026 end of line\n\nConstants\nPreprocessor Yes\n\nNo\n\nVariable\ndeclaration\n\nBefore you use it\n\nAt beginning of a block\n\nVariable\nnaming\nconventions\nAccessing a\nlibrary\nFrom http://www.cs.princeton.edu/introcs/faq/c2java.html\n\n14\n\n\fHello World\n\n15\n\n\fC Dialects\n\u2022 You will see a lot of different styles of C in the world at large.\n\u2022 The syntax has changed very little.\n\n\u2022 There have been a few different standard revisions.\n\u2022 C89 \u2013 ANSI / ISO C\n\u2022\n\n\u2013\n\n\u2013\n\n\u2022 C99 \u2013 Adds \u2018complex\u2019 numbers and single-line comments\n\u2022\n\n\u2013\n\n\u2022 C11 \u2013 Newer than 99 (laughs in Y2K bug) starts to standardize\nUnicode and threading libraries.\n\u2022\n\n\u2013\n\n\u2022 C18 \u2013 Minor refinement of C11. The current C standard.\n\u2022\n\n\u2013\n\n\u2022 We will more or less focus on the C99 standard in our course.\n\u2022 I\u2019ll try to point out some newer things if they are relevant.\n16\n\n\fThe C Syntax\nNothing can be said to be certain, except death and C-like syntaxes.\n\n17\n\n\fThe C Pre-Processor\n\u2022 The C language is incredibly simplistic.\n\u2022 To add some constrained complexity, there is a macro language.\n\u2022 This code does not get translated to machine code, but to more code!\n\n18\n\n\fThe \u201cmain\u201d function\n\n19\n\n\fDeclaring variables\n\n20\n\n\fCasting\n\n21\n\n\fInteger Sizes \u2013 Revisted: sizeof\n\n22\n\n\fInteger Sizes \u2013 Revisted\n\n23\n\n\fIntegers: Python vs. Java vs. C\nLanguage\nPython\nJava\nC\n\nsizeof(int)\n>=32 bits (plain ints), infinite (long ints)\n32 bits\nDepends on computer; 16 or 32 or 64\n\n\u2022 C:\n\u2022 integer type that target processor works with most efficiently\n\u2022 For modern C, this is generally a good-enough default choice.\n\n\u2022 Only guarantee:\n\u2022\n\u2265\n\u2022 Also,\n>= 16 bits,\n\u2022 All could be 64 bits\n\n\u2265\n\n\u2265\n\n>= 32 bits\n\n\u2022 Impacts portability between architectures\n24\n\n\fConstants\n\n25\n\n\fEnumerations\n\n26\n\n\fOperators: Java stole \u2018em from here\n\n27\n\n\fAugmented Operators\n\n\u2013\n\n28\n\n\fExpressions: an expression of frustration!!\n\n\u2022 C often coerces (implicitly casts) integers when operating on them.\n\u2022 To remove ambiguity, expressions, such as\nmost accommodates that operation.\n\n, result in a type that\n\n\u2022 Specifically, C will coerce all inputs of binary operators to at least\nan\ntype.\n\u2022 You\u2019ll find that \u201cthis is weird, but consistent\u201d is C\u2019s general motto\n\n29\n\n\fThe C Syntax: Control Flow\nOnce you C the program, you can BE the program.\n\n30\n\n\fControlling the flow: an intro to spaghetti\n\n31\n\n\fControlling the flow: Boolean Expressions\n\u2022 C does not have a Boolean type!\n\u2022 However, the C99 and newer standard library provides one in\n\n\u2022 The Boolean expressions are actually just an\n\ntype.\n\n\u2022 It is just the general, default type. Weird but consistent, yet again!\n\n32\n\n\fControlling the flow: Putting it Together\n\u2022\n\nstatements therefore take an\n\nand not a Boolean, as an expression.\n\n\u2022 If the expression is it is considered false.\n\u2022 Otherwise, it is considered true.\n\n33\n\n\fThrowing us all for a loop\n\n\u2022 Most loops (while, do) work exactly like Java.\n\u2022 Except, of course, the expressions are\n\ntyped, like\n\nstatements.\n\n\u2022 For loops only come in the traditional variety:\n\u2022\n\u2022 C89 does not allow variable declaration within:\n\u2022 ERROR:\n\n\u2022 However, C99 and newer does allow this. Please do it.\n\n\u2022 Loops have special statements that alter the flow:\n\u2022\n\u2022\n\nwill end the current iteration and start the next.\nwill exit the loop entirely.\n34\n\n\fLoop Refresher: While, Do-While, For Loops\n\n35\n\n\fTaking a break and switching it up\n\u2022 The\nproperly.\n\nstatement requires proper placement of\n\n\u2022 Starts at\nmatching expression and follows until it sees a\n\u2022 It will \u201cfall through\u201d other\nstatements if there is no\n\nto work\n.\nbetween them.\n\n\u2022 Sometimes fall through is used on purpose... but it\u2019s a bug 99% of the time :/\n36\n\n\fControl Flow: Summary\n\u2022 Conditional Blocks:\n\nNote: a\n\ncan be a { block }\n\n\u2022\n\u2022\n\u2022 The if statement can be chained:\n\n\u2022 Conventional Loops:\n\u2022\n\u2022\n37\n\n\fControl Flow: Summary\n\u2022 For Loops:\n\nNote: a\n\ncan be a { block }\n\n\u2022\n\u2022\n\u2022\n\n\u2022 Switch:\n\u2022\n\n\u2022\n38\n\n\fWhat\u2019s your function?\n\u2022 Familiar: Java is, once again, C-like\n\u2022 You declare the return type\nbefore the name.\n\u2022\n\nis used when there is nothing\nreturned\n\u2022 It is also used to explicitly denote\nthere being no arguments.\n\u2022 You SHOULD specify\ninstead\nof having an empty list.\n\n\u2022 Functions must be declared\nbefore they can be used.\n\u2022 We will look at how we divide\nfunctions up between files soon!\n\n39\n\n\fThis is all the structure you get, kid\n\u2022 C gives us a very simple method of defining aggregate data types.\n\u2022 The struct keyword can combine several data types together:\n\n40\n\n\fI don\u2019t like all that typing\u2026 So I\u2019ll\u2026 typedef it\n\u2022 To avoid typing the full name \u201cstruct Song\u201d we can create a Song type instead.\n\u2022 The typedef keyword defines new types.\n\n41\n\n\fI don\u2019t like all that typing\u2026 So I\u2019ll\u2026 typedef it\n\u2022 You can also do this with integer types, for instance to define bool:\n\n\u2022 And\n\ntypes, although it won\u2019t complain if you mix/match them:\n\n\u2022 Now, functions can better illustrate they take an enum value:\n\u2022 Though, it accepts any integer and, yikes, any enum value without complaint!\n\n42\n\n\fThat\u2019s seriously all you get\u2026\n\u2022 Unlike Java, C is not Object-Oriented and has no class instantiation.\n\u2022 That\u2019s C++!\n\n43\n\n\fGarbage in, garbage out: initialization\n\u2022 As we saw earlier, variables don\u2019t require initialization.\n\u2022 However, unlike Java, the variables do not have a default value.\n\u2022 Java will initialize integers to 0 if you do not specify.\n\u2022 C, on the other hand\u2026\n\n\u2022 The default values for variables are undefined.\n\u2022 They could be anything.\n\u2022 The Operating System ultimately decides.\n\u2022 Generally, whatever memory is left over. Also known as \u201cgarbage.\u201d\n\n\u2022 ALWAYS INITIALIZE YOUR VARIABLES\n44\n\n\fThe trouble is stacking up on us!\n\nQ: Hmm. Where is the value for \u2018x\u2019 coming from? Why?\n\n45\n\n\fWhere\u2019s that data coming from??\n\u2022 Every variable and data in your program technically has a location in which it\nlives.\n\u2022 In the previous nonsense example, the \u201cx\u201d variable was sharing the same space\nas the \u201ca\u201d variable from the other function.\n\u2022 The section of incremental memory called the stack, in this specific case.\n\u2022 This is not defined behavior of the language, but rather the OS.\n\n\u2022 C does not impose many rules on how memory is laid out and used.\n\u2022 In fact, it gets right out of the way and lets you fall flat on your face.\n\n\u2022 Now, we will take a deeper dive into\u2026\n\nMEMORY\n46\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}