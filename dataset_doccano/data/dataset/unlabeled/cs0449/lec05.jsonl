{"id": 134, "segment": "unlabeled", "course": "cs0449", "lec": "lec05", "text": "5\n\nIntroduction\nto Memory\n\nCS/COE 0449\nIntroduction to\nSystems Software\n\nLuis Oliveira\n(with content borrowed from wilkie and Vinicius Petrucci)\n\n\fThe Memory Model\nIf you forget how addressing works, I have a few pointers for you.\n\n2\n\n\fThe C Memory Model\n\u2022 Memory is a continuous series of bits.\n\nPotential Layout\n(32-bit addresses)\n\n\u2022 It can be logically divided into bytes or words.\n\n\u2022 We will treat it as byte-addressable which\nmeans individual bytes can be read.\n\nstack\n\n\u2022 This is not always the case!!\n\u2022 Consider masking and shifting to know the\nworkaround!\n\ncurrently unused but\navailable memory\n\n\u2022 With byte-addressable memory, each and\nevery byte (8 bits) has its own unique\naddress.\n\u2022 It\u2019s the place it lives!! Memory is JUST LIKE US!\n\u2022 Address starts at 0, second byte is at address 1,\nand increases (\u201cupward\u201d) as you add new data.\n\nheap\nstatic data\n\ncode\n3\n\n\fThe C Memory Model\n\u2022 There are two main parts of a\nprogram: code and data\n\u2022 \u201ccode\u201d is sometimes called \u201ctext\u201d\n\n\u2022 Where in memory should each go?\n\u2022 Should we interleave them?\n\u2022 Which do you think is usually largest?\n\n\u2022 How do we use memory dynamically?\n\u2022 That is, only when we know we need it,\nin the moment.\n\nPotential Layout\n(32-bit addresses)\n\nstack\ncurrently unused but\navailable memory\n\nheap\nstatic data\n\ncode\n4\n\n\fThe C Memory Model: Code\n\u2022 Code has a few known properties:\n\nPotential Layout\n(32-bit addresses)\n\n\u2022 It likely should not change.\n\u2022 It must be loaded before a program can start.\n\nstack\ncurrently unused but\navailable memory\n\nheap\nstatic data\n\ncode\n5\n\n\fThe C Memory Model: Static Data\n\u2022 Static Data is an oft forgotten but useful section.\n\u2022 It does change. (contrary to its name)\n\u2022 It generally must be loaded before a program starts.\n\u2022 The size of the data and section is fixed.\n\nPotential Layout\n(32-bit addresses)\n\nstack\ncurrently unused but\navailable memory\n\nheap\nstatic data\n\ncode\n6\n\n\fThe C Memory Model: The Stack\n\u2022 The Stack is a space for temporary dynamic data.\n\u2022 Holds local variables and function arguments.\n\u2022 Allocated when functions are called. Freed on return.\n\u2022 Grows \u201cdownward\u201d! (Allocates lower addresses)\n\nPotential Layout\n(32-bit addresses)\n\nstack\ncurrently unused but\navailable memory\n\nheap\nStack Allocation allows\nrecursion. However, the more\nyou recurse, the more you\nuse! (Stack is only freed on return)\n\nstatic data\n\ncode\n7\n\n\fRevisiting our past troubles:\n\n4. Stack Allocation (No initialization!)\nIt reuses what is already there!!\n2. Stack Allocation\n\n1. Function Call\n3. Function Call\nQ: Hmm. Where is the value for \u2018x\u2019 coming from? Why?\n\n8\n\n\fThe C Memory Model: The Heap\n\u2022 The Heap is the dynamic data section!\n\u2022 Managing this memory can be very complex.\n\u2022 No garbage collection provided!!\n\u2022 We will revisit it in greater detail very soon.\n\nPotential Layout\n(32-bit addresses)\n\nstack\ncurrently unused but\navailable memory\n\nheap\nstatic data\n\ncode\n\ud83d\ude31\n\n9\n\n\fCan an emoji be a variable name?\nThe questions that really matter \ud83d\ude03\nCompiler and version\n\nSuccess\n\ngcc main.c -std=c99\n\n\ud83d\ude14\n\ngcc main.c -std=c11\n\n\ud83d\ude14\n\ngcc main.c -std=c18\n\n\ud83d\ude14\n\nclang main.c -std=c99\n\n\ud83d\ude14\n\nclang main.c -std=c11\n\n\ud83d\ude03\n\nclang main.c -std=c18\n\n\ud83d\ude03\n\n#include <stdio.h>\nint main(void) {\nint \ud83d\ude31 = 3;\nprintf(\"\ud83d\ude31 is %d\\n\", \ud83d\ude31);\nreturn 0;\n}\nlun8@thoth:~/code_449$ ./Hello\n\ud83d\ude31 is 3\n\nAnswer: So\u2026 Not really, so avoid it (unless it\u2019s for fun)!\n10\n\n\fPointers\nThey point to things. They are not the things. But they are things!?\n\n11\n\n\fThe \u201cMemory Address\u201d Variable Type\n\u2022 In C, we have integer types, floating point types\u2026\n\u2022 Now we introduce our dedicated address type!\n\u2022 A pointer is a specific variable type that holds a memory address.\n\n\u2022 You can create a pointer that points to any address in memory.\n\u2022 Furthermore, you can tell it what type of data it should interpret that\nmemory to be: Just place that\nat the end.\n\n12\n\n\fInterpreting Pointers: Basics\n\ud83d\udc49\n\n\ud83d\udc49\n\nMemory\n(32-bit addresses)\n\n3.14159\n\n42\n\n\u2022 Pointers can pointer to individual sections of\nmemory.\n\u2022 They interpret whatever binary information is there.\n13\n\n\fInterpreting Pointers: Hmm\n\ud83d\udc49\n\n\ud83d\udc49\n\nMemory\n(32-bit addresses)\n\n3.14159\n\n42 or 0.1543e10(-8) ?\n\n\u2022 Pointers can refer to the same address as other\npointers just fine.\n\u2022 They interpret whatever binary information is\nthere.\n\n14\n\n\fInterpreting Pointers: A Sign of Trouble\n\ud83d\udc49\n\nMemory\n(32-bit addresses)\n\nHelp I\u2019m Lost!\n\n\ud83d\udc49\n\n3.14159\n\n\uf04c\n\n42 or 0.1543e10(-8) ?\n\n\u2022 Without the pointer, allocated data may linger\nforever without a way to reference it again!\n\u2022 C does not manage freeing memory for you.\n15\n\n\fDereferencing Pointers: A Star is Born\n\u2022 So, we have some ambiguity in our language.\n\u2022 If we have a variable that holds an address, normal operations\nchange the address not the value referenced by the pointer.\n\u2022 We use the dereference operator (\n\n)\n\n\ud83d\udc49\n\n\ud83d\udc49\n\ud83d\udc49\n\n\ud83d\udc49\n16\n\n\fDereferencing Pointers: A Star is Born\n\u2022 Remember: C implicitly coerces whatever values you throw at it\u2026\n\u2022 Incorrectly assigning a value to an address or vice versa will be\u2026\n\u2022 \u2026 Well \u2026 It will be surprising to say the least.\n\n\u2022 Generally, compilers will issue a warning.\n\u2022 But warnings mean it still compiles!! (You should eliminate warnings in practice)\n\n\ud83d\udc49\n\ud83d\udc49\n\ud83d\udc49 \ud83e\udd14\n\ud83d\udc49\n\n\ud83d\udc49\n\n17\n\n\fReferencing Data: An\u2026 &\u2026 is Born?\n\u2022 Again\u2026 ambiguity. When do you want the address or the data?\n\u2022 We can pull out the address to data and assign that to a pointer.\n\u2022 Sometimes we refer to pointers as \u2018references\u2019 to data.\n\n\u2022 We use the reference operator (\n\n)\n\n\ud83d\udc49\n\n\ud83d\udc49\n\ud83d\udc49\n18\n\n\fTurtles all the way down\n\ud83d\udc49_\n\n\ud83d\udc49_\ud83d\udc49_\n\n\ud83d\udc49_\n\n\ud83d\udc49_\n\n\ud83d\udc49_\ud83d\udc49_\n\ud83d\udc49_\ud83d\udc49_\n\n19\n\n\fRemoving the emoji\n\n20\n\n\fLike skipping rocks on the lake\u2026\n\n00\n\n01\n\n02\n\n03\n\n04\n\n05\n\n06\n\n42\n\n07\n\n08\n\n09\n\n0A\n\n0B\n\n0C\n\n0D\n\n0E\n\n0F\n\n10\n\n11\n\n12\n\n13\n\n4\ndata\n\ndataptr\n21\n\n\fLike skipping rocks on the lake\u2026\n\n00\n\n01\n\n02\n\n03\n\n04\n\n05\n\n06\n\n42\n\n07\n\n08\n\n09\n\n0A\n\n0B\n\n0C\n\n4\ndata\n\n0D\n\n0E\n\n0F\n\n10\n\n11\n\n12\n\n13\n\nA\ndataptr\n\ndataptrptr\n22\n\n\fThe C Memory Model: The Heap\n\u2022 The Heap is the dynamic data section!\n\u2022 You interact with the heap entirely with pointers.\n\u2022\nreturns the address to the heap with at\nleast the number of bytes requested. Or\non\nerror.\n\nPotential Layout\n(32-bit addresses)\n\nstack\ncurrently unused but\navailable memory\n\nheap\nstatic data\n\ncode\n23\n\n\fArrays\nIt is what all my fellow teachers desperately need: Arrays.\n\n24\n\n\fMany ducks lined up in a row\n\u2022 An array is simply a continuous span of memory.\n\n\u2022 You can declare an array on the stack:\n\n\u2022 You can declare an array on the heap:\n\nwriting in a pedantic style, you\nwould write the cast here.\n\n25\n\n\fInitialization\n\u2022 You can initialize them depending on how they are allocated:\n\u2022 You can initialize an array as it is allocated on the stack:\n\n\u2022 And the heap (for values other than 0, you\u2019ll need a loop):\n\nQ: Why is using\n\nimportant here?\n\n26\n\n\fCarelessness means the Stack; Can stab you in the back!\n\u2014 \u201cA poem about betrayal\u201d by wilkie\n\n\u2022 Remember: Variables declared on the stack are temporary.\n\u2022 All arrays can be considered pointers, but addresses to the stack are not\nreliable:\n\nStack allocation\nArrays are indeed just pointers! This is an address on the stack.\nStack deallocation (oh no!)\n\n\u2022 This may work sometimes.\n\n\u2022 However calling a new function will overwrite the array. Don\u2019t trust it!!\n\n\u2022 Instead: Allocate on the heap and pass in a buffer. (next slide)\n27\n\n\fAppropriate use of arrays. Approp-array-te.\nArrays don\u2019t store length. Gotta pass it in.\nPointers allow for passing arguments \u201cby reference\u201d\n\nPointers can indeed be array-like!\n\nHeap allocation!\nAlthough we overwrite all values, using calloc to\ninitialize array elements to 0 reduces surprises.\nQ: What happens if we pass 20 instead of 10 to powers_of_two?\n\n28\n\n\fQuick notes on function arguments, here\u2026\n\u2022 All arguments are passed \u201cby value\u201d in C.\n\u2022 This means the values are copied into temporary space (the stack, usually)\nwhen the functions are called.\n\u2022 This means changing those values does not change their original sources.\n\n\u2022 However, we can pass \u201cby reference\u201d indirectly using pointers:\n\u2022 Similar to how you pass \u201cby reference\u201d in Java by using arrays.\nThe \u201cvalue\u201d of the argument is the address.\n\n29\n\n\fCareful! No guard rails\u2026 You might run off the edge\u2026\n\u2022 Since arrays are just pointers\u2026 and the length is not known\u2026\n\u2022 Accessing any element is correct regardless of actual intended length!\n\u2022 No array bounds checking is the source of many very serious bugs!\n\u2022 Can pull out and leak arbitrary memory.\n\u2022 Can potentially cause the program to execute arbitrarily code.\n\nWhat if this is too big?\n\nA simple mistake, but it will gleefully write to it!\n\n30\n\n\fPointer arithmetic (Warning: it\u2019s wacky)\n\u2022 Because pointers and arrays are essentially the same concept in C\u2026\n\u2022 Pointers have some strange interactions with math operations.\n\n\u2022 Ideally pointers should \u201calign\u201d to their values in memory.\n\u2022 Goal: Incrementing an\npointer should go to the next\n\u2022 That is, not part way between two\nvalues.\n\nin memory.\n\n\u2022 Therefore, pointer sum is scaled to the element size.\n\u2022 Multiplication and other operators are undefined and result in a compiler\nerror.\n\n31\n\n\fPointer arithmetic in practice:\nAlternative (and less common) way of expressing a pointer.\n\nThe\n(postfix-increment) happens AFTER the dereference.\nThis is defined by the C language and is really confusing in practice.\n(but you\u2019ll see it. often.)\n\n32\n\n\fThe C Memory Model: The Heap\n\u2022 The Heap is the dynamic data section!\n\u2022 You interact with the heap entirely with pointers.\n\u2022\nreturns the address to the heap with at least the\nnumber of bytes requested. Or\non error.\n\nPotential Layout\n(32-bit addresses)\n\nstack\ncurrently unused but\navailable memory\n\nheap\nstatic data\n\ncode\n33\n\n\fStrings\nNo longer just for cats!\n\n34\n\n\fStrings\n\u2022 They are arrays and, as such, inherit all their limitations/issues.\n\u2022 The size is not stored.\n\u2022 They are essentially just pointers to memory.\n\n\u2022 Text is represented as an array of\n\nelements.\n\n\u2022 Representing text is hard!!!\n\u2022 Understatement of the dang century.\n\u2022 Original ASCII is 7-bit, encodes Latin and Greek\n\u2022 Hence\n\nbeing the C integer byte type.\n\n\u2022 Extended for various locales haphazardly.\n\u2022 7-bits woefully inadequate for certain languages.\n\n\u2022 Unicode mostly successfully unifies a variety of glyphs.\n\u2022 Tens of thousands of different characters! More than a byte!!\n\n35\n\n\fHow long is your string?\n\u2022 Arrays in C are just pointers and as such do not store their length.\n\u2022 They are simply continuous sections of memory!\n\u2022 Up to you to figure out how long it is!\n\u2022 Misreporting or assuming length is often a big source of bugs!\n\n\u2022 So, there are two common ways of expressing length:\n\u2022 Storing the length alongside the array.\n\u2022 Storing a special value within the array to mark the end. (A sentinel\nvalue)\n\n\u2022 Strings in C commonly employ a sentinel value.\n\u2022 Such a value must be something considered invalid for actual data.\n\u2022 How do you know how long such an array is?\n\u2022 You will have to search for the sentinel value! Incurring a \ud835\udc42(\ud835\udc5b) time cost.\n\n36\n\n\fThe string literal.\n\u2022 String literals should be familiar from Java.\n\u2022 However, in C, they are\npointers. (That is:\n)\n\u2022 The contents of the literal are read-only (immutable) so it is a:\n\u2022 Modifying it crashes your program!!\n\u2022 A pointer that can\u2019t change pointing to an immutable string is a\n\nLet\u2019s ignore this! \u263a\n(for now)\n\nThe variable is allocated on the stack,\nwhich is a pointer. The string itself is\n37\nlikely in the static data segment!\n\n\fHow long is your string? Let\u2019s find out.\n\u2022 The\n\nstandard library function reports the length of a string.\n\n\u2022 This is done in roughly \ud835\udc42(\ud835\udc5b) time as it must find the sentinel.\n\u2022 The following code investigates and prints out the sentinel:\n\n38\n\n\fWhen good strings go bad.\n\u2022 What happens if that sentinel\u2026 was not there?\n\u2022 Well\u2026 it would keep counting garbage memory until it sees a 0.\n\nThis syntax copies the string literal on to the stack.\nThis allows us to modify it. (otherwise, it is immutable)\n\nThe length here depends on the state of memory in the stack.\n\n39\n\n\fUsing stronger strings. A\u2026 rope\u2026 perhaps.\n\u2022 To ensure that malicious input is less likely to be disastrous\u2026\n\u2022 We have alternative standard functions that set a maximum length.\n\nstrnlen will stop after the 12th character if it does not see a sentinel.\n\n40\n\n\fComparing \u201cApples\u201d to \u201cOranges\u201d\n\u2022 When you compare strings using\n\nit compares the addresses!\n\n\u2022 Since string literals are constant, they only exist in the executable once.\n\u2022 All references will refer to the same string!\n\n41\n\n\fComparing \u201cApples\u201d to \u201cOranges\u201d\n\u2022 When the addresses differ, they are not equal.\n\u2022 So, you have to be careful when comparing them.\n\u2022 This is similar to Java when considering\nversus\n\n42\n\n\fComparing \u201cApples\u201d to \u201cOranges\u201d\n\u2022 To compare values instead, use the standard library\u2019s\n\n.\n\n\u2022 This will perform a byte-by-byte comparison of the string.\n\u2022 Upon finding a difference, it returns rough difference between those contrary bytes.\n\u2022 When they are the same, then the difference is 0!\n\n\u2022 Therefore, it is case sensitive! It also has a \ud835\udc42 \ud835\udc5b time complexity.\n\nwill return 0 when the strings\nare equal.\n\n43\n\n\fAppropriate string construction. A-rope-riate.\n\u2022 C is a very deliberate language.\nis important here! Ensures string has\na length of 0. (is initially empty, not garbage!)\nLike a ballroom. Empty, but spacious.\n\nis the bounded form of\nOverwrites string.\n\n.\n\nis the bounded form of\n.\nConcatenates to end of existing string.\n44\n\n\fMemory/Strings: Summary\n\u2022 Memory Allocation\n\u2022\n\u2022\n\u2022\n\u2022\n\nReturns pointer to length bytes\n\nReturns pointer to (count*size) bytes, zeros them\nDeallocates memory at \u2018ptr\u2019 so it can be allocated elsewhere\n\n\u2022 Strings\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022 Generally safer to use the bounded forms.\n\nCopies src to dst overwriting dst.\nCopies up to \u2018max\u2019 to dst.\nCopies string from src to end of dst.\nCopies up to \u2018max\u2019 to end of dst.\nReturns difference between strings. (0 if equal)\nCompares up to \u2018max\u2019 bytes.\n\n45\n\n\fInput/Output: Summary\n\u2022 Input\n\u2022\n\u2022\n\u2022\n\u2022\n\n\u2022 Output\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\nCopies string input by user into buffer (unsafe!)\nCopies up to 10 chars into buffer\n(my_buffer needs to be >= 11 bytes for sentinel)\nInterprets input and places value into int variable.\n\nupdates your variable, so you need to pass the address.\n(\ndoes not need it. Strings are already\n)\nPrints string. (technically unsafe)\nPrints up to 10 chars from string.\n(safe as long as my_buffer is >= 10 bytes)\nPrints int variable. (d for decimal, unfortunately)\nPrints int variable in hexadecimal. (x for hex)\nPrints long variable.\nPrints unsigned long variable.\n\n\u2022 Lots more variations! Generally\n\nand\n\nshare terms. Look them up!\n\n46\n\n\fStructures\nIt may not have class, but it has style.\n\n47\n\n\fQuick note on allocated structures\u2026\n\u2022 You are gonna allocate a lot of structures\u2026\n\u2022 They are big\u2026 you want them around\u2026 therefore, not good on the stack.\n\u2022 You could make them globals\u2026 except when you want them dynamically.\n\n48\n\n\fPointing to structure fields\u2026\n\u2022 A shorthand for\n\u2022 The \u201carrow\u201d syntax works only on\n\nis\npointers and dereferences a field.\n\n49\n\n\fPointing to structure fields\u2026\n\u2022 Recall that\n\u2022 If you want a\n\nis what names types.\ndata type, you can use\n\nto do so:\n\n50\n\n\fIt took humanity thousands of years to discover the NULL pointer error.\n\n\u2022 So, what do we use to denote that we are not pointing to anything?\n\u2022 Same as Java\u2026 we use a Null value and we hope nobody dereferences it.\n\u2022 It is not a built-in thing! We have to include\nto use it.\n\n51\n\n\fWhen malloc \u2026 goes bad\n\u2022 When your request for memory cannot be made, malloc returns\n\n!\n\n\u2022 In your perfect program, you would always check for this.\n\n52\n\n\fWhen malloc \u2026 goes bad\n\u2022 You can check if\n\nis null with\n\n\u2022 You might say, \u201chey!\nis not defined as\nby the C standard!\u201d\n\u2022 Yet, C specifically considers any pointer equal to\nto be a false value.\n\u2022 Regardless of the value of\n\nwhich is usually\n\nanyway.\n\n53\n\n\fExamples\nSome nice examples that address addressing!\n\n54\n\n\fSumming it all up.\n\n55\n\n\fSearching for values\n\nRemember that\n\nwants pointers to data.\n\n56\n\n\fPaving a new path\n\nRemember that\n\nwants pointers to data.\n\nWhen it sees more than 20 characters\u2026 what\nwill it do? (What will the next call to\ndo?)\n\n57\n\n\fPaving a new path (arbitrary number of directories!)\n\nwill resize the allocated space, copying the old\nvalue to a new chunk of memory if necessary.\nLook it up on your own!\n\n58\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}