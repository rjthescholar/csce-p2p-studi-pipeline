{"id": 178, "segment": "unlabeled", "course": "cs0449", "lec": "lec07", "text": "7\n\nIntroduction\nto x86 asm\n\nCS/COE 0449\nIntroduction to\nSystems Software\n\nLuis Oliveira\n(with content borrowed from wilkie and Vinicius Petrucci)\n\n\fAssembly Refresher\nWhat is forgotten\u2026 is art.\n\n2\n\n\fWhat is \u201cAssembly\u201d\n\u2022 Assembly: Human-readable representation of machine code.\n\u2022 Machine code: what a computer actually runs.\n\u2022 The \u201catoms\u201d that make up a program.\n\u2022 CPUs CAN actually be fairly simple in concept.\n\n\u2022 Each CPU chooses its own machine code (and therefore its own style\nof assembly language)\n\u2022 We used MIPS in CS 447.\n\u2022 A RISC processor.\n\n\u2022 We will compare that to x86 today!\n\u2022 A CISC processor.\n\n3\n\n\fWhat is \u201cAssembly\u201d\n\u2022 Involves very simple commands.\n\u2022 This command copies data from\none place to another.\n\n\u2022 Despite being called \u201cmove\u201d, ugh!\n\n\u2022 Surprise! It\u2019s actually shorthand\nfor a different set of instructions.\n\n\u2022 The processor can be made simpler.\n\n\u2022 This command gets transformed\ninto a numerical representation.\n\nCompute t0+0\nPut into \u201ca0\u201d\n\n\u2022 The processor then interprets the binary representation.\n\u2022 That\u2019s essentially all a computer does!\n\u2022 CS 447 looks at this in much greater detail.\n\n4\n\n\fAssembly vs. Machine Language\n\u2022 Machine language instructions are the patterns of bits that a\nprocessor reads to know what to do\n\u2022 Assembly language (or \"asm\") is a human-readable (mostly), textual\nrepresentation of machine language.\nMIPS asm\n\nMIPS machine language\n\n5\n\n\fIs Assembly Useful?\n\u2022 Short answer: YES\n\u2022 Assembly is \u201cfast\u201d, so we should use it for everything!\n--- NO!!! --\u2022 No type-checking, no control structures, very few abstractions.\nFairly impractical for large things --\u2022 Tied to a particular CPU.\n\n---\n\n\u2022 So, large programs have to be rewritten (usually) to work on new things.\n\n\u2022 Yet: good for specialized stuff.\n\u2022 Critical paths and \u201cboot\u201d code in Kernels / Operating Systems\n\u2022 HPC (simulators, supercomputer stuff)\n\u2022 Real-time programs (video games; tho increasingly less / abstracted away)\n\u2022 And\u2026\n\n6\n\n\fArchitecture Sits at the Hardware Interface\nSource code\n\nCompiler\n\nArchitecture\n\nApplications/algorithms\n\nPerform optimizations,\ngenerate instructions\n\nInstruction set\n\nDifferent implementations\n\nIntel Pentium 4\n\nC Language\nProgram\nA\n\nHardware\n\nIntel Core 2\n\nGCC\n\nx86-64\n\nIntel Core i7\nAMD Opteron\n\nProgram\nB\n\nAMD Athlon\nClang\n\nYour\nprogram\n\nARMv8\n(AArch64/A64)\n\nARM Cortex-A53\nApple A7\n\n\fPractical Applications of Assembly: Modification\n\u2022 Modifying programs after-the-fact. (Or reverse-engineering them)\n\u2022 Legal \u201cgray-area,\u201d / \u201cconfusing-mess\u201d but generally modification/reverse engineering is allowed.\nKinda? (Section 1201, US Code 17 \u00a7 108, etc)\n\u2022 Removing copy protection in order to preserve/backup.\n\u2022 Librarians and preservationists and \u201cpirates\u201d alike may all use/view/write assembly for this!\n\nI\u2019m not a lawyer\n\u2022 I know someone that patched (the freely distributed) Lost Vikings so it would avoid copy protection\uf04c\nand use a different sound configuration (so I could run it in a browser emulator)\n\nx86 (NASM / Intel Syntax, MS-DOS)\n\n8\n\n\fPractical Applications of Assembly: Debugging\n\n\u2022 Programs written in C, etc are generally translated into assembly.\n\u2022 And then into machine code.\n\n\u2022 You can look at the machine code of programs and get an assembly\ncode listing.\n\u2022 And step through the program one instruction at a time.\n\n\u2022 When programs crash (sometimes programs you don\u2019t have the code\nfor) you can look at the assembly code and assess.\n\u2022 Programs exist to help you (gdb, IDA Pro, radare, etc)\n\n\u2022 We will apply this knowledge (using gdb) in a future assignment!\n9\n\n\fBasics of x86 Assembly\nx86 really puts the\u2026 you know what\u2026 in Assembly\n\n10\n\n\fInstruction Set Architecture (ISA)\n\u2022 An ISA is the interface that a CPU presents to the programmer.\n\u2022 When we say \"architecture,\" this is what we mean.\n\n\u2022 The ISA defines:\n\u2022 What the CPU can do (add, subtract, call functions, etc.)\n\u2022 What registers it has (we'll get to those)\n\u2022 The machine language\n\u2022 That is, the bit patterns used to encode instructions.\n\n\u2022 The ISA does not define:\n\u2022 How to design the hardware!\n\u2022 \u2026if there's any hardware at all (think of Java, etc: virtual/hypothetical ISAs)\n\n11\n\n\fTypes of ISAs: RISC\n\u2022 RISC: \"Reduced Instruction Set Computer\"\n\u2022 ISA designed to make it easy to:\n\u2022 build the CPU hardware\n\u2022 make that hardware run fast\n\u2022 write compilers that make machine code\n\n\u2022 A small number of instructions.\n\u2022 Instructions are very simple\n\u2022 MIPS (and RISC-V) is very RISCy\n\n12\n\n\fTypes of ISAs: CISC\n\u2022 CISC: \"Complex Instruction Set Computer\"\n\u2022 ISA designed for humans to write asm.\n\u2022 From the days before compilers!\n\n\u2022 Lots of instructions and ways to use them\n\u2022 Complex (multi-step) instructions to shorten\nand simplify programs.\n\u2022 \"search a string for a character\"\n\u2022 \"copy memory blocks\"\n\u2022 \"check the bounds of an array access\u201c\n\n\u2022 Without these, you\u2019d just write your programs to use the\nsimpler instructions to build the complex behavior itself.\n\u2022 x86 is very CISCy\n13\n\n\fTypes of ISAs: Overview\n\u2022 CISC: Complex Instruction Set Computer (does a whole lot)\n\u2022 RISC: Reduced Instruction Set Computer (does enough)\n\u2022 Both: Equivalent!! (RISC programs might be longer)\n\n\u201cHackers\u201d (1995) \u2013 Of course, they are talking about a Pentium x86 chip\u2026\nwhich thanks to its backwards compatibility, is CISC. Oh well!\nThen again\u2026 x86 is so complex, modern designs translate the CISC instructions into RISC microcode on the fly\u2026 so it\u2019s RISC?? It can get complicated.\n\n14\n\n\fx86\n\u2022 Descended from 16-bit 8086 CPU from 1978.\n\u2022 Extended to 32 bits, then 64.\n\u2022 Each version can run most programs from the previous version.\n\u2022 You can (mostly) run programs written in \u201878 on your brand new x86 CPU!\n\n\u2022 This ISA is complex!\n\u2022 30 years of backwards-compatibility\u2026 yikes.\n\u2022 We won\u2019t exhaustively go over it.\n\u2022 There are, however, many very common idioms\nand instructions.\n\u2022 We will focus on these.\n\u2022 And we will focus on READING x86, not writing it.\n\n15\n\n\fx86 Registers (general)\n\u2022 Like MIPS, there are a set of general-purpose registers.\n\u2022 There are 16; 64-bits in size and hold integer values in binary form.\n\n\u2022 Unlike MIPS, you can refer to parts of each register.\n\u2022 Called partial registers.\n\nDenoted\nby %\n\nStack\nPointer\n\n16-bit register names\n\n32-bit register names\n\n16\n\n\fgeneral purpose\n\n32-bit OLD Registers \u2013 32 bits wide\n8 bits\n\n32 bits\n\n16 bits\n\n%eax\n\n%ax\n\n%ah\n\n%al\n\naccumulate\n\n%ecx\n\n%cx\n\n%ch\n\n%cl\n\ncounter\n\n%edx\n\n%dx\n\n%dh\n\n%dl\n\ndata\n\n%ebx\n\n%bx\n\n%bh\n\n%bl\n\nbase\n\n%esi\n\n%si\n\nsource index\n\n%edi\n\n%di\n\ndestination index\n\n%esp\n\n%sp\n\nstack pointer\n\n%ebp\n\n%bp\n\nbase pointer\n16-bit virtual registers\n(backwards compatibility)\n\nName Origin\n(mostly obsolete)\n\n\fx86 Registers (specialized)\n\u2022 There are also registers that you cannot directly interact with.\n\u2022 Like MIPS, x86 has a program counter (\n)\n\u2022 Also like MIPS, it cannot be read directly.\n\n\u2022 There is also a\nstatus register, which has information about the\nCPU state after an instruction is completed.\n\u2022 Stuff like a carry flag (CF) that denotes if an addition has a final carry.\n\u2022 Overflow detection (OF) denoting if an operation overflowed.\n\n\u2022 And some extra registers for vector math, floating point math, and for\nOS usage we won\u2019t go over.\n18\n\n\fx86 Instruction Types\n\u2022 In MIPS, you had R-type, I-type and J-type instructions.\n\u2022 In x86 (CISC) you generally can have any instruction refer to data anywhere it is:\n\u2022 Registers, Immediates, Memory addresses, etc\n\u2022 Cannot refer to memory twice! (not possible:\nx86-64 (gas / AT&T syntax)\n\n)\n\nMIPS\n\nImmediates (prefixed by $)\nMemory load (within parens)\nMemory store\n\nDisplacement (can be -4, etc)\n\n19\n\n\fComplex Addressing\n\u2022 In MIPS, you would carefully craft the set of instructions necessary to\ninterface with an array. (RISC)\n\u2022 In x86, you can do a lot with just a single instruction. (CISC)\n\u2022\n\n: Base + (Index Scalar) where Scalar must be 1, 2, 4 or 8\n\u2022 The fields are all optional; i.e.,\n\nx86-64 (gas / AT&T syntax)\n\ndoes just Index Scalar\n\nMIPS\n\n\u201cLoad Effective Address\u201d\n\nLEA simply computes address (no memory access)\n\n20\n\n\fComplex Addressing: CISC Strikes Again!!\n\u2022 When we say you can do a lot with just a single instruction, we\nmean it!\n\u2022\n: Base + (Index Scalar) where Scalar must be 1, 2, 4 or 8\n\u2022 What does the following do?\n\u2022\n\nx86-64 (gas / AT&T syntax)\n\n\u201cLoad Effective Address\u201d ???\n\nLEA simply computes address\u2026 it\u2019s just very specific math.\n\n21\n\n\fx86 Instruction Qualifiers\n\u2022 In MIPS, you sometimes had instructions varying on bitsize.\n\u2022 In x86 (CISC) you can operate on any part of a register.\n\u2022 64-bits, 32-bits, 16-bits\u2026 even 8-bit sections sometimes.\n\n\u2022 The assembler can assume usually, but explicit names also work:\nx86-64 (gas / AT&T syntax)\nThe assembler \u201cfigures it out\u201d\n\nMIPS64\n\n\u201cquad word\u201d which is 64-bits.\n\u201clong word\u201d which is 32-bits. \uf04c\nUgh. In x86 a \u201cword\u201d here is 16-bits\nCS/COE 0449 \u2013 Spring 2019/2020\n\n22\n\n\fHello World! (x86 vs. MIPS)\nx86-64 (gas / AT&T syntax)\n\nMIPS (MARS)\n\n23\n\n\fDoing some x86 maths\n\u2022 x86 and MIPS have, essentially, the same mathematical instructions.\nx86-64 (gas / AT&T syntax)\n\nMIPS\n\n24\n\n\fHowever, x86 lets you slice and dice\n\u2022 Each math instruction in x86 has variants based on the bitsize.\n\u2022\n\n(64-bit),\n\n(32-bit),\n\n(16-bit),\n\nx86-64 (gas / AT&T syntax)\n\n(8-bit) (rest of field zero extended!!)\n\nMIPS\n\nArithmetic shift (sign extends)\n\nLogical shift (zero extends)\n\n8-bit register aliases are not commonly used\n\n25\n\n\fAssembly Interlude\nHere, we take a break, and look at some existing code.\n\n26\n\n\fWhy write assembly? When you can write C\n\u2022 You can take any of your C programs and emit the assembly.\n\u2022 The compiler can do this for you:\n\n\u2022 This will create a file called\n\nwhich looks\u2026 messy.\n\n\u2022 It has a ton of messy specific stuff wedged in there.\n\u2022 But you can generally pull apart some meaning from it.\n\n27\n\n\fLooking at C compilers\u2026\n\u2022 The messy output of the gcc compilation to assembly:\nx86-64 (gas / AT&T syntax,\n\nmain hasn\u2019t even shown up yet\u2026\n\n)\n\nC\n\n28\n\n\fDisassembly \u2013 See how the sausage is made\u2026\n\u2022 So, that\u2019s not very useful. And often we don\u2019t have the code!\n\u2022 How do we go backward?\n\n\u2022 You can take any compiled program and emit the assembly.\n\u2022 Many tools can help you do this (radare, objdump, gdb)\n\n\u2022 Using a tool called objdump (only disassembles code section):\n\n\u2022 This will create a file called\n\n.\n\n\u2022 You can glance at it and notice that it does not have names.\n\u2022 And labels are a bit, well, nonexistent.\n29\n\n\fAnd\u2026 here we are\u2026\n\u2022 An objdump disassembly is slightly lacking context.\nx86-64 (gas / AT&T syntax,\n\n)\n\nC\n\nMachine code (in bytes)\nInstruction address\n30\n\n\fLooking deeper\n\u2022 Now we are starting to read the code\u2026 It does what we tell it to do!\nx86-64 (gas / AT&T syntax,\n\n)\nPreserves\n(caller activation frame)\nAllocates \u201c \u201d on stack ( from top)\nMove argument to\nCompares to and sets\nJumps if\nis 0 ( is positive)\nSets\nto\nResets caller activation frame\nReturns (return value is in\n)\n\nInstructions have varying size\nSo, the next instruction address\nis irregular. Compare with MIPS / RISC-V.\n\n31\n\n\fBrought to you by the letters: C ABI\n\u2022 The C Application Binary Interface (ABI) are assembly conventions\n\u2022 Like MIPS, certain registers are typically used for returns values, args, etc\n\u2022 It is not defined by the language, but rather the OS.\n\u2022 Windows and Linux (UNIX/System V) have a different C ABI \uf04c\n\n\u2022 In our x86-64 Linux C ABI, registers are used to pass arguments:\n\u2022\n,\n,\n,\n,\n,\n(First, second, etc) (Like MIPS\n\u2013\n)\n\u2022 Remaining arguments go on the stack.\n\u2022 Callee must preserve\n,\n,\n,\n,\n,\n(Like MIPS\n\u2013\n\u2022 Return value:\n(overflows into\nfor 128-bits) (MIPS\n\u2013\n)\n\u2022 Lots of other small things not worth going over.\n\n)\n\n\u2022 For reference: https://github.com/hjl-tools/x86-psABI/wiki/x86-64-psABI-1.0.pdf\n32\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}