{"id": 175, "segment": "unlabeled", "course": "cs0449", "lec": "lec09", "text": "8\n\nBuffer Overflow\n\nCS/COE 0449\nIntroduction to\nSystems Software\n\nLuis Oliveira\n(with content borrowed from wilkie and Vinicius Petrucci)\n\n\fReview: General Memory Layout\n\u2022 Stack\n\u2022 Local variables (procedure context)\n\n\u2022 Heap\n\n2N-1\n\nnot drawn to scale\n\nStack\n\n\u2022 Dynamically allocated as needed\n\u2022 malloc(), calloc(), new(), \u2026\n\n\u2022 Statically allocated Data\n\u2022 Read/Write: global variables\n\u2022 Read-only: string literals\n\nHeap\nStatic Data\n\n\u2022 Code/Instructions\n\u2022 Executable machine instructions\n\u2022 Read-only\n\nLiterals\n0\n\nInstructions\n\n\fx86-64 Linux Memory Layout\n\u2022 Stack\n\u2022 Runtime stack (8MB limit)\n\u2022 e.g., local variables\n\n\u2022 Heap\n\n00007FFFFFFFFFFF\n(= 247\u20131)\n00007FFFF0000000\n\nnot drawn to scale\nShared\nLibraries\nStack\n\n8MB\n\n\u2022 Dynamically allocated as needed\n\u2022 When call malloc(), new()\n\n\u2022 Data\n\u2022 Statically allocated data\n\u2022 e.g., global/static vars, string constants\n\n\u2022 Text / Shared Libraries\n\nHeap\n\n\u2022 Executable machine instructions\n\u2022 Read-only\nHex Address\n\n400000\n000000\n\nData\nText\n\n\fMemory Allocation Example\nnot drawn to scale\n\nchar big_array[1L<<24]; /* 16 MB */\nchar huge_array[1L<<31]; /* 2 GB */\n\nStack\n\nint global = 0;\nint useless() { return 0; }\nint main()\n{\nvoid *p1, *p2, *p3, *p4;\nint local = 0;\np1 = malloc(1L << 8); /* 256 B */\np2 = malloc(1L << 8); /* 256 B */\np3 = malloc(1L << 8); /* 256 B */\np4 = malloc(1L << 8); /* 256 B */\n/* Some print statements ... */\n}\nWhere does everything go?\n\nOther stuff\nShared\nLibraries\n\nHeap\nData\nInstructions\n4\n\n\fMemory Allocation Example\nnot drawn to scale\n\nchar big_array[1L<<24]; /* 16 MB */\nchar huge_array[1L<<31]; /* 2 GB */\n\nStack\n\nint global = 0;\nint useless() { return 0; }\nint main()\n{\nvoid *p1, *p2, *p3, *p4;\nint local = 0;\np1 = malloc(1L << 8); /* 256 B */\np2 = malloc(1L << 8); /* 256 B */\np3 = malloc(1L << 8); /* 256 B */\np4 = malloc(1L << 8); /* 256 B */\n/* Some print statements ... */\n}\nWhere does everything go?\n\nHeap stuff\nOther\nShared\nLibraries\nShared\nLibraries\n\nHeap\nData\nInstructions\n5\n\n\fReminder: x86-64/Linux Stack Frame\nHigher Addresses\n\n\u2022 Caller\u2019s Stack Frame\n\u2022 Arguments (if > 6 args) for this call\n\n\u2022 Current/Callee Stack Frame\n\u2022 Return address\n\u2022 Pushed by call instruction\n\n\u2022 Old frame pointer (optional)\n\u2022 Saved register context\n(when reusing registers)\n\u2022 Local variables\n(if can\u2019t be kept in registers)\n\u2022 \u201cArgument build\u201d area\n(If callee needs to call another function parameters for function about to call, if\nneeded)\n\nCaller\nFrame\n\nFrame pointer\n%rbp\n(Optional)\n\nArguments\n7+\nReturn Addr\nOld %rbp\n\nSaved\nRegisters\n+\nLocal\nVariables\n\nStack pointer\n%rsp\n\nArgument\nBuild\n(Optional)\n6 Lower Addresses\n\n\fRecall: Memory Referencing Bug Example\ntypedef struct {\nint a[2];\ndouble d;\n} struct_t;\ndouble fun(int i) {\nstruct_t s;\ns.d = 3.14;\ns.a[i] = 1073741824; /* Possibly out of bounds */\nreturn s.d;\n}\n\nfun(0)\nfun(1)\nfun(2)\nfun(3)\nfun(4)\n\n->3.1400000000\n->3.1400000000\n->3.1399998665\n->2.0000006104\n->Segmentation fault\n\nResult is system specific\n7\n\n\fMemory Referencing Bug Example\nfun(0)\nfun(1)\nfun(2)\nfun(3)\nfun(4)\nfun(8)\n\ntypedef struct {\nint a[2];\ndouble d;\n} struct_t;\n\nMemory:\n\nstruct_t\n\n???\n\n8\n\nCritical State\n\n7\n\nCritical State\n\n6\n\nCritical State\n\n5\n\nCritical State\n\n4\n\nd7 ... d4\n\n3\n\nd3 ... d0\n\n2\n\na[1]\n\n1\n\na[0]\n\n0\n\n->3.1400000000\n->3.1400000000\n->3.1399998665\n->2.0000006104\n->Segmentation fault\n->3.1400000000\n\nLocation accessed by\nfun(i)\n\n8\n\n\fBuffer Overflow\n\u2022 Traditional Linux memory layout provide\nopportunities for malicious programs\n\u2022 Stack grows \u201cbackwards\u201d in memory\n\u2022 Data and instructions both stored in the same memory\n\n\u2022 Recall that C does not check array bounds\n\u2022 Many Unix/Linux/C functions don\u2019t check argument sizes\n\u2022 Allows overflowing (writing past the end) of buffers\n(arrays)\n\n9\n\n\fBuffer Overflow (cont.)\n\u2022 Buffer overflows on the stack can overwrite \u201cinteresting\u201d\ndata\n\u2022 Attackers just choose the right inputs\n\n\u2022 Simplest form (sometimes called \u201cstack smashing\u201d)\n\u2022 Unchecked length on string input into bounded array causes\noverwriting of stack data\n\u2022 Try to change the return address of the current procedure\n\n\u2022 Why is this a big deal?\n\u2022 It is (was?) the #1 technical cause of security vulnerabilities\n\u2022 #1 overall cause is social engineering / user ignorance\n\n10\n\n\fString Library Code\n\u2022 Implementation of Unix function gets()\n/* Get string from stdin */\nchar* gets(char* dest) {\nint c = getchar();\nchar* p = dest;\nwhile (c != EOF && c != '\\n') {\n*p++ = c;\nc = getchar();\n}\n*p = '\\0';\nreturn dest;\n}\n\npointer to start\nof an array\nsame as:\n*p = c;\np++;\n\nWhat could go wrong in this code?\n11\n\n\fString Library Code\n\u2022 Implementation of Unix function gets()\n/* Get string from stdin */\nchar* gets(char* dest) {\nint c = getchar();\nchar* p = dest;\nwhile (c != EOF && c != '\\n') {\n*p++ = c;\nc = getchar();\n}\n*p = '\\0';\nreturn dest;\n}\n\n\u2022 No way to specify limit on number of characters to read\n\u2022 Similar problems with other Unix functions:\n\u2022 strcpy: Copies string of arbitrary length to a dst\n\u2022 scanf, fscanf, sscanf, when given %s specifier\n12\n\n\fVulnerable Buffer Code\n/* Echo Line */\nvoid echo() {\nchar buf[8];\ngets(buf);\nputs(buf);\n}\n\nCode example to try on Thoth!\nhttps://bit.ly/3eWwndQ\n/* Way too small! */\n\n\uf0e7 BTW, how big\nis big enough?\n\nvoid call_echo() {\necho();\n}\n\nunix> ./buf-nsp\nEnter string: 12345678901234567890123\n12345678901234567890123\nunix> ./buf-nsp\nEnter string: 123456789012345678901234\nSegmentation Fault\n\n\fBuffer Overflow Disassembly\n24 bytes (decimal)\n\necho:\n000000000040069c <echo>:\n40069c: 48 83 ec 18\n4006a0: 48 89 e7\n4006a3: e8 a5 ff ff ff\n4006a8: 48 89 e7\n4006ab: e8 50 fe ff ff\n4006b0: 48 83 c4 18\n4006b4: c3\n\n$0x18,%rsp\n%rsp,%rdi\n40064d <gets>\n%rsp,%rdi\n400500 <puts@plt>\n$0x18,%rsp\n\nreturn address\n\ncall_echo:\n4006b5:\n4006b9:\n4006be:\n4006c3:\n4006c7:\n\nsub\nmov\ncallq\nmov\ncallq\nadd\nretq\n\n48 83 ec 08\nb8 00 00 00 00\ne8 d9 ff ff ff\n48 83 c4 08\nc3\n\nsub\nmov\ncallq\nadd\nretq\n\n$0x8,%rsp\n$0x0,%eax\n40069c <echo>\n$0x8,%rsp\n\n\fBuffer Overflow Stack Example\nBefore call to gets\nStack Frame\nfor call_echo\n\nReturn Address\n(8 bytes)\n\n/* Echo Line */\nvoid echo()\n{\nchar buf[4];\ngets(buf);\nputs(buf);\n}\n\n/* Way too small! */\n\n20 bytes unused\n\n[3] [2] [1] [0] buf\n\n%rsp\n\necho:\nsubq $0x18, %rsp\nmovq %rsp, %rdi\ncall gets\n. . .\n15\n\n\fBuffer Overflow Stack Example\nBefore call to gets\nStack Frame\nfor call_echo\n\n00 Address\n00 00\n00\nReturn\n00 (8\n40bytes)\n06 c3\n\n20 bytes unused\n\n[3] [2] [1] [0] buf\n\nvoid echo()\n{\nchar buf[4];\ngets(buf);\n. . .\n}\n\necho:\nsubq $0x18, %rsp\nmovq %rsp, %rdi\ncall gets\n. . .\n\ncall_echo:\n. . .\n4006be:\n4006c3:\n. . .\n\ncallq\nadd\n\n4006cf <echo>\n$0x8,%rsp\n\n%rsp\n\n16\n\n\fBuffer Overflow Stack Example #1\nAfter call to gets\nStack Frame\nfor call_echo\n\n00\n00 Address\n00 00\nReturn\n00 (8\n40bytes)\n06 c3\n00 32 31 30\n39 38 37 36\n35\n34 unused\n33 32\n20 bytes\n31 30 39 38\n37 36 35 34\n33 32 31 30 buf\n\nvoid echo()\n{\nchar buf[4];\ngets(buf);\n. . .\n}\n\necho:\nsubq $0x18, %rsp\nmovq %rsp, %rdi\ncall gets\n. . .\n\ncall_echo:\n. . .\n4006be:\n4006c3:\n. . .\n\n%rsp\n\ncallq\nadd\n\n4006cf <echo>\n$0x8,%rsp\n\nunix>./bufdemo-nsp\nType a string:01234567890123456789012\n01234567890123456789012\n\n\u201c01234567890123456789012\\0\u201d\n\nOverflowed buffer, but did not corrupt state\n\n17\n\n\fBuffer Overflow Stack Example #2\nAfter call to gets\nStack Frame\nfor call_echo\n\n00\n00 Address\n00 00\nReturn\n00 (8\n40bytes)\n06 00\n33 32 31 30\n39 38 37 36\n35\n34 unused\n33 32\n20 bytes\n31 30 39 38\n37 36 35 34\n33 32 31 30 buf\n\nvoid echo()\n{\nchar buf[4];\ngets(buf);\n. . .\n}\n\necho:\nsubq $0x18, %rsp\nmovq %rsp, %rdi\ncall gets\n. . .\n\ncall_echo:\n. . .\n4006be:\n4006c3:\n. . .\n\n%rsp\n\ncallq\nadd\n\n4006cf <echo>\n$0x8,%rsp\n\nunix>./bufdemo-nsp\nType a string:012345678901234567890123\n012345678901234567890123\nSegmentation fault\n\nProgram \u201creturned\u201d to 0x0400600, and then crashed.\n\n18\n\n\fBuffer Overflow Example #2 Explained\nAfter return from echo\n0000000000400500 <deregister_tm_clones>:\nStack frame for\n400500: mov\n$0x60104f,%eax\ncall_echo\n400505: push\n%rbp\n\u27f5%rsp\n400506: sub\n$0x601048,%rax\n40050c: cmp\n$0xe,%rax\n00 00 00 00\n400510: mov\n%rsp,%rbp\n00 40 05 00\n400513: jbe\n400530\n34 33 32 31\n400515: mov\n$0x0,%eax\n40051a: test\n%rax,%rax\n30 39 38 37\n40051d: je\n400530\n36 35 34 33\n40051f: pop\n%rbp\n32 31 30 39\n400520: mov\n$0x601048,%edi\n400525: jmpq\n*%rax\n38 37 36 35\n400527: nopw\n0x0(%rax,%rax,1)\n34 33 32 31 buf\n40052e: nop\n400530: pop\n%rbp\n400531: retq\n\u201cReturns\u201d to unrelated code, but continues!\nEventually segfaults on retq of deregister_tm_clones.\n19\n\n\fMalicious Use of Buffer Overflow: Code Injection Attacks\nStack after call to gets()\nHigh Addresses\n\nvoid foo(){\nbar();\nA:...\n}\nint bar() {\nchar buf[64];\ngets(buf);\n...\nreturn ...;\n}\n\nfoo stack frame\nreturn address A\nAB\n(return address)\ndata written\nby gets()\nbuf starts here\n\nB\n\npad\n\nbar stack frame\n\nexploit\ncode\n\nLow Addresses\n\n\u2022 Input string contains byte representation of executable code\n\u2022 Overwrite return address A with address of buffer B\n\u2022 When bar() executes ret, will jump to exploit code\n\n20\n\n\fExploits Based on Buffer Overflows\n\u2022 Buffer overflow bugs can allow remote machines to execute arbitrary code on\nvictim machines\n\u2022 Distressingly common in real programs\n\u2022 Programmers keep making the same mistakes \uf04c\n\u2022 Recent measures make these attacks much more difficult\n\n\u2022 Examples across the decades\n\u2022 Original \u201cInternet worm\u201d (1988)\n\u2022 Still happens!!\n\u2022 Heartbleed (2014, affected 17% of servers)\n\u2022 Cloudbleed (2017)\n\n\u2022 Fun: Nintendo hacks\n\u2022 Using glitches to rewrite code: https://www.youtube.com/watch?v=TqK-2jUQBUY\n\u2022 FlappyBird in Mario: https://www.youtube.com/watch?v=hB6eY73sLV0\n\n\fExample: the original Internet worm (1988)\n\u2022 Exploited a few vulnerabilities to spread\n\u2022 Early versions of the finger server (fingerd) used gets() to read the argument\nsent by the client:\n\u2022 finger droh@cs.cmu.edu\n\n\u2022 Worm attacked fingerd server with phony argument:\n\u2022 finger \u201cexploit-code padding new-return-addr\u201d\n\u2022 Exploit code: executed a root shell on the victim machine with a direct TCP connection to the\nattacker\n\n\u2022 Scanned for other machines to attack\n\u2022 Invaded ~6000 computers in hours (10% of the Internet)\n\u2022 see June 1989 article in Comm. of the ACM\n\n\u2022 The young author of the worm was prosecuted\u2026\n22\n\n\fHeartbleed (2014)\n\u2022 Buffer over-read in OpenSSL\n\u2022 Open source security library\n\u2022 Bug in a small range of versions\n\n\u2022 \u201cHeartbeat\u201d packet\n\u2022 Specifies length of message\n\u2022 Server echoes it back\n\u2022 Library just \u201ctrusted\u201d this length\n\u2022 Allowed attackers to read contents\nof memory anywhere they wanted\n\n\u2022 Est. 17% of Internet affected\n\u2022 \u201cCatastrophic\u201d\n\u2022 Github, Yahoo, Stack Overflow,\nAmazon AWS, ...\n\nBy FenixFeather - Own work, CC BY-SA 3.0,\nhttps://commons.wikimedia.org/w/index.php?curid=32276981\n\n23\n\n\fCrafting Smashing String\nint echo() {\nchar buf[4];\ngets(buf);\n...\nreturn ...;\n}\n\nStack Frame\nfor call_echo\n\n07 00\nFF\n00\n00 Address\n00\nReturn\n00\n40\n06\nFF (8\nFFbytes)\nAB c3\n80\n33 32 31 30\n39 38 37 36\n35\n34 unused\n33 32\n20 bytes\n31 30 39 38\n37 36 35 34\n33 32 31 30\nAttack String (Hex)\n\n%rsp\n\n24 bytes\n\nTarget Code\nvoid smash() {\nprintf(\"I've been smashed!\\n\");\nexit(0);\n}\n00000000004006c8 <smash>:\n4006c8:\n48 83 ec 08\n\n30 31 32 33 34 35 36 37 38 39 30 31 32 33 34 35 36 37 38 39 30 31 32 33\nc8 06 40 00 00 00 00 00\n\n\fSmashing String Effect\nStack Frame\nfor call_echo\n\n07 00\nFF\n00\n00 Address\n00\nReturn\n00\n40\n06\nFF (8\nFFbytes)\nAB c8\n80\n33 32 31 30\n39 38 37 36\n35\n34 unused\n33 32\n20 bytes\n31 30 39 38\n37 36 35 34\n33 32 31 30\nAttack String (Hex)\n\n%rsp\n\nTarget Code\nvoid smash() {\nprintf(\"I've been smashed!\\n\");\nexit(0);\n}\n00000000004006c8 <smash>:\n4006c8:\n48 83 ec 08\n\n30 31 32 33 34 35 36 37 38 39 30 31 32 33 34 35 36 37 38 39 30 31 32 33\nc8 06 40 00 00 00 00 00\n\n\fPerforming Stack Smash\nCode example to try on Thoth!\nhttps://bit.ly/3eWwndQ\n\n\u2022 Put hex sequence in file smash-hex.txt\n\u2022 Use hexify program to convert hex digits to\ncharacters\n\u2022 Some of them are non-printing\n\n\u2022 Provide as input to vulnerable program\n$ cat smash-hex.txt\n30 31 32 33 34 35 36 37 38 39 30 31 32 33 34 35 36 37 38 39 30 31 32 33\nc8 06 40 00 00 00 00 00\n$ cat smash-hex.txt | ./hexify | ./bufdemo-nsp\nType a string:012345678901234567890123?@\nI've been smashed!\nvoid smash() {\nprintf(\"I've been smashed!\\n\");\nexit(0);\n}\n\n26\n\n\fCode Injection Attacks\nStack after call to gets()\nvoid P(){\nQ();\nA: ...\n}\n\nP stack frame\n\nReturn address A\n\nint Q() {\nchar buf[64];\ngets(buf);\n...\nreturn ...;\n}\n\nB\nABA\ndata written\nby gets()\nB\n\npad\n\nexploit\ncode\n\nQ stack frame\n\n\u2022 Input string contains byte representation of executable code\n\u2022 Overwrite return address A with address of buffer B\n\u2022 When Q executes ret, will jump to exploit code\n\n27\n\n\fHow Does The Attack Code Execute?\nrip\nvoid P(){\nQ();\n...\n}\n\nStack\nrsp\nrsp\n\nrsp\nShared\nLibraries\n\nret\n\nBB\nAA\npad\n\nret\nint Q() {\nchar buf[64];\ngets(buf); // A->B\n...\nreturn ...;\n}\n\n\u2026\n\nrip\nrip\n\nexploit\ncode\n\nHeap\n\nrip\nrip\n\nData\nText\n28\n\n\fDealing with buffer overflow attacks\n\n1) Avoid overflow vulnerabilities\n2) Employ system-level protections\n3) Have compiler use \u201cstack canaries\u201d\n\n30\n\n\f1) Avoid Overflow Vulnerabilities in Code\n\u2022 Use library routines that limit string lengths\n\u2022 fgets instead of gets (2nd argument to fgets sets limit)\n\u2022 strncpy instead of strcpy\n\u2022 Don\u2019t use scanf with %s conversion specification\n\u2022 Use fgets to read the string\n\u2022 Or use %ns where n is a suitable integer\n/* Echo Line */\nvoid echo()\n{\nchar buf[8]; /* Way too small! */\nfgets(buf, 8, stdin);\nputs(buf);\n}\n31\n\n\f2) System-Level Protections\nHigh Addresses\n\n\u2022 Randomized stack offsets\n\u2022 At start of program, allocate random amount of space on stack\n\u2022 Shifts stack addresses for entire program\n\nRandom\nallocation\nmain\u2019s\nstack frame\n\n\u2022 Addresses will vary from one run to another\n\n\u2022 Makes it difficult for hacker to predict beginning of inserted code\n\nOther\nfunctions\u2019\nstack frames\n\n\u2022 Example: Code from Slide 6 executed 5 times; address of variable\nlocal =\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\n0x7ffd19d3f8ac\n0x7ffe8a462c2c\n0x7ffe927c905c\n0x7ffefd5c27dc\n0x7fffa0175afc\n\n\u2022 Stack repositioned each time program executes\n\nB?\npad\n\nB?\n\nexploit\ncode\nLow Addresses\n\n32\n\n\f2) System-Level Protections\nStack after call\nto gets()\n\n\u2022 Non-executable code segments\n\nfoo\nstack\nframe\n\n\u2022 In traditional x86, can mark region of\nmemory as either \u201cread-only\u201d or \u201cwriteable\u201d\n\u2022 Can execute anything readable\n\n\u2022 x86-64 added explicit \u201cexecute\u201d permission\n\u2022 Stack marked as non-executable\n\u2022 Do NOT execute code in Stack, Static Data, or\nHeap regions\n\u2022 Hardware support needed\n\nB\ndata written\nby gets()\nB\n\npad\nexploit\ncode\n\nbar\nstack\nframe\n\nAny attempt to execute this code will fail\n33\n\n\f3) Stack Canaries\n\u2022 Basic Idea: place special value (\u201ccanary\u201d) on stack just beyond buffer\n\u2022 Secret value known only to compiler\n\u2022 \u201cAfter\u201d buffer but before return address\n\u2022 Check for corruption before exiting function\n\n\u2022 GCC implementation (now default)\n\u2022 -fstack-protector\n\u2022 Code back on Slide 14 (buf-nsp) compiled with\n\u2013fno-stack-protector flag\n\nunix>./buf\nEnter string: 12345678\n12345678\n\nunix> ./buf\nEnter string: 123456789\n*** stack smashing detected ***\n\n34\n\n\fProtected Buffer Disassembly (buf)\necho:\n400638:\n40063c:\n400645:\n40064a:\n...\n400656:\n400659:\n40065e:\n400661:\n400666:\n40066b:\n400674:\n400676:\n40067b:\n40067f:\n\nsub\n$0x18,%rsp\nmov\n%fs:0x28,%rax\nmov\n%rax,0x8(%rsp)\nxor\n%eax,%eax\n... call printf ...\nmov\n%rsp,%rdi\ncallq 400530 <gets@plt>\nmov\n%rsp,%rdi\ncallq 4004e0 <puts@plt>\nmov\n0x8(%rsp),%rax\nxor\n%fs:0x28,%rax\nje\n40067b <echo+0x43>\ncallq 4004f0 <__stack_chk_fail@plt>\nadd\n$0x18,%rsp\nretq\n\n\fSetting Up Canary\nBefore call to gets\nStack frame for\ncall_echo\nReturn address\n(8 bytes)\n\nCanary\n(8 bytes)\n[7] [6] [5] [4]\n\n/* Echo Line */\nvoid echo()\n{\nchar buf[8]; /* Way too small! */\ngets(buf);\nputs(buf);\n}\nSegment register\n(don\u2019t worry about it)\necho:\n. . .\nmovq\n%fs:40, %rax\n# Get canary\nmovq\n%rax, 8(%rsp)\n# Place on stack\nxorl\n%eax, %eax\n# Erase canary\n. . .\n\n[3] [2] [1] [0] buf \u27f5%rsp\n\n36\n\n\fChecking Canary\nAfter call to gets\nStack frame for\ncall_echo\nReturn address\n(8 bytes)\n\nCanary\n(8 bytes)\n\n00 37 36 35\n34 33 32 31\n\n/* Echo Line */\nvoid echo()\n{\nchar buf[8];\ngets(buf);\nputs(buf);\n}\necho:\n. . .\nmovq\nxorq\nje\ncall\n.L6:\n\n/* Way too small! */\n\n8(%rsp), %rax\n%fs:40, %rax\n.L2\n__stack_chk_fail\n. . .\n\n# retrieve from Stack\n# compare to canary\n# if same, OK\n# else, FAIL\n\nbuf \u27f5%rsp\n\nInput: 1234567\n37\n\n\fSummary\n\n1) Avoid overflow vulnerabilities\n\u2022\n\nUse library routines that limit string lengths\n\n2) Employ system-level protections\n\u2022\n\u2022\n\nRandomized Stack offsets\nCode on the Stack is not executable\n\n3) Have compiler use \u201cstack canaries\u201d\n\n38\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}