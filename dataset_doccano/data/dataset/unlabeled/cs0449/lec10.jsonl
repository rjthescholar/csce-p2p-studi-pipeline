{"id": 176, "segment": "unlabeled", "course": "cs0449", "lec": "lec10", "text": "10\n\nHow\nPrograms\nAre Made\n\nCS/COE 0449\nIntroduction to\nSystems Software\n\nLuis Oliveira\n(with content borrowed from wilkie and Vinicius Petrucci)\n\n\fLinkers\nFilling in the blanks.\n\n2\n\n\fCompilation: Simple Overview \u2013 Step 1\n\u2022 The compiler takes source code (\nfiles) and\ntranslates them into machine code.\n\nhello.c\n\nhello.o\n\n\u2022 This file is called an \u201cobject file\u201d and is just\npotentially one part of your overall project.\n\n\u2022 The machine code is not quite an executable.\n\u2022 This object file is JUST representing the code for that\nparticular source file.\n\u2022 You may require extra stuff provided by the system\nelsewhere.\n3\n\n\fCompilation: Simple Overview \u2013 Step 2\n\u2022 You may have multiple files.\n\u2022 They may reference each other.\n\nhello.c\n\nhello.o\n\n\u2022 For instance, one file may contain certain common\nfunctionality and then this is invoked by your program\nelsewhere.\n\n\u2022 You break your project up into pieces similarly to\nyour Java programs.\n\u2022 The compiler treats them independently.\nutil.c\nCS/COE 0449 \u2013 Spring 2019/2020\n\nutil.o\n4\n\n\fCompilation: Simple Overview \u2013 Step 3\n\u2022 Then, each piece is merged\ntogether to form the\nexecutable.\n\u2022 This process is done by a linker\nand is called linking.\nhello.c\n\nhello.o\n\nhello\n\n\u2022 The name refers to how the\nreferences to functions, etc,\nbetween files are now filled in.\n\nutil.c\nCS/COE 0449 \u2013 Spring 2019/2020\n\nutil.o\n\nstdio.o\nExternal Libraries\n\n\u2022 Before this step\u2026 it is unclear\nwhere functions will end up in\nthe final executable.\n5\n\n\fIt's just a grinder.\n\u2022 In summary:\n\nhello.c\n\ncode goes in, sausage object\nfiles come out\nThe executable is produced\nby a linker, which merges\ncode together.\n\nSome compilers output\nassembly and rely on an\nassembler to produce\nmachine code\nThese days, it's common\nfor the compiler itself to\nproduce machine code,\nor some kind of\nplatform-independent\nassembly code\n(typically: a bytecode)\n6\n\n\fCompiler\n\u2022 Input: Higher-level language code (e.g. C, Java)\n\u2022 foo.c\n\n\u2022 Output: Assembly language code (e.g. x86, ARM, MIPS)\n\u2022 foo.s\n\n\u2022 First there\u2019s a preprocessor step to handle #directives\n\u2022 Macro substitution, plus other specialty directives\n\u2022 If curious/interested: http://tigcc.ticalc.org/doc/cpp.html\n\n\u2022 Compiler optimizations\n\u2022 \u201cLevel\u201d of optimization specified by capital \u2018O\u2019 flag (e.g. -Og, -O3)\n\u2022 Options: https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html\n7\n\n\fCompilers Are Non-Trivial\n\u2022 There\u2019s a whole course about them \u2013 CS 1622\n\u2022 We won\u2019t go into much detail in this course\n\u2022 For the very curious: http://www.sigbus.info/how-i-wrote-a-self-hosting-ccompiler-in-40-days.html\n\n\u2022 Some examples of the task\u2019s complexity:\n\u2022 Operator precedence: 2 + 3 * 4\n\u2022 Operator associativity: a = b = c;\n\u2022 Determining locally whether a program is valid\nif (a) { if (b) { \u2026 /*long distance*/ \u2026 } } }//extra bracket\n\n8\n\n\fThe need for the linker\n\u2022 A compiler converts source code into machine code.\n\u2022 A linker merges pieces of machine code into an executable.\n\u2022 Why have a separate tool for creating executables?\n\u2022 Mixing different languages together (C, C++, Python, Rust, Go\u2026)\n\u2022 Lot\u2019s of complications we won\u2019t get to here.\n\u2022 Assembly is the glue\u2026 all high-level languages have to get there.\n\n\u2022 Let\u2019s us break large programs up into smaller pieces.\n\u2022 And we only have to recompile files that changed! (Faster)\n\n\u2022 Those small pieces can come from others. Code reuse!\n\u2022 We can share executable code among many running programs. (Shared Libraries)\n\n9\n\n\fWhat is inside that box?\n\u2022 To understand what linkers do, we\nneed to see what an executable is\nmade out of.\n(Spoilers: it is not just code/data)\n\u2022 A Linux executable is defined by\nthe Executable and Linkable\nFormat (ELF) standard.\n\u2022 Used for\nfiles\n\u2022 And executables\n\u2022 And\n(shared objects; soon!)\n10\n\n\fObject File Format\n1. object file header: size and position of the other pieces of the object\nfile\n2. text segment: the machine code\n3. data segment: data in the source file (binary)\n4. relocation table: identifies lines of code that need to be \u201chandled\u201d\n5. symbol table: list of this file\u2019s labels and data that can be referenced\n6. debugging information\n\u2022 A standard format is ELF (except MS)\n\u2022 http://www.skyfree.org/linux/references/ELF_Format.pdf\n\n\fObject File Information Tables\n\u2022 Symbol Table holds list of \u201citems\u201d that may be used by other files\n\u2022 Non-local labels \u2013 function names for call\n\u2022 Static Data \u2013 variables & literals that might be accessed across files\n\n\u2022 Relocation Table holds list of \u201citems\u201d that this file needs the address of later\n(currently undetermined)\n\u2022 Any label or piece of static data referenced in an instruction in this file\n\u2022 Both internal and external\n\n\u2022 Each file has its own symbol and relocation tables\n\n12\n\n\fWhat the ELF ??\n\u2022 Contains all of the segments and data sections defining a program.\n\u2022 The ELF executable has roughly the following structure:\nOffset\n\nName\n\nDescription\n\nMagic Number\n\n4 bytes: A\n\nClass\n\n1 byte:\n\nif 32-bit, 0x2 if 64-bit\n\nData\n\n1 byte:\n\nif little-endian, 0x2 if big-endian\n\nVersion\n\n1 byte:\n\nfor the current version.\n\nABI\n\n1 byte:\n\nfor System V (our C ABI)\n\nMachine\n\n2 bytes:\n\nbyte followed by \u201c\n\nis x86,\n\nis MIPS,\n\n\u201d in ASCII\n\nis RISC-V, etc\n\n13\n\n\fWhat the ELF ??\n\u2022 The remaining fields indicate where certain sections start.\n\u2022 An ELF executable contains these sections:\n\u2022 Segment Headers (where .text, .data, .bss, etc, exist in the executable)\n\u2022 The initial data for each memory segment in the memory layout!\n\u2022 We will look at these again when we look at loading.\n\n\u2022 The Symbol Table\n\u2022 All of the \u201cnames\u201d that may be referenced by other code.\n\n\u2022 Symbols can consist of:\n\u2022 Functions\n\u2022 Global variables\n\u2022 Special sections (special compiler or OS areas)\n\n\u2022 We will focus on function/variable symbols.\n14\n\n\f\u2013 Viewing the symbol table\n\u2022 You can investigate the symbols that are part of any object file\nusing the\ncommand on Linux/UNIX.\nC(\n\n)\n\nThis is a symbol. It has a location.\n\nHere it is! At 0x27 (39) bytes.\n\n15\n\n\f; Controlling the symbols\n\u2022 Remember the\n\nkeyword?\n\n\u2022 This forces any symbol to be local to the current file. That is, it can\nnot be referenced by an outside function.\n\u2022 This is because the symbol will not be included in the symbol table!\n\u2022 The linker will not be able to see it.\n\n\u2022 This is useful for avoiding name collisions, when two functions have\nthe same name.\n\u2022 This normally would make using multiple files and other people\u2019s code\ntroublesome.\n\u2022 Using\nhelps because it will not pollute the symbol table.\n16\n\n\fControlled the symbols\n\u2022 You can investigate the impact of using\ncommand on Linux/UNIX.\nC(\n\nby again using the\n\n)\nThis symbol has a location\u2026 but it can\nonly be referenced in this file.\n\nOur static function is now \u201cLOCAL\u201d\n\n17\n\n\f; when you used to be an intern\n\u2022 The other side of the coin is the\nkeyword.\n\u2022 This tells the linker that it should expect the symbol to be found\nelsewhere.\nC(\n\n)\n\nC(\n\n)\n\nHere it is!!\n\nThis symbol is\u2026 somewhere.\n\n18\n\n\fFinal thoughts of global variables\n\u2022 You should always avoid global variables.\n\u2022 However, if you are using them, make sure to liberally use\n\u2022 This will stop the names of variables from polluting the symbol table.\n\u2022 The use of\nis likely indicating a poor design.\n\n\u2022 This is also true for functions, too.\n\u2022 Generally declare them\nunless you need\nthem from within another file.\n\u2022 Helps make it clear what functions are important\nand which can be deleted or refactored.\n\u2022 (Much like private functions in classes)\n\n\u2022 Always initialize your global variables!\n\n19\n\n\fSeeing through the linker\u2019s eyes\n\u2022 Which symbols are part of each file?\n\u2022 Which are local and which are global?\n\u2022 Which symbols are satisfied by the other file?\nC(\n\n)\n\nA local symbol.\n\nA global symbol.\n\nReferenced here.\n\nC(\n\n)\n\nThe linker references\n\u201cmain\u201d when it compiles\nthe executable.\n\nWe need to tell the compiler\nthat we are linking to a symbol.\n\nA global symbol.\nLinker doesn\u2019t see these\ntemporary variables.\n\nReferenced here.\n\n20\n\n\fSumming it up: Playing mad-libs\n\nfibonacci.c\n\nfibonacci.o\n\nfibonacci\n\n0x007c0e10\n???\n\nmain.c\n\n\u2022 The compiler hands\noff object files with\nblanks where\nreferenced symbols\nreside.\n\u2022 The linker\u2019s job is to\nfill in those blanks\nwith the location of\nthe symbol in the\nfinal executable.\n\nmain.o\n21\n\n\fStatic Libraries (\n\nfiles)\n\u2022 If you want to share\nyour library with\nothers\u2026\n\nutil.c\n\ntree.c\n\nutil.o\n\ntree.o\n\nmy-lib.a\n\n\u2022 Instead of creating an\nexecutable, you can\npackage together all of\nthe\nfiles into a\nsingle archive (\nfile)\n\u2022 You can use the\nprogram on Linux for\nthis.\n22\n\n\fCompilation: Simple Overview \u2013 Redux\n\u2022 We can use my-lib.a in\nplace of the object files\nwe need.\n\nhello.c\n\nutil.c\nCS/COE 0449 \u2013 Spring 2019/2020\n\nhello.o\n\nutil.o\n\nhello\n\nmy-lib.a\nExternal Libraries\n\n\u2022 The\nfile is just a\ncontainer for a set of\nobject files. Essentially,\nit is just a kind of zip\nfile of object files.\n\u2022 These object files get\ncopied into our\nexecutable\u2026 not very\nefficient! Hmm!\n23\n\n\fLoaders\nYou should always stretch before you run \u2013 OSes do this, too.\n\n24\n\n\fThe Operating System\n\u2022 How does your ELF executable actually\nrun?\n\u2022 There needs to be some system software\nto unpack the executable into memory.\n\n\u2022 That system software is a loader and it is\npart of an operating system.\n\n25\n\n\fMemory Segments \u2013 Deeper dive!\n\u2022 The ELF executable defines several segments:\n\u2022\n\u2022\n\u2022\n\u2022\n\n\u2013 The code segment (machine code)\n\u2013 The data segment (program data)\n\u2013 The read-only data segment (constants)\n\u2013 Uninitialized data segment (\u201czero\u201d data)\n\n\u2022 The\nsegment is a special segment for all data\nthat starts as\nor\n.\n\u2022 (Its name is Block Started by Symbol which is a historic\nname.)\n\u2022 It is often an optimization: the executable does not need to\nstore a whole bunch of zeros.\n\u2022 Hmm\u2026 the operating system must then allocate a bunch of\nzeros. Is that fast?? (We\u2019ll get there)\n\nKernel Memory\nstack\ncurrently unused but\navailable memory\n\nheap\n.bss\n.data\n\n.text\n26\n\n\fRunning a program\n1. Take the ELF executable.\n\nOur lie starts to unravel!\nWe have a kernel\u2026\n\n\u2022 This defines each segment and where in memory\nit should go.\n\n2. Place the\nsegment into memory.\n3. Place the\nsegment into memory.\n4. Write the number of zeroes specified to the\nsegment.\n5. Allocate the stack and assign the stack\npointer (\n)\n6. Jump to the entry point address (the\nlocation of the\nsymbol)\n\u2022\n\nwill call main after initializing the C\nruntime and the heap.\n\nKernel Memory\nstack\ncurrently unused but\navailable memory\n\nheap\n.bss\n.data\n\n.text\n27\n\n\fSome .bss BS I\u2019ve dealt with\u2026\n\u2022 Forgetting to zero the .bss segment is\u2026 very interesting.\n\u2022 If you write an OS, and forget this, then you get loops that don\u2019t work write.\n\u2022 Because now variables that were equal to\nare now random garbage.\nC(\n\n)\n\nThis goes into the .bss because it is zero\n\nThis does not go into the .bss because it is not a symbol.\n\n28\n\n\fThat\u2019s it???\n\u2022 Pretty much! However, let\u2019s make it more flexible.\n\u2022 Our linking so far is static linking where all of the code goes into\nthe executable. Duplicate code from static libraries is copied in.\n\u2022 Not very space efficient. Duplicates code most programs are using! (libc)\n\u2022 What if we \u201cshared\u201d the code external to the executable?\n\n\u2022 For dynamic linking we will think about loading not just the\nexecutable, but library code as well. A shared library.\n\u2022 The OS loader must load the program into memory and also take on the\ntask of loading library code.\n\u2022 It then must do the \u201cmad-libs\u201d replacing references in the program to\npoint to where in memory the library code was loaded. Tricky!\n29\n\n\fDynamic Linking\nLinking but\u2026 yanno\u2026 animated.\n\n30\n\n\fCode that can be loaded\u2026 anywhere?\n\u2022 The main problem is this:\n\u2022 Programs generally need to assume where in\nmemory they live.\n\n\u2022 They refer to functions and data at particular\naddresses.\n\u2022 The linker decides where those are, but they are\nthen hard-coded in.\nWhere should this go??\n\n\u2022 We want to provide a single software library\nto multiple executables\u2026\n\u2022 We can\u2019t know ahead of time where that library\ncan go in memory since programs are different\nsizes\u2026 they might need multiple libraries\u2026 etc.\nCS/COE 0449 \u2013 Spring 2019/2020\n\nKernel Memory\nstack\nlibz.so .data\nlibz.so .text\n\n.bss\n.data\n\n.text\n31\n\n\fSolution: relocatable code\n\u2022 Let\u2019s allow code to refer to functions and/or data that may move.\n\u2022 Essentially, the operating system plays the mad-lib game.\n\u2022 The ELF executable has a list of \u201crelocatable entries\u201d\n\u2022 The OS goes through them and fills them in according to where the external\nsymbols are.\nLinking to the libz.so dynamic library\n\nC(\n\n)\n\nWe don\u2019t know where this function ultimately is\u2026\n\n32\n\n\fSolution: relocatable code\n\u2022 Let\u2019s allow code to refer to functions and/or data that may move.\n\u2022 Essentially, the operating system plays the mad-lib game.\n\u2022 The ELF executable has a list of \u201crelocatable entries\u201d\n\u2022 The OS goes through them and fills them in according to where the external symbols are.\nC(\n\n)\n\nx86-64 (\n\n)\n\n33\n\n\fSolution: relocatable code: Loading\n\u2022 When the OS loads this executable\u2026 it will have a relocation entry that tells\nit to overwrite at byte\nthe relative address of \u201ccompressBound\u201d\n\u2022 With this extra step, the OS loader is also providing dynamic linking.\nC(\n\n)\n\nx86-64 (\n\n)\n\n0x114b + 0x5fe = 0x1749\n(\nis relative to\n)\nIn modern times, this makes use of a jump table\ncalled\nProcedure\nLinkage Table (PLT).\nCS/COEa\n0449\n\u2013 Spring 2019/2020\n\n34\n\n\fTaking a PIC, eating some PIE \u2013 Avoiding relocations\n\u2022 In order to allow code to be resident\nanywhere in memory, the compiler must\nemit machine code that always uses\nrelative addresses!\n\n\u2022 This is called position independent\ncode (or PIC).\n\u2022 When your entire executable is made\nout of PIC, it is a position independent\nexecutable (or PIE)\n\u2022\n\nwill compile code this way when\nyou specify the\nflag.\n\nWho doesn\u2019t like pie???\n\n\u2022 You generally need this when creating\ndynamic libraries.\n\n35\n\n\fRunning a program - Redux\n1. Take the ELF executable.\n2. Place and initially prepare the\nsegments into memory.\n5. Allocate the stack and assign the stack pointer\n(\n)\n6. Repeatably load each required shared library.\n6a. Place .text and .data in memory\n6b. Rewrite .text sections by looking at the\nrelocatable entries\n6c. Repeat for each library.\n7. Jump to the entry point address (the location of\nthe\nsymbol)\n\u2022\n\nwill call main after initializing the C\nruntime and the heap.\n\nKernel Memory\nstack\nlibz.so .data\nlibz.so .text\n\nheap\n.bss\n.data\n\n.text\n36\n\n\fBeing lazy \u2013 Run-time loading\n\u2022 Having the OS load every library at\nthe start can delay the execution\nof a program.\n\u2022 What if your program rarely uses a\nlibrary?\n\u2022 What if you want to expand the\nprogram while it is running?\n\nC(\n\n)\n\nFunction pointers are\nvery messy.\n\n\u2022 Plugins are a good example.\n\n\u2022 We can make use of an OS service\nto dynamically load libraries.\n\u2022 On Linux we have the\nand\nsystem functions.\n\u2022 Look at the documentation online\nand refer to examples.\n\nPrints to the screen\u2019s \u201cerror\u201d buffer.\n\nUses the lazy-loaded function.\n\n37\n\n\fInvestigating dynamic libraries\n\u2022 If you would like to see what dynamic libraries a program uses, you\ncan use\nor the\ncommand.\n\u2022 Cannot see the\n\n/\n\nlazy loaded libraries.\n\n\u2022\n\u2022\n\n38\n\n\fLinking, loading; static and dynamic\u2026 Whew!\n\u2022 Linking is when we merge multiple pieces of executable code into one\nlogical program.\n\u2022 We link at various times:\n\u2022 At compile-time: using our normal\n\nfiles and static libraries (\n\n)\n\n\u2022 At load-time: our OS reads and loads the executable and loads dynamic libraries\n(\n) at the same time, rewriting relocatable sections.\n\u2022 At run-time: our program uses system services (\nlibraries lazily.\n\n) to load dynamic\n39\n\n\fSoftware Licensing\nCombining code\n\n40\n\n\fSo derivative\u2026\n\u2022 Software is generally built from existing software.\n\u2022 Only building bespoke programs would be impractical.\n\n\u2022 However, how do we negotiate such usage of software?\n\u2022 And how does this impact the design of systems?\n\n\u2022 Disclaimer: I am not a lawyer.\n\u2022 But\u2026 neither will you be one\u2026\n\u2022 And yet, we often find the need to be.\n\n41\n\n\fUNIX\n\u2022 The UNIX system, which Linux is somewhat modeled after, was\noriginally from American Telephone & Telegraph (AT&T).\n\u2022 Hence lots of AT&T intellectual residue\n\n\u2022 Because of an anti-trust case from 1956, they entered a \u201cconsent\ndecree\u201d with the government.\n\u2022 AT&T could not sell anything that does\nnot pertain to \u201ccommon carrier\ncommunications services\u201d (telephony)\n\u2022 Therefore, UNIX, their product, could\nnot be profitable\n\u2022 ANTI-TRUST WORKING?? WHAT A TIME!\n\n\u2022 Due to this, UNIX was shipped out\nmostly for a low cost; with source!\n\u2022 Hardware was the money maker.\n\n42\n\n\fThe bell tolls\u2026\n\u2022 AT&T often flirted with what they could get away with, yet in 1983,\nthe U.S. government broke up the \u201cBells\u201d that made up AT&T.\n\u2022 This freed AT&T from the decree.\n\u2022 And allowed them to commercialize UNIX.\n\n\u2022 The source code for UNIX became less\nand less available.\n\u25aa It came at a high cost\u2026 and not available to\nthe average user.\n\u25aa This motivated many engineers/researchers\nto organize.\n\n43\n\n\fA GNU world\u2026\n\u2022 Researchers, lulled into a world where systems software was opensource, felt disenfranchised by such new corporate policies.\n\u2022 Quite hard to research system design without easy access to the system.\n\n\u2022 Richard Stallman created the GNU\n(GNU is Not Unix) Project.\n\u2022 An effort to replace UNIX and other systems\nsoftware with community-built versions.\n\u2022 He creates the GNU C Compiler (gcc)\n\u2022 Organized around the Free Software\nFoundation (FSF)\n\n\u2022 He licenses the work under the GPL.\n\u2022 GNU Public License later GNU General\nPublic License\n44\n\n\fGPL: Free Software Movement\n\u2022 The GPL has evolved over time to legally enforce several things:\n\u2022 The work can be freely studied. (open source)\n\u2022 The work can be freely modified.\n\u2022 The work can be freely copied/distributed with/without changes.\n\n\u2022 These rules apply to all derivative versions. (All modifications)\n\u2022 Your modifications require you to distribute the source with your\nprogram.\n\u2022 Prevents others from adding substantive changes to divide userbases.\n\u2022 Known colloquially as a \u201ccopyleft\u201d license or \u201cviral\u201d license.\n\n\u2022 This contract is enforced by U.S. and international copyright law.\n\u2022 By not using a software license, technically nobody can modify or\ndistribute your code!\n\u2022 Current copyright law lasts the life of the author + 70 years.\n\u2022 Yikes.\n\n45\n\n\fWhat is derivative?\n\u2022 Copyright interacts heavily with systems software.\n\u2022 When your program calls a system call, it executes\ncode written by somebody else.\n\u2022 Is this copyrighted? (Yes. Everything is.)\n\u2022 If it is GPL, does it make your program a derivative?\n\u2022 AHHHHH.\n\n\u2022 If your compiler, like GCC, is copyleft, is your\nprogram derivative?\n\u2022 Generally, no, but runtime code and C standard library\nare GPL.\n\n\u2022 Special exceptions must exist for these blurry lines\nbetween systems software and application\nsoftware.\n\nLinux is licensed\nunder the GPL\n46\n\n\fOperating Systems and Copyright Law\n\u2022 We\u2019ve seen an executable loader in this lecture.\n\u2022 Part of the OS! Obviously derivative to the OS.\n\n\u2022 User programs are not considered \u201cderivative\u201d to the OS.\n\u2022 They aren\u2019t operating systems\u2026 just enabled by them.\n\u2022 THANK GOODNESS.\n\n\u2022 Linux has a \u201csystem call\u201d exception.\n\u2022 Use of system calls is never considered \u201cderivative\u201d\n\u2022 THANK GOODNESS.\n\n\u2022 But some other parts are left very very unclear.\n47\n\n\fThe Problem\n\u2022 What about device drivers??\n\u2022 Device drivers are small libraries the implement interactions with hardware.\n\u2022 They typically run in the operating system\u2019s space.\n\u2022 Do they \u201cderive\u201d the OS? (They cannot co-exist\u2026 they extend\u2026)\n\n\u2022 This is a difficult problem that plagues Linux\u2026\n\u2022 They need to support proprietary hardware\u2026\n\u2022 At least, not allow large companies software/hardware exclusivity\n\n\u2022 So they then need to wedge in proprietary code\u2026\n\u2022 They can\u2019t because it needs to be under the GPL\u2026\n\u2022 This is antagonistic to culture\u2026 the source cannot be read or modified.\n\n\u2022 Are we willing to wait 70-90 years for a device driver\u2019s copyright to lapse?\n48\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}