{"id": 184, "segment": "unlabeled", "course": "cs0449", "lec": "lec12", "text": "12\n\nHow Programs\nReproduce\n\nCS/COE 0449\nIntroduction to\nSystems Software\n\nLuis Oliveira\n(with content borrowed from wilkie and Vinicius Petrucci)\n\n\fCreating Processes\nForks: what you stick in things that are done\u2026 and sometimes a system call.\n\n2\n\n\fThis is a story about a system call\u2026\n\u2022 We are focusing several system calls starting with\n\u2022 This system call copies the current process.\n\u25aa This creates a \u201cchild\u201d process that is a duplicate of the\nmemory and state of its parent.\n\n\u2022 This can be a convenient way to gain concurrency.\n\u25aa Copy the process and run each copy \u2026\n\u25aa \u2026 those copies now run at the same time.\n\u2022 This is the origin of the term \u201cfork\u201d \u2026 a logical split in a\nprogram where there are now multiple paths.\n\n\u25aa We will see this idea in action soon.\n3\n\n\fHere\u2019s Dolly\n\u2022 The\n\nsystem call in action:\n\n\u25aa Copies the memory layout.\n\u25aa Copies the process state. (but gives it a unique ID)\n\nA\n\nParent\n\nChild\n\nstack\n\nstack\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\nCPU State A:\nRegisters\n,\n\nCPU State B:\nRegisters\n,\n\nPID: 4356\n\nPID: 6567\n\nB\n\n4\n\n\fHere\u2019s Dolly\u2019s ID tag\n\u2022 The\n\nsystem call in action:\n\n\u25aa Updates the child\u2019s CPU state so that it returns . (An invalid\n\u25aa Updates parent\u2019s CPU state to return the child\u2019s process ID. (\n\nA\n\nParent\n\nChild\n\nstack\n\nstack\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\nCPU State A:\nRegisters\n\nCPU State B:\nRegisters\n\nPID: 4356\n\nEnsures each\nprocess can detect\nwhich it is\n\n)\n)\n\nB\n\nPID: 6567\n\n5\n\n\fA small fork example\u2026 a\u2026 salad fork? example??\n\u2022 There is only one process when\nis called.\n\nC\n\n\u2022 However, when\nis called, the\nsystem call returns \u201ctwice\u201d\nThe x is copied,\nso it has different\nvalues in child\nand parent.\n\n\u25aa Once in the parent process\n\u25aa Once in the child process\n\n\u2022 This starts two concurrent executions\nwithin the same program.\n\u25aa Via two processes.\n\n\u2022 What does this print out?\n\n6\n\n\fChildren first\u2026 OR NOT\n\u2022 If the child process goes first\u2026\n\nC\n\n\u25aa Then it will print the child text.\nChild\n\nParent\n\n\u2022 Then the scheduler schedules the\nparent process once more.\n\u25aa Then it will print the parent text.\n\n\u2022 However, that\u2019s not the only possible\npattern.\n\u2022 If the parent process goes first...\n\u25aa Then it prints the parent text \u2026\n\u25aa \u2026 followed by the child.\n\n7\n\n\fTwo roads diverged in a yellow wood, AND I TOOK BOTH (NOT SORRY)\nC\n\n\u2022 If I were to extend the code to make\nit loop infinitely...\n\u25aa The parent and child will constantly race\nto print out their respective text.\n\n8\n\n\fThe good, the bad, and the unpredictable\n\u2022 Adding concurrency to your program makes things\u2026 weird.\n\u25aa You cannot rely on the order processes will be scheduled.\n\u25aa Your operations will be asynchronous (not synchronized; no known order)\n\n\u2022 If you need to synchronize processes, you can do so with\n\n\u2022\n\n.\n\nyields the process and returns only when a child process ends.\n\u25aa It returns when any child process exits.\n\u25aa Its return value is the pid of the child process that exited.\n\u25aa You can also use\nto specify a specific child process by its pid.\n\n9\n\n\fWaiting is such sweet sorrow\u2026 wait that\u2019s not right\n\u2022 By using\nthe parent process only\ncontinues when the child process ends.\nChild\n\nParent\n\n\u2022 Therefore, the output order is now\nknown.\n\nAlways:\n\n\u25aa If the parent goes first\u2026\n\u25aa It gets stuck at the\ncall.\n\u25aa Then the child goes until it hits\n\u25aa\nends the process.\n\u25aa And then the parent continues.\n\n\u2022 Nice and well-known behavior!\n10\n\n\fNotes on\n\u2022 The\n\nsystem call ends the current process.\n\n\u25aa The given argument is the process return code also known as an exit code.\n\u25aa Normally your program yields an exit code at the end of\n\u25aa Exit ends your program exactly at the point of the call.\n\u25aa Therefore, it has its own means of giving the exit code.\n\n\u2022 However, we can have processes that are no\nlonger running\u2026\n\u25aa Yet, not deallocated either.\n\u25aa The are not living\u2026\n\u25aa And not dead!!\n\n11\n\n\fZombies\n\u2022 A terminated process still takes up space\n\u25aa All that process metadata sticks around\n\u25aa Until the parent tells the system it doesn\u2019t need it\n\n\u2022 As long as the parent stays alive\u2026\n\u25aa The corpse of the child process sticks around, too.\n\n\u2022 These are called zombie processes.\n\u25aa They are processes that still exist and have an ID\nyet do not run and are no longer scheduled.\nDancing Zombie from Plants vs. Zombies\nCopyright PopCap Games, a subsidiary of EA Games\n\n12\n\n\fThe night of the living dead\nC\n\n\u2022 If I added an infinite loop to the\nparent\u2026\n\u25aa When the child ends\u2026\n\u25aa And I list the active processes using the\ncommand.\n\u25aa I see a \u201cdefunct\u201d child process. A ZOMBIE!\n\n13\n\n\fJust the normal kind of dead.\nC\n\n\u2022 However, if I added an infinite loop to\nthe child\u2026\n\u25aa When the parent ends\u2026 the program\nends as well!\n\u25aa And I list the active processes using the\ncommand. I see only the child process\n\nNo zombies here!\nJust orphans\u2026\n\n14\n\n\fHow to run a different program?\n\u2022 When you\nprocess.\n\na process, you are making an exact copy of that\n\n\u2022 However, maybe you want to create a process to run a different\nprogram altogether?\n\u25aa This is very useful\u2026 instead of using a software library\n\u25aa You could just run the existing program.\n\n\u2022 For this purpose, the\n\nfamily of system calls is used.\n\n\u25aa There are several different variations of exec calls\u2026\n\n15\n\n\fInvoking the OS loader\u2026\n\u2022 Using the\n\nC\n\nsystem call.\n\n\u25aa The call takes the path to an executable\n\u25aa And an array of strings for the arguments.\n\u2022 Sentinel: must end in a\n\n\u25aa The first argument to a C program is\nalways its own path!\n\nWe ran \u201c\n\n\u201d\n\nAdd then continued\nour own process.\n\n16\n\n\fHere\u2019s Dolly\u2019s brother Bobby. Bobby is a goat somehow. Don\u2019t ask.\n\u2022 The\n\nsystem call in action:\n\n\u25aa Copies the memory layout. Copies the process state. (but gives it a unique ID)\n\n\u2022 The\n\nsystem call in action:\n\n\u25aa It\u2019s a goat now.\n\nA\n\nParent\n\nChild\n\nstack\n\nnew\nstack\nstack\n\n.bss\n.data\n.text\n\nnew\n.bss\n.bss\nnew\n.data\n.data\nnew\n.text\n.text\n\nCPU State A:\nRegisters\n,\n\nCPU State B:\nRegisters\n,\n\nPID: 4356\n\nPID: 6567\n\nB\n\n17\n\n\fDifferent forms of\n\u2022 You can look up the many different styles of exec\n\u25aa Each one has a different way of calling it.\n\ncalled with an array of strings terminated with a\nsame, but can use specific environment variables\nsearches the system paths for the executable\ncombination of\nand\n\n\u2022\n\u2022\n\u2022\n\u2022\n\n\u2022 There are also\nfunctions that use function arguments instead\nof an array of strings.\n\u25aa\n18\n\n\fThe common ancestor\u2026 and the orphan.\n\u2022 UNIX/Linux has an interesting design: every application is a child process.\n\u25aa The root is the\ntask.\n\u25aa Your shell spawns child\nprocesses when you ask\nto run a command.\n\u25aa It uses\n/\n!\n\ninit\n\nhttpd\n(daemon)\n\nOrphans get adopted by\nthe root process.\n\nHow to interact with this process??\n(signals\u2026)\n\nBash\n(shell)\n\nGUI\n\n\u2022 When your own application\nspawns a process, the same thing\nhappens.\n\n./app\n\nchild\n\n\u25aa You use\n\u25aa If your app exits before the child\u2026\n\u25aa The child is an orphan process. 19\n\n\fAn extreme attitude\n\u2022 How do we interact with orphaned processes?\n\u2022 How do we synchronize at a finer granularity?\n\u25aa Using\nis rather inflexible.\n\u25aa It can only detect that a child process ends using\n\nor via main\n\n\u2022 What if you want to synchronize smaller events\u2026\n\n\u25aa The child process does something... The parent responds\u2026\n\u25aa But, keep the child process running longer.\n\n\u2022 For this, we will need the parent and child to be able to communicate\nwith one another.\n20\n\n\fInter-Process Communication\nIPC \u2026 not to be confused with the other IPC\n\n21\n\n\fWhat that last slide said\u2026\n\u2022 Passing data or messages from one process to another is called\ninter-process communication.\n\u2022 This is a broad OS topic as there are many ways to do this.\n\u25aa Shared memory (we will talk about this a bit later)\n\u25aa Message passing (we will talk about this NOW)\n\u2022 Simple messages (signals, this lecture)\n\u2022 More complex (pipes, semaphores, etc, soon)\n\u2022 Most complex (network sockets, we will look at this later)\n\n\u2022 Message passing is a fancy way of saying are using an API to send a\nsmall message to another process.\n\u25aa And also some means of listening for messages.\n22\n\n\fAll aboard the train metaphor\n\u2022 In UNIX/Linux, tiny messages sent between processes are called\nsignals.\n\u2022 They are typically used to send messages about events from the\nsystem. Here are a few:\nNumber\n\nName\n\nDescription\n\nDefault Behavior\n\nInterruption \u2013 Somebody pressed CTRL+C\n\nTerminate\n\nKill \u2013 Somebody wants us gone\u2026 \uf04c\n\nTerminate\n\nMemory Violation \u2013 Oops! Seg-fault\n\nTerminate\n\nChild exited \u2013 Child process ended\n\nIgnore\n\nA signal that you can use for any purpose\n\nIgnore\n\n23\n\n\fTalking to orphans\n\u2022 Recall the infinite looping child.\n\u2022 Orphans run in the background.\n\u2022 However, we can send a\nmessage ( ) to the process by its id.\n\nC\n\nThe parent ended.\n\nBut not the child.\nWe can send a\nusing the\n\nmessage\napplication..\n\nAnd the child is gone!\n\n24\n\n\fReceiving Signals\nC\n\n\u2022 The\nstandard function will\nset up your application to listen for a\nparticular signal.\n\n\u2022 This example hooks the empty\nfunction sigint_handler to override\nthe default behavior of the SIGINT\nsignal.\n\u2022 If you recall, that happens on a\nCTRL+C\u2026 which now does not\nterminate the foreground process!\n\u25aa Needs to be killed using\n\nnow.\n25\n\n\fWaiting for a signal\u2026\n\u2022 Proper use of signals and waiting on\nthe values of variables to change can\ncreate synchronization.\nBoth processes set\nto 0 on\n1.\n\n.\n\nis initially\n2. Which causes\nthe child to wait\u2026\n5. Until child signals it back\nafter printing its own message.\n3. Until the parent process signals it,\nafter it prints its message.\n\n6. Repeat\u2026 for both\n\n4. Afterward, the\nparent process waits\n\n26\n\n\fLet\u2019s look at that again. (animated)\n1. Child waits\n2. Parent prints\nChild 0\n\n1. Sets its own wait variable\n2. Sends signal to child\n3. Waits\n\nParent 0\n\n3. Child prints\n1. Sets its wait variable\n2. Sends signal to parent\n3. Waits\n\n4. Parent prints\n1. Sets its own wait variable\n2. Sends signal to child\n3. Waits\n5.\n\nRepeat\u2026\n\n27\n\n\fIf you are in a hurry... (animated)\n1. Child waits\n2. Parent prints\nChild 0\n\n1. Sets its own wait variable\n2. Sends signal to child\n3. Waits\n\nParent 0\n\n3. Child prints\n1. Sends signal to parent\n2. Sets its wait variable\n3. Waits\n\nLet\u2019s Mess Things Up!!\n4. Parent prints\n\n1. Sets its own wait variable\n2. Sends signal to child\n3. Waits\n5.\n\nOH NO!!!\n\n28\n\n\fThe race is on!\n\u2022 When you have concurrent tasks, they may compete.\n\u2022 A bug in a concurrent program where the logic breaks if one process\nout-paces another is called a race condition.\n\u25aa That is, if the correctness requires a strict order, but that order is not\nguaranteed.\n\n\u2022 When you add synchronization you need to be careful that you ensure\nthat each synchronized section (called a critical section) is logically\nsound.\nWe know we won\u2019t be interrupted\nbetween the while loop and the signal.\n(This is our critical section)\n\n29\n\n\fSummary\n\u2022 Today we learned the birds and bees of programs.\n\u25aa They start as processes (technically children of a shell or some root process)\n\u25aa They can spawn child processes using\n\u25aa They can load executables over top of them using\nsystem calls\n\u25aa And if one process ends before the other, we either get zombies or orphans.\n\n\u2022 We also learned about inter-process communication in the form of\nsignals.\n\u25aa These are tiny messages sent using the\nfunction; received via\n.\n\u25aa We can use them to synchronize events between processes.\n\u25aa However, if we aren\u2019t careful, we may introduce a bug called a race condition.\n\u25aa This is when the program requires a logical order it cannot guarantee.\n30\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}