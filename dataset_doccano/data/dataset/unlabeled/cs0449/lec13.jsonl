{"id": 181, "segment": "unlabeled", "course": "cs0449", "lec": "lec13", "text": "13\n\nVirtual\nMemory\n\nCS/COE 0449\nIntroduction to\nSystems Software\n\nLuis Oliveira\n(with content borrowed from wilkie and Vinicius Petrucci)\n\n\fThe Virtual\nI just want to use this time to point out that \u201cVirtual Reality\u201d is an oxymoron.\n\n2\n\n\fOur protagonist\u2019s journey so far\u2026\n\u2022 Processes have an addressable memory space.\n\u25aa We call this an address space.\n\n\u2022 Now, we know it has some obvious things\u2026\n\u25aa The code (.text)\n\u25aa The data (.data)\n\u25aa A stack and some available space that can be\nallocated as we need it.\n\n\u2022 We added the \u201cKernel\u201d memory to our diagram.\n\u25aa This is the OS code and data.\n\u25aa For system processes to run, they need to be\nresident in memory as well.\n3\n\n\fRandom Access Memory\n\u2022 Memory is a\nphysical device.\n\nSense Line\n\n\u2022 It is a random\naccess device.\n\u25aa Allows the\nmachine to access\ndata at any point.\n\nCapacitor\nControl\nLine\n\n\u2022 As opposed to\n\nsequential access.\nDynamic RAM (DRAM)\n\n4\n\n\fLet\u2019s get physical\n\u2022 Physical\naddressing is\nwhen hardware\nrelates a program\naddress directly to\nthe memory\nhardware.\n\u2022 The program\naddresses are the\nexact physical\nlocations of data.\nDynamic RAM (DRAM)\n\n5\n\n\fLet\u2019s get physical\n\u2022 Physical addressing is\nuseful when you\nhave only a single,\nsimple process.\n\u2022 Embedded devices\n(small, specific uses)\n\u2022 Think of your\ntoaster\u2026 or a\nthermostat.\n\nMemory load\n\nAddress Space\n\nCPU\n\nDynamic RAM (DRAM)\n\n6\n\n\fThe problem\n\u2022 However, we don\u2019t always have such simple cases.\n\u25aa A general-purpose system, like our phones and desktop machines, can run a\nvariety of programs.\n\u25aa We often have multitasking operating systems running many programs at the\nsame time.\n\n\u2022 When we have several processes, how to we manage memory?\n\u25aa How to present a consistent address space?\n\u25aa How to prevent other processes from interfering?\n\u25aa How to prevent address space fragmentation?\n\n\u2022 The solution, as usual: indirection: Virtual Memory.\n7\n\n\fVirtual vs. Reality\n\u2022 Just like \u201cvirtual reality,\u201d we create a\nworld that resembles reality, but it\nreally is a facsimile.\n\u2022 We can provide a scheme, backed\nby hardware, that allows memory\naddresses to be seen by programs in\na specific place\u2026\n\n\u2022 Yet, those addresses differ from the\nactual physical memory location.\n\nAngela Lansbury as Jessica Fletcher, Director Lee Smith\nMurder, She Wrote; \u201cA Virtual Murder\u201d\nUniversal Studios, Universal Television, 1993\n\n8\n\n\fConsistency, dear Watson.\n\u2022 When you write a program, do you write it deliberately for the\nmemory layout of your OS?\n\u25aa No!\n\n\u2022 The OS loads executables to specific places in memory.\n\u25aa The program expects data to be in a specific place.\n\u25aa The program expects memory to be \u201clarge enough.\u201d\n\n\u2022 So, we will look at one strategy to define well-known stretches of\nmemory (virtually) that are mapped to physical memory (in reality.)\n\n9\n\n\fSegmentation\nIt\u2019s not just a type of fault.\n\n10\n\n\fSegmentation\n\u2022 Segmentation is a virtual\nmemory system where spans\nof physical memory called a\nsegment are given a physical\nbase address.\n\u2022 The application refers to the\nvirtual address by its segment\nindex which is translated by\nhardware into the real address\nbehind-the-scenes.\n\n\u2022 Here, we have a segment table\nwhich defines two segments.\n\u25aa The first segment defines a range of\naddresses from\nto\n.\n\u25aa Second is\nto\nSegment Table\nIndex\n\nPhysical\nBase\n\nSize\n\n11\n\n\fAddress Translation\n\u2022 The Memory Management Unit\n(MMU) is a hardware component of\nyour CPU that translates virtual\naddresses to physical addresses.\n\u2022 Here, it translates based on the\nsegment table.\nAddress Space\n\nSegment Table\nIndex\n\nPhysical\nBase\n\nSize\n\nMMU\n\nCPU\n\nDynamic RAM (DRAM)\n\n12\n\n\fAddressing the Code Segment\n\u2022 The MMU translates\naddresses by looking\nup the segment index\nand adding the base to\nthe given offset.\nMMU\n\nMemory load\n\nSegment Table\nIndex\n\nPhysical\nBase\n\nSize\n\nAddress Space\n\nCPU\n\nDynamic RAM (DRAM)\n\n13\n\n\fAddressing the Data Segment\n\u2022 The same offset might\nrefer to a different\nphysical address\ndepending on the\nindex and the table.\nMMU\n\nMemory load\n\nSegment Table\nIndex\n\nPhysical\nBase\n\nSize\n\nAddress Space\n\nCPU\n\nDynamic RAM (DRAM)\n\n14\n\n\fAddressing\u2026 nothing\n\u2022 However, if the MMU\ncannot translate an\naddress, it will fault.\n\u2022 This is a segmentation\nfault.\n\nMMU\n\nMemory load\n\nSegment Table\nIndex\n\nPhysical\nBase\n\nSize\n\nAddress Space\n\nCPU\n\nDynamic RAM (DRAM)\n\n15\n\n\fAddressing\u2026 out of range\n\u2022 This is true even if the\naddress calculation results\nin an address that is\nallocated to another\nsegment.\n\u2022 Fault: It goes beyond the\nsize of the segment.\n\nMMU\n\nMemory load\n\nSegment Table\nIndex\n\nPhysical\nBase\n\nSize\n\nAddress Space\n\nCPU\n\nDynamic RAM (DRAM)\n\n16\n\n\fIt\u2019s for your pwn protection\n\u2022 The lie only operates if processes cannot see each other.\n\u25aa It\u2019s not just about address spaces not overlapping\u2026\n\u25aa It is also for security purposes!\n\n\u2022 You don\u2019t want your login process to be snooped on by another.\n\n\u2022 Yet, also, you don\u2019t want your own program to do ridiculous things it\nshould not do!\n\u25aa Should your program be able to write to constant values?\n\u25aa Should your program be able to execute instructions in the\n\nsegment?\n\n\u2022 Virtual memory generally also has ways to arbitrate access.\n17\n\n\fAmending to add access control\n\u2022 The MMU can also arbitrate access\nto the segments by adding access\ncontrol to the segment table.\n\u2022 Here, a in the table denotes the\naction is allowed.\n\u25aa\n\u25aa\n\nWrites allowed.\nCan be executed.\n\nAddress Space\n\nSegment Table\nI\n\nPhysical\nBase\n\nSize\n\nW\n\nX\n\nMMU\n\nCPU\n\nDynamic RAM (DRAM)\n\n18\n\n\fWriting to the Code Segment? NO!!\n\u2022 When the MMU\ndecides if an action is\nallowed, it looks at the\naccess control bits in\nthe table.\nMMU\n\nMemory store\n\nSegment Table\nI\n\nPhysical\nBase\n\nSize\n\nW\n\nX\n\nAddress Space\n\nCPU\n\nDynamic RAM (DRAM)\n\n19\n\n\fExecuting the Data Segment? ABSOLUTELY NOT!!\n\u2022 This feature can be\nused to effectively\nprevent many buffer\noverflow attacks.\n\u2022 Here, you can\u2019t\nexecute application\ndata.\n\nMMU\nInstruction Fetch\n\nSegment Table\nI\n\nPhysical\nBase\n\nSize\n\nW\n\nX\n\nAddress Space\n\nCPU\n\nDynamic RAM (DRAM)\n\n20\n\n\fA Problem Remains: Fragmentation\n\u2022 In a purely segmented system, you can map\nregions of physical memory.\n\n???\n\n\u2022 However, the segments of virtual memory\nare continuous in physical memory and\ncannot overlap other physical regions on the\nsystem.\n\n\u2022 We may run out of room as we run more\nprocesses\u2026\n\u2022 \u2026 and as processes finish, they may leave\nawkward gaps in memory. (external\nfragmentation)\n21\n\n\fPaging\nThis won\u2019t give you paper cuts... I don\u2019t think.\n\n22\n\n\fMaking things\u2026 smaller.\n\u2022 So, segmentation helped us isolate\nprocesses by allowing a virtual address\nspace where large spans of memory\nwere mapped continuously to a\nphysical address range.\n\u2022 Since segments are large, managing\nthat space is difficult.\n\u2022 So why don\u2019t we make the segments\u2026\nsmall? And use more of them?\n\n\u2022 Welcome to the wonderful world of\npages!\n\nProcess\u2019s Virtual\nAddress Space\n\n23\n\n\fPaging Mr. Herman\u2026 Mr. P. W. Herman\u2026\n\u2022 Each segment is itself divided into\nsmaller pieces called a page.\n\u2022 This allows us to even interleave the\ndifferent pages that make up a section\nof memory.\n\u2022 Because of this interleaving and that\nevery page is the same exact size,\nremoving a page leaves room for\nexactly one page\u2026 no fragmentation.\n\u25aa At the cost of over-allocating, if we need\nless space than a single page.\n\nAllocating this:\n\nRemoving this\npage left room big\nenough for\u2026 a new\npage!\n\nProcess\u2019s Virtual\nAddress Space\n\n24\n\n\fPage Tables\n\u2022 There are many strategies for\nmaintaining the metadata that maps\nvirtual addresses to physical\naddresses.\n\nCPU\n\nVirtual Address\nPage Index\n\nPage Offset\n\n\u2022 The first we will look at is the simple\npage table.\n\u2022 In this strategy, we will maintain a\ndata structure that maps virtual\naddresses to physical addresses.\n\nPhysical Address\nPage Index\n\nPage Offset\n\n25\n\n\fAddress Fields\nVirtual Address\n\n\u2022 First, you need to set a static\npage size.\n\nPage Index\n\nPage Offset\n\n\u25aa Every page is the same size.\nProcess Page Table\n\n\u2022 Part of the virtual address is the\noffset, which is retained when\nthe MMU translates the physical\naddress.\n\nValid\n\nWrite\n\nExecute\n\nPage Address\n\nIndex\n\n\u25aa This is determined by the page size.\nPhysical Address\n\n\u2022 The remainder is used to\ndetermine the entry in the table.\n\nPage Index\n\nPage Offset\n\n26\n\n\fIt\u2019s not your fault\u2026\nVirtual Address\n\n\u2022 If there is no entry for the given\npage or the entry isn\u2019t valid\u2026\n\nPage Index\n\nPage Offset\n\n\u25aa Or if an operation is not allowed.\nProcess Page Table\nValid\n\n\u2022 This signals a page fault.\n\nExecute\n\nPage Address\n\nIndex\n\n\u25aa Similar to a segmentation fault.\n\u25aa In fact, many OSes retain that term\nto this day, even when it is a page\nfault, technically.\n\n\u2022 This is a generic error that is\ntriggered by the MMU on such\ninvalid accesses.\n\nWrite\n\nDRAM\nCPU\n\nVirtual Address\n\nX MMU\n\n27\n\n\fProcess Isolation\n\u2022 To give each\nprocess its own\nvirtual address\nspace, each process\ngets its own page\ntable.\n\nPage Table\nAddress\nProcess Page Table\nValid\n\nWrite\n\nExecute\n\nPage Address\n\nIndex\n\n\u2022 The CPU keeps\ntrack of which page\ntable is active.\nDRAM\nCPU\n\nVirtual Address\n\nMMU\n\nPhysical Address\n\n28\n\n\fContext Switching: Getting to the root of it.\n\u2022 When an Operating\nSystem goes from one\nprocess to another, it\nperforms a context\nswitch.\n1. Store registers\n(including stack\npointer and program\ncounter) to memory.\n2. Determine next\nprocess to run.\n3. Load those registers\nfrom memory.\nSwitch address\nspace.\n4. Jump to old program\ncounter. Go!\n\nProcess A\n\nProcess B\n\nProcess C\n\nstack\n\nstack\n\nstack\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\nCPU State A:\nRegisters\n,\n\nCPU State B:\nRegisters\n,\n\nCPU State C:\nRegisters\n,\n\nPage Table\nAddress A\n\nPage Table\nAddress B\n\nPage Table\nAddress C\n\nDRAM\nCPU\n\nVirtual Address\n\nMMU\n\nPhysical Address\n\n29\n\n\fAddressing the granularity issue\n\u2022 The table size has to do with how big\nyou make each page.\n\u25aa The bigger the page, the less entries you\u2019ll\nneed for your process.\n\u25aa However, the more internal\nfragmentation if you do not need some of\nthat space!\n\n\u2022 For a page size of \ud835\udc3e\n\u25aa Page offset will have log 2 \ud835\udc3e bits.\n\u25aa Page index will be the remaining bits.\n\n\u2022 For 32-bit address spaces:\n\u25aa Assuming table entries are also 32-bits.\n\nVirtual Address\nPage Index\n\nPage Offset\n\n\ud835\udc3e = 216 \ud835\udc3e\ud835\udc56\ud835\udc35 = 64\ud835\udc3e\ud835\udc56\ud835\udc35\nMapping 2MiB takes 32 pages.\nPage table size: 216 \u2217 4\ud835\udc35 = 256\ud835\udc3e\ud835\udc56\ud835\udc35\nPage Index\n\nPage Offset\n\n\ud835\udc3e = 212 \ud835\udc3e\ud835\udc56\ud835\udc35 = 4\ud835\udc3e\ud835\udc56\ud835\udc35\nMapping 2MiB takes 512 pages.\nPage table size: 220 \u2217 4\ud835\udc35 = 4\ud835\udc40\ud835\udc56\ud835\udc35\nPage Index\n\nPage Offset\n\n\ud835\udc3e = 28 \ud835\udc35 = 256\ud835\udc35\nMapping 2MiB takes 8192 pages.\nPage table size: 224 \u2217 4\ud835\udc35 = 64\ud835\udc40\ud835\udc56\ud835\udc35 30\n\n\fInverted Page Tables\n\u2022 There are many strategies for\nmaintaining the metadata that maps\nvirtual addresses to physical\naddresses.\n\nCPU\n\nVirtual Address\nPage Index\n\nPage Offset\n\n\u2022 Now we will look at the inverted page\ntable.\n\u2022 In this strategy, we switch things\naround: we have just one table for the\nwhole system and an entry for every\npossible physical page.\n\nPhysical Address\nPage Index\n\nPage Offset\n\n31\n\n\fAddress Fields\nVirtual Address\n\n\u2022 In this case, you have a single\ntable for the entire system.\n\u2022 When translating, you scan\nthe table to find an entry that\ncontains the page index.\n\nPage Tag\n\nPage Offset\n\nInverted Page Table\nPage Tag\n\nValid\n\nWrite\n\nExecute\n\nIndex\n\n\u25aa This may be intensive!\n\n\u2022 When you do, and it is valid,\nmake a note of the index of\nthe entry. That is the physical\npage index.\n\nPhysical Address\nPage Index\n\nPage Offset\n\n32\n\n\fProcess Isolation\n\u2022 Many processes exist, and\neach may use the same\nvirtual address.\n\u25aa And expect a different physical\npage!\n\nVirtual Address\nPage Tag\n\nProcess ID\n\nPage Offset\n\nInverted Page Table\nPage Tag\n\nProcess ID\n\nValid\n\nWrite\n\nExecute\n\nIndex\n\n\u2022 Since there is only one table\non the entire system, we\nhave to disambiguate.\n\n\u2022 Therefore, we also tag by the\nprocess identifier.\n\nPhysical Address\nPage Index\n\nPage Offset\n\n33\n\n\fWhat\u2019s the size??\n\u2022 One nice feature of an inverted\npage table is the size is bound.\n\nInverted Page Table\nPage Tag\n\nProcess ID\n\nValid\n\nWrite\n\nExecute\n\n\u2022 Since an inverted page table has\nan entry for every possible\nphysical page\u2026\n\u25aa You can simply allocate the table\nof a fixed size big enough to\nrepresent all of physical memory.\n\n\u2022 The size of the table is the\nproduct of the entry size and\nthe number of physical pages.\n\nIf the page size (K) is 4KiB and our\nsystem has 16GiB of RAM, how big\nis the inverted page table?\n234\n16\ud835\udc3a\ud835\udc56\ud835\udc35 / 4\ud835\udc3e\ud835\udc56\ud835\udc35 = 12 = 222 \ud835\udc5d\ud835\udc4e\ud835\udc54\ud835\udc52\ud835\udc60\n2\n222 \ud835\udc5d\ud835\udc4e\ud835\udc54\ud835\udc52\ud835\udc60 \u2217 32 \ud835\udc4f\ud835\udc56\ud835\udc61\ud835\udc60 = 222 \ud835\udc5d\ud835\udc4e\ud835\udc54\ud835\udc52\ud835\udc60 \u2217 4\ud835\udc35\n224 \ud835\udc35 = 24 220 \ud835\udc35 = 16\ud835\udc40\ud835\udc56\ud835\udc35\n\n34\n\n\fTrade-offs. Trade-offs everywhere!\n\u2022 What is best? \u2026 Who even knows.\n\u2022 Inverted page tables are very space efficient since entries are ordered\nby physical page.\n\u25aa However, translations mean scanning the table for entries\u2026 a time-consuming\ntask. \ud835\udc42(\ud835\udc5b) (Can implement with a hashing function, see your OS course.)\n\u25aa Normal page tables are a constant time lookup, \ud835\udc42 1\n\n\u2022 Since they are indexed by virtual address, normal page tables require\nordered virtual memory to be space efficient.\n\u25aa Gaps in virtual memory mean lots of page table entries going unused.\n\u25aa Perhaps we can solve this problem\u2026\n35\n\n\fMulti-level Page Tables (Not a pyramid scheme)\n\u2022 Perhaps we can allow\ngaps in virtual memory\nif we use MORE\nINDIRECTION!\n\n32-bit Virtual Address (\nPage Table\nRoot Address\n\nSecond Index\n\nFirst Index\n\n)\nPage Offset\n\n2nd Level Page Table\n\n\u2022 The use of multiple\nlevels of indirection\ngives a lot of flexibility\nin defining the virtual\naddress space.\n\u2022 Each page table is the\nsize of a page. (\n)\n\n1st Level Page Table\n\nDRAM\n\n36\n\n\fIndirection times two\n\u2022 We split up the virtual\naddress into further\nindex fields.\n\n32-bit Virtual Address (\nPage Table\nRoot Address\n\nSecond Index\n\nFirst Index\n\n)\nPage Offset\n\n2nd Level Page Table\nIndex\n\n\u2022 The top-level index\nyields the real\nphysical address of\nthe page containing\nthe next page table.\n\nWrite\n\nExecute\n\n1st Level Page Table (Real\nIndex\n\n\u2022 This table is used to\ndetermine the referred\nphysical page.\n\nValid\n\nValid\n\nWrite\n\nExecute\n\nPage Table Address\n\n)\nPage Address\n\nDRAM\n\n37\n\n\fHome, home on the [memory] range\n\u2022 Each entry in the toplevel page table\nrepresents an entire\nrange of memory.\n\n32-bit Virtual Address (\nPage Table\nRoot Address\n\n\u2022 Here, the 2nd level index\nis\n. This represents all\nvirtual memory addresses\nwith the most significant\nbinary digits:\n\nFirst Index\n\nPage Offset\n\n2nd Level Page Table\nIndex\n\nValid\n\nWrite\n\nExecute\n\nPage Table Address\n\n1st Level Page Table (Real\nIndex\n\nMaps 4KiB virtual page starting at 0x00400000\nMaps 4KiB virtual page starting at 0x00401000\n...\nMaps 4KiB virtual page starting at 0x007ff000\n\nSecond Index\n\n)\n\nValid\n\nWrite\n\nExecute\n\n)\nPage Address\n\n38\n\n\fIt\u2019s a sparse world, after all\n\u2022 By marking entries\ninvalid in the top-level\npage table, this\ninvalidates the entire\nmemory range.\n\u2022 Attempting to access\nsuch a virtual address\nwould immediately page\nfault.\n\n32-bit Virtual Address (\nPage Table\nRoot Address\n\nSecond Index\n\nFirst Index\n\n)\nPage Offset\n\n2nd Level Page Table\nIndex\n\nValid\n\nWrite\n\nExecute\n\nPage Table Address\n\nNo 1st level table.\n\nTherefore: all virtual addresses between\nand\nare not mapped (and are not referenceable.)\n\n39\n\n\fA got a sparsity jacket, but it was just the sleeves.\n32-bit Virtual Address\n\n\u2022 Given a 32-bit virtual address.\n\nSecond Index\n\n\u25aa And multi-level paging with two\nlevels, each index 10 bits.\n\n\u2022 What is the page size?\n\u25aa 32 \u2212 10 \u2212 10 = 12 \ud835\udc4f\ud835\udc56\ud835\udc61\ud835\udc60 for offset\n\u25aa 212 \ud835\udc35 = 4\ud835\udc3e\ud835\udc56\ud835\udc35 (4 Kibibytes)\n\nFirst Index\n\nPage Offset\n\n2nd Level Page Table\nIndex\n\nValid\n\nWrite\n\nExecute\n\nPage Table Address\n\n\u2022 Given the root page table here,\nand assuming unknown entries\nare invalid, what virtual address\nranges are potentially used?\n\u25aa Let\u2019s find out\u2026\n40\n\n\fContinuing: Filling in the blanks\n\u2022 Given the root page table here, and\nassuming unknown entries are invalid, what\nvirtual address ranges are potentially used?\n\nSecond Index\n\nFirst Index\n\nPage Offset\n\n2nd Level Page Table\n\nto\n\nMaps virtual pages from\n\n32-bit Virtual Address\n\nIndex\n\nValid\n\nWrite\n\nExecute\n\nPage Table Address\n\nto\nto\n\nMaps virtual pages from\n\nto\nto\n\nMaps virtual pages from\n\nto\n\n41\n\n\fBest of both worlds.\n\u2022 With multi-level page tables, we can\nrepresent large ranges of memory\nwith gaps, much like segments!\n\n32-bit Virtual Address\nSecond Index\n\n\u25aa All the while, we can satisfy each\nindividual page in this \u201csegment\u201d by\ninterleaving them throughout physical\nram. (flexibility, no external\nfragmentation)\n\n2nd Level Page Table\n\n1st Level Page Table\n\n\u25aa x86-64 uses a 4 level page table!\nto\nto\nto\n\nPage Offset\n\nPage Table\nRoot Address\n\n\u2022 Modern architectures often use\nmulti-level page tables.\nMaps virtual pages from\nMaps virtual pages from\nMaps virtual pages from\n\nFirst Index\n\nSegments?\n(kinda)\n\nDRAM\n\n42\n\n\fSummary\nSo, we have many complex processes running at the same time.\n\u2022 How to present a consistent address space?\n\u25aa Indirection using segments or page tables.\n\u25aa We translate virtual addresses to physical addresses.\n\n\u2022 How to prevent other processes from interfering?\n\u25aa We can mark segments or individual pages with access controls. (Read-only,\nnon-execute, etc.)\n\n\u2022 How to prevent address space fragmentation?\n\u25aa We give each process its own address space.\n\u25aa When we context switch, we switch address spaces.\n43\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}