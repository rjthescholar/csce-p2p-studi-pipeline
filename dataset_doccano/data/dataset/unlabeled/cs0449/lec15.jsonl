{"id": 183, "segment": "unlabeled", "course": "cs0449", "lec": "lec15", "text": "15\n\nThreads\nand\n\nSynchronization\n\nCS/COE 0449\nIntroduction to\nSystems Software\n\nLuis Oliveira\n(with content borrowed from wilkie and Vinicius Petrucci)\n\n\fThreads\nStrings? Threads?? What are we building\u2026 a loom???\n\n2\n\n\fOur story so far\u2026\n\u2022 We looked at how processes reproduce with\n\u25aa This gave us some type of concurrency.\n\u25aa It is process-level, so the OS is scheduling each task.\n\n\u2022 We saw some issues with concurrent programming.\n\u25aa Race conditions mean we have to much more carefully\nconsider our code.\n\n\u2022 This time\u2026\n\u25aa We will look at other forms of concurrency.\n\u25aa Some new methods of coordinating the different subprograms.\n\u25aa And some new\u2026 dreaded\u2026 types of concurrency bugs.\n3\n\n\fThreads\n\u2022 Process-level concurrency with\npowerful, but inflexible.\n\nis\n\n\u25aa The OS schedules the task, incurring context\nswitching overhead.\n\u25aa The process memory is copied making it hard\nto share data among tasks.\n\n\u2022 A thread is a concurrency primitive that is\ninner-process.\n\u25aa The program itself schedules the task as part\nof the same process.\n\u25aa Process memory, therefore, is shared across all\nthreads.\n4\n\n\fRecall our friend Dolly\u2026\n\u2022 The\n\nsystem call in action:\n\n\u25aa Copies the memory layout.\n\u25aa Copies the process state. (but gives it a unique ID)\n\nA\n\nCS/COE 0449 \u2013 Spring 2019/2020\n\nParent\n\nChild\n\nstack\n\nstack\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\nCPU State A:\nRegisters\n,\n\nCPU State B:\nRegisters\n,\n\nPID: 4356\n\nPID: 6567\n\nPage Table A\n\nPage Table B\n\nB\n\n5\n\n\fDolly learned a new trick!\n\u2022 However, with threads\u2026 we retain much of the address space.\n\u25aa Threads share code/data/etc, however they have their own stack and CPU state.\n\u25aa They execute in parallel with one another interacting directly with the same data.\nProcess\n\n.bss\n.data\n.text\n\nA\n\nstack\n\nstack\n\nstack\n\nCPU State A:\nRegisters\n,\n\nCPU State B:\nRegisters\n,\n\nCPU State B:\nRegisters\n,\n\nPID: 4356\nPage Table A\n\n6\n\n\f\u2022 The 2011 amendment to the C standard (C11) added a threading API.\n\u25aa However, we will still be looking at an older, more prevalent standard.\n\n\u2022 We will be reviewing the\n\nstandard.\n\n\u25aa The C11\nAPI is still very similar.\n\u25aa There are ports of the\ninterface to many OSes.\n\u25aa Lots of threading APIs in other language emulate it.\n\n\u2022 Still very useful to learn!\n\n7\n\n\fPOSIX\n\u2022 The \u201cp\u201d in pthread stands for the Portable\nOperating System Interface (POSIX).\n\u25aa This is a standard for creating OS abstractions.\n\u25aa Intended to lower the burden of porting applications.\n\u2022 Most OSes conform to most POSIX standards.\n\u2022 However, very few OSes fully implement POSIX.\n\n\u2022 POSIX standardizes threads, but also process\ncreation and the behavior of fork, file\nabstractions, and how data is shared among\nprocesses.\n\u25aa Many OS interfaces are POSIX interfaces and remain\n(mostly) true across different platforms.\n8\n\n\fCreating\u2026 hmm\u2026 no\u2026 weaving a thread\nC(\n\n)\n\n\u2022 Here is a basic threaded program.\n\u25aa\n\nThis function runs in a thread\n\nHolds the thread ID.\n\nThe thread function\n\nSpring 2019/2020\n\nFunction\nargument\n\nis within the main thread.\n\n\u2022 The\nfunction\ncreates a second thread, which\nruns alongside the main thread.\n\u25aa The first argument is the address of\na variable to hold the thread ID.\n\u25aa The NULL is where you can add\nsome flags, but the defaults are OK.\n\u25aa The thread is the function to use.\n\u25aa The last argument is passed to that\nfunction and generally an address.\n9\n\n\fThe race to the finish.\nC(\n\n)\n\nThis never happens!\n\n\u2022 However, when the process exits\nnormally, all threads are also\ncanceled, even if they haven\u2019t\ncompleted.\n\u2022 In this run, the second thread\nnever prints its message.\n\nIn the end of the program, threads are also all exited, potentially prematurely.\n\n10\n\n\fBeing considerate\nC(\n\n)\n\n\u2022\nThe \u201cstr\u201d argument.\n\nwaits for the\ngiven thread to exit by thread ID.\n\u25aa The NULL is, again, optional flags.\n\n\u2022 Here, the main thread waits until\nthe thread function completes.\n\u25aa It prints out the string given by the\nargument.\nWaits\u2026\nGuaranteed to happen only after\n\ncompletes.\n\n11\n\n\fSharing is caring\nC(\n\n)\n\nThread function increments\n\n\u2022 Unlike process-level concurrency\nusing\n, threads share\nmemory.\n\u2022 Each thread, here, shares access to\nthe same global variable\n.\n\u25aa When the main thread updates, the\nsecondary thread sees that value.\n\n\u2022 Threads share the same virtual\naddress space (and page table.)\nMain thread increments, too!\n\n\u25aa They only have their own stack and\nCPU state.\n12\n\n\fA problem returns with a vengeance\nC(\n\n)\n\nThread function might get\ninterrupted before the print\n\nThen main thread increments! :(\nRace Condition 13\n\n\fWhat happened???\nC(\n\n)\n\nThread function increments\n\n\u2022 Since the threads share memory,\naccess to a variable, such as this,\nmay require extra care.\n\u2022 When the main thread gets\ninterrupted just as it was printing\nthe value, the thread is scheduled.\n\u25aa The thread prints the value instead.\n\u25aa Then the main thread, when it\ncontinues, prints it again!\n\nMain thread increments, too!\n\n\u2022 If only we had a way to\u2026 align\nthem in time\u2026 what\u2019s the word\u2026\n\n14\n\n\fSynchronization\nYou can\u2019t touch this! Stop! Hammer time!\n\n15\n\n\fA story about the railroad\n\u2022 Systems scientists have long been inspired\nby the real-world for insight on design.\n\u2022 The rail system requires a lot of attention to\ndetail to provide:\n\u25aa Orderly and timely scheduling of trains.\n\u25aa Shared use of a single resource: rail.\n\u25aa Coordination with trains and competing interests.\n\n\u2022 In order to provide this, trains make use of\nsignals and switching areas.\n\u25aa Trains wait while others pass, all agreeing on the\nnature of signals.\n\u25aa The signals are called semaphores.\n\n16\nPhoto by David Ingham\n\n\fThe seminal semaphore\n\u2022 A semaphore is a special counter used for synchronization.\n\u25aa Invented by Dutch systems scientist Edsger Dijkstra in the early 1960s.\n\n\u2022 The counter is a signed integer that often starts at zero or one.\n\u2022 Two defined operations:\n\u25aa Up (signal/release); increments counter.\n\u25aa Down (wait/acquire); decrements counter but waits if the counter is 0.\n\n\u2022 These operations often have different names or are abbreviated:\n\u25aa V (Based on Dutch vrijgave \u201cto release\u201d)\n\u25aa P (Based on Dutch passering \u201cto pass\u201d, based around railroad terminology)\n17\n\n\fSemaphores to prevent the derailing\nC(\n\n)\n\n\u2022\n\ncreates a new semaphore.\n\u25aa The first argument is an address to a\nvariable that will hold the semaphore data.\n\u25aa The second argument, when 0, means that\nother threads can see the semaphore.\nNon-zero means other threads cannot\ninteract with the semaphore, which is a bit\nmore advanced.\n\u25aa The third argument is the initial value.\n\nCritical Section\n\n\u2022 Here it is 1.\n\n\u2022\n\ndecrements the counter.\n\u25aa Waits to decrement if the counter is 0.\n\n\u2022\n\nincrements the counter.\n\u25aa May release a thread waiting at\n\n18\n\n\fSemaphores to prevent the derailing\nC(\n\n)\n\n\u2022 When both threads hit\nat\nthe same time, only one continues.\n\u2022 When one sets the lock; other waits.\n\nCritical Section\n\n\u25aa The other thread relies on the first to\neventually release the lock using\n\u25aa When this happens, the other thread can go.\n\n\u2022 The lock/unlock pattern creates a\ncritical section, a piece of code that has\nthe guarantee that only one task can\nenter at a time.\nSpring 2019/2020\n\n\u25aa Here, the counter is guaranteed to update at\nthe same time as it is printed.\n19\n\n\fSemaphores to prevent the derailing\nC(\n\n)\n\nCritical Section\n\n20\n\n\fMutex\u2026 ew\u2026 don\u2019t like the sound of that\n\u2022 As you can see, there is a common case.\n\u25aa Simple critical sections just need a counter that covers 0 and 1.\n\n\u2022 A mutex is a special Boolean used for synchronization.\n\u25aa It is short for \u201cmutual exclusion,\u201d a term for when two things can only have one\nresource at a time.\n\n\u2022 There are two defined operations:\n\u25aa lock / wait; only proceeds if the mutex is unlocked.\n\u25aa unlock / release; unlocks the mutex.\n\n\u2022 A mutex can be created using a semaphore.\n\u25aa It provides a subset of the capabilities of the more general semaphore.\n\n21\n\n\fA mutex to prevent the derailing\nC(\n\n)\n\n\u2022 Mutexes are useful for locking\nsingle resources.\n\u25aa It follows much the same pattern as\nsemaphores, and perhaps easier to\nunderstand.\n\nCritical Section\n\n\u2022\n\n\u2022\n\nmutex similarly to\n\ncreates the\n.\n\nand\ndo the\nlocking and unlocking, as\nexpected.\n22\n\n\fA mutex to prevent the derailing\nC(\n\n)\n\nCritical Section\n\n23\n\n\fStrategies\n\u2022 Semaphores and mutexes are both primitives to aid in concurrent\nprogramming.\n\u2022 We saw, here, another example of a race condition, a concurrency\nbug where the absence of guaranteed order can result in incorrect\nbehavior.\n\u25aa Namely, threads being interrupted in-between operations that need to happen\ntogether and racing another thread that will incorrectly use that intermediate\nvalue.\n\n\u2022 However, that\u2019s not the only type of concurrency bug we can have!\n\u25aa Yay! \uf04c\n24\n\n\fParallel Pitfalls\nThis is like that time when a bird pooped on me the same time I stepped in a very\nmuddy puddle.\n\n25\n\n\fEverybody loves resources\nResource contention:\n\u2022 Printer needs paper\u2026\n\u2022 You need to buy some\npaper\u2026\n\u2022 You need to print an order\nform for paper\u2026\n\u2022 Printer needs paper\u2026\n26\n\n\fTypically\u2026\n\u2022 Metaphor: intersection.\n\u2022 The intersection is a shared\nresource, much like a device or\nthe CPU.\nIt is fine when two\ntasks can share a\nresource without\nconflict\u2026 they do\nnot need to\ncoordinate.\n\n\u2022 Multiplexing the intersection is\nimportant to avoid crashes.\n\u2022 When the streets aren\u2019t busy,\ncars just make it safely across.\n27\n\n\fDeadlock: The traffic jam (it\u2019s not very delicious)\n\u2022 However, in some\ncircumstances, several cars\nmay reach the intersection at\nthe same time.\n\nNot fine if tasks\nneed a common\nresource at the\nsame time without\nan agreed way to\nproceed.\n\n\u2022 If there is no previously\ndefined way to handle this,\nthey all wait for the others to\nget out of the way.\n\u25aa Forever.\n\n\u2022 Deadlock occurs when multiple\ntasks are waiting for each\nother, making no progress.\n\n28\n\n\fSynchronization solves deadlock\n\u2022 Deadlock is a bug that needs\nextra consideration to avoid.\n\u2022 In this case, you need some\nmethod of making only some\nof the cars (tasks) wait, while\nletting others go.\n\nWith synchronization,\n\u25aa Traffic light, perhaps\ntasks can agree which\nget to go next, and\nwhich have to wait. \u2022 Beyond defining order,\n\nsynchronization helps avoid\nthese types of logical errors.\n29\n\n\fStarved for attention\u2026\n\u2022 Another issue, related to\ndeadlock, is starvation where\nthe system makes progress but\none task is perpetually delayed.\n\n\u2022 When some tasks have priority\nover resources, they may not\ngive them up for other tasks.\n\nWhen nobody yields\nto a particular task\n\u25aa Those tasks wait forever.\nand gives up a shared\nresource, that task\ncannot proceed!\n\u2022 Without a traffic light, you rely\n\non people being nice. :(\n\n30\n\n\fStarvation: a matter of fairness\n\u2022 This can happen in situations where \u201cfairness\u201d scheduling goes awry.\n\u2022 If you have a webserver, the OS might schedule that process whenever\nthere is some incoming requests.\n\u25aa What if you are getting a lot of traffic!\n\u25aa The OS might always schedule the webserver.\n\u25aa Important background tasks might not run!\n\n\u2022 Preventing starvation might be keeping track of how much time a\nprocess has a resource and how long it has waited in line.\n\u25aa Low-priority tasks start at the back of the line and move up the queue the longer\nthey wait\u2026 eventually cutting in front of high-priority tasks that start in the front.\n\n\u2022 That\u2019s just one idea. Scheduling resources is a very difficult problem!\n\n31\n\n\fLivelock: The hallway problem\n\u2022 There is a narrow hallway.\n\u2022 Let\u2019s say you have two very polite\npeople.\n\u2022 They walk toward each other\u2026 and try\nvery hard to get out of each other\u2019s way.\n\u25aa They keep insisting the other go ahead of\nthem.\n\n\u2022 This is livelock, where two tasks are\nactively signaling the other to go and\nmaking no progress.\nSpring 2019/2020\n\n32\n\n\fCareful design works around livelock\n\u2022 Livelock can be solved using a tiebreaking scheme.\n\u25aa Just find something comparable and unique\namong the tasks to create an arbitrary\npriority.\n\n\u2022 All threads have IDs, so one easy\nstrategy is to have the largest ID yield to\nthe smaller.\n\u25aa This also helps starvation since livelock is\nstarvation to the extreme: where everybody\nis starving.\n\n33\n\n\fDeadlock vs. Livelock\n\u2022 In deadlock, all tasks are waiting for a signal that will never happen.\n\u25aa They are inactively achieving nothing. (\u201cZZZZZZZZ\u201d, \u201cZZZZZZZZ\u201d)\n\n\u2022 In contrast, livelock occurs when each task signals the other, and they\nrespond by signaling back. (\u201cNo, you.\u201d \u201cNo\u2026 you!\u201d)\n\u25aa They are actively achieving nothing.\n\n\u2022 Detecting that your program has a deadlock or livelock is tricky.\n\u25aa When it does, it may only happen a small percentage of the time.\n\u25aa In your OS course, you will learn more about deadlock detection and resolution.\n\n34\n\n\fSolving things\n\u2022 Proper synchronization and planning can solve all these issues.\n\u25aa Deadlock: Avoid patterns of critical sections that depend on each other.\n\u25aa Livelock: Establish a tie-breaking mechanism (thread with smallest ID goes first!)\n\u25aa Yet, it takes a good deal of programming experience to handle them.\n\n\u2022 The wide prevalence of multiprocessing and multithreading capable\ncomputers in the hands of average consumers is changing\nprogramming.\n\u25aa New (and old) languages are being pushed for their better handling of\nconcurrency issues.\n\u25aa Best-practices and frameworks continue to adapt to avoid many of the pitfalls\nwe have discussed today.\n\u25aa Pay attention in your compilers and OS course to hone your own skill!\n35\n\n\fbasic API summary\n\u2022 Thread creation\n\u25aa\n\n\u2022 Join threads (wait until complete)\n\u25aa\n\n\u2022 Getting thread ID\n\nWaits for the given thread to end.\n\nReturns the thread ID of the current thread.\n\n\u25aa\n\n\u2022 Thread destruction (explicit)\n\u25aa\n\u25aa\n\nAttempts to preemptively exit the given thread.\nEnds current thread and returns the provided value.\n\n36\n\n\fsynchronization API summary\n\u2022 Semaphores\n\u25aa\n\u25aa\nCreates a semaphore with the given initial value. (The second argument means it the semaphore\ndata is in shared memory. If non-zero, it can\u2019t be seen by other threads.)\n\n\u25aa\n\u25aa\n\nDecrements counter unless it is 0 in which case it waits.\nIncrements counter.\n\n\u2022 Mutexes\n\u25aa\n\u25aa\n\u25aa\n\u25aa\nSpring 2019/2020\n\nCreates a mutex (unlocked).\nWaits until it can lock the mutex.\nUnlocks the mutex.\n37\n\n\fSummary\n\u2022 Threads are a different way to provide concurrency in a program.\n\u25aa Unlike process-level concurrency, threads share memory within the process.\n\n\u2022 Synchronization primitives such as semaphores allow for creation of\ncritical sections; necessary for correct concurrent code.\n\u2022 Incorrect code may result in a new set of logical errors.\n\u25aa Race conditions \u2013 When execution order stochastically results in wrong behavior.\n\u25aa Deadlock \u2013 When resources are contended so much the program freezes.\n\u25aa Starvation \u2013 When a resource is greedily kept by a task, certain tasks freeze.\n\u25aa Livelock \u2013 Starvation happens at every task\u2026 they all actively yield to each other.\n\n38\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}