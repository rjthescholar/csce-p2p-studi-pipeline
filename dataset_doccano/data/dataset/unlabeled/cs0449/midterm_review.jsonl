{"id": 164, "segment": "unlabeled", "course": "cs0449", "lec": "midterm_review", "text": "Intro to Systems\nSoftware\n\nMidterm Review\n\nCS/COE 0449\nIntroduction to\nSystems Software\n\nLuis Oliveira\n(with content borrowed from wilkie and Vinicius Petrucci)\n\n1\n\n\fTopics for the Midterm\n\u2022 Data Representation\n\u2022 2\u2019s complement, Floating point, Bitwise operations,\nEndianness\n\n\u2022 C Programming\n\u2022 Pointers, Arrays, Strings, Memory Management\n\n\u2022 Machine-level Representation (x86-64)\n\u2022 Assembly Basics, Control Flow, Calling Conventions, Buffer\nOverflow\n\n\u2022 Executables\n\u2022 Compilers, Assemblers, Linkers, Loaders\n2\n\n\fData representation\n\n\fEncoding Integers\nTwo\u2019s Complement\n\nUnsigned\n\nB2U(X ) =\n\nw\u22121\n\n\uf0e5 xi \uf0d72\n\nB2T (X ) = \u2212 xw\u22121 \uf0d72\n\ni\n\nw\u22121\n\nSign Bit\n\n\u2022 Two\u2019s Complement Examples (w = 5)\n10 =\n\n-10 =\n\n8\n\n4\n\n2\n\n1\n\n0\n\n1\n\n0\n\n1\n\n0\n\n-16\n\n8\n\n4\n\n2\n\n1\n\n1\n\n0\n\n1\n\n1\n\n0\n\n+ \uf0e5 xi \uf0d72\ni=0\n\ni=0\n\n-16\n\nw\u22122\n\n8+2 = 10\n\n-16+4+2 = -10\n\ni\n\n\fUnsigned & Signed Numeric Values\nX\n0000\n0001\n0010\n0011\n0100\n0101\n0110\n0111\n1000\n1001\n1010\n1011\n1100\n1101\n1110\n1111\n\nB2U(X)\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\nB2T(X)\n0\n1\n2\n3\n4\n5\n6\n7\n\u20138\n\u20137\n\u20136\n\u20135\n\u20134\n\u20133\n\u20132\n\u20131\n\n\u2022 Equivalence\n\u2022 Same encodings for\nnonnegative values\n\n\u2022 Uniqueness\n\u2022 Every bit pattern represents\nunique integer value\n\u2022 Each representable integer has\nunique bit encoding\n\u2022 Expression containing signed\nand unsigned int:\nint is cast to unsigned\n\n\fImportant: Numeric Ranges\n\n\u2022 Unsigned Values\n\u2022 UMin =\n\n\u2022 Two\u2019s Complement Values\n\u2022 TMin\n=\n\u20132w\u20131\n\n0\n\n\u2022 000\u20260\n\n\u2022 UMax\n\n=\n\n\u2022 100\u20260\n\n\u2022 TMax\n\n2w \u2013 1\n\n\u2022 111\u20261\n\n=\n\n\u2022 011\u20261\n\n\u2022 Minus 1\n\u2022 111\u20261\nValues for W = 16\nUMax\nTMax\nTMin\n-1\n0\n\nDecimal\n65535\n32767\n-32768\n-1\n0\n\nHex\nFF FF\n7F FF\n80 00\nFF FF\n00 00\n\nBinary\n11111111 11111111\n01111111 11111111\n10000000 00000000\n11111111 11111111\n00000000 00000000\n\n2w\u20131 \u2013 1\n\n\fThree \u201ckinds\u201d of floating point numbers\ns exp\n1\n\n00\u202600\n\ndenormalized\n\nfrac\ne-bits\n\nf-bits\n\nexp \u2260 0 and exp \u2260 11\u202611\n\nnormalized\n\n11\u202611\n\nspecial\n\n\f\u201cNormalized\u201d Values\n\n\u2022 When: exp \u2260 000\u20260 and exp \u2260 111\u20261\n\u2022 Exponent coded as a biased value: E = exp \u2013 Bias\n\u2022 exp: unsigned value of exp field\n\u2022 Bias = 2k-1 - 1, where k is number of exponent bits\n\u2022 Single precision: 127 (exp: 1\u2026254, E: -126\u2026127)\n\u2022 Double precision: 1023 (exp: 1\u20262046, E: -1022\u20261023)\n\n\u2022 Significand coded with implied leading 1: M = 1.xxx\u2026x2\n\u2022 xxx\u2026x: bits of frac field\n\u2022 Minimum when frac=000\u20260 (M = 1.0)\n\u2022 Maximum when frac=111\u20261 (M = 2.0 \u2013 \u03b5)\n\u2022 Get extra leading bit for \u201cfree\u201d\n\nv = (\u20131)s M 2E\n\n\fDenormalized Values\n\n\u2022 Condition: exp = 000\u20260\n\u2022 Exponent value: E = 1 \u2013 Bias (instead of exp \u2013 Bias) (why?)\n\u2022 Significand coded with implied leading 0: M = 0.xxx\u2026x2\n\u2022 xxx\u2026x: bits of frac\n\n\u2022 Cases\n\u2022 exp = 000\u20260, frac = 000\u20260\n\u2022 Represents zero value\n\u2022 Note distinct values: +0 and \u20130 (why?)\n\n\u2022 exp = 000\u20260, frac \u2260 000\u20260\n\u2022 Numbers closest to 0.0\n\u2022 Equispaced\n\nv = (\u20131)s M 2E\nE = 1 \u2013 Bias\n\n\fSpecial Values\n\n\u2022 Condition: exp = 111\u20261\n\u2022 Case: exp = 111\u20261, frac = 000\u20260\n\u2022 Represents value \uf0a5 (infinity)\n\u2022 Operation that overflows\n\u2022 Both positive and negative\n\u2022 E.g., 1.0/0.0 = \u22121.0/\u22120.0 = +\uf0a5, 1.0/\u22120.0 = \u2212\uf0a5\n\n\u2022 Case: exp = 111\u20261, frac \u2260 000\u20260\n\u2022 Not-a-Number (NaN)\n\n\u2022 Represents case when no numeric value can be determined\n\u2022 E.g., sqrt(\u20131), \uf0a5 \u2212 \uf0a5, \uf0a5 \uf0b4 0\n\n\fCasting floats to ints and vice versa\n\u2022 (int) floating_point_expression\n\u2022 Coerces and converts it to the nearest integer\n(C uses truncation)\ni = (int) (3.14159 * f);\n\n\u2022 (float) integer_expression\n\u2022 Converts integer to nearest floating point\nf = f + (float) i;\n\n\ffloat \u2192 int \u2192 float\nif (f == (float)((int) f)) {\nprintf(\u201ctrue\u201d);\n}\n\u2022 Does it always print \u201ctrue\u201d?\n\u2022 No, small floating point numbers (< 1) don\u2019t have integer\nrepresentations\n\n\u2022 For other numbers, often will be rounding errors\n\n\fint \u2192 float \u2192 int\nif (i == (int)((float) i)) {\nprintf(\u201ctrue\u201d);\n}\n\u2022 Does it always print \u201ctrue\u201d?\n\u2022 No, many large values of integers don\u2019t have exact floating\npoint representations\n\n\u2022 What about double?\n\u2022 Yes, significand is now 52 bits, which can hold all of 32-bit\ninteger, so will always print \u201ctrue\u201d\n\n\fBitwise Operations\n\u2022 Write a C expression that will yield a word consisting of the\nleast significant byte of x and the remaining bytes of y\n\u2022 For operands x = 0x89ABCDEF and y =\n0x76543210, this would give 0x765432EF\n\nHint: use masking and bit manipulation\n\n20\n\n\fBitwise Operations\n\u2022 Write a C expression that will yield a word consisting of the\nleast significant byte of x and the remaining bytes of y\n\u2022 For operands x = 0x89ABCDEF and y =\n0x76543210, this would give 0x765432EF\n\n1) How to extract the upper 3 bytes of x?\n\n(x & 0xFF)\n\n2) How to extract the lower 1 byte of y?\n\n(y & ~0xFF)\n\n3) How to combine them?\n\n(x & 0xFF) | (y & ~0xFF)\n\n21\n\n\fBitwise Operations\n\u2022 How to perform the operation below using shifts/adders only?\n\na * 7\n(a << 3) - a\nlong m12(long x)\n{\nreturn x*12;\n}\n\nConverted to x86-64 by compiler:\nleaq (%rdi,%rdi,2), %rax\nsalq $2, %rax\n\n# t = x+2*x\n# return t<<2\n\n22\n\n\fBitwise Operations\n\u2022 Suppose we number the bytes in a w-bit word from 0 (least significant) to w/8 \u2013 1\n(most significant)\n\u2022 Write code for the following C function, which will return an unsigned value in\nwhich byte i of argument x has been replaced by byte b:\n\nunsigned replace_byte (unsigned x, int i, unsigned char b);\n\nreplace_byte(0x12345678, 2, 0xAB) --> 0x12AB5678\nreplace_byte(0x12345678, 0, 0xAB) --> 0x123456AB\n\n23\n\n\fBitwise Operations\n\u2022 Write code for the following C function, which will return an unsigned value in\nwhich byte i of argument x has been replaced by byte b:\n\nunsigned replace_byte (unsigned x, int i, unsigned char b) {\nint itimes8 = i << 3;\n\nunsigned mask = 0xFF << itimes8;\nreturn (x & ~mask) | (b << itimes8);\n}\n\n24\n\n\fByte Ordering\n\u2022 Example\n\u2022 Variable x has 4-byte value of 0x01234567\n\u2022 Address given by &x is 0x100\nBig Endian\n\n0x100 0x101 0x102 0x103\n\n01\n01\n\nLittle Endian\n\n23\n23\n\n45\n45\n\n67\n67\n\n0x100 0x101 0x102 0x103\n\n67\n67\n\n45\n45\n\n23\n23\n\n01\n01\n\n\fC Programming\n\n\fC Memory Layout Analysis\n\ns1[0] \u2192 ??\n\ns2[0] \u2192 ??\n\n27\n\n\fC Programming\n\u2022 What is wrong with the C code below?\nint* pi = malloc(314*sizeof(int));\nif(!raspberry) {\npi = malloc(1 *sizeof(int));\n}\nreturn pi;\nThere\u2019s a memory leak if raspberry is false as the original value of pi will be\nunreachable\n28\n\n\fC programming\nConsider the following code snippet which allocates an array and\nsets the values:\n1\n2\n3\n4\n5\n6\n7\n8\n\nint main(int argc, char** argv) {\nint *a = (int*) malloc(213 * sizeof(int));\nfor (int i=0; i<213; i++) {\nif (a[i] == 0) a[i]=i;\nelse a[i]=-i;\n}\nreturn 0;\n}\n\nWhich lines have a problem and how can you fix it?\n\n\fC programming\n\n1\n2\n\n3\n4\n5\n6\n7\n8\n\nint main(int argc, char** argv) {\nint *a = (int*) malloc(213 * sizeof(int));\nif (a == NULL) return 0;\nfor (int i=0; i<213; i++) {\nif (a[i] == 0) a[i]=i;\nelse a[i]=-i;\n}\nreturn 0;\n}\n\nmalloc can fail!\n\n\fC programming\n1\n2\n3\n4\n5\n6\n7\n8\n\nint main(int argc, char** argv) {\nint *a = (int*) calloc(213, sizeof(int));\nif (a == NULL) return 0;\nfor (int i=0; i<213; i++) {\nif (a[i] == 0) a[i]=i;\nelse a[i]=-i;\n}\nreturn 0;\n}\n\nAllocated memory is not initialized!\n\n\fC programming\n1\n2\n3\n4\n5\n6\n\n7\n8\n\nint main(int argc, char** argv) {\nint *a = (int*) calloc(213, sizeof(int));\nif (a == NULL) return 0;\nfor (int i=0; i<213; i++) {\nif (a[i] == 0) a[i]=i;\nelse a[i]=-i;\n}\nfree(a);\nreturn 0;\n}\n\nAll allocated memory must be freed!\n\n\fC programming\nWhat lines make safe_int_malloc not so safe?\n1\n2\n3\n4\n5\n\nint *safe_int_malloc(int *pointer) {\npointer = malloc(sizeof(int));\nif (pointer == NULL) exit(-1);\nreturn &pointer;\n}\n\npointer is a local copy of the pointer! Modifying *pointer only changes the value\nwithin the scope of this function not outside\n\n\fC programming\nPassing in an int** let\u2019s us change the value of int* pointer\n\n1\n2\n3\n4\n5\n\nint *safe_int_malloc(int **pointer) {\n*pointer = malloc(sizeof(int));\nif (pointer == NULL) exit(-1);\nreturn &pointer;\n}\n\nWhat\u2019s STILL wrong?\n\n\fC programming\nThe address of something on the stack will be invalid after the\nfunction\u2019s execution\n\n1\n2\n3\n4\n5\n\nint *safe_int_malloc(int **pointer) {\n*pointer = malloc(sizeof(int));\nif (pointer == NULL) exit(-1);\nreturn &pointer;\n}\n\n&pointer is a location on the stack in\nsafe_int_malloc\u2019s frame!\n\n\fC programming\n\n1\n2\n3\n4\n5\n\nint **safe_int_malloc(int **pointer) {\n*pointer = malloc(sizeof(int));\nif (pointer == NULL) exit(-1);\nreturn pointer;\n}\n\n\fPointers\n\u2022 Pointer: stores address of some value in memory\n\u2022 Example:\n\u2022 Let us have a pointer a where int* a = 0x100\n\n*a = accesses value stored at location 0x100\na + i = 0x100 + sizeof(*a) * i\n\u2022 Dereferencing a NULL pointer or any other invalid memory\naddress causes segmentation fault\n\n\fx86 programming\n\n\fx86-64: Stack Manipulation\nWe execute:\n\nmov $0x449, %rax\npushq %rax\nFor each of the following instructions, determine if they will result in\nthe value 0x449 being placed in %rcx?\n\n1) mov (%rsp), %rcx\n2) mov 0x8(%rsp), %rcx\n3) mov %rsp, %rcx\n4) popq %rcx\n\n\fx86-64: Stack is memory\nWe execute:\nmov $0x449, %rax\npushq %rax\npopq %rax\nIf we now execute: mov -0x8(%rsp), %rcx\nwhat value is in %rcx?\n1) 0x0 / NULL\n2) Seg fault\n3) Unknown\n4) 0x449\n\n\fx86-64: Sometimes arguments are implicit\n* How many arguments does \u201crsr\u201d take?\n* How many registers are changed before the function call?\n(Note, %sil is the lower 1 byte of %rsi)\n0x0400596 <+0>:\n0x040059a <+4>:\n0x040059c <+6>:\n0x04005a0 <+10>:\n0x04005a4 <+14>:\n0x04005a9 <+19>:\n0x04005ad <+23>:\n0x04005ae <+24>:\n0x04005b0 <+26>:\n\ncmp\nje\nsub\nsub\ncallq\nadd\nretq\nmov\nretq\n\n%sil,(%rdi,%rdx,1)\n0x4005ae <rsr+24>\n$0x8,%rsp\n$0x1,%rdx\n0x400596 <rsr>\n$0x8,%rsp\n%edx,%eax\n\n\fx86-64: Arguments can already be \u201ccorrect\u201d\nrsr does not modify s and t, so the arguments in those\nregisters are always correct\n\nint rsr(char* s, char t, size_t pos)\n{\nif (s[pos] == t) return pos;\nreturn rsr(s, t, pos - 1);\n}\n\n\fExample: Reverse-engineer Assembly to C\nmystery(long, long, long):\nleaq (%rdi,%rsi), %rax\naddq %rdx, %rax\ncmpq $3, %rdi\njg .L2\ncmpq %rdx, %rsi\njge .L3\nmovq %rdi, %rax\nimulq %rsi, %rax\nret\n.L3:\nmovq %rsi, %rax\nimulq %rdx, %rax\nret\n.L2:\ncmpq $10, %rdi\njle .L1\nmovq %rdi, %rax\nimulq %rdx, %rax\n.L1:\nret\n\nlong mystery(long x, long y, long z)\n{\nlong val = _______________;\nif (__________) {\nif (_________) {\nval = ___________;\n} else {\nval = ____________;\n\n}\n} else if (___________) {\nval = __________;\n}\n\nreturn ________;\n}\n\n43\n\n\fExample: increment\n\nlong increment(long *p, long val) {\nlong x = *p;\nlong y = x + val;\n*p = y;\nreturn x;\n}\n\nincrement:\nmovq\n(%rdi), %rax\naddq\n%rax, %rsi\nmovq\n%rsi, (%rdi)\nret\n44\n\nRegister\n\nUse(s)\n\n%rdi\n\n1st arg (p)\n\n%rsi\n\n2nd arg (val), y\n\n%rax\n\nx, return value\n\n\fProcedure Call Example (initial state)\nlong call_incr() {\nlong v1 = 449;\nlong v2 = increment(&v1, 100);\nreturn v1 + v2;\n}\n\nInitial Stack Structure\n\u2022\u2022\u2022\nReturn addr <main+8>\n\ncall_incr:\nsubq\n$16, %rsp\nmovq\n$449, 8(%rsp)\nmovl\n$100, %esi\nleaq\n8(%rsp), %rdi\ncall\nincrement\naddq\n8(%rsp), %rax\naddq\n$16, %rsp\nret\n\n\u27f5%rsp\n\n\u2022 Return address on stack is the\naddress of instruction\nimmediately following the call to\n\u201ccall_incr\u201d\n\u2022 Shown here as main, but could be\nanything)\n\u2022 Pushed onto stack by call\ncall_incr\n\n\fProcedure Call Example (step 1)\nStack Structure\n\nlong call_incr() {\nlong v1 = 449;\nlong v2 = increment(&v1, 100);\nreturn v1 + v2;\n}\n\n\u2022\u2022\u2022\n\nReturn addr <main+8>\ncall_incr:\nsubq\n$16, %rsp\nmovq\n$449, 8(%rsp)\nmovl\n$100, %esi\nleaq\n8(%rsp), %rdi\ncall\nincrement\naddq\n8(%rsp), %rax\naddq\n$16, %rsp\nret\n\nAllocate space\nfor local vars\n\n449\nUnused\n\n\u27f5old %rsp\n\u27f5%rsp+8\n\u27f5%rsp\n\n\u2022 Setup space for local variables\n\u2022 Only v1 needs space on the stack\n\n\u2022 Compiler allocated extra space\n\u2022 Often does this for a variety of\nreasons, including alignment\n\n\fProcedure Call Example (step 2)\nlong call_incr() {\nlong v1 = 449;\nlong v2 = increment(&v1, 100);\nreturn v1 + v2;\n}\n\nStack Structure\n\u2022\u2022\u2022\nReturn addr <main+8>\n\ncall_incr:\nsubq\n$16, %rsp\nmovq\n$449, 8(%rsp)\nmovl\n$100, %esi\nleaq\n8(%rsp), %rdi\ncall\nincrement\naddq\n8(%rsp), %rax\naddq\n$16, %rsp\nret\n\n449\nUnused\n\nSet up parameters for call\nto increment\n\nAside: movl is used because 100 is a small positive value that fits\nin 32 bits. High order bits of rsi get set to zero automatically. It\ntakes one less byte to encode a movl than a movq.\n\n\u27f5%rsp+8\n\u27f5%rsp\n\nRegister\n\nUse(s)\n\n%rdi\n\n&v1\n\n%rsi\n\n100\n\n\fProcedure Call Example (step 3)\nlong call_incr() {\nlong v1 = 449;\nlong v2 = increment(&v1, 100);\nreturn v1 + v2;\n}\n\nStack Structure\n\u2022\u2022\u2022\nReturn addr <main+8>\n\ncall_incr:\nsubq\n$16, %rsp\nmovq\n$449, 8(%rsp)\nmovl\n$100, %esi\nleaq\n8(%rsp), %rdi\ncall\nincrement\naddq\n8(%rsp), %rax\naddq\n$16, %rsp\nret\nincrement:\nmovq\n(%rdi), %rax\naddq\n%rax, %rsi\nmovq\n%rsi, (%rdi)\nret\n\n449\nUnused\nReturn addr <call_incr+?>\n\n\u2022 State while inside increment\n\n\u27f5%rsp\n\n\u2022 Return address on top of stack is address of\nthe addq instruction immediately following\ncall to increment\nRegister\n\nUse(s)\n\n%rdi\n\n&v1\n\n%rsi\n\n100\n\n%rax\n\n48\n\n\fProcedure Call Example (step 4)\nStack Structure\n\nlong call_incr() {\nlong v1 = 449;\nlong v2 = increment(&v1, 100);\nreturn v1 + v2;\n}\n\n\u2022\u2022\u2022\nReturn addr <main+8>\n\ncall_incr:\nsubq\n$16, %rsp\nmovq\n$449, 8(%rsp)\nmovl\n$100, %esi\nleaq\n8(%rsp), %rdi\ncall\nincrement\naddq\n8(%rsp), %rax\naddq\n$16, %rsp\nret\n\n549\nUnused\nReturn addr <call_incr+?>\n\n\u27f5%rsp\n\n\u2022 State while inside increment\n\u2022 After code in body has been executed\n\nincrement:\nmovq\n(%rdi), %rax # x = *p\naddq\n%rax, %rsi\n# y = x + 100\nmovq\n%rsi, (%rdi) # *p = y\nret\n\nRegister\n\nUse(s)\n\n%rdi\n\n&v1\n\n%rsi\n\n549\n\n%rax\n\n449\n\n49\n\n\fProcedure Call Example (step 5)\nlong call_incr() {\nlong v1 = 449;\nlong v2 = increment(&v1, 100);\nreturn v1 + v2;\n}\n\nStack Structure\n\u2022\u2022\u2022\nReturn addr <main+8>\n\ncall_incr:\nsubq\n$16, %rsp\nmovq\n$449, 8(%rsp)\nmovl\n$100, %esi\nleaq\n8(%rsp), %rdi\ncall\nincrement\naddq\n8(%rsp), %rax\naddq\n$16, %rsp\nret\n\n549\n\n\u27f5%rsp+8\n\nUnused\n\n\u27f5%rsp\n\n\u2022 After returning from call to increment\n\u2022 Registers and memory have been modified and\nreturn address has been popped off stack\n\nRegister\n\nUse(s)\n\n%rdi\n\n&v1\n\n%rsi\n\n549\n\n%rax\n\n449\n\n\fProcedure Call Example (step 6)\nlong call_incr() {\nlong v1 = 449;\nlong v2 = increment(&v1, 100);\nreturn v1 + v2;\n}\n\nStack Structure\n\u2022\u2022\u2022\nReturn addr <main+8>\n\ncall_incr:\nsubq\n$16, %rsp\nmovq\n$449, 8(%rsp)\nmovl\n$100, %esi\nleaq\n8(%rsp), %rdi\ncall\nincrement\naddq\n8(%rsp), %rax\naddq\n$16, %rsp\nret\n\n549\n\n\u27f5%rsp+8\n\nUnused\n\n\u27f5%rsp\n\nUpdate %rax to contain v1+v2\nRegister\n\nUse(s)\n\n%rdi\n\n&v1\n\n%rsi\n\n549\n\n%rax\n\n549+449\n\n\fProcedure Call Example (step 7)\nlong call_incr() {\nlong v1 = 449;\nlong v2 = increment(&v1, 100);\nreturn v1 + v2;\n}\n\nStack Structure\n\u2022\u2022\u2022\nReturn addr <main+8>\n\ncall_incr:\nsubq\n$16, %rsp\nmovq\n$449, 8(%rsp)\nmovl\n$100, %esi\nleaq\n8(%rsp), %rdi\ncall\nincrement\naddq\n8(%rsp), %rax\naddq\n$16, %rsp\nret\n\n549\nUnused\n\n\u27f5%rsp\n\u27f5old %rsp\n\nDe-allocate space for local vars\nRegister\n\nUse(s)\n\n%rdi\n\n&v1\n\n%rsi\n\n549\n\n%rax\n\n998\n\n\fProcedure Call Example (step 8)\nlong call_incr() {\nlong v1 = 449;\nlong v2 = increment(&v1, 100);\nreturn v1 + v2;\n}\ncall_incr:\nsubq\n$16, %rsp\nmovq\n$449, 8(%rsp)\nmovl\n$100, %esi\nleaq\n8(%rsp), %rdi\ncall\nincrement\naddq\n8(%rsp), %rax\naddq\n$16, %rsp\nret\n\nStack Structure\n\u2022\u2022\u2022\nReturn addr <main+8>\n\n\u27f5%rsp\n\n\u2022 State just before returning from\ncall to call_incr\nRegister\n\nUse(s)\n\n%rdi\n\n&v1\n\n%rsi\n\n549\n\n%rax\n\n998\n\n\fProcedure Call Example (step 9)\nlong call_incr() {\nlong v1 = 449;\nlong v2 = increment(&v1, 100);\nreturn v1 + v2;\n}\ncall_incr:\nsubq\n$16, %rsp\nmovq\n$449, 8(%rsp)\nmovl\n$100, %esi\nleaq\n8(%rsp), %rdi\ncall\nincrement\naddq\n8(%rsp), %rax\naddq\n$16, %rsp\nret\n\nFinal Stack Structure\n\u2022\u2022\u2022\n\u27f5%rsp\n\n\u2022 State immediately after returning from\ncall to call_incr\n\u2022 Return addr has been popped off stack\n\u2022 Control has returned to the instruction\nimmediately following the call to\ncall_incr (not shown here)\n\nRegister\n\nUse(s)\n\n%rdi\n\n&v1\n\n%rsi\n\n549\n\n%rax\n\n998\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}