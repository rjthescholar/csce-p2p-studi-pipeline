{"id": 156, "segment": "unlabeled", "course": "cs1502", "lec": "lec02_finite_automata_01", "text": "Finite Automata 01\nThumrongsak Kosiyatrakul\ntkosiyat@cs.pitt.edu\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 01\n\n\fFinite Automata\nSuppose you are asked to write a software to control an\nautomatic door as shown below:\nfront\npad\n\nrear\npad\n\ndoor\n\nAssume we have the following methods:\ngetFrontPad(): returns true if there is a person standing on\nthe front pad. Otherwise, it returns false.\ngetRearPad(): returns true if there is a person standing on\nthe rear pad. Otherwise, it returns false.\nopenDoor(): when called it will open the door.\ncloseDoor(): when called it will close the door.\n\nHow the write the program in Java?\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 01\n\n\fFinite Automata\nProgram to control the automatic door:\npublic class DoorController {\npublic static void main(String[] args) {\nboolean isDoorOpen = false;\nwhile(true) {\nif(getFrontPad() && !getRearPad() && !isDoorOpen) {\nopenDoor();\nisDoorOpen = true;\n}\nif(!getFrontPad() && !getRearPad() && isDoorOpen) {\ncloseDoor();\nisDoorOpen = false;\n}\n}\n}\n}\n\nThe variable isDoorOpen of type boolean is used to record\nthe status of the door (1 bit of memory is required).\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 01\n\n\fFinite Automata\n\ngetFrontPad() and getRearPad() together acts as external\ninput to the program:\ngetFrontPad() getRearPad()\nInput\ntrue\ntrue\nBoth\ntrue\nfalse\nFront\nfalse\ntrue\nRear\nfalse\nfalse\nNeither\nWe can define the behavior of our program based on its input\nas well as the status of the door whether it is current open or\nclose\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 01\n\n\fRepresentations\nThe program can be represented in two standard ways\nState Diagram:\nRear\n\nRear\n\nFront\nBoth\n\nOpen\n\nClosed\n\nBoth\n\nNeither\n\nNeither\n\nState Transition Table:\nNeither\nClosed Closed\nOpen\nClosed\n\nFront\n\nFront\nOpen\nOpen\n\nRear\nClosed\nOpen\n\nBoth\nClosed\nOpen\n\nBut how to represent these in a mathematical way?\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 01\n\n\fFinite State Machine\nConsider the following finite state machine M1 :\n0\n\n1\n\n0\n\n1\n\nq0\n\nq1\n\nq2\n0, 1\n\nMachine M1 consists of:\nThree states: q0 , q1 , and q2\nThe start state q0 (arrow pointing to it from nowhere)\nAn accept state q1 (double circle)\nAll single circle states are called non-accept state\n\nArrows represent transition functions\nThe label 0, 1 represents two transitions\nq1\n\nq2\n0\n1\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 01\n\n\fFinite State Machine\nConsider the following finite state machine M1 :\n0\n\n1\n\n0\n\n1\n\nq0\n\nq1\n\nq2\n0, 1\n\nWhen an input string is given to this machine, it returns\neither accept or reject.\n1101: accept\n1\n\n1\n\n0\n\n1\n\nq0 \u2192 q1 \u2192 q1 \u2192 q2 \u2192 q1\n\n(an accept state)\n\n0010: reject\n0\n\n0\n\n1\n\n0\n\nq0 \u2192 q0 \u2192 q0 \u2192 q1 \u2192 q2\n\n(a non-accept state)\n\n0100: accept\n0\n\n1\n\n0\n\n0\n\nq0 \u2192 q0 \u2192 q1 \u2192 q2 \u2192 q1\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\n(an accept state)\n\nFinite Automata 01\n\n\fFinite State Machine\nConsider the following finite state machine M1 :\n0\n\n1\n\n0\n\n1\n\nq0\n\nq1\n\nq2\n0, 1\n\nCan we define the set of inputs that is accepted by the above\nmachine?\nM1 accepts any strings that end with a 1\nM1 also accepts a string that ends with a 0 but it needs to\nhave even number of 0s after the last 1\n\nThe set of all strings accepted by this machine is\n{x | x ends with a 1 and x is a string\nthat ends with an even number of 0s following the last 1}\nThe above set is called the language of the machine M1\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 01\n\n\fFinite-State Automaton\nA finite state machine M can be defined as five tuple\nM = (Q, \u03a3, \u03b4, q0 , F )\nQ is a non-empty finite set of states\nM must have at least one state\n\n\u03a3 is an alphabet (a finite set of symbols)\n\u03b4 : Q \u00d7 \u03a3 \u2192 Q is the transition functions\nWe generally use a table to represent \u03b4\n\nq0 \u2208 Q is the starting state\nA finite automata can only have exactly one start state\n\nF \u2286 Q is the set of accept states\nF can be \u2205\nM can have no accept state (rejects all strings)\n|F | can be more than 1\nM has more than one accept states\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 01\n\n\fExample: Machine M1\n0\n\n1\n\n0\n\n1\n\nq0\n\nq1\n\nq2\n0, 1\n\nM1 = (Q, \u03a3, \u03b4, q0 , F )\nQ = {q0 , q1 , q2 }\n\u03a3 = {0, 1}\n\u03b4 can be defined using the table below:\n\u03b4\n0\n1\nq0 q0 q1\nq1 q2 q1\nq2 q1 q1\nq0 is the start state\nF = {q1 }\n\nThe state diagram and its formal definition are equivalent\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 01\n\n\fFormal Definition of Machine M1\nM1 = ({q0 , q1 , q2 }, {0, 1}, \u03b4, q0 , {q1 }) where \u03b4 is as follows:\n\u03b4\n0 1\nq0 q0 q1\nq1 q2 q1\nq2 q1 q1\nThe above formal definition allows use to precisely answer\nquestions about M1 :\nIs 0101 is a valid input for this machine?\nYes. 0 \u2208 {0, 1} and 1 \u2208 {0, 1}.\n\nIs 01a0 is a valid input for this machine?\nNo. a 6\u2208 {0, 1}\n\nIs input 010 accepted by this machine?\n0\n\n1\n\n0\n\nNo. q0 \u2192 q0 \u2192 q1 \u2192 q2 and q2 6\u2208 {q1 }.\n\nIs input 101 accepted by this machine?\n1\n\n0\n\n1\n\nYes. q0 \u2192 q1 \u2192 q2 \u2192 q1 and q1 \u2208 {q1 }.\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 01\n\n\fLanguage Recognized\n\nA string w = w1 w2 . . . wn is accepted by M if and only if\nafter processing each symbol wi of w, where 1 \u2264 i \u2264 n, M\nfinds itself in an accept state (a state belonging to F ).\nOtherwise, we say w is rejected by M .\nIf A is the set of all strings accepted by M , we say A is the\nlanguage of finite-state machine M , denoted by\nL(M ) = A\nWe say that M recognizes A\nA machine may accept several strings but it always recognizes\nonly one language.\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 01\n\n\fExample\n0\n\n1\n1\n\nq1\n\nq2\n0\n\nM2 = (Q, \u03a3, \u03b4, start state, F )\nWhat is the formal definition of the above machine and the\nlanguage that it recognises?\nQ = {q1 , q2 }\n\u03a3 = {0, 1}\n\u03b4\n0 1\nq1 q1 q2\nq2 q1 q2\nThe start state is q1\nF = {q2 }\nL(M2 ) = {w | w ends in a 1}\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 01\n\n\fExample\n0\n\n1\n1\n\nq1\n\nq2\n0\n\nM3 = (Q, \u03a3, \u03b4, start state, F )\nWhat is the formal definition of the above machine and the\nlanguage that it recognises?\nQ = {q1 , q2 }\n\u03a3 = {0, 1}\n\u03b4\n0 1\nq1 q1 q2\nq2 q1 q2\nStart state is q1\nF = {q1 }\nL(M2 ) = {w | w is the empty string \u03b5 or ends in a 0}\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 01\n\n\fExample\nQ = {s, q1 , q2 , r1 , r2 }\n\u03a3 = {a, b}\na\n\nb\n\nr1\n\nq1\n\na\nb\nb\n\ns\n\na\n\nq2\n\na\n\nb\nb\n\nr2\n\nM4 = (Q, \u03a3, \u03b4, start state, F )\n\na\n\nTransition Functions:\n\u03b4\na b\ns q1 r1\nq1 q1 q2\nq2 q1 q2\nr1 r2 r1\nr2 r2 r1\nStart state is s\nF = {q1 , r1 }\n\nWhat is the formal definition of\nthe above machine and the language that it recognises?\n\nL(M2 ) =\n{w | w starts and ends\nwith the same symbol}\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 01\n\n\fExample\nQ = {q0 , q1 , q2 }\n\n0\n\n\u03a3 = {0, 1, 2, <RESET>}\nq1\n\n<RESET>\n\n1\n2\n\n0\n\n2\n\n1\n2\n\nq0\n\n1\n\nq2\n\n0\n\n<RESET>\n<RESET>\n\nM5 = (Q, \u03a3, \u03b4, start state, F )\nWhat is the formal definition of\nthe above machine and the language that it recognises?\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTransition Functions:\n\u03b4\n0 1 2 <RESET>\nq0 q0 q1 q2\nq0\nq1 q1 q2 q0\nq0\nq2 q2 q0 q1\nq0\nStart state is q0\nF = {q0 }\nL(M2 ) =\n{w | w is the empty string \u03b5 or\nends with <RESET> or\nsum of input is multiple\nof 3 after the last\n<RESET>}\nFinite Automata 01\n\n\fDesigning a Finite-State Machine\n\nA computation model simulates a set of algorithms\nDesigning a finite-state machine is the same as writing a\nprogram\nUse states to capture state-of-minds\nI just see a 1\nI just see two consecutive 0s\nI already saw 00 or 11\n\nDo not force yourself to use the least number of states\nNobody asks you to write a shortest possible program\nUnless you are asked to do so\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 01\n\n\fDesigning Finite Automata\nSuppose the alphabet \u03a3 is {0, 1}. Create a machine such that its\nlanguage is the set of all strings that contain either 11 or 00 as a\nsubstring.\nq1\n1\n\nq0\n\n1\n\n1\n\nq3\n\n0\n\n0\n\n0\n\nq2\n\nCommon mistakes:\n\u03b4(q1 , 0) = q0\n\u03b4(q2 , 1) = q0\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 01\n\n0,1\n\n\fDesigning Finite Automata\nSuppose the alphabet \u03a3 is {0, 1}. Create a machine such that its\nlanguage is the set of all strings that contain 011 as a substring.\n0\n\n1\n\n0\n\n1\n0\n\nqs\n\n1\n\nq0\n\nq01\n\nq011\n\n1\n\n0\n\nCommon mistakes:\n\u03b4(q0 , 0) = qs\n\u03b4(q01 , 0) = qs\n\nHint: Name of a state can be used to indicate a state-of-mind\nq01 means \u201cI just see a 0 immediately followed by a 1\u201d\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 01\n\n\fDesigning Finite Automata\nSuppose the alphabet \u03a3 is {0, 1}. Create a machine such that its\nlanguage is the set of all strings that ends with 0110.\n1\n\n0\n1\n0\n\nq0\n\n1\n\nq1\n\nq2\n\n0\n\nq3\n\n0\n1\n\n0\n\nCommon mistakes:\n\u03b4(q2 , 0) = q0\n\u03b4(q4 , 0) = q0\n\u03b4(q4 , 1) = q0\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 01\n\nq4\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}