{"id": 267, "segment": "unlabeled", "course": "cs1502", "lec": "lec23_reducibility_06", "text": "Reducibility 06\nThumrongsak Kosiyatrakul\ntkosiyat@cs.pitt.edu\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nReducibility 06\n\n\fReductions\nRecall the concept of reducibility:\nA problem A is reducible to a problem B if the solution to the\nproblem B can be used to solve the problem A\n\nTo show that a language A is undecidable, we show that ATM\n(or other undecidable language) is reducible to A\nATM is reducible to HALT TM\nWe want to know whether hM, wi \u2208 ATM\nTurn hM, wi to hM 0 , w0 i (in our case w0 = \u03b5)\nCheck whether hM 0 , w0 i \u2208 HALT TM\nhM, wi \u2208 ATM \u2194 hM 0 , w0 i \u2208 HALT TM\n\nATM is reducible to ETM\nWe want to know whether hM, wi \u2208 ATM\nTurn hM, wi to hM 0 i\nCheck whether hM 0 i \u2208 ETM\nhM, wi \u2208 ATM \u2194 hM 0 i 6\u2208 ETM\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nReducibility 06\n\n\fReductions\nATM is reducible to REGULAR TM\nWe want to know whether hM, wi \u2208 ATM\nTurn hM, wi to hM 0 i\nCheck whether hM 0 i \u2208 REGULAR TM\nhM, wi \u2208 ATM \u2194 hM 0 i \u2208 REGULAR TM\nhM, wi \u2208 ATM \u2194 hM 0 i 6\u2208 REGULAR TM\n\nATM is reducible to EQ TM\nWe want to know whether hM, wi \u2208 ATM\nTurn hM, wi to hM1 , M2 i\nCheck whether hM1 , M2 i \u2208 EQ TM\nhM, wi \u2208 ATM \u2194 hM1 , M2 i \u2208 EQ TM\n\nETM is reducible to EQ TM\nWe want to know whether hM i \u2208 ETM\nTurn hM i to hM, ME i\nCheck whether hM, ME i \u2208 EQ TM\nhM i \u2208 ETM \u2194 hM, ME i \u2208 EQ TM\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nReducibility 06\n\n\fReductions via Computation Histories\n\nSo for we construct TMs to show that ATM is reducible to\ncertain languages\nAnother method is Reduction via Computation Histories\nGenerally use when the problem to be shown undecidable\ninvolves testing for the existence of something\nGiven a polynomial p, does it has an integral root?\nGiven a set of dominoes, does it has a match?\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nReducibility 06\n\n\fDefinitions\n\nRecall definitions about configuration:\nSuppose the start state of TM M is q0 , the start\nconfiguration of M on input w is q0 w\nAn accepting configuration is a configuration uqaccept v for\nstrings u and v\nA rejecting configuration is a configuration uqreject v for\nstrings u and v\nA configuration Ci legally go to Cj according to the\ntransitions of the TM M\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nReducibility 06\n\n\fReductions via Computation Histories\nDefinition 5.5\nLet M be a Turing machine and w an input string. An accepting\ncomputation history for M on w is a sequence of configurations,\nC1 , C2 , . . . Cl where C1 is the start configuration of M on w, Cl is\nan accepting configuration of M , and each Ci legally follows from\nCi\u22121 according to the rules of M . A rejecting computation\nhistory for M on w is defined similarly, except that Cl is a\nrejecting configuration.\nNote that M must halt on input w. Otherwise, accepting or\nrejection computation history does not exists\nFor simplicity, we only consider deterministic Turing machine\nIf M halts on w, exactly one computation history exists\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nReducibility 06\n\n\fReductions via Computation Histories\nAgain, to show that a language A is undecidable, we show\nthat ATM is reducible to A\nGiven a TM M and a string w, there is no algorithm to check\nwhether hM, wi \u2208 ATM because ATM is undecidable\nBut we know that\nIf M accepts w, hM, wi \u2208 ATM\nIf M does not accept w, hM, wi 6\u2208 ATM\n\nUsing the concept of computation histories:\nIf the accepting computation history of M on input w exists\nhM, wi \u2208 ATM\nM accepts w\nIf the accepting computation history of M on input w does\nM does not accept w\nhM, wi 6\u2208 ATM\nnot exists\n\nLet\u2019s try to use reduction via computation histories with a\nvariation of a TM called Linear Bounded Automaton (LBA)\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nReducibility 06\n\n\fLinear Bounded Automaton\nDefinition 5.6\nA linear bounded automaton is a restricted type of Turing\nmachine wherein the tape head isn\u2019t permitted to move off the\nportion of the tape containing the input. If the machine tries to\nmove its head off either end of the input, the head stays where it is.\ncontrol\n\na\n\nb\n\na\n\nb\n\na\n\nn\n\nWith an input of length n, the amount of memory available is\nlinear in n.\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nReducibility 06\n\n\fLinear Bounded Automaton\n\nProblem: Given an LBA M and a string w, is there an\nalgorithm to determine whether M accepts w?\nFormally,\nALBA = {hM, wi | M is an LBA that accepts w}\nIs ALBA decidable?\nThis sounds like ATM\nATM = {hM, wi | M is a TM that accepts w}\nEven though ATM is undecidable, ALBA is actually decidable\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nReducibility 06\n\n\fLinear Bounded Automaton\n\nRecall a configuration uqv\nuv is the content of the tape\n\nRecall that very TM has an infinite long tape\nTherefore, there are infinite number of distinct strings uv\nBut the tape of an LBA is finite\nThe length of its tape on input string w is |w|\nThe number of states and |\u0393| of an LBA are also finite\nBecause of these, the set of all distinct configurations that an\nLBA can have on an input string w is finite\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nReducibility 06\n\n\fLinear Bounded Automaton\nConsider an LBA with the following specification:\nThe number of states is q\n|\u0393| = g (number of symbols in its tape alphabets)\nThe length of the tape is n\n\nFrom the above LBA:\nFor each square on the tape, there can be one of g symbols\nThere are the total of g n unique tape contents\n\nThere are n possible positions of the tape head\nFor each tape head position, it can be in one of q states\n\nThus, there are exactly qng n distinct configurations\nBecause of this, we can detect when an LBA is entering a\nloop by checking whether sequence of configurations when\nrunning an LBA and a string w contains a duplicate\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nReducibility 06\n\n\fLinear Bounded Automaton\nTo detect an infinite loop in an LBA, consider an LBA M\nwhere its series of configuration while processing w is as\nfollows:\nC1 , C2 , C3 , C4 , C5 , C6 , C7 , C8 , C9 , C10 , C11 , . . .\nWhat if the configuration C3 is the same as C9 ?\nThe content of the tape are exactly the same\nThe current state of M are the same\nThe tape head are at the same location\n\nThus\nC10 will be the same as C4\nC11 will be the same as C5\nand so on\n\nHowever, this method requires us to keep track of sequence of\nconfigurations\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nReducibility 06\n\n\fLinear Bounded Automaton\n\nRecall that if we run an LBA on input w for 1 step, we\nalready sees two configurations\nThe start configuration\nThe next configuration that legally goes from the start\nconfiguration\n\nThus, if we run an LBA on input w for k steps, we already see\nk + 1 configurations\nRecall that the total number of distinct configurations is qng n ,\nwe can simply run the LBA for qng n steps or until it halts\nIf it does not halt after qng n steps, we already see qng n + 1\nconfigurations\nBut there are only qng n distinct configurations\nThus, at least two of them must be the same (loop indefinitely)\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nReducibility 06\n\n\fLinear Bounded Automaton\n\nTheorem 5.9\nALBA = {hM, wi | M is an LBA that accepts string w} is\ndecidable.\nConstruct a TM L that decides ALBA as follows:\nL = \u201cOn input hM, wi, where M is an LBA and w is a string:\n1\n2\n\nSimulate M on input w for qng n steps or until it halts.\nIf M has halted, accept if it has accepted and reject if it has\nrejected. if it has not halted, reject.\u201d\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nReducibility 06\n\n\fELBA is Undecidable\n\nNow, we just verify that ALBA is decidable\nBut what about the problem of determining whether an LBA\nM accepts no strings (L(M ) = \u2205)\nFormally,\nELBA = {hM i | M is an LBA and L(M ) = \u2205}\nIt turns out that this problem is unsolvable\nIn other words, ELBA is undecidable\nLet\u2019s try to prove it using the same method that we used to\nprove that ETM is undecidable to try to prove that ELBA is\nundecidable\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nReducibility 06\n\n\fELBA is Undecidable\nAssume that ELBA . Since ELBA is decidable, there exists a TM R that decides\nELBA . Construct a TM S (to decide ATM ) as follows:\nS = \u201cOn input hM, wi where M is a TM and w is a string:\n1 Construct an LBA M 0 as follows:\nM 0 = \u201cOn input x:\nRun M on input w.\nIf M accepts w, accept; otherwise, reject.\u201d\n2 Run R (a decider for ELBA ) on input hM 0 i.\n3 If R accepts hM 0 i, reject. If R rejects hM 0 i, accept.\u201d\nNext, we need to prove that the TM S above, decides ATM . . .\n1\n\n2\n\nDid you see a problem in the above prove?\nM 0 (constructed by S) must be an LBA\nAn LBA has a finite long tape\nTo run TM M on input w, the LBA M 0 may need infinite\nlong tape\nYou cannot construct an LBA that can always run a TM M\non an input w\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nReducibility 06\n\n\fELBA is Undecidable\nIn this case, we need to show that ATM is reducible to ELBA\nusing the computation history method\nThis method will also give you the same conclusion:\nIf ELBA is decidable, ATM is decidable\n\nThe idea is to construct an LBA B that accepts exactly one\nstring\nThe string will be a string representation of the accepting\ncomputation history for M on w\nWhy this work?\nIf hM, wi \u2208 ATM\nM accepts w\nthe accepting\nLBA B accepts\ncomputation history for M on w exists\nexactly one string\nL(B) 6= \u2205\nhBi 6\u2208 ELBA\nM does not accept w\nthe accepting\nIf hM, wi 6\u2208 ATM\nLBA B\ncomputation history for M on w does not exists\nL(B) = \u2205\nhBi \u2208 ELBA\naccepts no strings\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nReducibility 06\n\n\fELBA is Undecidable\n\nBut can we construct an LBA that accepts exactly one string\nwhich is the accepting computation history for M on w\nwithout requiring an infinite amount of tape?\nRecall that an LBA cannot always runs M on input w because\nof its finite long tape\nSo, can an LBA checks whether a given string is the accepting\ncomputation history for M on w without actually run M on\ninput w?\nIt turns out, we can\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nReducibility 06\n\n\fELBA is Undecidable\nAn accepting computation history for M on w is a series of\nconfigurations C1 , C2 , . . . Cl where\nC1 is the start configuration of M on input w\nCl is an accepting configuration\nCi yields Ci+1 according to M\n\nWe can represents an accepting computation history by a\nsingle string with the configurations separated from each\nother by the # symbol\n#\n\n#\nC1\n\n#\nC2\n\n#\nC3\n\n#\n\n#\nCl\n\nFor example an accepting computation history of TM M2 in\nExample 3.7 on input 0 can be represented as a single string\nas follows:\n#q1 0#tq2 #ttqaccept #\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nReducibility 06\n\n\fELBA is Undecidable\nWith an input string x to the LBA B, the machine B must\ncheck the following conditions before accepting x\n1\n2\n3\n4\n\nx is in the form of #C1 #C2 # . . . #Cl # for a number l\nC1 is the start configuration for M on w\nCi+1 legally follows from Ci\nCl is an accepting configuration for M\n\nGiven the definition of a TM M and a input string w:\nWe know the start state of M\nThus, we know the start configuration\n\nWe know the transition function of M\nThus, we can check whether Ci+1 legally follows from Ci\n\nAccepting configuration is just uqaccept v for strings u and v\n\nThis show that there is an algorithm to check whether an\ninput string x is an accepting computation history for M on w\nwithout actually running M on input w\nTherefore, the LBA B can be constructed\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nReducibility 06\n\n\fELBA is Undecidable\n\nTheorem 5.10\nELBA = {hM i | M is an LBA and L(M ) = \u2205} is undecidable.\nFor the sake of contradiction, assume that ELBA is decidable\nThere exists a TM R decides ELBA\nConstruct a TM S decides ATM as follows:\nS = \u201cOn input hM, wi, where M is a TM and w is a string:\n1\n2\n3\n\nConstruct LBA B from M and w as described in the proof idea\nRun R on input hBi\nIf R rejects hBi, accept; if R accepts hBi, reject.\u201d\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nReducibility 06\n\n\fELBA is Undecidable\nSketch of the proofs:\nIf hM, wi \u2208 ATM :\nM accepts w\nThe accepting computation history for M on w exists\nB accepts exactly one string\nL(B) 6= \u2205\nR rejects hBi\nS accepts hM, wi\n\nIf hM, wi 6\u2208 ATM :\nM does not accept w\nThe accepting computation history for M on w does not exists\nB accepts no strings\nL(B) = \u2205\nR accepts hBi\nS rejects hM, wi\n\nThis show that S is a decider for ATM\nIn other words, ATM is decidable \u2014 contradiction\nTherefore, ELBA is undecidable\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nReducibility 06\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}