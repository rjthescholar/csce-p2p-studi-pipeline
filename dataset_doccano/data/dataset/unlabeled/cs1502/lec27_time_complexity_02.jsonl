{"id": 254, "segment": "unlabeled", "course": "cs1502", "lec": "lec27_time_complexity_02", "text": "Time Complexity 02\nThumrongsak Kosiyatrakul\ntkosiyat@cs.pitt.edu\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 02\n\n\fPolynomial Time vs Exponential Time\n\nPolynomial time is considered small but exponential time is\nconsidered large\nConsider a problem size n = 1000\nAssume that algorithms A and B requires to execute n2 and\n2n instructions respectively\nAssume that each instruction takes 1 nanosecond\n\nAlgorithm A takes\n10002 \u00d7 10\u22129 = 106 \u00d7 10\u22129 = 10\u22123 = 0.001second\nAlgorithm B takes\n21000 \u00d7 10\u22129 \u2248 10301 \u00d7 10\u22129 = 10292 seconds \u2248 10284 years\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 02\n\n\fClass P\n\nDefinition 7.12\nP is the class of languages that are decidable in polynomial time\non a deterministic single-tape Turing machine. In other words,\n[\nP =\nTIME(nk )\nk\n\nRecall that TIME(nk ) is a set of languages that can be\ndecided in O(nk ) time Turing machine\nP is a class of problems that are realistically solvable on a\ncomputer\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 02\n\n\fClass P\n\nConsider the following Turing machine:\nM = \u201cOn input x:\n1\n2\n3\n\nDo this\nWhile this is true\nDo that\n\nThere are two meanings of the word \u201cstep\u201d of a TM M :\nThe above TM has three steps, step 1, step 2, and step 3\nEach step takes a number of steps to execute\nOne step results in a configuration\n\nA TM runs in polynomial time if\n1\n\n2\n\nThe number of times each step is executed (including\nrepeated) is a polynomial (nk for some k)\nEach step takes a polynomial time (O(nk ) for some k)\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 02\n\n\fAnalyzing Algorithms\n\nRecall our Turing machine M1 that decides\nA = {0k 1k | k \u2265 0}\nM1 = \u201cOn input string w:\n1\n\n2\n3\n4\n\nScan across the tape and reject if a 0 is found to the right of a\n1.\nRepeat if both 0s and 1s remain on the tape:\nScan across the tape, crossing off a single 0 and a single 1.\nIf 0s still remain after all the 1s have been crossed off, or if 1s\nstill remain after all the 0s have been crossed off, reject.\nOtherwise, if neither 0s nor 1s remain on the tape, accept.\u201d\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 02\n\n\fAnalyzing Algorithm\nInput 0k 1k where k = n/2\nNumber of times each step is executed:\nStep 1 will be executed 1 time\nStep 2 and 3 will be executed n/2 times\nStep 4 will be executed 1 time\n\nNumber of steps of each step\nStep 1 takes O(n) steps\nStep 2 and 3 take O(n) steps\nStep 4 takes O(n) steps\n\nFrom the analysis:\nThe number of times each step is executed (including repeat)\nis polynomial\nEach step takes polynomial time\nTherefore, M1 runs in polynomial time\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 02\n\n\fExamples of Problems in P\nLet\nPATH = {hG, s, ti | G is a directed graph that has a\ndirected path from s to t}\nG\n\ns\n\nt\n\nIs PATH \u2208 P ?\nIf PATH can be decided by a TM in polynomial time,\nPATH \u2208 P\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 02\n\n\fBrute-Force Algorithm for PATH\nSuppose a directed graph G consists of m nodes\nA brute-force algorithm:\nCreating all possible paths of length at most m\nSearch for a direct path from s to t\n\nExample: All possible paths of length at most 3:\n\n1\n\n1\n\n2\n\n3\n\n1\n\n2\n\n3\n\n2\n\n3\n\n1\n\n2\n\n1\n\n1\n\n1\n\n2\n\n1\n\n2\n\n1\n\n2\n\n2\n\n2\n\n3\n\n3\n\n3\n\n3\n\n1\n\n2\n\n1\n\n3\n\n1\n\n2\n\n3\n\n2\n\n3\n\n1\n\n2\n\n3\n\n3\n\n1\n\n2\n\n1\n\n3\n\n1\n\nMaximum Paths with 3 nodes\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\n3\n\nTime Complexity 02\n\n2\n\n2\n\n3\n\n1\n\n2\n\n3\n\n3\n\n1\n\n2\n\n3\n\n\fBrute-Force Algorithm for PATH\n\nThe number of possible paths is roughly mm\nFor each path, you need to check whether it is a path from s\nto t\nThere are roughly mm paths\nTo search all possible paths is O(mm )\nO(mm ) = O((2log2 m )m ) = O(2m log2 m )\nThis will take an exponential time\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 02\n\n\fBreadth-First Search for PATH\nUse breadth-first search to achieve polynomial time for PATH:\nM = \u201cOn input hG, s, ti, where G is a directed graph with\nnodes s and t:\n1\n2\n3\n\n4\n\nPlace a mark on node s.\nRepeat the following until no additional nodes are marked:\nScan all the edges of G. If an edge (a, b) is found going\nfrom a marked node a to an unmarked node b, mark node b.\nIf t is marked, accept. Otherwise, reject.\u201d\n\nFor simplicity of analysis, we are going to assume the\nfollowing:\nThe number of nodes is n\nThe number of edges is proportional to the number of nodes\nkn edges for some k\nThe string representation of a graph is proportional to the\nnumber of nodes and the number of edges\n\nIn doing so, we can simply use n (number of nodes) as the\nproblem size instead of the length of the input string\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 02\n\n\fBreadth-First Search for PATH\nAnalysis where input string is hG, s, ti where G is a directed\ngraph and s and t are nodes\nStep 1: Place a mark on node s.\nThis step will be executed one time and the number of steps\nis O(n)\n\nStep 4: If t is marked, accept. Otherwise, reject.\nThis step will be executed one time and the number of steps\nis O(n)\n\nSteps 2 and 3:\nRuns at most n times (mark one additional node every\nrepetition)\nRecall that there are kn edges\nFor each execution of step 3, it needs O(kn) = O(n) steps\n\nConclusion:\nNumber of times each step will be executed is polynomial\nEach step is polynomial\nTherefore, this algorithm M is polynomial\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 02\n\n\fRelatively Prime\nTwo numbers are relatively prime if 1 is the largest integer\nthat evenly divides them both\nFormally,\nRELPRIME = {hx, yi | x and y are relatively prime}\nIs RELPRIME \u2208 P ?\nBrute-force algorithm:\nFind all possible divisors of both numbers and accept if none\nare greater than 1\nIf a number is represented by n-bit binary, the number of\npossible value is 2n\nThus, to find all possible divisor of x and y is O(2n )\n(exponential)\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 02\n\n\fEuclidean Algorithm for Greatest Common Divisor\n\nWe can check whether x and y are relatively prime by\ncomputing their Greatest Common Divisor (GCD)\nIf gcd(x, y) = 1, x and y are relatively prime\n\nComputing a gcd can be done using Euclidean Algorithm in a\nform of a TM as follows:\nE = \u201cOn input hx, yi, where x and y are natural numbers:\n1\n2\n3\n4\n\nRepeat until y = 0:\nAssign x \u2190 x mod y.\nExchange x and y.\nOutput x.\u201d\n\nWhen we run TM E on input hx, yi where x and y are natural\nnumbers, it simply output their GCD\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 02\n\n\fEuclidean Algorithm for Greatest Common Divisor\n\nThis algorithm R solves RELPRIME\nR = \u201cOn input hx, yi, where x and y are natural numbers in\nbinary:\n1\n2\n\nRun E on hx, yi.\nIf the result is 1, accept. Otherwise, reject.\n\nAnalysis:\nThere is no loop in TM R\nStep 1 will be executed one time\nStep 2 will be executed one time\n\nFor the number of steps in each step:\nFor step 1, it depends on the number of steps of TM E\nFor step 2, at most O(n)\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 02\n\n\fRELPRIME \u2208 P\n\nAnalysis of Algorithm E:\nGiven two numbers x and y, there are two possibilities:\n1\n2\n\nx/2 \u2265 y or\nx/2 < y\n\nIf x/2 \u2265 y, x mod y < y < x/2\nIf x/2 < y, x mod y = x \u2212 y < x/2\nIn other words, performing x = x mod y reduces the value of\nx roughly in half\nThus, steps 2 and 3 will be repeated roughly 2 log2 x or\n2 log2 y (proportional to the length of either x or y)\nMultiplied by 2 because of the swap in step 3\n\nAlgorithm E runs in polynomial time\n\nRELPRIME \u2208 P\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 02\n\n\fHamiltonian Path\nA Hamiltonian path in a directed graph G is a directed path\nthat goes through each node exactly once\nFormally,\nHAMPATH = {hG, s, ti | G is a directed graph with a\nHamiltonian path from s to t}\n\ns\n\nt\n\nIs HAMPATH \u2208 P ?\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 02\n\n\fPolynomial Verifiability\n\nUnfortunately, we need the brute-force algorithm:\nFirst, we generate all possible paths\nThen check each path whether it is a Hamiltonian path from s\nto t\n\nThis requires exponential time since there are roughly mm\npossible paths\nNo one know an algorithm that can solve Hamiltonian path in\npolynomial time yet\nNo one can prove that the Hamiltonian path problem cannot\nbe solved in polynomial time yet\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 02\n\n\fPATH vs HAMPATH\n\nRecall languages PATH and HAMPATH\nPATH = {hG, s, ti | G is a directed graph that has a\ndirected path from s to t}\nHAMPATH = {hG, s, ti | G is a directed graph with a\nHamiltonian path from s to t}\nGiven hG, s, ti:\nto decide whether it is in PATH can be done in polynomial\ntime\nto decide whether it is in HAMPATH (as of now) cannot be\ndone in polynomial time\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 02\n\n\fCOMPOSITES\n\nAnother problem is called COMPOSITES\nFormally,\nCOMPOSITES = {x | x = pq, for integers p, q > 1}\nGiven a composite number x = pq where p and q are large\nprime numbers, it takes a very long time to find p and q\nThe RSA algorithm is based on the fact that COMPOSITES\nrequires an exponential time\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nTime Complexity 02\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}