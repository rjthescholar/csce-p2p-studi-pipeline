{"id": 234, "segment": "unlabeled", "course": "cs1541", "lec": "lec2.1_processor_review", "text": "Processor Review\nCS 1541\nWonsun Ahn\n\n\fClocking Review\nStuff you learned in CS 447\n\n\fLogic components\n\u25cf Do you remember what all these do?\nNOT gate\n\nMultiplexer\n(MUX)\n32\n\nAND gate\n\n32\nDecoder\n\nOR gate\n\nXOR gate\n\nALU\n\n32\n\nThese wires\ncarry several\nbits at once.\n\nBlue wires are control signals.\n\n3\n\n\fUses of a Decoder\n\u25cf Translates a set of input signals to a bunch of output signals.\no E.g. a binary decoder:\nTruth Table for Decoder\nQ0\nA\n\nQ1\n\nB\n\nQ2\nQ3\n\nA\n\nB\n\nQ0\n\nQ1\n\nQ2\n\nQ3\n\n0\n\n0\n\n1\n\n0\n\n0\n\n0\n\n0\n\n1\n\n0\n\n1\n\n0\n\n0\n\n1\n\n0\n\n0\n\n0\n\n1\n\n0\n\n1\n\n1\n\n0\n\n0\n\n0\n\n1\n\no You can come up with any truth table and make a decoder for it!\n\n4\n\n\fUses of a Multiplexer\n\u25cf No problem in fanning out one signal to two points\nA\n\n+\n\n=\nB\n\nA\n\nB\n\n\u25cf Cannot connect two signals to one point\no Must use a multiplexer to select between the two\n+\n\nPath A\n\n=\n\nPath B\n\nMux control =\n0 for path A\n1 for path B\n\n5\n\n\fGates are made of transistors (of course)\n\n\u2022 NOT gate\n\n\u2022 NAND gate\n\n6\n\n\fThe clock signal\n\u25cf The clock is a signal that alternates regularly between 0 and 1:\n\n1\n\n0\n\ntime\n\n\u25cf Bits are latched on to registers and flip-flops on rising edges\n\u25cf In between rising edges, bits propagate through the logic circuit\no Composed of ALUs, muxes, decoders, etc.\no Propagation delay: amount of time it takes from input to output\n7\n\n\fCritical Path\n\u25cf Critical path: path in a circuit that has longest propagation delay\no Determines the overall clock speed.\n5 ns\n\nA\nD Q\n\nEN\n\nB\nD Q\n\n1\n\n+\n\nIN\n\n5 ns\n\nOUT\n\nEN\nSelect\n\no The ALU and the multiplexer both have a 5 ns delay\n\u25cf How fast can we clock this circuit?\no Is it 1 / 5 ns (5 \u00d7 10-9s) = 200 MHz?\no Or is it 1 / 10 ns (10 \u00d7 10-9s) = 100 MHz?\n\n8\n\n\fMIPS Review\nStuff you learned in CS 447\n\n\fThe MIPS ISA - Registers\n\u25cf MIPS has 32 32-bit registers, with the following usage conventions\n\no But really, all are general purpose registers (nothing special about them)\nName\n$zero\n$at\n$v0-$v1\n$a0-$a3\n$t0-$t7\n$s0-$s7\n$t8-$t9\n$k0-$k1\n$gp\n$sp\n$fp\n$ra\n\nRegister number\nUsage\n0\nthe constant value 0 (can't be written)\n1\nassembler temporary\n2-3\nvalues for results and expression evaluation\n4-7\nfunction arguments\n8-15\nunsaved temporaries\n16-23\nsaved temporaries (like program variables)\n24-25\nmore unsaved temporaries\n26-27\nreserved for OS kernel\n28\nglobal pointer\n29\nstack pointer\n30\nframe pointer\n31\nreturn address\n10\n\n\fThe MIPS ISA - Memory\n\u25cf MIPS is a RISC (reduced instruction set computer) architecture\n\u25cf It is also a load-store architecture\no All memory accesses performed by load and store instructions\n\u25cf Memory is a giant array of 232 bytes\nAddr\n\nData\n\nAddr\n\nData\n\nAddr\n\nData\n\n0\n\n0x3F\n\n0\n\n0x3F00\n\n0\n\n0x3F002A08\n\n1\n\n0x00\n\n2\n\n0x2A08\n\n4\n\n0x47F426B9\n\n2\n\n0x2A\n\n4\n\n0x47F4\n\n...\n\n...\n\n3\n\n0x08\n\n6\n\n0x26B9\n\n4\n\n0x47\n\n...\n\n...\n\n5\n\n0xF4\n\n6\n\n0x26\n\n7\n\n0xB9\n\n...\n\n...\n\n\u2022 The same memory viewed as bytes, 16-bit\nhalfwords, and 32-bit words (using big-endian)\n\u2022 All addresses are aligned (multiples of data size)\n11\n\n\fThe MIPS ISA - Memory\n\n\u2022 Loads move data from\n\nmemory into the registers.\n\nlw $t0, 8($s4)\n\n0x0000CAFE\n0x0000BEEF\n\ns4\n\n0x00000004\n\nRegisters\n\nregisters into memory.\n\nsw $t0, 12($s4)\n\nThis is the address, and it\nmeans \"the value of $s4 + 8.\"\n\nt0\n\n\u2022 Stores move data from the\n$t0 is the SOURCE!\n\n0\n\n0x3F002A08\n\n4\n\n0x47F426B9\n\n8\n\n0x00000000\n\n$s4 + 8\n\n12\n\n0x0000BEEF\n\n$s4 + 12\n\n16\n\n0x0000DEAD\n0x0000BEEF\n\n...\n\n...\n\nlw\n\nsw\n\nMemory\n12\n\n\fThe MIPS ISA \u2013 Flow control\n\u25cf Jump and branch instructions change the flow of execution.\n\n_top:\n# ....\n# lots o' code\n# ....\nj _top\n\nli\n$s0, 10\n_loop:\n# ....\naddi $s0, $s0, -1\nbne $s0, $zero, _loop\njr\n$ra\n\nj : jumps unconditionally\n\u2022 jumps to _top\n\nbne : jumps conditionally\nIf $s0 != $zero, jumps to _loop\nIf $s0 == $zero, continues to jr\n\n$ra\n\n13\n\n\fPhases of instruction execution\n\u25cf In most architectures, there are five phases:\n1. IF (Instruction Fetch) \u2013 get next instruction from memory\n2. ID (Instruction Decode) \u2013 figure out what instruction it is\n3. EX (Execute \u2013 ALU) \u2013 do any arithmetic\n4. MEM (Memory) \u2013 read or write data from/to memory\n5. WB (Register Writeback) \u2013 write any results to the registers\n\n\u25cf Sometimes these phases are chopped into smaller stages\n\n14\n\n\fA simple single-cycle implementation\n\nInstruction\nMemory\n\nControl\n\nPC\n\nRegister\nFile\n\nIF\n\nID\n\nWB\n\nALU\n\nEX\n\nData\nMemory\n\nMEM\n\n\u25cf An instruction goes through IF/ID/EX/MEM/WB in one cycle\n\n15\n\n\f\"Minimal MIPS\"\n\n16\n\n\fIt\u2019s a \u201csubset\u201d of MIPS\n\u25cf For pedagogical (teaching) purposes\n\n\u25cf Contains only a minimal number of instructions:\no lw, sw, add, sub, and, or, slt, beq, and j\no Other instructions in MIPS are variations on these anyway\n\u25cf Let's review the Minimal MIPS CPU focusing on the control signals\no Again, these control signals are decoded from the instruction\n\n17\n\n\fThe Minimal MIPS single-cycle CPU\n\u25cf A more detailed view of the 5-phase implementation\n\nInstruction\nMemory\n\nIns. Decoder\n\nPC\n\nPCSrc\n\n+\n\n4\n\n+\n\nimm field\n\ndst\nsrc1\nsrc2\n\nRegDataSrc\n\nData\nMemory\n\nRegister\nFile\n\nRegWrite\n\nimm field\n\nsxt\n\nMemWrite\n\nALUSrc\n\nALUOp\n\n18\n\n\fControl signals\n\u25cf Registers\no RegDataSrc: controls source of a register write (ALU / memory)\no RegWrite: enables a write to the register file\no src1, src2, dst: the register number for each respective operand\n\u25cf ALU\no ALUSrc: whether second operand of ALU is a register / immediate\no ALUOp: controls what the ALU will do (add, sub, and, or etc)\n\u25cf Memory\no MemWrite: enables a write to data memory\n\u25cf PC\no PCSrc: controls source of next PC (PC + 4 / PC + 4 + imm)\n\u2192 All these signals are decoded from the instruction!\n19\n\n\fHow an add/sub/and/or/slt work\n\nInstruction\nMemory\n\nIns. Decoder\n\nPC\n\nPCSrc\n\n+\n\n4\n\nadd t0, t3, s0\n\n+\n\nimm field\n\nnext instruction\nt0 dst\nt3 src1\ns0 src2\nRegister\n\nData\nMemory\nMemWrite\n\nFile\n\nRegDataSrc\nfrom ALU\n\nRegWrite\nenable\n\nimm field\n\nsxt\n\ndisable\n\nALUSrc\n\nfrom reg\n\nALUOp\nadd\n\n20\n\n\fHow an lw works\n\nInstruction\nMemory\n\nIns. Decoder\n\nPC\n\nPCSrc\n\n+\n\n4\n\nlw s4, 12(s0)\n\n+\n\nimm field\n\nnext instruction\ns4 dst\ns0src1\nx src2\nRegister\n\nData\nMemory\nMemWrite\n\nFile\n\nRegWrite\nRegDataSrc\nenable\nfrom Mem\n12\nsxt\nimm field\n\ndisable\n\nALUSrc\n\nfrom imm\n\nALUOp\nadd\n\n21\n\n\fHow an sw works\n\nInstruction\nMemory\n\nIns. Decoder\n\nPC\n\nPCSrc\n\n+\n\n4\n\nsw t3, 8(sp)\n\n+\n\nimm field\n\nnext instruction\nx dst\nspsrc1\nt3 src2\nRegister\n\nData\nMemory\nMemWrite\n\nFile\n\nRegWrite\nRegDataSrc\ndisable\nx\n8\nsxt\nimm field\n\nenable\n\nALUSrc\n\nfrom imm\n\nALUOp\nadd\n\n22\n\n\fWhat about beq?\n\u25cf Compares numbers by subtracting and see if result is 0\no If result is 0, we set PCSrc to use the branch target.\no Otherwise, we set PCSrc to PC + 4.\nisBEQ\nisZero\n\u2022 Instruction decoder outputs isBEQ\n\u2022 1: When instruction is beq\n\u2022 0: When instruction not beq\n\nALU\n\nPCSrc\n\n\u2022 When PCSrc is 1,\nPC = PC + 4+ imm\n(relative branch target)\n\u2022 When PCSrc is 0,\nPC = PC + 4\n\n23\n\n\fHow a beq works\n\nbeq t0, t1, loop\n\nInstruction\nMemory\n\nIns. Decoder\n\nPC\n\nPCSrc\n\n+\n\n4\n\nTake green PC path when t0 == t1\nTake red PC path when t0 != t1\n\n+\n\nimm field\nloop\n\nx dst\nt0 src1\nt1 src2\n\nRegDataSrc\nx\n\nData\nMemory\n\nRegister\nFile\n\nRegWrite\ndisable\n\nimm field\n\nsxt\n\nMemWrite\n\ndisable\n\nALUSrc\n\nfrom reg\n\nALUOp\nsub\n\n24\n\n\fWhat about j?\n\u25cf We have to add another input to the PCSrc mux.\n\nj\n\ntop\n\nPC+4\nPC+4+imm\njump target\n(now 2 bits)\n\nPCSrc\n25\n\n\fA Single-cycle Implementation is not Optimal\n\nInstruction\nMemory\n\nControl\n\nPC\n\nRegister\nFile\n\nIF\n\nID\n\nWB\n\nALU\n\nEX\n\nData\nMemory\n\nMEM\n\n\u25cf Why? Since the longest critical path must be chosen for cycle time\no And there is a wide variation among different instructions\n26\n\n\fA Single-cycle Implementation is not Optimal\n\u25cf In our CPU, the lw instruction has the longest critical path\no Must go through all 5 stages: IF/ID/EX/MEM/WB\no Whereas add goes through just 4 stages: IF/ID/EX/WB\n\u25cf If each phase takes 1 ns each, cycle time must be 5 ns:\no Because it needs to be able to handle lw, which takes 5 ns\no add also takes 5 ns when it could have been done in 4 ns\n\nQ) If lw is 1% and add is 99% of instruction mix,\nwhat is the average instruction execution time?\nA) Still 5 ns! Even if lw is only 1% of instructions!\n\n27\n\n\fA Multi-cycle Implementation\n\u25cf It takes one cycle for each phase through the use of internal latches\n\nMemory\n\nID\nIns. Decoder\n\nIF\n\nRegister\nFile\n\nEX\n\nALU\n\nMEM\n\nMemory\n\nWB\n28\n\n\fA Multi-cycle Implementation is Faster!\n\u25cf Now each instruction takes different number of cycles to complete\no lw takes 5 cycles: IF/ID/EX/MEM/WB\no add takes 4 cycles: IF/ID/EX/WB\n\u25cf If each phase takes 1 ns as before:\no lw takes 5 ns and add takes 4 ns\nQ) If lw is 1% and add is 99% of instruction mix,\nwhat is the average instruction execution time?\nA) 0.01 * 5 ns + 0.99 * 4 ns = 4.01 ns (25% faster than single cycle)\n* Caveat: delay due to the added latches not shown, but net win\n29\n\n\fAnd we can do even better!\n\u25cf Did you notice?\no When an instruction is on a particular phase (e.g. IF) \u2026\no \u2026 other phases (ID/EX/MEM/WB) are not doing any work!\n\u25cf Our CPU is getting chronically underutilized!\no If CPU is a factory, 80% (4/5) of the workers are idling!\n\u25cf Car factories create an assembly line to solve this problem\no No need to wait until a car is finished before starting on next one\no Our CPU is going to use a pipeline (similar concept)\n\n30\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}