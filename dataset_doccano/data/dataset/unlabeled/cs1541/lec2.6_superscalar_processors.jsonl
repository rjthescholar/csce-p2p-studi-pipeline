{"id": 215, "segment": "unlabeled", "course": "cs1541", "lec": "lec2.6_superscalar_processors", "text": "SuperScalar Processors\nCS 1541\nWonsun Ahn\n\n\fIn-order vs. Out-of-order superscalars\n\u25cf Superscalar: a wide-issue processor that does dynamic scheduling\no Extracts instruction level parallelism (ILP) within the processor\n\u25cf In-order superscalar: does not reorder instructions\no Only detects hazards between instructions to insert bubbles\no Only extracts ILP that arises from given ordering of instructions\no The processor simulated in Project 1\n\u25cf Out-of-order superscalar: does reorder instructions\no Reorders instructions to remove hazards and increase utilization\no Typically results in higher performance compared to in-order\no But dynamic reordering consumes lots of power\n\u25cf Out-of-order sounds more exciting so let\u2019s talk about that\n2\n\n\fName of the game is still ILP\n\u25cf The processor internally constructs the data dependency graph\n\u25cf The processor tries to take advantage of ILP as much as possible\no By executing the red nodes in parallel with the blue nodes\n\n3\n2\n\n1\n\n2\n\n1\n\n1\n2\n\n1\n1\n\n2\n\ntotal 7 cycles\n\nillustration courtesy of Dr. Melhem\n3\n\n\fInstruction Queue\n\nRegister\nFile\n\nInstruction Queue\n\nI-Mem\n\nIns. Decoder\n\n\u25cf In order to expose ILP, superscalars need a big instruction window\no Just like the compiler did for VLIWs\no HW structure for storing instructions is called instruction queue\no Now EX stage has a big pool of instructions to choose from\n\nALU\n\n+\n\nD-Mem\n\n4\n\n\fInstruction Queue\n\nInstruction Queue\n\n\u25cf In order to expose ILP, superscalars need a big instruction window\no Just like the compiler did for VLIWs\no HW structure for storing instructions is called instruction queue\nLoad/\nStore\n\nInstruction\nScheduler\n\nInt ALU 1\n\nInt ALU 2\nFloat\nALU\n\n\u25cf At ID, instructions are decoded\no And dispatched to the i-queue\n\u25cf At EX, ready instructions are chosen\nfrom the instruction queue\no Ready as in operands are available\no And issued to an EX unit\n\u25cf Typically queue is always full\no Insts start queueing up when insts\nfail to issue due to hazards\n5\n\n\fScheduling the Instruction Queue\n\n[Dispatched]\nli t0, 1\nli t1, 2\nadd t2, t0, t1\n\nInstruction Queue\n\n\u25cf Now we have pool of instructions. When do they become ready?\no Ready operands and instructions are in green\no Not ready operands and instructions are in red\nLoad/\nStore\n\n[Issued]\nInstruction\nScheduler\n\nInt ALU 1\n\nInt ALU 2\n\nFloat\nALU\n6\n\n\fScheduling the Instruction Queue\n\n[Dispatched]\nli t0, 1\nli t1, 2\nadd t2, t0, t1\n\nInstruction Queue\n\n\u25cf Initially both li t0, 1 and li t1, 2 are ready\no The li instruction does not have any register operands\no Instruction scheduler has a choice of what to issue\nLoad/\nStore\n\n[Issued]\nInstruction\nScheduler\n\nInt ALU 1\n\nInt ALU 2\n\nFloat\nALU\n7\n\n\fScheduling the Instruction Queue\n\n[Dispatched]\nli t0, 1\nli t1, 2\nadd t2, t0, t1\n\nInstruction Queue\n\n\u25cf Let\u2019s say the scheduler issues li t1, 2 first\n\u25cf Then the t1 operand becomes ready after it completes\nLoad/\nStore\n\nInstruction\nScheduler\n\nInt ALU 1\n\n[Issued]\nli t1, 2\n\nInt ALU 2\n\nFloat\nALU\n8\n\n\fScheduling the Instruction Queue\n\n[Dispatched]\nli t0, 1\nadd t2, t0, t1\n\nInstruction Queue\n\n\u25cf Now the only ready instruction li t0, 1 issues\n\u25cf Then the t0 operand becomes ready after it completes\n\u25cf Now add t2, t0, t1 is finally ready to issue\nLoad/\nStore\n\nInstruction\nScheduler\n\nInt ALU 1\n\n[Issued]\nli t1, 2\nli t0, 1\n\nInt ALU 2\n\nFloat\nALU\n9\n\n\fScheduling the Instruction Queue\n\n[Dispatched]\n\nInstruction Queue\n\n\u25cf And we are done!\n\nLoad/\nStore\n\nInstruction\nScheduler\n\nInt ALU 1\n\nInt ALU 2\n\n[Issued]\nli t1, 2\nli t0, 1\nadd t2, t0, t1\n\nFloat\nALU\n10\n\n\fScheduling the Instruction Queue\n\n[Dispatched]\nli t0, 1\nli t1, 2\nadd t2, t0, t1\n\nInstruction Queue\n\n\u25cf Note how we reordered li t0, 1 and li t1, 2\no There are no dependencies between the two, so no issues\no Also, RAW dependency with add t2, t0, t1 was enforced\nLoad/\nStore\n\nInstruction\nScheduler\n\nInt ALU 1\n\nInt ALU 2\n\n[Issued]\nli t1, 2\nli t0, 1\nadd t2, t0, t1\n\nFloat\nALU\n11\n\n\fWhat if we had a WAW dependency?\n\n[Dispatched]\nli t0, 1 WAW!\nli t0, 2\nadd t2, t0, t0\n\nInstruction Queue\n\n\u25cf Reordering li t0, 1 and li t0, 2 still allowed (both are ready)\no Now t2 = 4 in original code, but t2 = 2 during execution!\no How do we disallow this from happening?\nLoad/\nStore\n\nInstruction\nScheduler\n\nInt ALU 1\n\nInt ALU 2\n\n[Issued]\nli t0, 2\nli t0, 1\nadd t2, t0, t0\n\nFloat\nALU\n12\n\n\fWAW and WAR dependencies are tricky\n\u25cf RAW (true) dependencies are automatically enforced\no Instructions cannot issue until all operands are ready (written)\n\u25cf WAW and WAR dependencies are not enforced\no There is no data passing between the two instructions\no The two instructions can become ready in any order\n\u25cf We could somehow enforce WAW and WAR dependencies\no But there is a better solution: register renaming!\no Remember? That\u2019s what the compiler did to remove WAW/WAR.\n\n13\n\n\fRegister Renamer and the RAT\n\n[Decoded]\nli t0, 1 WAW!\nli t0, 2\nadd t2, t0, t0\n\nAll 32 MIPS registers\n\nRegister\nRenamer\nRAT\n\nt0\n\np1\n\nt1\n\n-\n\nt2\n\np2\n\n\u2026\n\n\u2026\n\n[Dispatched]\nli p0, 1 No\nli p1, 2 WAW!\nadd p2, p1, p1\n\nInstruction Queue\n\n\u25cf As soon as decode, Register Renamer renames all registers\no Done with the help of the Register Alias Table (RAT)\no RAT is current mapping between architectural and physical registers\n\u25aa Architectural registers: Registers in ISA used in programs (t0, t1, t2, \u2026)\n\u25aa Physical registers: Renamed registers used in processor (p0, p1, p2, \u2026)\n\n14\n\n\fRegister Renamer and the RAT\n\u25cf So how does the RAT work?\n\u25cf Initially, no assignments have been done, so mapping is empty.\n\nRegister\nRenamer\nRAT\n\nAll 32 MIPS registers\n\nt0\n\n-\n\nt1\n\n-\n\nt2\n\n-\n\n\u2026\n\n\u2026\n\n[Dispatched]\n\nInstruction Queue\n\n[Decoded]\n\n15\n\n\fRegister Renamer and the RAT\n\n[Decoded]\nli t0, 1\n\nRegister\nRenamer\nRAT\n\nAll 32 MIPS registers\n\nt0\n\np0\n\nt1\n\n-\n\nt2\n\n-\n\n\u2026\n\n\u2026\n\n[Dispatched]\nli p0, 1\n\nInstruction Queue\n\n1. li t0, 1 is decoded, destination t0 is renamed to p0\n\n16\n\n\fRegister Renamer and the RAT\n\n[Decoded]\nli t0, 1\nli t0, 2\n\nRegister\nRenamer\nRAT\n\nAll 32 MIPS registers\n\nt0\n\np1\n\nt1\n\n-\n\nt2\n\n-\n\n\u2026\n\n\u2026\n\n[Dispatched]\nli p0, 1\nli p1, 2\n\nInstruction Queue\n\n1. li t0, 1 is decoded, destination t0 is renamed to p0\n2. li t0, 2 is decoded, destination t0 is renamed to p1\no Remember the single assignment rule?\no A new value always gets a new register\n\n17\n\n\fRegister Renamer and the RAT\n\n[Decoded]\nli t0, 1\nli t0, 2\nadd t2, t0, t0\n\nAll 32 MIPS registers\n\nRegister\nRenamer\nRAT\n\nt0\n\np1\n\nt1\n\n-\n\nt2\n\np2\n\n\u2026\n\n\u2026\n\n[Dispatched]\nli p0, 1\nli p1, 2\nadd p2, p1, p1\n\nInstruction Queue\n\n1. li t0, 1 is decoded, destination t0 is renamed to p0\n2. li t0, 2 is decoded, destination t0 is renamed to p1\n3. add t2, t0, t0 is decoded:\no Two t0 input registers use current mapping p1\no Destination register t2 is renamed to p2\n\n18\n\n\fRegister Rename Removes all WAW/WAR Deps\n\n[Decoded]\nli t0, 1 WAW!\nli t0, 2\nadd t2, t0, t0\n\nRegister\nRenamer\nt0\n\nRAT\nrenamed p\n\n\u2026\n\n\u2026\n\nt9\n\nrenamed p\n\nInstruction Queue\n\n\u25cf By the time instructions are dispatched to i-queue\no All architectural registers have been renamed to physical registers\no All WAR and WAR dependencies have been removed\n[Dispatched]\nli p0, 1 No\nli p1, 2 WAW!\nadd p2, p1, p1\nInstruction\nScheduler\n\nLoad/\nStore\nInt ALU 1\n\n[Issued]\nli p1, 2\nli p0, 1\nadd p2, p1, p1\n\nInt ALU 2\n\nFloat\nALU\n19\n\n\fAll Computation Done using Physical Registers\n\nPhysical\nRegister File\n\np0\np1\n\nRegister\nRenamer\nt0\n\nRAT\nrenamed p\n\n\u2026\n\n\u2026\n\nt9\n\nrenamed p\n\np2\n\u2026\n\np(n-1)\np(n)\n\nInstruction Queue\n\nInstruction Decoder\n\n\u25cf Now ID stage (dispatch) reads registers from physical register file\n\u25cf All data forwarding also done based on physical registers\nLoad/\nStore\n\nInstruction\nScheduler\n\nInt ALU 1\n\nInt ALU 2\nFloat\nALU\n20\n\n\fILP limits performance improvements of wide-issue\n\u25cf We already discussed limits on pipelining.\n\u25cf Time to discuss limits on IPC improvements through wide-issue!\n\u25cf There is a fundamental limit to achievable IPC\no Amount of ILP (Instruction Level Parallelism) in code\no Remember the data dependence graph?\no ILP is constrained only by true RAW dependencies\no How about control dependencies?\n\u25aa Not a fundamental limit \u2192 can elide using branch prediction\n\u25cf ILP is a property of the program, not the processor\no This limit applies to both VLIW and superscalar processors\n\n21\n\n\fILP present in different programs\n\u25cf After renaming, theoretical limit of IPC is 35 ~ 4003!\n\nMatthew Postiff et al. \u201cThe Limits\nof Instruction Level Parallelism in\nSPEC95 Applications\u201d. ACM\nSIGARCH Computer Architecture\nNews, 1999\n22\n\n\fPractical limits on performance of Superscalar\n\u25cf Achieving the theoretical limit would be awesome\no In reality, superscalars are typically no more than 10-wide\n\u25cf Practical limits on superscalar processors\no Number of execution units (e.g. ALU, Load/Store) not really a limit\no Practical limits on the IPC you can achieve\n\u25aa Instruction queue size (impacts scheduling window)\n\u25aa Physical register file size (also impacts scheduling window)\no Upsizing above structures negatively impacts cycle time\n\u25aa Time to search and schedule instruction queue\n\u25aa Time to access register file (increased size and number of ports)\no Upsizing above structures negatively impacts energy efficiency\n\n23\n\n\fExceptions\n\n24\n\n\fExceptions Review\n\u25cf Exception: an event which causes the CPU to stop the normal flow of\nexecution and go somewhere else (the exception handler)\n\u25cf There are mainly two causes of exceptions:\no Software exceptions (or traps): Triggered by a program instruction\n\u25aa Trap instruction: typically used to call OS routines (system calls)\n\u25aa Page fault: instruction accessed a page not mapped to memory\n\u25aa Divide-by-0: instruction performed a divide-by-0 arithmetic\n\u25aa Arithmetic overflow: instruction overflowed MAX_INT of register\no Hardware exceptions (or interrupts): Triggered by hardware event\n\u25aa User has typed on the keyboard\n\u25aa A network packet has arrived\n\u25aa A file block read has completed\n\n\u25cf In all cases, the OS exception handler is invoked\n\n25\n\n\fHandling exceptions\n\u25cf What happens when an exception is triggered:\n1. Processor stops execution of user program.\n2. Processor stores information about exception (cause, PC).\n3. Processor jumps to the OS exception handler.\n4. Handler creates backup of program register values in memory.\n5. Handler inspects exception info and handles it accordingly.\n\u25aa While overwriting some of the registers that were backed up.\n6. Handler restores program register values from memory.\n7. Processor resumes execution of user program.\n\u25cf Processor must provide precise register values at point of exception\no Otherwise, when processor resumes, program will malfunction\no Guaranteeing this is called a precise exception\n26\n\n\fRules for Precise Exceptions\n1. All instructions before the exception must have executed\n\n2. No instructions after the exception must execute\n\u25cf Architectural state: the state visible to the ISA (i.e. software)\no State in architectural registers (For MIPS: t0, t1, t2, \u2026)\no State in data memory\n\n\u25cf Architectural state at point of exception must reflect above rules\n\n27\n\n\fPrecise Exceptions in In-order Processors is Easy\n\nI-Mem\n\nIns. Decoder\n\n\u25cf Exceptions are typically detected at the EX stage\no Stage where all arithmetic happens as well as address calculations\n\u25cf On exception, flush EX and all previous stages (ID and IF)\no Since in-order, guarantees instructions following EX do not writeback\no Only state leading up to instruction at EX will be written to reg / mem\n\nRegister\nFile\n\nALU\n\nD-Mem\n\nALU\n28\n\n\fPrecise Exceptions in Out-of-order Processors is Hard\n\n[Decoded]\nli t0, 0\nli t1, 1\ndiv t2,t1,t0\nli t0, 3\n\nRegister\nRenamer\n\nInstruction Queue\n\n\u25cf Suppose div t2,t1,t0 and li t0, 3 issue out-of-order as below\no div p2,p1,p0 triggers a divide-by-zero exception (p0 = 0)\no But at point of exception, t0 appears to be 3 due to li p3, 3!\n\u25aa At that point, t0 is mapped to p3 in the RAT (not p0)\n[Dispatched]\nli p0, 0\nli p1, 1\ndiv p2,p1,p0\nli p3, 3\n\nInstruction\nScheduler\n\nLoad/\nStore\nInt ALU 1\n\nInt ALU 2\n\n[Issued]\nli p0, 0\nli p1, 1\nli p3, 3\ndiv p2,p1,p0\nDivide-by-zero\nException!\n\nFloat\nALU\n29\n\n\fPrecise Exceptions in Out-of-order Processors is Hard\n\u25cf This is the challenge with out-of-order processors\no Instructions execute and complete out-of-order\no For precise exceptions, instructions must appear to complete in-order\n\u25cf Solution: update architectural state in-order\no When instructions execute, have them only update \u201cinternal\u201d state\n\u25aa Physical registers\n\u25aa Store queue (MEM queues up stores instead of performing them)\no Internal state is transferred to visible state during in-order commit\n\u25aa Physical registers are copied to architectural registers\n\u25aa Store queue entries are written to memory\n\n30\n\n\fIn-order Commit\n\n[Decoded]\nli t0, 0\nli t1, 1\ndiv t2,t1,t0\nli t0, 3\n\nRegister\nRenamer\nPhysical\nRegister\nFile\n\nRetirement Register File\nt0\ns0\na0\nt1\ns1\na1\nt2\ns2\na2\n\u2026\n\u2026\n\u2026\nInstruction Queue\ninstructions dest done?\nli p0, 0\nt0\nY\nli p1, 1\nt1\nY\ndiv p2,p1,p0 t2\nN\nli p3, 3\nt0\nY\n\nArchitectural\nRegisters\n\ncommit in order\n\nInstruction Decoder\n\n\u25cf Decoded instructions are stored to i-queue in-order\n\u25cf Instructions execute out-of-order (updating done? field)\n\u25cf Done instructions commit in-order to Retirement Register File (RRF)\n\nInstruction\nScheduler\n\nLoad/\nStore\nInt ALU 1\n\nInt ALU 2\nFloat\nALU\n31\n\n\fIn-order Commit Example: Cycle 1\n\n[Decoded]\nli t0, 0\nli t1, 1\ndiv t2,t1,t0\nli t0, 3\n\nRegister\nRenamer\nPhysical\nRegister\nFile\n\nRetirement Register File\nt0\ns0\na0\nt1\ns1\na1\nt2\ns2\na2\n\u2026\n\u2026\n\u2026\nInstruction Queue\ninstructions dest done?\nli p0, 0\nt0\nY\nli p1, 1\nt1\nY\ndiv p2,p1,p0 t2\nN\nli p3, 3\nt0\nY\n\nArchitectural\nRegisters\n\ncommit in order\n\nInstruction Decoder\n\n\u25cf At this point, all li instructions have completed but not the div\n\u25cf li p0, 0 and li p1, 1 can commit on the next cycle\no But not li p3, 3 since we have in-order commit!\n\nInstruction\nScheduler\n\nLoad/\nStore\nInt ALU 1\n\nInt ALU 2\nFloat\nALU\n32\n\n\fIn-order Commit Example : Cycle 2\n\n[Decoded]\nli t0, 0\nli t1, 1\ndiv t2,t1,t0\nli t0, 3\n\nRegister\nRenamer\nPhysical\nRegister\nFile\n\nRetirement Register File\nt0\ns0\na0\nt1\ns1\na1\nt2\ns2\na2\n\u2026\n\u2026\n\u2026\nInstruction Queue\ninstructions dest done?\ndiv p2,p1,p0 t2\nY\nli p3, 3\nt0\nY\n\u2026\n\u2026\n\nArchitectural\nRegisters\n\ncommit in order\n\nInstruction Decoder\n\n\u25cf li p0, 0 and li p1, 1 have committed updating t0 and t1\n\u25cf div p2,p1,p0 has completed execution and is finally ready to commit\no On completion, div has set an \u201cexception bit\u201d in i-queue (not shown here)\n\nInstruction\nScheduler\n\nLoad/\nStore\nInt ALU 1\n\nInt ALU 2\nFloat\nALU\n33\n\n\fIn-order Commit Example : Cycle 3\n\n[Decoded]\nli t0, 0\nli t1, 1\ndiv t2,t1,t0\nli t0, 3\n\nRegister\nRenamer\nPhysical\nRegister\nFile\n\nRetirement Register File\nt0\ns0\na0\nt1\ns1\na1\nt2\ns2\na2\n\u2026\n\u2026\n\u2026\nInstruction Queue\ninstructions dest done?\ndiv p2,p1,p0 t2\nY\nli p3, 3\nt0\nY\n\u2026\n\u2026\n\nArchitectural\nRegisters\n\nInstruction\nScheduler\nException!\n\nFlush!\n\nInstruction Decoder\n\n\u25cf An exception is raised for div p2,p1,p0 when it tries to commit\no Instructions following div are flushed, without modifying RRF\n\u25cf Retirement Register File contains a precise architectural state\nLoad/\nStore\nInt ALU 1\n\nInt ALU 2\nFloat\nALU\n34\n\n\fIn-order Commit also solves branch misprediction\n\n[Decoded]\nli t0, 0\nli t1, 1\ndiv t2,t1,t0\nli t0, 3\n\nRegister\nRenamer\nPhysical\nRegister\nFile\n\nRetirement Register File\nt0\ns0\na0\nt1\ns1\na1\nt2\ns2\na2\n\u2026\n\u2026\n\u2026\nInstruction Queue\ninstructions dest done?\nli p0, 0\nt0\nY\nli p1, 1\nt1\nY\nbeq p0,p1,\u2026 t2\nN\nli p3, 3\nt0\nY\n\nArchitectural\nRegisters\n\nInstruction\nScheduler\n\nFlush!\n\nInstruction Decoder\n\n\u25cf What if processor finds out it mispredicted a branch?\no Just flush instructions below it after the branch executes!\no Also restore an RAT snapshot that was taken at point of branch.\n\nMispredict!\n\nLoad/\nStore\nInt ALU 1\n\nInt ALU 2\nFloat\nALU\n35\n\n\fIn-order Commit also solves physical register recycling\n\nInstruction Decoder\n\n\u25cf When can the processor recycle physical registers?\no The prev column records previous physical register mapped to dest.\no When li p3, 3 commits, p0 previously mapped to t0 can be recycled\n[Decoded]\nli t0, 0\nli t1, 1\ndiv t2,t1,t0\nli t0, 3\n\nRegister\nRenamer\nPhysical\nRegister\nFile\n\nRetirement Register File\nt0\ns0\na0\nt1\ns1\na1\nt2\ns2\na2\n\u2026\n\u2026\n\u2026\nInstruction Queue\ninstructions dest prev\nli p0, 0\nt0\nli p1, 1\nt1\nbeq p0,p1,\u2026 t2\nli p3, 3\nt0\np0\n\nArchitectural\nRegisters\n\nInstruction\nScheduler\nRecycle p0\non commit\n\nLoad/\nStore\nInt ALU 1\n\nInt ALU 2\nFloat\nALU\n36\n\n\fLoad / Store Queue\n\n37\n\n\fHow about data dependencies through memory?\n\u25cf RAW, WAR, and WAW dependencies happen through memory as well\no Clearly, the below code has no data dependencies through registers\nsw\n$t0, 4($s0)\n// stores to 0xdeadbeef\nlw\n$t1, 8($s1)\n// loads from 0xdeadbeef\no But there is a RAW dependency through the location 0xdeadbeef\n\u25cf Question: how does processor enforce RAW dependencies?\n\u25cf Question: how does processor deal with WAR and WAW dependencies?\n\n\u25cf Answer: through memory renaming using a load / store queue\no Just like registers, a new queue entry created for every store instruction\n\u2192 All WAR and WAW memory dependencies are removed\no Loads fetch data from most recent queue entry with same address\n\u2192 All RAW memory dependencies are enforced\n38\n\n\fEvery store gets a new store queue entry\n\nInstruction Decoder\n\n\u25cf Loads / stores are inserted into load / store queue as well instruction queue\no Age denotes age of memory operation (incremented at every mem op)\no Address and value of mem op is unknown until mem op is complete\nStore Queue\n[Decoded]\naddr\nvalue\nsw $t0, 0($s0) age\n0($s0) ???\n???\nsw $t1, 0($s1) 1\n0($s1) ???\n???\nlw $t2, 0($s2) 2\n\u2026\n\u2026\n\u2026\n\nRegister\nRenamer\n\nInstruction\nQueue\n\nPhysical\nRegister\nFile\n\nLoad Queue\nage\naddr\ndone?\n3\n0($s2) ???\nN\n\u2026\n\u2026\n\u2026\n\nRenamed\nMemory\n\nInstruction\nScheduler\n\nLoad/\nStore\nInt ALU 1\n\nInt ALU 2\nFloat\nALU\n39\n\n\fScenario 1: WAW reordering of two stores\n\nInstruction Decoder\n\n\u25cf Let\u2019s say sw $t1, 0($s1) becomes ready first in the i-queue and executes\no 0($s1) is resolved to 0xdeadbeef and $t1 is resolved to 1\nStore Queue\n[Decoded]\naddr\nvalue\nsw $t0, 0($s0) age\n0($s0) ???\n???\nsw $t1, 0($s1) 1\n0xdeadbeef\n1\nlw $t2, 0($s2) 2\n\u2026\n\u2026\n\u2026\n\nRegister\nRenamer\n\nInstruction\nQueue\n\nPhysical\nRegister\nFile\n\nLoad Queue\nage\naddr\ndone?\n3\n0($s2) ???\nN\n\u2026\n\u2026\n\u2026\n\nRenamed\nMemory\n\nInstruction\nScheduler\n\nLoad/\nStore\nInt ALU 1\n\nInt ALU 2\nFloat\nALU\n40\n\n\fScenario 1: WAW reordering of two stores\n\nInstruction Decoder\n\n\u25cf Next, sw $t0, 0($s0) becomes ready in the i-queue and executes\no 0($s0) is also resolved to 0xdeadbeef and $t0 is resolved to 0\no So, we have effectively reordered execution of a WAW dependency\nStore Queue\n[Decoded]\naddr\nvalue\nsw $t0, 0($s0) age\n0xdeadbeef\n0\nsw $t1, 0($s1) 1\n0xdeadbeef\n1\nlw $t2, 0($s2) 2\n\u2026\n\u2026\n\u2026\n\nRegister\nRenamer\n\nInstruction\nQueue\n\nPhysical\nRegister\nFile\n\nLoad Queue\nage\naddr\ndone?\n3\n0($s2) ???\nN\n\u2026\n\u2026\n\u2026\n\nRenamed\nMemory\n\nInstruction\nScheduler\n\nLoad/\nStore\nInt ALU 1\n\nInt ALU 2\nFloat\nALU\n41\n\n\fScenario 1: WAW reordering of two stores\n\nInstruction Decoder\n\n\u25cf Finally, lw $t2, 0($s2) becomes ready in the i-queue and executes\no 0($s2) also resolves to 0xdeadbeef meaning a RAW dependence\no Load Unit searches Store Queue for most recent store matching address\nStore Queue\n[Decoded]\naddr\nvalue\nsw $t0, 0($s0) age\n0xdeadbeef\n0\nsw $t1, 0($s1) 1\n0xdeadbeef\n1\nlw $t2, 0($s2) 2\n\u2026\n\u2026\n\u2026\n\nRegister\nRenamer\n\nInstruction\nQueue\n\nPhysical\nRegister\nFile\n\nLoad Queue\nage\naddr\ndone?\n3\n0xdeadbeef\nY\n\u2026\n\u2026\n\u2026\n\n$t2 = 1\n\naddr == 0xdeadbeef\n&&\nage < 3?\n\nInstruction\nScheduler\n\nLoad/\nStore\nInt ALU 1\n\nInt ALU 2\nFloat\nALU\n42\n\n\fScenario 2: Flush due to RAW violation\n\nInstruction Decoder\n\n\u25cf In this scenario, lw $t2, 0($s2) becomes ready first and executes\no Load Unit searches store queue but does not find matching entry\no So, it simply fetches value for $t2 from memory\nStore Queue\n[Decoded]\naddr\nvalue\nsw $t0, 0($s0) age\n0($s0) ???\n???\nsw $t1, 0($s1) 1\n0($s1) ???\n???\nlw $t2, 0($s2) 2\n\u2026\n\u2026\n\u2026\n\nRegister\nRenamer\n\nInstruction\nQueue\n\nPhysical\nRegister\nFile\n\nLoad Queue\nage\naddr\ndone?\n3\n0xdeadbeef\nY\n\u2026\n\u2026\n\u2026\n\naddr == 0xdeadbeef\n&&\nage < 3?\n\nInstruction\nScheduler\n\nLoad/\nStore\nInt ALU 1\n\nInt ALU 2\nFloat\nALU\n43\n\n\fScenario 2: Flush due to RAW violation\n\nInstruction Decoder\n\n\u25cf Next, sw $t0, 0($s0) becomes ready in the i-queue and executes\no Store Unit searches Load Queue to see if there were RAW violations\no And, yes, there is a Load that performed earlier than it should have!\nStore Queue\n[Decoded]\naddr\nvalue\nsw $t0, 0($s0) age\n0xdeadbeef\n0\nsw $t1, 0($s1) 1\n0($s1) ???\n???\nlw $t2, 0($s2) 2\n\u2026\n\u2026\n\u2026\n\nRegister\nRenamer\nPhysical\nRegister\nFile\n\nInstruction\nQueue\n\nLoad/\nStore\n\nInstruction\nScheduler\n\nLoad Queue\nage\naddr\ndone?\naddr == 0xdeadbeef\n3\n0xdeadbeef\nY\n&& age > 1\n\u2026\n\u2026\n\u2026\n&& done?\n\nInt ALU 1\n\nInt ALU 2\nFloat\nALU\n44\n\n\fScenario 2: Flush due to RAW violation\n\nStore Queue\n[Decoded]\naddr\nvalue\nsw $t0, 0($s0) age\n0xdeadbeef\n0\nsw $t1, 0($s1) 1\n0($s1) ???\n???\nlw $t2, 0($s2) 2\n\u2026\n\u2026\n\u2026\n\nRegister\nRenamer\n\nInstruction\nQueue\n\nPhysical\nRegister\nFile\n\nLoad Queue\nage\naddr\ndone?\n3\n0xdeadbeef\nY\n\u2026\n\u2026\n\u2026\n\nLoad/\nStore\n\nInstruction\nScheduler\n\nFlush!\n\nInstruction Decoder\n\n\u25cf Flush lw $t2, 0($s2) and all instructions that follow it in i-queue\no All following execution has been polluted by incorrect value of $t2\n\nInt ALU 1\n\nInt ALU 2\nFloat\nALU\n45\n\n\fPrecise exceptions through in-order commit\n\nInstruction Decoder\n\n\u25cf Values in Store Queue are committed in-order\no When store instruction reaches head of i-queue, value stored to memory\no Guarantees precise exceptions\nStore Queue\n[Decoded]\naddr\nvalue\nsw $t0, 0($s0) age\n0xdeadbeef\n0\nsw $t1, 0($s1) 1\n0xdeadbeef\n1\nlw $t2, 0($s2) 2\n\u2026\n\u2026\n\u2026\n\nRegister\nRenamer\n\nInstruction\nQueue\n\nPhysical\nRegister\nFile\n\nLoad Queue\nage\naddr\ndone?\n3\n0xdeadbeef\nY\n\u2026\n\u2026\n\u2026\n\nCommitted\nIn-order\n\nInstruction\nScheduler\n\nLoad/\nStore\nInt ALU 1\n\nInt ALU 2\nFloat\nALU\n46\n\n\fReal Life Superscalars\n\n47\n\n\fThe ARM Cortex-A8 architecture\n\u25cf The ARM Cortex-A8 is an in-order superscalar processor\no Notice the use of the architectural register file\n\nFIGURE 4.75 The A8 pipeline. The first three stages fetch instructions into a 12-entry instruction\nfetch buffer. The Address Generation Unit (AGU) uses a Branch Target Buffer (BTB), Global\nHistory Buffer (GHB), and a Return Stack (RS) to predict branches to try to keep the fetch queue\nfull. Instruction decode is five stages and instruction execution is six stages.\n\n48\n\n\fThe AMD Opteron X4 Microarchitecture\n\u25cf The AMD Opteron is an out-of-order superscalar processor\no Commit unit oversees retiring instructions from operation queue\nInstruction Fetch\nand Decode\n\nRegister read\nand Dispatch\n\nExecute\n\nMem\n\nWrite Back\n\n49\n\n\fThe Intel Core i7 architecture\n\u25cf The Intel Core i7 is another out-of-order superscalar processor\n\nFIGURE 4.77 The Core i7 pipeline with\nmemory components. The total pipeline\ndepth is 14 stages, with branch\nmispredictions costing 17 clock cycles.\nThis design can buffer 48 loads and 32\nstores. It is a 4-wide processor but has 6\nexecution units of different types to reduce\nstructural hazards.\n\n50\n\n\fIntel Core i7 Performance\n\u25cf Ideal CPI = 0.25 since this is a 4-wide processor\n\n51\n\n\fIntel Core i7 Impact of Branch Misprediction\n\u25cf Due to deep pipeline, tiny misprediction can have outsized impact\n\n52\n\n\fRecap:\nVLIWs vs SuperScalars\n\n53\n\n\fAbility to deal with hazards\n\u25cf Hazards prevent the full exploitation of ILP (Instruction Level Parallelism)\n\u25cf Which processor type is better at dealing with various hazards?\nVLIW\n\nOut-of-order SuperScalar\n\nStructural Hazards\nData Hazards (Registers)\nData Hazards (Memory)\nControl Hazards\nInstruction Window\n\n54\n\n\fAbility to operate energy efficiently\n\u25cf We learned that performance and power are two sides of the same coin.\n\u25cf Which processor type has less power-hungry control structures?\nVLIW\n\nOut-of-order SuperScalar\n\nBig Register File\nRegister Alias Table\nInstruction Queue\nData Forwarding Wires\n\n55\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}