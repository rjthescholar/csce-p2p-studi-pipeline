{"id": 201, "segment": "unlabeled", "course": "cs1550", "lec": "lec03", "text": "Introduction to Operating Systems\nCS/COE 1550\nSpring 2022\n\nSherif Khattab\nksm73@pitt.edu\n(Some slides are from Silberschatz, Galvin and Gagne \u00a92013)\n\n\fAnnouncements\n\u2022 Homework 1 is due next Monday at 11:59 pm\n\n\u2022 Lab 1 is due on 2/4 at 11:59 pm\n\u2022 Distributed using GitHub Classroom\n\u2022 Explained in this week\u2019s recitations\n\n\u2022 TA Office hours available on the syllabus page\n\n\u2022 Project 1 will be up on Canvas this Friday\n\u2022 Docker images are available on Canvas\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n2\n\n\fMuddiest Points\n\u2022 the while(1) loop in the spinlocks example (just a placeholder I\nassume?)\n\u2022 It would be helpful to have a step-by-step written out\nrepresentation of Context Switching in Xv6 to accompany the\ngraphic\n\u2022 Why only certain registers were pushed/popped in the context\nswitches. Is it just because these are the only registers the\nprocesses could be using?\n\u2022 How can hardware be directly accessed by user tasks, like the\nfirst two options in the spin lock slide? My thought was that\nsomething like an atomic swap would need hard wiring, not\nsoftware\n\u2022 Are race condition prevention methods implemented by the\nprogrammer or the operating system?\n\u2022 What exactly is a critical region again?\n\u2022 Are context switching done by the kernel?\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n3\n\n\fAgenda\n\u2022 Busy Waiting Problem\n\n\u2022 Why does it happen?\n\u2022 What are its implications?\n\u2022 How to solve it?\n\u2022 Sempahores\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n4\n\n\fToday\u2019s problem: Busy Waiting\n\u2022 A process that is trying to acquire a locked spinlock is\nrunning!\n\u2022 It continuously checks:\n\u2022 can I get the lock? No, lock is held by another process\n\u2022 can I get the lock? No, lock is held by another process\n\u2022 \u2026\n\n\u2022 This continuous check is called spinning or busy waiting\n\u2022 But what is wrong with that?\n\u2022 Busy waiting wastes CPU cycles\n\u2022 on a single-core system it delays the process that is holding the\nlock from releasing it\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n5\n\n\fToday\u2019s problem: Busy Waiting\nWhile P1 is in the critical region, P2 is busy waiting\nShared Data\nSpinlock lk;\nint x;\nProcess P1\nlock(lk);\n\nProcess P2\nlock(lk);\n\n//critical region (e.g., x++) //critical region (e.g., x++)\nunlock(lk);\n\nunlock(lk);\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n6\n\n\fBut why?\n\nWhy does busy waiting happen with spinlocks?\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n7\n\n\fAtomic TestAndSet\n\u2022 TestAndSet is an\natomic instruction\n\nint TestAndSet(int &x){\n\n\u2022 Works for singlecore and multicore Symmetric\nMulti-Processing\n(SMP)\n\nlock memory access to x\nint temp = *x;\n\n*x = 1;\nunlock memory access to x\nreturn temp;\n\n}\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n8\n\n\fSpinlock implementation using TestAndSet\n\u2022\n\nSingle shared variable: lock\n\n\u2022\n\nWorks for any number of processes\n\nint lock = 0;\nLock(){\nwhile (TestAndSet(&lock))\n;\n}\nUnlock(){\nlock = 0;\n}\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n9\n\n\fAtomic Swap\n\u2022 Swap is an atomic\ninstruction\n\nint Swap(int &x, int y){\n\n\u2022 Works for singlecore and multicore Symmetric\nMulti-Processing\n(SMP)\n\nlock memory access to x\nint temp = *x;\n\n*x = y;\nunlock memory access to x\nreturn temp;\n\n}\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n10\n\n\fSpinlock implementation using Swap\n\u2022\n\nSingle shared variable: lock\n\n\u2022\n\nWorks for any number of processes\n\nint lock = 0;\nLock(){\nwhile (Swap(&lock, 1))\n;\n}\nUnlock(){\nlock = 0;\n}\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n11\n\n\fImplication of Busy Waiting\nSubproblem: priority inversion (higher priority process busy\nwaits for lower priority process)\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n12\n\n\fImplementation Detail\ncompiler and/or hardware may reorder instructions\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n13\n\n\fXv6 Walkthrough\n\u2022 Spinlocks\n\u2022 __sync_synchronize() is a memory barrier instruction\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n14\n\n\f\u2022\n\n\u2022\n\nSemaphores\nSolution: use semaphores\n\u2022\n\nSynchronization mechanism that doesn\u2019t require busy waiting\n\nImplementation\n\u2022\n\nSemaphore S accessed by two atomic operations\n\u2022\n\nDown(S): decrement the semaphore if > 0; block otherwise\n\n\u2022\n\nUp(S): increment the semaphore and wakeup one blocked process if any\n\n\u2022\n\nDown() is another name for P()\n\n\u2022\n\nUp() is another name for V()\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n15\n\n\fBusy waiting vs. Blocking\n\nBlocking involves 2 context switches\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n16\n\n\fCritical sections using semaphores\nShared variables\nSemaphore sem(1);\n\nCode for process Pi\n\nwhile (1) {\n// non-critical section\ndown(sem);\n// critical section\nup(sem);\n// non-critical section\n}\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n17\n\n\fTypes of semaphores\n\u2022 Two different types of semaphores\n\u2022 Counting semaphores\n\u2022 Binary semaphores\n\n\u2022 Counting semaphore\n\u2022 Value can range over an unrestricted range\n\n\u2022 Binary semaphore\n\u2022 Only two values possible\n\u2022 1 means the semaphore is available\n\u2022 0 means a process has acquired the semaphore\n\n\u2022 May be simpler to implement\n\n\u2022 Possible to implement one type using the other\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n18\n\n\fSemaphore Implementation\n\nBut how do semaphores avoid busy waiting?\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n19\n\n\f\u2022\n\n\u2022\n\nImplementing semaphores with blocking\nAssume two operations:\n\u2022\n\nSleep(): suspends current\nprocess\n\n\u2022\n\nWakeup(P): allows process P\nto resume execution\n\nSemaphore data structure\n\u2022\n\nTracks value of semaphore\n\n\u2022\n\nKeeps a list of processes\nwaiting for the semaphore\nstruct Semaphore {\nint value;\nProcessList pl;\n};\n\ndown ()\n{\nvalue -= 1;\nif (value < 0) {\n// add this process to pl\nSleep ();\n}\n}\nup () {\nProcess P;\nvalue += 1;\nif (value <= 0) {\n// remove a process P\n// from pl\nWakeup (P);\n}\n}\n\nHow to protect these shared variables??\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n20\n\n\fSpinlocks in Semaphores\ndown ()\n{\nvalue -= 1;\nif (value < 0) {\n// add this process to pl\nSleep ();\n}\nstruct Semaphore {\nint value;\nProcessList pl;\n\n};\n\n}\nup () {\nProcess P;\nvalue += 1;\nif (value <= 0) {\n// remove a process P\n// from pl\nWakeup (P);\n}\n}\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n21\n\n\fSpinlocks are sometimes better than Semaphores\n\u2022 Very (very) short waiting time to enter the critical\nsection < the 2 context switches needed for blocking\n\u2022 Multi-core\n\u2022 so that the spinlock can be unlocked while the process is busy\nwaiting\n\n\u2022 Few contending processes for the critical section\n\n\u2022 Short critical section code\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n22\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}