{"id": 233, "segment": "unlabeled", "course": "cs1550", "lec": "lec09", "text": "Introduction to Operating Systems\nCS/COE 1550\nSpring 2022\n\nSherif Khattab\nksm73@pitt.edu\n(Some slides are from Silberschatz, Galvin and Gagne \u00a92013)\n\n\fAnnouncements\n\u2022 Upcoming deadlines\n\u2022 Homework 4 is due next Monday 2/14\n\u2022 Project 1 due on 2/18\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n2\n\n\fPrevious lecture \u2026\n\u2022 Readers-Writers problem\n\u2022 Semaphore solution\n\u2022 Condition Variable solution\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n3\n\n\fMuddiest Points (Semaphores solution)\n\u2022 reader writer queue\n\u2022 Why the read section of the Reader code includes\nmutex.down(). Why is it not included in the ReaderDone\nsection?\n\u2022 Why mutex need to up and down two times?\n\u2022 I confused about finally which of writing or reading has\npriority?\n\u2022 Starting off the readers writers problem how do you know\nthe amount of m, w, and nr ?\n\u2022 could you reiterate the reasoning for why a mutex doesn't\nwork for the writing semaphore? I think I understood it but I\njust want to be sure\n\u2022 does writing start at 0 or 1?\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n4\n\n\fMuddiest Points (Condition Variable Solution)\n\u2022 Which solution is more optimal for the readers and\nwriters problem... CV or semaphores?\n\n\u2022 Ideas for more efficient implementation of condition\nvariable/mutex code for reader/writer problem\n\u2022 In the \"real world\" what is more commonly used, CV or\nsemaphore ?\n\n\u2022 can you post the cv example?\n\u2022 Why was the code at the end different from the code we\nwent over during lecture?\n\u2022 Understanding when a reader or writer is asked to wait!\n\n\u2022 Does the last example of the code in class prevent\nstarvation of writers?\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n5\n\n\fMuddiest Points (misc.)\n\u2022 Can you expand on project 1's writeup?\n\n\u2022 I was confused on the producer consumer buffer and\nhow the producers go to sleep when waiting to enter.\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n6\n\n\fProblem of the Day\n\u2022\n\n\u2022\n\nDining Philosophers\n\nN philosophers around\na table\n\u2022\n\nAll are hungry\n\n\u2022\n\nAll like to think\n\nN chopsticks available\n\u2022\n\n1 between each pair of\nphilosophers\n\n\u2022\n\nPhilosophers need two\nchopsticks to eat\n\n\u2022\n\nPhilosophers alternate\nbetween eating and\nthinking\n\n\u2022\n\nGoal: coordinate use of\nchopsticks\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n7\n\n\fDining Philosophers: solution 1\n\u2022\n\nUse a semaphore for each chopstick\n\n\u2022\n\nA hungry philosopher\n\n\u2022\n\nGets the chopstick to his left\n\nShared variables\n\n\u2022\n\nGets the chopstick to his right\n\n\u2022\n\nEats\n\nconst int n;\n// initialize to 1\nSemaphore chopstick[n];\n\n\u2022\n\nPuts down the chopsticks\n\n\u2022\n\nPotential problems?\n\u2022\n\nDeadlock\n\n\u2022\n\nFairness\n\nCode for philosopher i\nwhile(1) {\nchopstick[i].down();\nchopstick[(i+1)%n].down();\n// eat\nchopstick[i].up();\nchopstick[(i+1)%n].up();\n// think\n}\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n8\n\n\fTracing: Sequence 1\n\u2022 P0 picks left\n\n\u2022 P0 picks right\n\u2022 P3 picks left\n\u2022 P3 picks right\n\u2022 P3 eats\n\u2022 P0 eats\n\u2022 P3 puts down\n\u2022 P0 puts down\n\nShared variables\nconst int n;\n// initialize to 1\nSemaphore chopstick[n];\n\nCode for philosopher i\nwhile(1) {\nchopstick[i].down();\nchopstick[(i+1)%n].down();\n// eat\nchopstick[i].up();\nchopstick[(i+1)%n].up();\n// think\n}\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n9\n\n\fTracing: Sequence 2\n\u2022 for(i=0; i<6; i++)\n\u2022 Pi picks left\n\n\u2022 P3 eats\n\u2022 P0 eats\n\u2022 P3 puts down\n\n\u2022 P0 puts down\n\nShared variables\nconst int n;\n// initialize to 1\nSemaphore chopstick[n];\n\nCode for philosopher i\nwhile(1) {\nchopstick[i].down();\nchopstick[(i+1)%n].down();\n// eat\nchopstick[i].up();\nchopstick[(i+1)%n].up();\n// think\n}\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n10\n\n\fWhat is a deadlock?\n\u2022 Formal definition:\n\u201cA set of processes is deadlocked if each process in\nthe set is waiting for an event that only another\nprocess in the set can cause.\u201d\n\u2022 Usually, the event is release of a currently held\nresource\n\n\u2022 In deadlock, none of the processes can\n\u2022 Run\n\u2022 Release resources\n\u2022 Be awakened\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n11\n\n\fHow to solve the Deadlock problem?\n\u2022 Ignore the problem\n\n\u2022 Detect and react\n\u2022 Prevent (intervene at design-time)\n\u2022 Avoid (intervene at run-time)\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n12\n\n\fThe Ostrich Algorithm\n\u2022 Pretend there\u2019s no problem\n\n\u2022 Reasonable if\n\u2022 Deadlocks occur very rarely\n\u2022 Cost of prevention is high\n\n\u2022 UNIX and Windows take this approach\n\u2022 Resources (memory, CPU, disk space) are plentiful\n\u2022 Deadlocks over such resources rarely occur\n\u2022 Deadlocks typically handled by rebooting\n\n\u2022 Trade off between convenience and correctness\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n13\n\n\fDeadlock Detection\n\nHow can the OS detect a deadlock?\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n14\n\n\f\u2022\n\n\u2022\n\u2022\n\n\u2022\n\nResource allocation graphs\nResource allocation modeled by directed\ngraphs\n\nA\n\nExample 1:\n\u2022\n\nR\n\nResource R assigned to process A\n\nB\n\nExample 2:\n\u2022\n\nProcess B is requesting / waiting for resource S\n\nS\n\nExample 3:\n\u2022\n\nProcess C holds T, waiting for U\n\n\u2022\n\nProcess D holds U, waiting for T\n\n\u2022\n\nC and D are in deadlock!\n\nT\n\nC\n\nD\nU\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n15\n\n\fDeadlock Prevention\n\nHow an application/system designer prevent\ndeadlocks?\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n16\n\n\fDining Philosophers: solution 2\n\u2022\n\nUse a semaphore for each\nchopstick\n\n\u2022\n\nA hungry philosopher\n\nCode for philosopher i\n\n\u2022\n\nGets lower, then higher numbered\nchopstick\n\n\u2022\n\nEats\n\n\u2022\n\nPuts down the chopsticks\n\nint i1,i2;\nwhile(1) {\nif (i != (n-1)) {\ni1 = i;\ni2 = i+1;\n} else {\ni1 = 0;\ni2 = n-1;\n}\nchopstick[i1].down();\nchopstick[i2].down();\n// eat\nchopstick[i1].up();\nchopstick[i2].up();\n// think\n}\n\n\u2022\n\nPotential problems?\n\u2022\n\nDeadlock\n\n\u2022\n\nFairness\n\nShared variables\nconst int n;\n// initialize to 1\nSemaphore chopstick[n];\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n17\n\n\fDeadlock Avoidance\n\nHow can the OS intervene at run-time to avoid\ndeadlocks?\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n18\n\n\fDeadlock detection algorithm\n\n1\n\n3 2\n\n1\n\n0\n\n2\n\n2 2\n\n0\n\n0\n\n3\n\n3 5\n\n3\n\n1\n\ncurrent=avail;\nfor (j = 0; j < N; j++) {\nfor (k=0; k<N; k++) {\nif (finished[k])\ncontinue;\nif (want[k] <= current) {\nfinished[k] = 1;\ncurrent += hold[k];\nbreak;\n}\n}\nif (k==N) { //reached end of loop\nprintf \u201cDeadlock!\\n\u201d;\n// finished[k]==0 means process is in\n// the deadlock\nbreak;\n}\n}\n\n4\n\n0 4\n\n1\n\n1\n\nNote: want[j], hold[j], current, avail are arrays!\n\nA B C D\nAvail\n\n2 3 0 1\n\nHold\n\nProcess A B C D\n1\n\n0 3\n\n0\n\n0\n\n2\n\n1 0\n\n1\n\n1\n\n3\n\n0 2\n\n1\n\n0\n\n4\n\n2 2\n\n3\n\n0\n\nWant\n\nProcess A B C D\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}