{"id": 235, "segment": "unlabeled", "course": "cs1550", "lec": "lec10", "text": "Introduction to Operating Systems\nCS/COE 1550\nSpring 2022\n\nSherif Khattab\nksm73@pitt.edu\n(Some slides are from Silberschatz, Galvin and Gagne \u00a92013)\n\n\fAnnouncements\n\u2022 Upcoming deadlines:\n\u2022 Project 1: due on 2/18\n\u2022 Homework 5: due 2/21\n\u2022 Lab 2: due on 2/28\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n\fPrevious lecture \u2026\n\u2022 Dining philosophers\n\n\u2022 Deadlock prevention\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n\fMuddiest Points\n\u2022 Checked on Tophat\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n\fQuestions of the Day\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n\fBanker\u2019s Algorithm\n\nWe can use the same algorithm for both detecting and\navoiding deadlocks\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n\fDeadlock detection algorithm\n\nA B C D\nAvail\n\n2 3 0 1\n\nHold\n\nProcess A B C D\n1\n\n0 3\n\n0\n\n0\n\n2\n\n1 0\n\n1\n\n1\n\n3\n\n0 2\n\n1\n\n0\n\n4\n\n2 2\n\n3\n\n0\n\nWant\n\nProcess A B C D\n1\n\n3 2\n\n1\n\n0\n\n2\n\n2 2\n\n0\n\n0\n\n3\n\n3 5\n\n3\n\n1\n\n4\n\n0 4\n\n1\n\n1\n\ncurrent=avail;\nfor (j = 0; j < N; j++) {\nfor (k=0; k<N; k++) {\nif (finished[k])\ncontinue;\nif (want[k] <= current) {\nfinished[k] = 1;\ncurrent += hold[k];\nbreak;\n}\n}\nif (k==N) {\nprintf \u201cDeadlock!\\n\u201d;\n// finished[k]==0 means process is in\n// the deadlock\nbreak;\n}\n}\n\nNote: want[j], hold[j], current, avail are arrays!\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n\fDeadlock detection algorithm\n\nA B C D\ncurrent 2 3 0 1\n\nHold\n\nProcess A B C D\n1\n\n0 3\n\n0\n\n0\n\n2\n\n1 0\n\n1\n\n1\n\n3\n\n0 2\n\n1\n\n0\n\n4\n\n2 2\n\n3\n\n0\n\nWant\n\nProcess A B C D\n1\n\n3 2\n\n1\n\n0\n\n2\n\n2 2\n\n0\n\n0\n\n3\n\n3 5\n\n3\n\n1\n\n4\n\n0 4\n\n1\n\n1\n\ncurrent=avail;\nfor (j = 0; j < N; j++) {\nfor (k=0; k<N; k++) {\nif (finished[k])\ncontinue;\nif (want[k] <= current) {\nfinished[k] = 1;\ncurrent += hold[k];\nbreak;\n}\n}\nif (k==N) {\nprintf \u201cDeadlock!\\n\u201d;\n// finished[k]==0 means process is in\n// the deadlock\nbreak;\n}\n}\n\nNote: want[j], hold[j], current, avail are arrays!\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n\fDeadlock detection algorithm\n\nA B C D\ncurrent\n\n2 3 0 1\n\nHold\n\nProcess A B C D\n1\n\n0 3\n\n0\n\n0\n\n2\n\n1 0\n\n1\n\n1\n\n3\n\n0 2\n\n1\n\n0\n\n4\n\n2 2\n\n3\n\n0\n\nWant\n\nProcess A B C D\n1\n\n3 2\n\n1\n\n0\n\n2\n\n2 2\n\n0\n\n0\n\n3\n\n3 5\n\n3\n\n1\n\n4\n\n0 4\n\n1\n\n1\n\ncurrent=avail;\nfor (j = 0; j < N; j++) {\nfor (k=0; k<N; k++) {\nif (finished[k])\ncontinue;\nif (want[k] <= current) {\nfinished[k] = 1;\ncurrent += hold[k];\nbreak;\n}\n}\nif (k==N) {\nprintf \u201cDeadlock!\\n\u201d;\n// finished[k]==0 means process is in\n// the deadlock\nbreak;\n}\n}\n\nNote: want[j], hold[j], current, avail are arrays!\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n\fDeadlock detection algorithm\n\nA B C D\ncurrent\n\n3 3 1 2\n\nHold\n\nProcess A B C D\n1\n\n0 3\n\n0\n\n0\n\n2\n\n1 0\n\n1\n\n1\n\n3\n\n0 2\n\n1\n\n0\n\n4\n\n2 2\n\n3\n\n0\n\nWant\n\nProcess A B C D\n1\n\n3 2\n\n1\n\n0\n\n2\n\n2 2\n\n0\n\n0\n\n3\n\n3 5\n\n3\n\n1\n\n4\n\n0 4\n\n1\n\n1\n\ncurrent=avail;\nfor (j = 0; j < N; j++) {\nfor (k=0; k<N; k++) {\nif (finished[k])\ncontinue;\nif (want[k] <= current) {\nfinished[k] = 1;\ncurrent += hold[k];\nbreak;\n}\n}\nif (k==N) {\nprintf \u201cDeadlock!\\n\u201d;\n// finished[k]==0 means process is in\n// the deadlock\nbreak;\n}\n}\n\nNote: want[j], hold[j], current, avail are arrays!\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n\fDeadlock detection algorithm\n\nA B C D\ncurrent\n\n3 3 1 2\n\nHold\n\nProcess A B C D\n1\n\n0 3\n\n0\n\n0\n\n2\n\n1 0\n\n1\n\n1\n\n3\n\n0 2\n\n1\n\n0\n\n4\n\n2 2\n\n3\n\n0\n\nWant\n\nProcess A B C D\n1\n\n3 2\n\n1\n\n0\n\n2\n\n2 2\n\n0\n\n0\n\n3\n\n3 5\n\n3\n\n1\n\n4\n\n0 4\n\n1\n\n1\n\ncurrent=avail;\nfor (j = 0; j < N; j++) {\nfor (k=0; k<N; k++) {\nif (finished[k])\ncontinue;\nif (want[k] <= current) {\nfinished[k] = 1;\ncurrent += hold[k];\nbreak;\n}\n}\nif (k==N) {\nprintf \u201cDeadlock!\\n\u201d;\n// finished[k]==0 means process is in\n// the deadlock\nbreak;\n}\n}\n\nNote: want[j], hold[j], current, avail are arrays!\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n\fDeadlock detection algorithm\n\nA B C D\ncurrent\n\n3 3 1 2\n\nHold\n\nProcess A B C D\n1\n\n0 3\n\n0\n\n0\n\n2\n\n1 0\n\n1\n\n1\n\n3\n\n0 2\n\n1\n\n0\n\n4\n\n2 2\n\n3\n\n0\n\nWant\n\nProcess A B C D\n1\n\n3 2\n\n1\n\n0\n\n2\n\n2 2\n\n0\n\n0\n\n3\n\n3 5\n\n3\n\n1\n\n4\n\n0 4\n\n1\n\n1\n\ncurrent=avail;\nfor (j = 0; j < N; j++) {\nfor (k=0; k<N; k++) {\nif (finished[k])\ncontinue;\nif (want[k] <= current) {\nfinished[k] = 1;\ncurrent += hold[k];\nbreak;\n}\n}\nif (k==N) {\nprintf \u201cDeadlock!\\n\u201d;\n// finished[k]==0 means process is in\n// the deadlock\nbreak;\n}\n}\n\nNote: want[j], hold[j], current, avail are arrays!\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n\fDeadlock detection algorithm\n\nA B C D\ncurrent\n\n3 3 1 2\n\nHold\n\nProcess A B C D\n1\n\n0 3\n\n0\n\n0\n\n2\n\n1 0\n\n1\n\n1\n\n3\n\n0 2\n\n1\n\n0\n\n4\n\n2 2\n\n3\n\n0\n\nWant\n\nProcess A B C D\n1\n\n3 2\n\n1\n\n0\n\n2\n\n2 2\n\n0\n\n0\n\n3\n\n3 5\n\n3\n\n1\n\n4\n\n0 4\n\n1\n\n1\n\ncurrent=avail;\nfor (j = 0; j < N; j++) {\nfor (k=0; k<N; k++) {\nif (finished[k])\ncontinue;\nif (want[k] <= current) {\nfinished[k] = 1;\ncurrent += hold[k];\nbreak;\n}\n}\nif (k==N) {\nprintf \u201cDeadlock!\\n\u201d;\n// finished[k]==0 means process is in\n// the deadlock\nbreak;\n}\n}\n\nNote: want[j], hold[j], current, avail are arrays!\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n\fDeadlock detection algorithm\n\nA B C D\ncurrent\n\n3 6 1 2\n\nHold\n\nProcess A B C D\n1\n\n0 3\n\n0\n\n0\n\n2\n\n1 0\n\n1\n\n1\n\n3\n\n0 2\n\n1\n\n0\n\n4\n\n2 2\n\n3\n\n0\n\nWant\n\nProcess A B C D\n1\n\n3 2\n\n1\n\n0\n\n2\n\n2 2\n\n0\n\n0\n\n3\n\n3 5\n\n3\n\n1\n\n4\n\n0 4\n\n1\n\n1\n\ncurrent=avail;\nfor (j = 0; j < N; j++) {\nfor (k=0; k<N; k++) {\nif (finished[k])\ncontinue;\nif (want[k] <= current) {\nfinished[k] = 1;\ncurrent += hold[k];\nbreak;\n}\n}\nif (k==N) {\nprintf \u201cDeadlock!\\n\u201d;\n// finished[k]==0 means process is in\n// the deadlock\nbreak;\n}\n}\n\nNote: want[j], hold[j], current, avail are arrays!\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n\fDeadlock detection algorithm\n\nA B C D\ncurrent\n\n3 6 1 2\n\nHold\n\nProcess A B C D\n1\n\n0 3\n\n0\n\n0\n\n2\n\n1 0\n\n1\n\n1\n\n3\n\n0 2\n\n1\n\n0\n\n4\n\n2 2\n\n3\n\n0\n\nWant\n\nProcess A B C D\n1\n\n3 2\n\n1\n\n0\n\n2\n\n2 2\n\n0\n\n0\n\n3\n\n3 5\n\n3\n\n1\n\n4\n\n0 4\n\n1\n\n1\n\ncurrent=avail;\nfor (j = 0; j < N; j++) {\nfor (k=0; k<N; k++) {\nif (finished[k])\ncontinue;\nif (want[k] <= current) {\nfinished[k] = 1;\ncurrent += hold[k];\nbreak;\n}\n}\nif (k==N) {\nprintf \u201cDeadlock!\\n\u201d;\n// finished[k]==0 means process is in\n// the deadlock\nbreak;\n}\n}\n\nNote: want[j], hold[j], current, avail are arrays!\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n\fDeadlock detection algorithm\n\nA B C D\ncurrent\n\n5 8 4 2\n\nHold\n\nProcess A B C D\n1\n\n0 3\n\n0\n\n0\n\n2\n\n1 0\n\n1\n\n1\n\n3\n\n0 2\n\n1\n\n0\n\n4\n\n2 2\n\n3\n\n0\n\nWant\n\nProcess A B C D\n1\n\n3 2\n\n1\n\n0\n\n2\n\n2 2\n\n0\n\n0\n\n3\n\n3 5\n\n3\n\n1\n\n4\n\n0 4\n\n1\n\n1\n\ncurrent=avail;\nfor (j = 0; j < N; j++) {\nfor (k=0; k<N; k++) {\nif (finished[k])\ncontinue;\nif (want[k] <= current) {\nfinished[k] = 1;\ncurrent += hold[k];\nbreak;\n}\n}\nif (k==N) {\nprintf \u201cDeadlock!\\n\u201d;\n// finished[k]==0 means process is in\n// the deadlock\nbreak;\n}\n}\n\nNote: want[j], hold[j], current, avail are arrays!\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n\fDeadlock detection algorithm\n\nA B C D\ncurrent\n\n5 8 4 2\n\nHold\n\nProcess A B C D\n1\n\n0 3\n\n0\n\n0\n\n2\n\n1 0\n\n1\n\n1\n\n3\n\n0 2\n\n1\n\n0\n\n4\n\n2 2\n\n3\n\n0\n\nWant\n\nProcess A B C D\n1\n\n3 2\n\n1\n\n0\n\n2\n\n2 2\n\n0\n\n0\n\n3\n\n3 5\n\n3\n\n1\n\n4\n\n0 4\n\n1\n\n1\n\ncurrent=avail;\nfor (j = 0; j < N; j++) {\nfor (k=0; k<N; k++) {\nif (finished[k])\ncontinue;\nif (want[k] <= current) {\nfinished[k] = 1;\ncurrent += hold[k];\nbreak;\n}\n}\nif (k==N) {\nprintf \u201cDeadlock!\\n\u201d;\n// finished[k]==0 means process is in\n// the deadlock\nbreak;\n}\n}\n\nNote: want[j], hold[j], current, avail are arrays!\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n\fDeadlock detection algorithm\n\nA B C D\ncurrent\n\n5 10 5 2\n\nHold\n\nProcess A B C D\n1\n\n0 3\n\n0\n\n0\n\n2\n\n1 0\n\n1\n\n1\n\n3\n\n0 2\n\n1\n\n0\n\n4\n\n2 2\n\n3\n\n0\n\nWant\n\nProcess A B C D\n1\n\n3 2\n\n1\n\n0\n\n2\n\n2 2\n\n0\n\n0\n\n3\n\n3 5\n\n3\n\n1\n\n4\n\n0 4\n\n1\n\n1\n\ncurrent=avail;\nfor (j = 0; j < N; j++) {\nfor (k=0; k<N; k++) {\nif (finished[k])\ncontinue;\nif (want[k] <= current) {\nfinished[k] = 1;\ncurrent += hold[k];\nbreak;\n}\n}\nif (k==N) {\nprintf \u201cDeadlock!\\n\u201d;\n// finished[k]==0 means process is in\n// the deadlock\nbreak;\n}\n}\n\nNote: want[j], hold[j], current, avail are arrays!\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n\fDeadlock detection algorithm\n\nA B C D\ncurrent\n\n5 10 5 2\n\nHold\n\nProcess A B C D\n1\n\n0 3\n\n0\n\n0\n\n2\n\n1 0\n\n1\n\n1\n\n3\n\n0 2\n\n1\n\n0\n\n4\n\n2 2\n\n3\n\n0\n\nWant\n\nProcess A B C D\n1\n\n3 2\n\n1\n\n0\n\n2\n\n2 2\n\n0\n\n0\n\n3\n\n3 5\n\n3\n\n1\n\n4\n\n0 4\n\n1\n\n1\n\ncurrent=avail;\nfor (j = 0; j < N; j++) {\nfor (k=0; k<N; k++) {\nif (finished[k])\ncontinue;\nif (want[k] <= current) {\nfinished[k] = 1;\ncurrent += hold[k];\nbreak;\n}\n}\nif (k==N) {\nprintf \u201cDeadlock!\\n\u201d;\n// finished[k]==0 means process is in\n// the deadlock\nbreak;\n}\n}\n\nNote: want[j], hold[j], current, avail are arrays!\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n\fBanker\u2019s Algorithm Insights\n\u2022 It is possible that some event sequences lead a\ndeadlock\n\u2022 What we are looking for is at least one event\nsequence that can make all processes finish\n\u2022 If such sequence exists, the state is safe\n\n\u2022 The Banker\u2019s algorithm finds such sequence if it\nexists\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n\fUsing the Banker\u2019s Algorithm for Deadlock Avoidance\n\u2022 Call the algorithm on the following ``What-if\u201d state\ninstead of the current state\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n\fProof sketch for Deadlock Prevention\n\n\u2022 If resources are ordered and resource requests within\neach process follow the resource ordering, the\nresource allocation graph will have no downward\narrows.\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n\fProblem of the Day: Sleepy Barbers\n\u2022 We have two sets of processes\n\u2022\n\u2022\n\nWorker processes (e.g., barbers)\nCustomer processes\n\n\u2022 Customer processes may arrive at anytime\n\u2022 Worker processes check in when they are not serving any\ncustomers\n\u2022 Each worker process must wait until it gets matched with a\ncustomer process\n\u2022 Each customer process must wait until it gets matched with a\nworker process\n\u2022 The customer process cannot leave until the matched worker\nprocess finishes the work\n\u2022 The worker process cannot check in for the next customer until\nthe matched customer process leaves\n\u2022 Many applications in the real-world\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n\fRendezvous Pattern\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n\fSolution Using Semaphores: Take 1\n\u2022 One pair of semaphores per rendezvous\n\u2022 RV1a and RV1b\n\u2022 RV2a and RV2b\n\n\u2022 Notice the flipped order of the down and up calls in\nthe two processes\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n\fSolution Using Semaphores: Take 1\n\u2022 This solution doesn\u2019t work for multiple workers and\nmultiple customers\n\u2022 A customer can leave before its associated worker\nfinishes\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}