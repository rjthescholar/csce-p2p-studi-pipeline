{"id": 218, "segment": "unlabeled", "course": "cs1550", "lec": "lec11", "text": "Introduction to Operating Systems\nCS/COE 1550\nSpring 2022\n\nSherif Khattab\nksm73@pitt.edu\n(Some slides are from Silberschatz, Galvin and Gagne \u00a92013)\n\n\fAnnouncements\n\u2022 Upcoming deadlines:\n\u2022 Project 1: due on 2/18\n\u2022 Homework 5: due 2/21\n\u2022 Lab 2: due on 2/28\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n\fPrevious lecture \u2026\n\u2022 Deadlock detection and avoidance using the\nBanker\u2019s algorithm\n\u2022 Sleepy Barbers problem\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n\fMuddiest Points\n\u2022 Checked on Tophat\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n\fSleepy Barbers Solution: Take 2\nstruct mysems {\nSemaphore RV1a(0), RV1b(0), RV2a(0), RV2b(0);\n};\nSharedBuffer buff; //producers-consumers problem\nWorker Process\n\nCustomer Process\n\nstruct mysems sems = buff.consume();\n\nstruct mysems sems = new struct mysems\n\nup(sems.RV1a);\n\nbuff.produce(sems);\n\ndown(sems.RV1b);\n\ndown(sems.RV1a);\n\n//do work\n\nup(sems.RV1b);\n\ndown(sems.RV2a);\n\n//get work\n\nup(sems.RV2b);\n\nup(sems.RV2a);\n\n//check-in for next customer\n\ndown(sems.RV2b);\n//leave\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n\fQuestions of the Day\n\u2022 How to implement condition variables?\n\n\u2022 Reflect more on all the solutions/problems that we\nhave studied\n\n\fUser-level implementation of Condition Variables\nA Lock with two waiting queues\n\nstruct Lock {\nSemaphore mutex(1);\nSemaphore next(0);\nint nextCount = 0;\nRelease(){\n\n}\n\nif(nextCount > 0){\n\nAcquire(){\n\nnext.up();\n\nmutex.down();\n\nnextCount--;\n\n}\n\n} else mutex.up();\n}\n\n\fCondition Variable\nstruct ConditionVariable {\nSemaphore condSem(0);\nint semCount = 0;\nLock *lk;\n}\nWait(){\nif(lk->nextCount > 0)\n\nSignal(){\n\nlk->next.up();\n\nif(semCount > 0){\n\nlk->nextCount--;\n\ncondSem.up()\nlk->nextCount++\n\nelse {\n\nlk->next.down();\n\nlk->mutex.up();\n\nlk->nextCount\u2014\n\n}\nsemCount++;\ncondSem.down();\nsemCount--;\n}\n\n}\n}\n\n\fLock and Condition Variable Implementation\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n\fImplementing locks with semaphores\n\u2022\n\nUse mutex to ensure exclusion within the lock bounds\n\n\u2022\n\nUse next to give lock to processes with a higher priority (why?)\n\n\u2022\n\nnextCount indicates whether there are any higher priority waiters\n\nclass Lock {\nSemaphore mutex(1);\nSemaphore next(0);\nint nextCount = 0;\n};\nLock::Acquire()\n{\nmutex.down();\n}\nLock::Release()\n{\nif (nextCount > 0)\nnext.up();\nelse\nmutex.up();\n}\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n\fImplementing condition variables\n\u2022\n\nAre these Hoare or Mesa semantics?\n\n\u2022\n\nCan there be multiple condition variables for a single Lock?\n\nclass Condition {\nLock *lock;\nSemaphore condSem(0);\nint semCount = 0;\n};\nCondition::Wait ()\n{\nsemCount += 1;\nif (lock->nextCount > 0)\nlock->next.up();\nelse\nlock->mutex.up();\ncondSem.down ();\nsemCount -= 1;\n}\n\nCondition::Signal ()\n{\nif (semCount > 0) {\nlock->nextCount += 1;\ncondSem.up ();\nlock->next.down ();\nlock->nextCount -= 1;\n}\n}\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n\fProcess Synchronization inside Monitors\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n\fCondition Variable-based Solutions\n\u2022 Code Walkthrough at:\n\nhttps://cs1550-2214.github.io/cs1550-codehandouts/ProcessSynchronization/Slides/\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n13\n\n\fReflections on semaphore usage\n\u2022 Semaphores can be used as\n\u2022 Resource counters\n\u2022 Waiting spaces\n\u2022 For mutual exclusion\n\n\fReflections on Condition Variables\n\u2022 Define a class and put all shared variables inside the\nclass\n\u2022 Include a mutex and a condition variable in the class\n\u2022 For each public method of the class\n\u2022 Start by locking the mutex lock\n\n\u2022 If need to wait, use a while loop and wait on the condition\nvariable\n\u2022 Before broadcasting on the condition variable, make\nsure to change the waiting condition\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}