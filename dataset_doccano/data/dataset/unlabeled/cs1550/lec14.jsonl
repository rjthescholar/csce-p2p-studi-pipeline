{"id": 213, "segment": "unlabeled", "course": "cs1550", "lec": "lec14", "text": "Introduction to Operating Systems\nCS/COE 1550\nFall 2021\n\nSherif Khattab\nksm73@pitt.edu\n(Some slides are from Silberschatz, Galvin and Gagne \u00a92013)\n\n\fAnnouncements\n\u2022 Upcoming deadlines:\n\u2022 Homework 7: due on 3/14\n\u2022 Homework 8: due on 3/21\n\u2022 Project 2: due on 3/18\n\n\u2022 Midterm exam on Thursday 3/3\n\u2022 In-person, on paper, closed book\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n2\n\n\fPrevious lecture \u2026\n\u2022 CPU scheduling\n\u2022 Multi-level Feedback Queues\n\u2022 Service time estimation for SJF\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n3\n\n\fMuddiest Points (multi-level feedback queue)\n\u2022 in multilevel scheduling, do processes in the lower\npriority ready queues need to wait for every higher\npriority ready queue to be empty?\n\u2022 How many queues would there realistically be using\nMultilevel feedback scheduling?\n\u2022 I need some time to build an intuition for why the\nMultilevel Feedback Scheduling is good.\n\u2022 The most muddy was how the MFS has absolute priority.\n\u2022 In multilevel feedback scheduling, is the number of\npriority queues pre-set or is each queue generated\ndynamically?\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n4\n\n\fMuddiest Points (exponential averaging)\n\u2022 The graphs for CPU Burst Exponential estimation\n\n\u2022 Could you please explain why changing the value of\nalpha weights more recent / older observations?\n\u2022 determining or choosing the alpha value\n\u2022 what does exponential average reflect\n\n\u2022 Does S mean the all previous estimate? What is the\ndifference between the most recent and S[n]\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n5\n\n\fMuddiest Points (misc.)\n\u2022 CPU Burst vs Quantum vs Time Slice?\n\n\u2022 The whole lecture\n\u2022 active time in the scheduler\n\u2022 Everything is clear\n\u2022 Nothing felt good.\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n6\n\n\fIn an ideal world\u2026\n\u25fc\n\nThe ideal world has memory that is\nVery large\n\u25fc Very fast\n\u25fc Non-volatile (doesn\u2019t go away when power is turned\noff)\n\u25fc\n\n\u25fc\n\nThe real world has memory that is:\nVery large\n\u25fc Very fast\n\u25fc Affordable!\n\uf0dePick any two\u2026\n\u25fc\n\n\u25fc\n\nMemory management goal: make the real world\nlook as much like the ideal world as possible\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n7\n\n\fMemory hierarchy\n\u25fc\n\nWhat is the memory hierarchy?\nDifferent levels of memory\n\u25fc Some are small & fast\n\u25fc Others are large & slow\n\u25fc\n\n\u25fc\n\nWhat levels are usually included?\n\u25fc\n\nCache: small amount of fast, expensive memory\nL1 (level 1) cache: usually on the CPU chip\n\u25fc L2 & L3 cache: off-chip, made of SRAM\n\u25fc\n\nMain memory: medium-speed, medium price memory (DRAM)\n\u25fc Disk: many gigabytes of slow, cheap, non-volatile storage\n\u25fc\n\n\u25fc\n\nMemory manager handles the memory hierarchy\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n8\n\n\fProblem of the Day\n\nHow can we share computer\u2019s memory between\nmultiple processes?\nHow can we protect each process\u2019s memory\npartition from other processes?\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n9\n\n\fHow many programs is enough?\nSeveral memory partitions (fixed or variable size)\n\u25fc Lots of processes wanting to use the CPU\n\u25fc Tradeoff\n\u25fc\n\nMore processes utilize the CPU better\n\u25fc Fewer processes use less memory (cheaper!)\n\u25fc\n\n\u25fc\n\nHow many processes do we need to keep the\nCPU fully utilized?\nThis will help determine how much memory we need\n\u25fc Is this still relevant with memory costing $10/GB?\n\u25fc\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n10\n\n\fWhy do we need more processes?\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n11\n\n\fModeling multiprogramming\n\u25fc\n\nMore I/O wait means\nless processor\nutilization\nAt 20% I/O wait, 3\u20134\nprocesses fully utilize\nCPU\n\u25fc At 80% I/O wait, even 10\nprocesses aren\u2019t enough\n\n1\n0.9\n\n\u25fc\n\n0.7\n\nCPU Utilization\n\nThis means that the OS\nshould have more\nprocesses if they\u2019re I/O\nbound\n\u25fc More processes =>\nmemory management &\nprotection more\nimportant!\n\u25fc\n\n0.8\n\n0.6\n0.5\n0.4\n0.3\n0.2\n0.1\n0\n0\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\nDegree of Multiprogramming\n80% I/O Wait\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n50% I/O Wait\n\n20% I/O Wait\n\n12\n\n\fBasic memory management\n\u25fc\n\nComponents include\nOperating system (perhaps with device drivers)\n\u25fc Single process\n\u25fc\n\n\u25fc\n\nGoal: lay these out in memory\nMemory protection may not be an issue (only one program)\n\u25fc Flexibility may still be useful (allow OS changes, etc.)\n\u25fc\n\n\u25fc\n\nNo swapping or paging\n0xFFFF\n\n0xFFFF\nUser program\n(RAM)\n\n0\n\nOperating system\n(RAM)\n\nOperating system\n(ROM)\n\nUser program\n(RAM)\n\nDevice drivers\n(ROM)\nUser program\n(RAM)\nOperating system\n(RAM)\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n0\n13\n\n\fMemory Management for Embedded Systems\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n14\n\n\fFixed partitions: multiple programs\n\u25fc\n\nFixed memory partitions\nDivide memory into fixed spaces\n\u25fc Assign a process to a space when it\u2019s free\n\u25fc\n\n\u25fc\n\nMechanisms\nSeparate input queues for each partition\n\u25fc Single input queue: better ability to optimize CPU usage\n\u25fc\n\n900K\nPartition 4\nPartition 3\nPartition 2\n\nPartition 4\n700K\n600K\n500K\n\nPartition 1\nOS\n\n900K\n\nPartition 3\nPartition 2\n\n700K\n600K\n500K\n\nPartition 1\n\n100K\n0\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\nOS\n\n100K\n0\n15\n\n\fProblem of the Day\n\nHow can we share computer\u2019s memory between\nmultiple processes?\nHow can we protect each process\u2019s memory\npartition from other processes?\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n16\n\n\fBase and limit registers\n\u25fc\n\nSpecial CPU registers: base\n& limit\n\n0xFFFF\n\nAccess to the registers limited\nto kernel (privileged) mode\n\u25fc Registers contain\n\n0x2000\n\n\u25fc\n\nLimit\nProcess\npartition\n\nBase: start of the process\u2019s\nmemory partition\n\u25fc Limit: length of the process\u2019s\nmemory partition\n\u25fc\n\n\u25fc\n\nBase\n0x9000\n\nAddress generation\nPhysical address: location in\nactual memory\n\u25fc Logical address: location from\nthe process\u2019s point of view\n\u25fc Physical address = base +\nlogical address\n\u25fc Logical address larger than\nlimit => error\n\u25fc\n\nOS\n0\n\nLogical address: 0x1204\nPhysical address:\n0x1204+0x9000 = 0xa204\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n17\n\n\fVirtual and physical addresses\n\u25fc\n\nAddresses local to the process\n\u25fc Hardware translates virtual\naddress to physical address\n\u25fc\n\nCPU chip\nCPU\n\nProgram uses virtual\naddresses\n\nMMU\n\u25fc\n\nVirtual addresses\nfrom CPU to MMU\n\nTranslation done by the\nMemory Management Unit\nUsually on the same chip as the\nCPU\n\u25fc Only physical addresses leave the\nCPU/MMU chip\n\u25fc\n\nMemory\n\u25fc\n\nPhysical addresses\non bus, in memory\n\nPhysical memory indexed by\nphysical addresses\n\nDisk\ncontroller\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n18\n\n\fAddress Translation\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n19\n\n\fVirtual memory\nBasic idea: allow the OS to hand out more\nmemory than exists on the system\n\u25fc Keep recently used stuff in physical memory\n\u25fc Move less recently used stuff to disk\n\u25fc Keep all of this hidden from processes\n\u25fc\n\nProcesses still see an address space from 0 \u2013 max\naddress\n\u25fc Movement of information to and from disk handled by\nthe OS without process help\n\u25fc\n\n\u25fc\n\nVirtual memory (VM) especially helpful in\nmultiprogrammed system\n\u25fc\n\nCPU schedules process B while process A waits for its\nmemory to be retrieved from disk\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n20\n\n\fPaging and page tables\n\u25fc\n\nVirtual addresses mapped to\nphysical addresses\n\u25fc\n\u25fc\n\n\u25fc\n\n\u25fc\n\nTable translates virtual page\nnumber to physical page number\n\u25fc\n\n\u25fc\n\n\u25fc\n\nUnit of mapping is called a page\nAll addresses in the same virtual\npage are in the same physical\npage\nPage table entry (PTE) contains\ntranslation for a single page\n\nNot all virtual memory has a\nphysical page\nNot every physical page need be\nused\n\nExample:\n\u25fc\n\u25fc\n\n64 KB virtual memory\n32 KB physical memory\n\n60\u201364K\n56\u201360K\n52\u201356K\n48\u201352K\n44\u201348K\n40\u201344K\n36\u201340K\n32\u201336K\n28\u201332K\n24\u201328K\n20\u201324K\n16\u201320K\n12\u201316K\n8\u201312K\n4\u20138K\n0\u20134K\n\n-\n\n6\n5\n1\n\n-\n\n3\n\n0\n4\n7\n\nVirtual\naddress\nspace\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n28\u201332K\n24\u201328K\n20\u201324K\n16\u201320K\n12\u201316K\n8\u201312K\n4\u20138K\n0\u20134K\n\nPhysical\nmemory\n\n21\n\n\fWhat\u2019s in a page table entry?\n\u25fc\n\nEach entry in the page table contains\n\u25fc\n\nValid bit: set if this logical page number has a corresponding physical frame in\nmemory\n\u25fc\n\n\u25fc\n\u25fc\n\u25fc\n\n\u25fc\n\nIf not valid, remainder of PTE is irrelevant\n\nPage frame number: page in physical memory\nReferenced bit: set if data on the page has been accessed\nDirty (modified) bit :set if data on the page has been modified\nProtection information\n\nProtection\n\nDirty bit\n\nD\n\nR\n\nV\n\nReferenced bit\n\nPage frame number\n\nValid bit\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n22\n\n\fImplementing page tables in hardware\nPage table resides in main (physical) memory\n\u25fc CPU uses special registers for paging\n\u25fc\n\nPage table base register (PTBR) points to the page table\n\u25fc Page table length register (PTLR) contains length of page table:\nrestricts maximum legal logical address\n\u25fc\n\n\u25fc\n\nTranslating an address requires two memory accesses\nFirst access reads page table entry (PTE)\n\u25fc Second access reads the data / instruction from memory\n\u25fc\n\n\u25fc\n\nReduce number of memory accesses\nCan\u2019t avoid second access (we need the value from memory)\n\u25fc Eliminate first access by keeping a hardware cache (called a\ntranslation lookaside buffer or TLB) of recently used page table\nentries\n\u25fc\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n23\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}