{"id": 206, "segment": "unlabeled", "course": "cs1550", "lec": "lec16", "text": "Introduction to Operating Systems\nCS 1550\nSpring 2022\n\nSherif Khattab\nksm73@pitt.edu\n(Some slides are from Silberschatz, Galvin and Gagne \u00a92013)\n\n\fAnnouncements\n\u2022 Upcoming deadlines:\n\u2022 Project 2: due on 3/18\n\u2022 Homework 8: due on 3/21\n\u2022 Quiz 2: due on 3/25\n\u2022 Lab 3: due on 4/1\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n2\n\n\fPrevious Lecture \u2026\n\u2022 Memory allocation and protection (Take II)\n\u2022 Virtual memory\n\u2022 Fixed-size pages, on-demand, appear as if having more\nmemory that physically in the system\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n3\n\n\fProblem of the Day\n\u2022 Page fault forces a choice\n\u2022 No room for new page (steady state)\n\u2022 A page must be removed to make room for an incoming\npage.\n\u2022 Which page to select?\n\u2022 Victim page\n\n\u2022 Evicted/purged\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n4\n\n\fPage replacement algorithms\n\u25fc\n\nHow is a page removed from physical memory?\nIf the page is unmodified, simply overwrite it: a copy\nalready exists on disk\n\u25fc If the page has been modified, it must be written back\nto disk: prefer unmodified pages?\n\u25fc\n\n\u25fc\n\nBetter not to choose an often used page\n\u25fc\n\nIt\u2019ll probably need to be brought back in soon\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n5\n\n\fOptimal page replacement algorithm\n\u25fc\n\nWhat\u2019s the best we can possibly do?\nAssume perfect knowledge of the future\n\u25fc Not realizable in practice (usually)\n\u25fc Useful for comparison: if another algorithm is within\n5% of optimal, not much more can be done\u2026\n\u25fc\n\n\u25fc\n\nAlgorithm: replace the page that will be used\nfurthest in the future\nOnly works if we know the whole sequence!\n\u25fc Can be approximated by running the program twice\n\u25fc\n\nOnce to generate the reference trace\n\u25fc Once (or more) to apply the optimal algorithm\n\u25fc\n\n\u25fc\n\nNice, but not achievable in real systems!\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n6\n\n\fOPT Examples\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n7\n\n\fNot-recently-used (NRU) algorithm\n\u25fc\n\nEach page has reference bit and dirty bit\n\u25fc\n\n\u25fc\n\nBits are set when page is referenced and/or modified\n\nPages are classified into four classes\n0: not referenced, not dirty\n\u25fc 1: not referenced, dirty\n\u25fc 2: referenced, not dirty\n\u25fc 3: referenced, dirty\n\u25fc\n\n\u25fc\n\nClear reference bit for all pages periodically\n\nCan\u2019t clear dirty bit: needed to indicate which pages need to be\nflushed to disk\n\u25fc Class 1 contains dirty pages where reference bit has been\ncleared\n\u25fc\n\n\u25fc\n\nAlgorithm: remove a page from the lowest non-empty\nclass\n\u25fc\n\nSelect a page at random from that class\n\nEasy to understand and implement\n\u25fc Performance adequate (though not optimal)\n\u25fc\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n8\n\n\fNRU Operation\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n9\n\n\fFirst-In, First-Out (FIFO) algorithm\n\u25fc\n\nMaintain a linked list of all pages\n\u25fc\n\nMaintain the order in which they entered memory\n\nPage at front of list replaced\n\u25fc Advantage: (really) easy to implement\n\u25fc Disadvantage: page in memory the longest may\nbe often used\n\u25fc\n\nThis algorithm forces pages out regardless of usage\n\u25fc Usage may be helpful in determining which pages to\nkeep\n\u25fc\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n10\n\n\fPage Replacement Algorithms Components\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n11\n\n\f\u2022\n\n\u2022\n\nSecond chance page replacement\nModify FIFO to avoid throwing out heavily used pages\n\u2022\n\nIf reference bit is 0, throw the page out\n\n\u2022\n\nIf reference bit is 1\n\u2022\n\nReset the reference bit to 0\n\n\u2022\n\nMove page to the tail of the list\n\n\u2022\n\nContinue search for a free page\n\nStill easy to implement, and better than plain FIFO\nreferenced unreferenced\nA\nt=0\n\nB\nt=4\n\nC\nt=8\n\nD\nt=15\n\nE\nt=21\n\nF\nt=22\n\nG\nt=29\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n12\n\nH\nt=30\n\nA\nt=32\n\n\fClock algorithm\n\u2022\n\nSame functionality as second\nchance\n\n\u2022\n\nSimpler implementation\n\n\u2022\n\n\u2022\n\n\u201cClock\u201d hand points to next\npage to replace\n\n\u2022\n\nIf R=0, replace page\n\n\u2022\n\nIf R=1, set R=0 and advance\nthe clock hand\n\nContinue until page with R=0\nis found\n\u2022\n\nH\nt=30\n\nA\nt=32\nt=0\n\nB\nt=32\nt=4\n\nG\nt=29\nF\nt=22\n\nThis may involve going all the\nway around the clock\u2026\n\nC\nt=32\nt=8\n\nE\nt=21\n\nD\nJ\nt=15\nt=32\n\nreferenced unreferenced\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n13\n\n\fLeast Recently Used (LRU)\n\u2022 Assume pages used recently will be used again soon\n\u2022 Throw out page that has been unused for longest time\n\n\u2022 Must keep a linked list of pages\n\u2022 Most recently used at front, least at rear\n\u2022 Update this list every memory reference!\n\u2022 This can be somewhat slow: hardware has to update a linked list\non every reference!\n\n\u2022 Alternatively, keep counter in each page table entry\n\u2022 Global counter increments with each CPU cycle\n\u2022 Copy global counter to PTE counter on a reference to the\npage\n\u2022 For replacement, evict page with lowest counter value\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n14\n\n\fSimulating LRU in software\n\u2022 Few computers have the necessary hardware to\nimplement full LRU\n\u2022 Linked-list method impractical in hardware\n\u2022 Counter-based method could be done, but it\u2019s slow to find\nthe desired page\n\n\u2022 Approximate LRU with Not Frequently Used (NFU)\nalgorithm\n\u2022 At each clock interrupt, scan through page table\n\u2022 If R=1 for a page, add one to its counter value\n\u2022 On replacement, pick the page with the lowest counter\nvalue\n\n\u2022 Problem: no notion of age\u2014pages with high counter\nvalues will tend to keep them!\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n15\n\n\f\u2022\n\nAging replacement algorithm\nReduce counter values over time\n\u2022\n\nDivide by two every clock cycle (use right shift)\n\n\u2022\n\nMore weight given to more recent references!\n\n\u2022\n\nSelect page to be evicted by finding the lowest counter value\n\n\u2022\n\nAlgorithm is:\n\u2022\n\nEvery clock tick, shift all counters right by 1 bit\n\n\u2022\n\nOn reference, set leftmost bit of a counter (can be done by copying the reference\nbit to the counter at the clock tick)\nReferenced\nthis tick\nPage 0\nPage 1\nPage 2\nPage 3\nPage 4\nPage 5\n\nTick 0\n\nTick 1\n\nTick 2\n\nTick 3\n\nTick 4\n\n10000000\n\n11000000\n\n11100000\n\n01110000\n\n10111000\n\n00000000\n10000000\n00000000\n\n10000000\n01000000\n00000000\n\n01000000\n00100000\n00000000\n\n00100000\n10010000\n10000000\n\n00010000\n01001000\n01000000\n\n10000000\n10000000\n\n01000000\n11000000\n\n10100000\n01100000\n\n11010000\n10110000\n\n01101000\n11011000\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n16\n\n\fWorking set\n\u2022 Demand paging: bring a page into memory when it\u2019s\nrequested by the process\n\n\u2022 How many pages are needed?\n\u2022\n\nCould be all of them, but not likely\n\n\u2022\n\nInstead, processes reference a small set of pages at any given\ntime\u2014locality of reference\n\n\u2022\n\nSet of pages can be different for different processes or even\ndifferent times in the running of a single process\n\n\u2022 Set of pages used by a process in a given interval of time is\ncalled the working set\n\u2022\n\nIf entire working set is in memory, no page faults!\n\n\u2022\n\nIf insufficient space for working set, thrashing may occur\n\n\u2022\n\nGoal: keep most of working set in memory to minimize the number\nof page faults suffered by a process\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n17\n\n\fHow big is the working set?\n\nw(k,t)\n\nk\n\n\u2022\n\nWorking set is the set of pages used by the k most recent\nmemory references\n\n\u2022\n\nw(k,t) is the size of the working set at time t\n\n\u2022\n\nWorking set may change over time\n\u2022\n\nSize of working set can change over time as well\u2026\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n18\n\n\fKeeping track of the Working Set\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n19\n\n\fWorking set page replacement algorithm\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n20\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}