{"id": 205, "segment": "unlabeled", "course": "cs1550", "lec": "lec19", "text": "Introduction to Operating Systems\nCS 1550\nSpring 2022\n\nSherif Khattab\nksm73@pitt.edu\n(Some slides are from Silberschatz, Galvin and Gagne \u00a92013)\n\n\fAnnouncements\n\u2022 Upcoming deadlines:\n\u2022 Lab 3: due on 4/1\n\u2022 Homework 9: due on 4/4\n\u2022 Project 3: due on 4/11\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n2\n\n\fPrevious lecture \u2026\n\u2022 The problem of large page tables\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n3\n\n\fMuddiest Points (1/2)\n\u2022 How to determine number of bits (2^n) from day 4gb or\n4kb\n\n\u2022 Calculating the PTE frame number size.\n\u2022 calculating the number of frames\n\u2022 userspace page replacement\n\u2022 For the final top hat question, how did we get 24 in the\nanswer 24*(2^20)? I understand that we did log(2^20) to\nget 20, but where did the extra 4 come from?\n\u2022 I don't understand the last two examples about\ncalculating the PTE s and frames, what information\n(values) do we need to look at in terms of different\nquestions?\n\u2022 Could you list the formulas for page table entries?\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n4\n\n\fMuddiest Points (2/2)\n\u2022 In the OPT simulation, why do we only re order the\npages above the one we want? Wouldn't it be better\nto re order everything?\n\u2022 OPT trace was slightly confusing of what switches\nwhere\n\u2022 How to find the number of writes for LRU and OPT?\n\u2022 How to calculate the distance in the tables we made\n\u2022 Are local or global selection policies more common in\nmodern OS\u2019s?\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n5\n\n\fProblem of the Day\n\n\u2022 How to keep track of larger page tables that can store\nmore pages\n\u2022 How big can a page table be?\n\u2022 64-bit machine\n\u2022 4 KB page size\n\n\u2022 How many pages?\n\u2022 How many PTE?\n\u2022 How big is a PTE?\n\u2022 How big is the page table of one process?\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n6\n\n\fAddress Translation Structures\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n7\n\n\fMemory & paging structures\nPhysical\nmemory\n\nPage frame number\n\nPage 0\nPage 1\nPage 2\nPage 3\nPage 4\nLogical memory (P0)\n\n6\n3\n4\n9\n2\nPage table (P0)\n\nPage 0\nPage 1\n\n8\n0\n\nLogical memory (P1)\n\nPage table (P1)\n\n0\n\nPage 1 (P1)\n\n1\n2\n3\n\nFree\npages\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n4\n\nPage 4 (P0)\nPage 1 (P0)\nPage 2 (P0)\n\n5\n6\n\nPage 0 (P0)\n\n7\n8\n9\n\nPage 0 (P1)\nPage 3 (P0)\n\n8\n\n\fMapping logical => physical address\n\u25fc\n\nSplit address from CPU into two\npieces\nPage number (p)\n\u25fc Page offset (d)\n\u25fc\n\n\u25fc\n\nPage number\n\nExample:\n\u2022 4 KB (=4096 byte) pages\n\u2022 32 bit logical addresses\n\nIndex into page table\n2d = 4096\n\u25fc Page table contains base address of\npage in physical memory\n\u25fc\n\n\u25fc\n\nPage offset\n\u25fc\n\n\u25fc\n\nd = 12\n\nAdded to base address to get actual\nphysical memory address\n\n32-12 = 20 bits\n\n12 bits\n\np\n\nd\n\nPage size = 2d bytes\n\n32 bit logical address\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n9\n\n\fAddress translation architecture\npage number\n\nCPU\n\np\n\nPage frame number\n\nPage frame number\n\npage offset\n\nd\n0\n1\np-1\np\np+1\n\nf\n\nd\n\n..\n.\n\n..\n.\nf\n\n..\n.\n\n0\n1\n\nf-1\nf\nf+1\nf+2\n\nphysical memory\npage table\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n10\n\n\fMemory Sizes\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n11\n\n\fAddress Translation Relations\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n12\n\n\fPage number vs. Offset\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n13\n\n\fSolution 1: Two-level page tables\n\u25fc\n\nProblem: page tables can be too\nlarge\n\u25fc\n\n\u25fc\n\n\u25fc\n\n\u25fc\n\n220\n657\n\nSolution: use multi-level page\ntables\n\u25fc\n\n\u25fc\n\n232 bytes in 4KB pages need 1\nmillion PTEs\n\n\u201cPage size\u201d in first page table is\nlarge (megabytes)\nPTE marked invalid in first page\ntable needs no 2nd level page\ntable\n\n..\n.\n\n401\n\n..\n.\n\n1st level page table has pointers to\n1st level\n2nd level page tables\npage table\n2nd level page table has actual\nphysical page numbers in it\n2nd level\npage tables\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n125\n613\n\n..\n.\n\n961\n884\n960\n\n..\n.\n\n955\n\n..\n.\n..\n.\n..\n.\n..\n.\n..\n.\n..\n.\n..\n.\n..\n.\n..\n.\nmain\nmemory\n14\n\n\fTwo-level Page Table\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n15\n\n\fMore on two-level page tables\n\u25fc\n\nTradeoffs between 1st and 2nd level page table\nsizes\nTotal number of bits indexing 1st and 2nd level table is\nconstant for a given page size and logical address\nlength\n\u25fc Tradeoff between number of bits indexing 1st and\nnumber indexing 2nd level tables\n\u25fc\n\nMore bits in 1st level: fine granularity at 2nd level\n\u25fc Fewer bits in 1st level: maybe less wasted space?\n\u25fc\n\nAll addresses in table are physical addresses\n\u25fc Protection bits kept in 2nd level table\n\u25fc\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n16\n\n\fTwo-level paging: example\n\u25fc\n\nSystem characteristics\n\u25fc\n\u25fc\n\n\u25fc\n\nPage number divided into:\n\u25fc\n\u25fc\n\n\u25fc\n\n8 KB pages\n32-bit logical address divided into 13 bit page offset, 19 bit page number\n10 bit page number\n9 bit page offset\n\nLogical address looks like this:\n\u25fc\n\u25fc\n\np1 is an index into the 1st level page table\np2 is an index into the 2nd level page table pointed to by p1\n\npage number\np1 = 10 bits\n\np2 = 9 bits\n\npage offset\noffset = 13 bits\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n17\n\n\f2-level address translation example\npage number\np1 = 10 bits\n\nPage\ntable\nbase\n\npage offset\n\np2 = 9 bits\n\noffset = 13 bits\n\nframe\nnumber\n0\n1\n\nphysical address\n\n19\n\n0\n1\np1\n\n..\n.\n\n0\n1\n\n..\n.\n\np2\n\n1st level page table\n\n13\n\n..\n.\n..\n.\n\n..\n.\n..\n.\nmain memory\n\n2nd level page table\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n18\n\n\fAddress Translation: 2-level Page Table\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n19\n\n\fTLB\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n20\n\n\fTranslation Lookaside Buffer (TLB)\n\u25fc\n\nSearch the TLB for the desired logical\npage number\n\u25fc\n\u25fc\n\n\u25fc\n\n\u25fc\n\nSearch entries in parallel\nUse standard cache techniques\n\nIf desired logical page number is found,\nget frame number from TLB\nIf desired logical page number isn\u2019t found\n\u25fc\n\n\u25fc\n\nGet frame number from page table in\nmemory\nReplace an entry in the TLB with the\nlogical & physical page numbers from this\nreference\n\nLogical\npage #\n\nPhysical\nframe #\n\n8\nunused\n2\n3\n12\n29\n22\n7\n\n3\n1\n0\n12\n6\n11\n4\n\nExample TLB\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n21\n\n\fHandling TLB misses\nIf PTE isn\u2019t found in TLB, OS needs to do the lookup in the\npage table\n\u25fc Lookup can be done in hardware or software\n\u25fc Hardware TLB replacement\n\u25fc\n\nCPU hardware does page table lookup\n\u25fc Can be faster than software\n\u25fc Less flexible than software, and more complex hardware\n\u25fc\n\n\u25fc\n\nSoftware TLB replacement\nOS gets TLB exception\n\u25fc Exception handler does page table lookup & places the result into the\nTLB\n\u25fc Program continues after return from exception\n\u25fc Larger TLB (lower miss rate) can make this feasible\n\u25fc\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n22\n\n\fHow long do memory accesses take?\n\u25fc\n\nAssume the following times:\nTLB lookup time = a (often zero - overlapped in CPU)\n\u25fc Memory access time = m\n\u25fc\n\n\u25fc\n\nHit ratio (h) is percentage of time that a logical page number\nis found in the TLB\nLarger TLB usually means higher h\n\u25fc TLB structure can affect h as well\n\u25fc\n\n\u25fc\n\nEffective access time (an average) is calculated as:\nEAT = (m + a)h + (m + m + a)(1-h)\n\u25fc EAT =a + (2-h)m\n\u25fc\n\n\u25fc\n\nInterpretation\nReference always requires TLB lookup, 1 memory access\n\u25fc TLB misses also require an additional memory reference\n\u25fc\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n23\n\n\fEffective Access Time\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n24\n\n\fEAT Calculation\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n25\n\n\fSolution 2: Inverted page table\nReduce page table size further: keep one entry for\neach frame in memory\n\u25fc PTE contains\n\u25fc\n\nVirtual address pointing to this frame\n\u25fc Information about the process that owns this page\n\u25fc\n\n\u25fc\n\nSearch page table by\nHashing the virtual page number and process ID\n\u25fc Starting at the entry corresponding to the hash result\n\u25fc Search until either the entry is found or a limit is\nreached\n\u25fc\n\nPage frame number is index of PTE\n\u25fc Improve performance by using more advanced\nhashing algorithms\n\u25fc\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n26\n\n\fInverted page table architecture\n\nprocess ID\n\npid\n\npage number\n\npage offset\n\np = 19 bits\n\noffset = 13 bits\n\np\nsearch\n0\n1\nk\n\nphysical address\n19\n13\npid0\npid1\npidk\n\np0\n\n..\n.\n..\n.\n\n..\n.\n\n..\n.\n\np1\npk\n\nPage frame\nnumber\n0\n1\n\nk\n\nmain memory\n\ninverted page table\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n27\n\n\fInverted Page Table Example\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n28\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}