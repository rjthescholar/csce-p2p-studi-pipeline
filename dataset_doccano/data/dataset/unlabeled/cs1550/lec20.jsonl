{"id": 220, "segment": "unlabeled", "course": "cs1550", "lec": "lec20", "text": "Introduction to Operating Systems\nCS 1550\nSpring 2022\n\nSherif Khattab\nksm73@pitt.edu\n(Some slides are from Silberschatz, Galvin and Gagne \u00a92013)\n\n\fAnnouncements\n\u2022 Upcoming deadlines:\n\u2022 Lab 3: due on 4/1\n\u2022 Homework 9: due on 4/4\n\u2022 Project 3: due on 4/11\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n2\n\n\fPrevious lecture \u2026\n\u2022 Large Page Table problem\n\u2022 multi-level page tables\n\u2022 inverted page tables\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n3\n\n\fMuddiest Points\n\u2022 EAT\n\u2022 Inverted page tables\n\u2022 Would you please solve a problem about Inertial\nPage Table? Thank you so much\n\u2022 why again will there be multiple memory accesses\nusing a TLB?\n\u2022 Two level page tables and how they are better than\nsingle page tables (take up less space)\n\u2022 Where are the second and third level page tables\nstored? Are they paged in and out of memory like a\nnormal page?\n\u2022 when will we get our midterm grades\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n4\n\n\fHow big should a page be?\n\u25fc\n\nSmaller pages have advantages\nLess internal fragmentation\n\u25fc Better fit for various data structures, code sections\n\u25fc Less unused physical memory (some pages have 20\nuseful bytes and the rest isn\u2019t needed currently)\n\u25fc\n\n\u25fc\n\nLarger pages are better because\n\u25fc\n\nLess overhead to keep track of them\nSmaller page tables\n\u25fc TLB can point to more memory (same number of pages, but\nmore memory per page)\n\u25fc Faster paging algorithms (fewer table entries to look\nthrough)\n\u25fc\n\n\u25fc\n\nMore efficient to transfer larger pages to and from disk\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n5\n\n\fSharing Pages\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n6\n\n\fSharing pages\n\u25fc\n\nProcesses can share pages\nEntries in page tables point to the same physical page\nframe\n\u25fc Easier to do with code: no problems with modification\n\u25fc\n\n\u25fc\n\nVirtual addresses in different processes can be\u2026\nThe same: easier to exchange pointers, keep data\nstructures consistent\n\u25fc Different: may be easier to actually implement\n\u25fc\n\nNot a problem if there are only a few shared regions\n\u25fc Can be very difficult if many processes share regions with\neach other\n\u25fc\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n7\n\n\fPage Sharing\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n8\n\n\fImplementation issues\nFour times when OS involved with paging\n\u25fc Process creation\nDetermine program size\n\u25fc Create page table\n\u25fc\n\n\u25fc\n\nDuring process execution\nReset the MMU for new process\n\u25fc Flush the TLB (or reload it from saved state)\n\u25fc\n\n\u25fc\n\nPage fault time\nDetermine virtual address causing fault\n\u25fc Swap target page out, needed page in\n\u25fc\n\n\u25fc\n\nProcess termination time\nRelease page table\n\u25fc Return pages to the free pool\n\u25fc\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n9\n\n\fHow is a page fault handled?\nHardware causes a page\nfault\n\u25fc General registers saved (as\non every exception)\n\u25fc OS determines which virtual\npage needed\n\u25fc\n\nActual fault address in a\nspecial register\n\u25fc Address of faulting instruction\nin register\n\n\u25fc\n\n\u25fc\n\n\u25fc\n\n\u25fc\n\n\u25fc\n\nPage fault was in fetching\ninstruction, or\n\u25fc Page fault was in fetching\noperands for instruction\n\u25fc OS must figure out which\u2026\n\u25fc\n\nOS checks validity of address\n\n\u25fc\n\n\u25fc\n\u25fc\n\n\u25fc\n\u25fc\n\n\u25fc\n\nProcess killed if address was\nillegal\n\nOS finds a place to put new\npage frame\nIf frame selected for\nreplacement is dirty, write it\nout to disk\nOS requests the new page\nfrom disk\nPage tables updated\nFaulting instruction backed up\nso it can be restarted\nFaulting process scheduled\nRegisters restored\nProgram continues\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n10\n\n\fPage locking\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n11\n\n\fLocking pages in memory\nVirtual memory and I/O occasionally interact\n\u25fc P1 issues call for read from device into\nbuffer\n\u25fc\n\nWhile it\u2019s waiting for I/O, P2 runs\n\u25fc P2 has a page fault\n\u25fc P1\u2019s I/O buffer might be chosen to be paged out\n\u25fc\n\n\u25fc\n\n\u25fc\n\nThis can create a problem because an I/O device is\ngoing to write to the buffer on P1\u2019s behalf\n\nSolution: allow some pages to be locked into\nmemory\nLocked pages are immune from being replaced\n\u25fc Pages only stay locked for (relatively) short\nperiods\n\u25fc\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n12\n\n\fMap of MMU, TLB, Page Table, etc.\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n13\n\n\fWhen are dirty pages written to disk?\n\u25fc\n\nOn demand (when they\u2019re replaced)\nFewest writes to disk\n\u25fc Slower: replacement takes twice as long (must wait for\ndisk write and disk read)\n\u25fc\n\n\u25fc\n\nPeriodically (in the background)\n\u25fc\n\n\u25fc\n\nBackground process scans through page tables, writes\nout dirty pages that are pretty old\n\nBackground process also keeps a list of pages\nready for replacement\nPage faults handled faster: no need to find space on\ndemand\n\u25fc Cleaner may use the same structures discussed\nearlier (clock, etc.)\n\u25fc\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n14\n\n\fProblem of the Day\n\nHow to allocate disk blocks to files and directories?\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n15\n\n\fHow complex is the OS\u2019s job?\nLet\u2019s look at one of the resources managed by the OS:\nI/O devices\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n16\n\n\fCarving up the disk\nEntire disk\nPartition table\nMaster\nboot record\n\nPartition 1\n\nPartition 2\n\nPartition 3\n\nBoot\nblock\n\nFree space\nmanagement\n\nIndex\nnodes\n\nFiles & directories\n\nSuper\nblock\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\nPartition 4\n\n17\n\n\fContiguous allocation for file blocks\n\u2022 Contiguous allocation requires all blocks of a file to\nbe consecutive on disk\n\u2022 Problem: deleting files leaves \u201choles\u201d\n\u2022 Similar to memory allocation issues\n\u2022 Compacting the disk can be a very slow procedure\u2026\nA\n\nB\n\nC\n\nD\n\nE\n\nF\n\nA\n\nFree\n\nC\n\nFree\n\nE\n\nF\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n18\n\n\fContiguous allocation\n\u2022 Data in each file is stored in\nconsecutive blocks on disk\n\u2022 Simple & efficient indexing\n\u2022\n\u2022\n\nStarting location (block #) on disk\n(start)\nLength of the file in blocks (length)\n\n0\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n\u2022 Random access well-supported\n\u2022 Difficult to grow files\n\u2022\n\nMust pre-allocate all needed space\n\n\u2022\n\nWasteful of storage if file isn\u2019t using\nall of the space\n\n\u2022 Logical to physical mapping is easy\nblocknum = (pos / 1024) + start;\noffset_in_block = pos % 1024;\n\nStart=5\nLength=2902\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n19\n\n\fLinked allocation\n\u2022 File is a linked list of disk\nblocks\n\n0\n\n\u2022\n\nBlocks may be scattered\naround the disk drive\n\n4\n\n\u2022\n\nBlock contains both pointer\nto next block and data\n\n4\n\n\u2022\n\nFiles may be as long as\nneeded\n\n\u2022 New blocks are allocated\nas needed\n\u2022\n\u2022\n\nLinked into list of blocks in\nfile\nRemoved from list (bitmap)\nof free blocks\n\n1\n\n3\n6\n\n5\n\nx\n\n8\n\n2\n\n6\n\n7\n\nx\n\n9\n\n10\n\n11\n\n0\n\nStart=9\nEnd=4\nLength=2902\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\nStart=3\nEnd=6\nLength=1500\n20\n\n\fData Structures for Linked Allocation\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n21\n\n\fFinding blocks with linked allocation\n\u2022 Directory structure is simple\n\u2022\n\u2022\n\nStarting address looked up from directory\nDirectory only keeps track of first block (not others)\n\n\u2022 No wasted blocks - all blocks can be used\n\u2022 Random access is difficult: must always start at first\nblock!\n\u2022 Logical to physical mapping is done by\nblock = start;\noffset_in_block = pos % 1020;\nfor (j = 0; j < pos / 1020; j++) {\nblock = block->next;\n}\n\u2022\n\u2022\n\nAssumes that next pointer is stored at end of block\nMay require a long time for seek to random location in file\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n22\n\n\fOffset Calculation\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n23\n\n\fFile Allocation Table (FAT)\n\u2022 Links on disk are slow\n\u2022 Keep linked list in memory\n\n\u2022 Advantage: faster\n\u2022 Disadvantages\n\u2022 Have to copy it to disk at some point\n\u2022 Have to keep in-memory and on-disk\ncopy consistent\n\nCS/COE 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n4\n-1\n-1\n-2\n-2\n-1\n3\n-1\n-1\n0\n-1\n-1\n-1\n-1\n-1\n-1\n\nB\n\nA\n\n24\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}