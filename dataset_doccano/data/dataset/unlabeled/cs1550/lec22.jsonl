{"id": 202, "segment": "unlabeled", "course": "cs1550", "lec": "lec22", "text": "Introduction to Operating Systems\nCS 1550\nSpring 2022\n\nSherif Khattab\nksm73@pitt.edu\n(Some slides are from Silberschatz, Galvin and Gagne \u00a92013)\n\n\fAnnouncements\n\u2022 Upcoming deadlines:\n\u2022 Homework 10: due on 4/11\n\u2022 Project 3: due on 4/11\n\u2022 Lab 4: due on 4/15\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n2\n\n\fPrevious Lecture \u2026\n\u2022 Indexed Allocation\n\n\u2022 Directory contents\n\u2022 Free block tracking\n\u2022 bitmap\n\u2022 linked list of free blocks\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n3\n\n\fMuddiest Points (1/3)\n\u2022 Bitmapping for free blocks\n\u2022 It seems that directories have a limit to the number of\nfiles / subdirectories they contain based on the size of a\ndisk block. Is / how is this limit overcome?\n\u2022 Everything\n\u2022 are the index nodes for the directories stored on the\nheap? is this different than the index nodes from the file\nallocation table?\n\u2022 Variable sized file name structures\u2019 pros and cons\n\u2022 what exactly is an i-node and where is it stored?\n\n\u2022 Might need some recap on inode. So inode contains\ninformation for a specific file and block index is a block\nstoring only the addresses of all the file block?\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n4\n\n\fMuddiest Points (2/3)\n\u2022 a little confused about Fast File System indexing\n\u2022 For FFS, all the files will be kept in one directoriy (or\nmany directories?) and then we adopt the direct pointers\nor one-level or multi-level pointers to point to their data\nbased on their size?\n\u2022 Typically one directory per index block? What about a\nsubdirectory in a parent directory? Would there be\nanother block index (for the subdirectory) stored in the\nparent directory?\n\u2022 Can you explain why smaller page size leads to more\npage fault?\n\n\u2022 Linked allocation versus contiguous and when is it\noptimal to use linked\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n5\n\n\fMuddiest Points (3/3)\n\u2022 how do we do midterm corrections\n\n\u2022 Top hat question about partition\n\u2022 Still a but confused on indexing for the Page Table\nAllocation\n\u2022 structure of a disk section\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n6\n\n\fProblem of the Day \u2013 Part 1\n\u2022 How does a file system handle errors?\n\u2022 Answer: Defense in Depth\n\u2022 multiple layers of error detection/correction\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n7\n\n\fSoftware Stack\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n8\n\n\fDevice drivers\n\u2022 Device drivers go between\ndevice controllers and rest of\nOS\n\nUser\nspace\n\n\u2022 Drivers standardize interface\nto widely varied devices\n\nKernel\nspace\n\n\u2022 Device drivers communicate\nwith controllers over bus\n\u2022 Controllers communicate with\ndevices themselves\n\nUser\nprogram\n\nRest of the OS\n\nKeyboard\ndriver\n\nDisk\ndriver\n\nKeyboard\ncontroller\n\nDisk\ncontroller\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n9\n\n\fLayers of I/O software\n\nUser-level I/O software & libraries\nDevice-independent OS software\nDevice drivers\nInterrupt handlers\n\nUser\nOperating\nsystem\n(kernel)\n\nHardware\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n10\n\n\fAnatomy of an I/O request\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n11\n\n\fDevice Driver goals\n\u2022 Device independence\n\u2022\n\u2022\n\nPrograms can access any I/O device\nNo need to specify device in advance\n\n\u2022 Uniform naming\n\u2022\n\u2022\n\nName of a file or device is a string or an integer\nDoesn\u2019t depend on the machine (underlying hardware)\n\n\u2022 Error handling\n\u2022\n\u2022\n\nDone as close to the hardware as possible\nIsolate from higher-level software\n\n\u2022 Synchronous vs. asynchronous transfers\n\u2022\n\nBlocked transfers vs. interrupt-driven\n\n\u2022 Buffering\n\u2022\n\nData coming off a device cannot be stored in final destination\n\n\u2022 Sharable vs. dedicated devices\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n12\n\n\fDisk drive structure\n\u2022 Data stored on surfaces\n\u2022\n\nUp to two surfaces per platter\n\n\u2022\n\nOne or more platters per disk\n\nhead\n\nsector\n\n\u2022 Data in concentric tracks\n\u2022\n\u2022\n\nTracks broken into sectors\n\nplatter\n\n\u2022 256B-1KB per sector\n\ntrack\n\nCylinder: corresponding tracks\non all surfaces\n\ncylinder\n\n\u2022 Data read and written by\nheads\n\u2022\n\u2022\n\nActuator moves heads\n\nsurfaces\n\nspindle\n\nHeads move in unison\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\nactuator\n13\n\n\fDisks, cylinders, cylinder groups\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n14\n\n\fDisk Sector\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n15\n\n\fWhat\u2019s in a disk request?\n\u2022 Time required to read or write a disk block\ndetermined by 3 factors\n\u2022 Seek time\n\n\u2022 Rotational delay\n\u2022 Average delay = 1/2 rotation time\n\u2022 Example: rotate in 10ms, average rotation delay = 5ms\n\n\u2022 Actual transfer time\n\u2022 Transfer time = time to rotate over sector\n\u2022 Example: rotate in 10ms, 200 sectors/track => 10/200 ms =\n0.05ms transfer time per sector\n\n\u2022 Seek time dominates, with rotation time close\n\n\u2022 Error checking is done by controllers\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n16\n\n\fDisk drive specifics\nIBM 360KB floppy\n\nWD 18GB HD\n\nCylinders\n\n40\n\n10601\n\nTracks per cylinder\n\n2\n\n12\n\nSectors per track\n\n9\n\n281 (average)\n\nSectors per disk\n\n720\n\n35742000\n\nBytes per sector\n\n512\n\n512\n\nCapacity\n\n360 KB\n\n18.3 GB\n\nSeek time (minimum)\n\n6 ms\n\n0.8 ms\n\nSeek time (average)\n\n77 ms\n\n6.9 ms\n\nRotation time\n\n200 ms\n\n8.33 ms\n\nSpinup time\n\n250 ms\n\n20 sec\n\nSector transfer time\n\n22 ms\n\n17 msec\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n17\n\n\fStructure of a disk sector\n\u2022 Preamble contains information about the sector\n\u2022 Sector number & location information\n\n\u2022 Data is usually 256, 512, or 1024 bytes\n\u2022 ECC (Error Correcting Code) is used to detect &\ncorrect minor errors in the data\nPreamble\n\nData\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\nECC\n\n18\n\n\fParity Examples\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n19\n\n\f1-d parity\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n20\n\n\f2-d parity\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n21\n\n\fWhen good disks go bad\u2026\nDisks have defects\nIn 3M+ sectors, this isn\u2019t surprising!\n\nECC helps with errors, but sometimes this isn\u2019t enough\n\nDisks keep spare sectors (normally unused) and remap bad\nsectors into these spares\nIf there\u2019s time, the whole track could be reordered\u2026\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n22\n\n\fRAIDs, RAIDs, and more RAIDs\nstrip\n\nstrip\n\nStripe\nRAID 0\n(Redundant Array of Inexpensive Disks\n\nRAID 1\n(Mirrored copies)\n\nRAID 4\n(Striped with parity)\n\nRAID 5\n(Parity rotates through disks)\n\nCS 1550 \u2013 Operating Systems \u2013 Sherif Khattab\n\n23\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}