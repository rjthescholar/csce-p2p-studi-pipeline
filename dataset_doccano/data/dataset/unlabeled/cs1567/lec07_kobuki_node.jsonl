{"id": 200, "segment": "unlabeled", "course": "cs1567", "lec": "lec07_kobuki_node", "text": "Kobuki Node\nThumrongsak Kosiyatrakul\n\nThumrongsak Kosiyatrakul\n\nKobuki Node\n\n\fKobuki Node\nThe kobuki node communicates with a Kobuki robot via USB\nProvide hardware abstractions\nMotors with synchronization\nBumper switches\nButtons\nLEDs\n\nTo control a robot, simply communicate with the kobuki node\nPublish commands to the kobuki node\nSubscribe for information about the robot\n\nTo start a kobuki node, use the following command:\nroslaunch kobuki_node minimal.launch\n\nTo ensure the stability of the robot\u2019s odometry, the robot should\nbe on the ground/table before executing the above command\n\nThumrongsak Kosiyatrakul\n\nKobuki Node\n\n\fKobuki\u2019s Subscriptions and Publications\nBy default the kobuki node subscribes to the following topic:\n/mobile_base/commands/reset_odometry\n/mobile_base/commands/sound\n/mobile_base/commands/led1\n/mobile_base/commands/led2\n/mobile_base/commands/velocity\n\nWe simply publish data to the above topics to control the robot\nThe kobuki node publishes to the following topic:\n/odom\n/mobile_base/events/bumper\n/mobile_base/events/button\n\nWe simply subscribe to the above topics to receive data from the\nrobot\nThere are more topics related to kobuki node but we will only\nfocus on topics listed above.\nThumrongsak Kosiyatrakul\n\nKobuki Node\n\n\fSounds\nA Kobuki robot has an ability to make sounds\nSimply publish a message of type Sound to the topic named\n/mobile_base/commands/sound\n\nTo recognize a message of type Sound, we need to import it\nfrom kobuki_msgs.msg import Sound\n\nSound message consists of only one component named value\nSimply set the value between 0 and 6 and publish\nValues:\n0 - turn on\n1 - turn off\n2 - recharge start\n3 - press button\n4 - error sound\n5 - start cleaning\n6 - cleaning end\nThumrongsak Kosiyatrakul\n\nKobuki Node\n\n\fSounds\n#!/usr/bin/env python\nimport rospy\nfrom kobuki_msgs.msg import Sound\ndef sendSounds():\nrospy.init_node('sound_sender', anonymous=True)\npub = rospy.Publisher('/mobile_base/commands/sound', Sound,\nqueue_size=10)\nwhile pub.get_num_connections() == 0:\npass\ns = Sound()\nfor x in range (0,7):\ns.value = x\npub.publish(s)\nrospy.sleep(1.5)\nif __name__ == '__main__':\ntry:\nsendSounds()\nexcept rospy.ROSInterruptException:\npass\n\nThumrongsak Kosiyatrakul\n\nKobuki Node\n\n\fLEDs\nThere are two LEDs on a Kobuki robot named LED1 and LED2\nTo control an LED, simply publish a message type Led to its\nassociate topic:\nLED1: /mobile_base/commands/led1\nLED2: /mobile_base/commands/led2\n\nTo recognize a message of type Led, we need to import it\nfrom kobuki_msgs.msg import Led\n\nLed message consists of only one component named value\nSimply set the value and publish\nValues:\n0 - Black (Off)\n1 - Green\n2 - Orange\n3 - Red\nThumrongsak Kosiyatrakul\n\nKobuki Node\n\n\fLEDs\n#!/usr/bin/env python\nimport rospy\nfrom kobuki_msgs.msg import Led\ndef sendLEDs():\nrospy.init_node('leds_sender', anonymous=True)\npub1 = rospy.Publisher('/mobile_base/commands/led1', Led, queue_size=10)\npub2 = rospy.Publisher('/mobile_base/commands/led2', Led, queue_size=10)\nwhile pub1.get_num_connections() == 0 or pub2.get_num_connections() == 0:\npass\nled = Led()\nx = 3\nwhile x != -1:\nled.value = x\npub1.publish(led)\nx = x - 1\nrospy.sleep(1)\nx = 3\nwhile x != -1:\nled.value = x\npub2.publish(led)\nx = x - 1\nrospy.sleep(1)\nif __name__ == '__main__':\ntry:\nsendLEDs()\nexcept rospy.ROSInterruptException:\npass\n\nThumrongsak Kosiyatrakul\n\nKobuki Node\n\n\fBumpers\nThere are three bumpers on a Kobuki robot, left, center, and right\nIf a bumper is pressed or release, it will publish a message of\ntype BumperEvent to the topic:\n/mobile_base/events/bumper\n\nNeed to import the message of type BumperEvent as usual:\nfrom kobuki_msgs.msg import BumperEvent\n\nBumperEvent consists of two components:\nbumper with the following possible values:\n0 - Left\n1 - Center\n2 - Right\n\nstate with the following possible values:\n0 - Released\n1 - Pressed\n\nSimply subscribe to the topic to receive the message:\nrospy.Subscriber('/mobile_base/events/bumper', BumperEvent, bumperCallback)\nThumrongsak Kosiyatrakul\n\nKobuki Node\n\n\fBumpers\n#!/usr/bin/env python\nimport rospy\nfrom kobuki_msgs.msg import BumperEvent\ndef bumperCallback(data):\nstr = \"\"\nif data.bumper == 0:\nstr = str + \"Left bumper is \"\nelif data.bumper == 1:\nstr = str + \"Center bumper is \"\nelse:\nstr = str + \"Right bumper is \"\nif data.state == 0:\nstr = str + \"released.\"\nelse:\nstr = str + \"pressed.\"\nrospy.loginfo(str)\ndef bumperExample():\nrospy.init_node('bumper_example', anonymous=True)\nrospy.Subscriber('/mobile_base/events/bumper', BumperEvent, bumperCallback)\nrospy.spin()\nif __name__ == '__main__':\nbumperExample()\n\nThumrongsak Kosiyatrakul\n\nKobuki Node\n\n\fButtons\nKobuki robot consists of three buttons, B0, B1, and B2\nIf a button is pressed or released, a message of type\nButtonEvent will be published into the topic\n/mobile_base/events/button\n\nYour program must import the message type ButtonEvent\nas shown below:\nfrom kobuki_msgs.msg import ButtonEvent\n\nThe message of type ButtonEvent consists of two\ncomponents:\nbutton with the following possible values:\n0 - B0\n1 - B1\n2 - B2\n\nstate with the following possible values:\n0 - released\n1 - pressed\n\nSimply subscribe to the topic as usual:\nrospy.Subscriber('/mobile_base/events/button', ButtonEvent, bumperCallback)\nThumrongsak Kosiyatrakul\n\nKobuki Node\n\n\fButton\n#!/usr/bin/env python\nimport rospy\nfrom kobuki_msgs.msg import ButtonEvent\ndef buttonCallback(data):\nstr = \"\"\nif data.button == 0:\nstr = str + \"B0 is \"\nelif data.button == 1:\nstr = str + \"B1 is \"\nelse:\nstr = str + \"B2 is \"\nif data.state == 0:\nstr = str + \"released.\"\nelse:\nstr = str + \"pressed.\"\nrospy.loginfo(str)\ndef bumperExample():\nrospy.init_node('button_example', anonymous=True)\nrospy.Subscriber('/mobile_base/events/button', ButtonEvent, buttonCallback)\nrospy.spin()\nif __name__ == '__main__':\nbumperExample()\n\nThumrongsak Kosiyatrakul\n\nKobuki Node\n\n\fOdometry\nRepresents an estimate of a robot position in free space\nA Kobuki robot has three main information related to position\nand orientation:\nposition.x\n\norientation.z\n\nposition.y\n\nKobuki\n\nInformation from an odometry allows us to move the robot with\nbetter precision\nThumrongsak Kosiyatrakul\n\nKobuki Node\n\n\fOdometry\nType: nav_mags/Odometry.msg\nThe component that we will focus on in Odometry message is\npose\nThe pose component contains two components and one of them\nis named pose (again)\nThe inner pose component consists of two components:\nposition (in meter) consists of 3 components of type float\nnamed x, y, and z\norientation (in quaternion) consists of 4 components of type\nfloat named x, y, z, and w\n\nFor a Kobuki robot:\npose.pose.position.z is always 0\npose.pose.orientation.x is always 0\npose.pose.orientation.y is always 0\n\nThumrongsak Kosiyatrakul\n\nKobuki Node\n\n\fOdometry\nNote that the orientation from Kobuki\u2019s odometry is in\nquaternion\nQuaternion is a unit suitable for rotating objects in 3D\nA quaternion value consists of four values, x, y, z, and w\nWe generally familiar with roll, pitch, and yaw\nSince a Kobuki can only turn about the Z-axis, only yaw is\napplicable\nWe can calculate yaw (in radian) using the following formula:\nyaw = arcsin(2 \u2217 \ud835\udc65 \u2217 \ud835\udc66 + 2 \u2217 \ud835\udc67 \u2217 \ud835\udc64)\nBecause \ud835\udc65 and \ud835\udc66 orientations of a Kobuki robot are always 0,\nyaw = arcsin(2 \u2217 \ud835\udc67 \u2217 \ud835\udc64)\nTo convert radian to degree simply multiply by\nThumrongsak Kosiyatrakul\n\nKobuki Node\n\n180\n\ud835\udf0b\n\n\fReset Kobuki\u2019s Odometry\nOften time, we may want to reset the odometry to 0\nThis can be done by publishing an Empty message to\n/mobile_base/commands/reset_odometry\n\nYou must make sure that your program already establish a\nconnection with the robot first\nExample:\n#!/usr/bin/env python\nimport rospy\nfrom std_msgs.msg import Empty\ndef resetter():\npub = rospy.Publisher('/mobile_base/commands/reset_odometry',\nEmpty, queue_size=10)\nrospy.init_node('resetter', anonymous=True)\nwhile pub.get_num_connections() == 0:\npass\npub.publish(Empty())\nif __name__ == '__main__':\nresetter()\n\nThumrongsak Kosiyatrakul\n\nKobuki Node\n\n\fOdometry\nTopic: /odom\nPurpose: Information about robot\u2019s where about\nType: nav_msgs/Odometry.msg\nIf you create a function named odomCallback that will be\ncalled every the program receive message from the topic /odom\nas follows:\ndef odomCallback(data):\n\ndata.pose.pose.position.x is the position of the robot\nfrom the origin along the x-axis\ndata.pose.pose.position.y is the position of the robot\nfrom the origin along the y-axis\ndata.pose.pose.orientation.z together with\ndata.pose.pose.orientation.w is the direction where\nthe robot is facing (quaternion).\n\nThumrongsak Kosiyatrakul\n\nKobuki Node\n\n\fodom\n#!/usr/bin/env python\nimport rospy\nimport math\nfrom nav_msgs.msg import Odometry\nfrom tf.transformations import euler_from_quaternion\ndef odomCallback(data):\n# Convert quaternion to degree\nq = [data.pose.pose.orientation.x,\ndata.pose.pose.orientation.y,\ndata.pose.pose.orientation.z,\ndata.pose.pose.orientation.w]\nroll, pitch, yaw = euler_from_quaternion(q)\n# roll, pitch, and yaw are in radian\ndegree = yaw * 180 / math.pi\nx = data.pose.pose.position.x\ny = data.pose.pose.position.y\nmsg = \"(%.6f,%.6f) at %.6f degree.\" % (x, y, degree)\nrospy.loginfo(msg)\ndef odomExample():\nrospy.init_node('odom_example', anonymous=True)\nrospy.Subscriber('/odom', Odometry, odomCallback)\nrospy.spin()\nif __name__ == '__main__':\nodomExample()\n\nThumrongsak Kosiyatrakul\n\nKobuki Node\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}