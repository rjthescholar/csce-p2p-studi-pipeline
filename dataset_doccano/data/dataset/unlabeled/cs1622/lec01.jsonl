{"id": 240, "segment": "unlabeled", "course": "cs1622", "lec": "lec01", "text": "Intro and Rust\nCS 1622\nJarrett Billingsley\n\n\fClass announcements\n\u25cf be sure to check the notes on each of my slides\no for extra explanations, examples, snarky comments etc.\no as well as answers to the questions on the slides so you can study.\n\u25cf also, be sure to use Powerpoint to view my slides\no not Keynote, not Google Drive; they absolutely butcher alignment\nand diagrams and arrows and I use a lot of those. it\u2019s bad enough\nthat diagrams can become incorrect/misleading.\no if you use a note-taking app, open the pptx in Powerpoint and\nexport it as PDF, then use that. it will look much better than\nopening the pptx directly in your note-taking app.\n\n2\n\n\fAdministrivia\n\n3\n\n\fhi\n\u25cf you can just call me Jarrett\n\n\u25cfjarrett@cs.pitt.edu\n\u25cfsites.pitt.edu/~jfb42\n\n\u25cf Office hours: Mon/Wed 1:15-3:30 in 6509 SENSQ\n\u25cf Religious absences: contact me ASAP\n\u25cf Students with disabilities: contact the DRS ASAP\n\u25cf Everything in this section is also on my site in \"course info\"!\no I use red on the slides for really important things\n\n4\n\n\fCommunication\n\u25cf I send announcements through Canvas which come thru email\no it is not my responsibility to make sure you get them, it\u2019s yours\n\u25cf announcements/grades are the only things I use Canvas for\no (well recording class too)\no everything else is on my site.\no including the course schedule/syllabus.\n\u25cf Discord hours: most days after 12PM and before 9PM EDT\no\n\nbut I don't really have a healthy work/life separation so\n\n\u25cf For more \"official\" communications, or if you need my attention\nimmediately, use email.\no otherwise, Discord is preferred \u2013 much better for sharing code,\nscreenshots, etc. in a much quicker way.\n\n5\n\n\fTextbooks???\n\u25cf I'm not really a book person.\n\u25cf none of these are required and the first two are free (see course info)\n\n6\n\n\fGrading\n\u25cf Projects (x4): 60%\no each is worth 15%\no there is a late submission policy, see the course info page\n\u25cf Exams (x2): 40%\no each worth 20%\no exam 2 is not cumulative! it\u2019s just on the stuff after exam 1.\no on both exam days, we will do a short review session beforehand.\n\u25cf There are no labs or recitations or anything.\n\u25cf Attendance is not graded for lectures\u2026\no but people who don't come and interact don't do well.\n\n7\n\n\fTeaching philosophy\n\u25cf I'm more of a \"big picture\" teacher\no I care about high-level concepts and problem-solving\no you won't get exam questions about function parameters\n\u25cf You are a student. you are supposed to be confused.\no I wanna help you understand!\no never say \"this is a dumb question\" cause there aren't any!\n\noDON\u2019T STRUGGLE IN SILENCE!!!! EVER!!\n\n\u25cf What is a university setting good for today?\no focus, practice, and access to people who know stuff\no your friends do not know as much about this stuff as I do\no but also\u2026 your friends can be very helpful when studying or in\npractical matters (installing stuff etc)!\no studying together is not cheating! do it!\n8\n\n\fI can tell when you cheat :^)\n\u25cf If you cheat, you fail the course. Period.\n\u25cf Don't post your code on github, baidu etc.\n\u25cf Don't \"help\" your friends by giving them code.\n\n9\n\n\fAcademic Integrity\n\u25cf If you \"help\" a friend, you are only delaying their failure until a\nlater point when it will be too late to fix the problems.\no a 0 will hurt way, way more than a 60, and it'll hurt you both.\n\u25cf Don't cheat if your enrollment is contingent upon your GPA.\no or your ROTC or your student visa or your graduation or whatever.\n\u25cf Generally speaking, I trust you!\no I try to be accommodating about extensions and such\no I don\u2019t think most cheaters are being lazy\n\u25cf But you\u2019re an adult, and are responsible for your actions.\no I hate being in a position where I have your future in my hands\u2026\no especially when you're the one who put it there.\no Do not take advantage of my trust.\n\u25cf If you're confused, don't cheat, ask for help. yes, even on the\nexams. yes, even an hour before the project is due.\n10\n\n\fIntro\n\n11\n\n\fWhat, Why, and How\n\u25cf for every topic, ask yourself (and me!) these questions:\n\nWhy do we use it?\n\n\"splitting code into functions makes it\neasier to read, understand, and reuse.\"\n\nWhat is it?\n\n\"a function is a named piece of code.\"\n\"in Java, you write the return type,\n\nHow do we do it?\n\nthen the name, then a left parenthesis,\nthen any arguments, with the type and name,\n\nseparated by commas, then a right parenthesis, then\u2026\n\nwhat and why are almost always more important than how.\non the exams, be sure you are answering the right question.\nif I ask \"what is X,\" don't explain how to X.\n12\n\n\fWhat is language?\n\u25cf a system of encoding information by using arbitrary symbols\no \"symbols\" can also include sounds, objects, actions, etc.\nhuman languages are massively\ncomplex, like anything involving brains.\nwithin the mess, there are kernels of\nmathematical and logical truth\u2026\n\n\u2203\ud835\udc65\u2208\ud835\udc46 \u2200\ud835\udc66\u2260\ud835\udc65 \ud835\udc43 \ud835\udc66 \u2192 \ud835\udc44(\ud835\udc65)\n\u2026upon which computer\nlanguages were designed.\n\n13\n\n\fComputer languages\n\u25cf modeled after human languages, these are much simpler languages\nused to encode information in a way that is useful for computing.\ndeclarative languages\nencode data and rules.\n\nprogramming\nlanguages encode\ninstructions for the\ncomputer to\nexecute.\n\ninterchange and binary file\nformats encode domain- or\napplication-specific data.\neven things like network\nprotocols are a kind of language!\n14\n\n\fProgramming languages\n\u25cf one definition is that programs are sequences of instructions\u2026\n\u25cf but programs are also proofs.\n\nfn main() {\nfor i in 0 .. 10 {\nprintln!(\"i = {}\", i);\n}\n}\n\nthe Curry-Howard correspondence\nshows that programs and proofs\nare two ways of expressing the\nsame mathematical objects.\n\nthere are proof languages and proof assistants which can\nfunction as both programming languages and proof checkers.\n\n15\n\n\fThe Origin of (high-level programming) Languages\n\u25cf as you learned in 447, CPUs execute machine code\u2026\no and assembly language is a textual representation of that.\nmain:\nbut even the simplest tasks take a lot of code in\nli\ns0, 0\nassembly, and more code = more mistakes.\n_loop:\nla\na0, msg\nli\nv0, 4\nwe invented high-level languages (HLLs) to let\nsyscall\nus write programs in shorter, human-friendly ways.\nmove a0, s0\nli\nv0, 1\nfn main() {\nsyscall\nfor i in 0 .. 10 {\nli\na0, '\\n'\nli\nv0, 11\nprintln!(\"i = {}\", i);\nsyscall\n}\nadd s0, s0, 1\n}\nblt s0, 10, _loop\n16\n\n\fPerformance \u221d 1 / Abstraction\n\u25cf HLLs allow us to focus more on solving problems than on holding\nthe CPU's hand through every step of computation\n\u25cf but most abstractions come at a performance cost\n\nfor(i = 0; i < n; i++) {\nA[i] = B[i] + C[i];\n}\n\nA = B + C\n\nlower-level languages like C\nprovide abstractions that better\nmatch* what the underlying\nhardware provides.\n\nhigher-level languages like\nPython give you more powerful\nabstractions, at the cost of lower\nperformance (usually).\n\nbut it all depends on the CPU design and the\nquality of the language implementation.\n17\n\n\fCompilers\n\n18\n\n\fWhat's a compiler?\n\u25cf it's a program that translates one programming language (the\nsource language) to another (the target language).\n\u25cf typically this is from an HLL to a machine language.\n\nJava\n\ntranspilers convert\nbetween HLLs.\n\njavac\n\nC\ngcc\n\nrecompilers convert\nbetween machine languages.\n\nJVM Bytecode\n\nand decompilers\nattempt to reconstruct\nHLL code from\nmachine language!\ne.g. ghidra,\nhex-rays\n\nx86 Machine Code\njava\n19\n\n\fAhead-of-time vs. Just-in-time (AOT vs JIT)\n\u25cf AOT compilers produce a file that contains the native machine code.\n\u25cf JIT compilers produce native machine code right before it's needed.\n\nC\n\nJava\n\ngcc\n\nCPU\n\nhello.exe\n\nJVM\njavac\n\nhello.class\n\njava\n\n\u2026can use an\ninterpreter to run\nthe bytecode, or JIT\nit to native code.\n20\n\n\fOkay, okay: HOW does a compiler WORK\n\u25cf there are kind of two broad stages:\nthe frontend reads the\nsource code and checks it\nfor \"correctness.\"\n\nthe backend produces target\ncode from the compiler's\n\"idea\" of your program.\n\nFrontend\n\nBackend\nhello.exe\n\nhello.c\n\nthis \"idea\" is the intermediate representation (IR):\na sort of third language which \"bridges the gap.\"\n\n21\n\n\fFrontend step 1: Lexical Analysis (Lexing (or Scanning))\n\u25cf lexing splits the source text into tokens: words, symbols, etc.\n\u25cf it's a straightforward string processing algorithm.\n\nThis is English.\n\nThis, is, English, .\n\nvoid main(){}\n\nvoid, main, (, ), {, }\n\n\"hello!\n\nerror: unclosed string literal\n\nif<class)++\n\nif, <, class, ), ++\n\nthis last one is nonsense, but the lexer doesn't know that.\nthat's the responsibility of\u2026\n22\n\n\fFrontend step 2: Syntactic Analysis (Parsing)\n\u25cf parsing takes the lexed tokens and extracts structure from them.\n\u25cf a language's grammar defines the rules of these structures.\nIF-ELSE\n\nS\nVP\nNP\nART\n\nCALL\n\nPP\nN\n\nV\n\nPREP PRN\n\nThe cat stares at me.\n\nID\n\nID\n\n[]\n\nCALL\nID\n\n[]\n\nif(x) y(); else z();\n\nthis is where you get syntactic errors, like \"missing\nsemicolon\" or \"unexpected closing paren\" or whatever.\n\nthe result is an AST: Abstract Syntax Tree.\nbut this just looks like a program. is it one?\n\n23\n\n\fFrontend step 3: Semantic Analysis\n\u25cf this checks for \"correctness\" according to the rules of the language.\no things like type checking, name usage, privacy\u2026\n\nColorless green dreams sleep furiously.\n(syntactically correct, but nonsense.)\n\nx = 10;\n\nerror: undefined reference to 'x'\n\nint x = 1.0;\n\nerror: possible loss of precision\n\nint x = 1;\n\n\ud83d\udc4d\n\nI keep quoting \"correctness\" because it's absolutely possible\nto write incorrect programs that pass these checks.\nmuch PL research is about making these checks better!\n24\n\n\fBackend: optimization and code generation\n\u25cf optimization rewrites the program to do the same things but faster.\n\u25cf codegen produces the target language code from the IR.\nfor(i = 0; i < 4; i++)\nA[i] = B[i] + C[i];\n\nA[0] = B[0] + C[0];\nA[1] = B[1] + C[1];\nA[2] = B[2] + C[2];\nA[3] = B[3] + C[3];\n\nla\nla\nla\nlw\nlw\nadd\nsw\nlw\nlw\nadd\nsw\nlw\nlw\nadd\nsw\nlw\nlw\nadd\nsw\n\nt0, A\nt1, B\nt2, C\nt3, 0(t1)\nt4, 0(t2)\nt3, t3, t4\nt3, 0(t0)\nt3, 4(t1)\nt4, 4(t2)\nt3, t3, t4\nt3, 4(t0)\nt3, 8(t1)\nt4, 8(t2)\nt3, t3, t4\nt3, 12(t0)\nt3, 12(t1)\nt4, 12(t2)\nt3, t3, t4\nt3, 12(t0)\n\nand boom... we\nhave a program!\n\n25\n\n\fWhat we'll talk about along the way\n\u25cf grammars and abstract syntax trees!\n\u25cf type theory and type systems!\no static and dynamic typing!\no strong and weak typing!\no parametric types and generics!\n\u25cf runtime representation!\n\u25cf memory management!\n\u25cf ABIs and linking!\n\u25cf and more!\n\n26\n\n\fRust\n\n27\n\n\fIf you want to write a compiler\u2026\n\u25cf different problems require different tools.\n\u25cf when writing compilers, some language features will be very useful:\nJava\n\nC\n\nRust\n\nGood string manipulation\n\n4/5\n\n0/5\n\n5/5\n\nAutomatic memory management\n\n5/5\n\n0/5\n\n5/5\n\nGenerics (types and code)\n\n4/5\n\n1/5\n\n4/5\n\nFunctional programming style\n\n3/5\n\n0/5\n\n4/5\n\nAlgebraic data types\n\n1/5\n\n1/5\n\n5/5\n\nLess repetitive boilerplate\n\n0/5\n\n0/5\n\n4/5\n\nStrong, expressive type system\n\n2/5\n\n0/5\n\n5/5\n\nratings are my opinion based on experience. this is a limited view of their strengths/weaknesses.\n\n28\n\n\fWhat is Rust?\n\u25cf it's a systems language like C, but designed to not be terrible.\n\u25cf it's rigorously defined and borrows many features from PL theory\u2026\n\u25cf \u2026but also tries to be a practical language for writing real programs.\nyou might have heard that\nit's complex and confusing.\nand it sure can be!\n\nfn err_context<'a, O, F>(kind: LexErrorKind, parser: F) ->\nimpl Fn(Span<'a>) -> LResult<'a, O>\nwhere\nF: Fn(Span<'a>) -> IResult<Span<'a>, O, LexError>,\n\nfn main() {\nlet nums = vec![1, 3, 5, 7, 10];\nfor (i, n) in nums.iter().enumerate() {\nprintln!(\"nums[{}] = {}\", i, n);\n}\n\nbut it can also be simple,\nelegant, and readable.\n\nlet sum: i32 = nums.iter().sum();\nprintln!(\"sum of nums = {}\", sum);\n}\n29\n\n\fBasic tools and vocabulary\n\u25cf rustup is the tool to install the Rust toolchain.\n\u25cf cargo is the \"swiss army knife\" for creating and building programs.\no it lets you create new Rust projects with some basic features.\no it acts as a build tool like make.\no it lets you run tests, build documentation, and so on.\no it lets you specify dependencies on external libraries (crates).\no it automatically downloads, builds, and installs those libraries.\n\u25cf a crate is like a Java package: a self-contained program or library.\no crates.io is the website where you can search for crates.\no each Rust program you make is its own crate.\n\n30\n\n\fRust by Comparison\n\u25cf here is a simple program written in Java and Rust.\npublic class Code {\npublic static void main(String[] a) {\nfor(int i = 1; i <= 100; i++) {\nif((i % 3) == 0)\nSystem.out.print(\"Fizz\");\nif((i % 5) == 0)\nSystem.out.print(\"Buzz\");\nif((i % 3) != 0 && (i % 5) != 0)\nSystem.out.print(i);\nSystem.out.println();\n}\n}\n}\n\nfn main() {\nfor i in 1 ..= 100 {\nif (i % 3) == 0 {\nprint!(\"Fizz\");\n}\nif (i % 5) == 0 {\nprint!(\"Buzz\");\n}\nif (i % 3) != 0 && (i % 5) != 0 {\nprint!(\"{}\", i);\n}\nprintln!();\n}\n}\n\nwhat are some differences?\n(see slide notes for some answers)\n\n31\n\n\fMore Comparison\n\u25cf it really isn't THAT scary. (class/main/System.out omitted for space)\nint[] nums = new int[]{1, 3, 5, 7, 10};\n\nlet nums = vec![1, 3, 5, 7, 10];\n\nfor(int i = 0; i < nums.length; i++) {\nfor (i, n) in nums.iter().enumerate() {\nprintf(\"nums[%d] = %d\\n\", i, nums[i]);\nprintln!(\"nums[{}] = {}\", i, n);\n}\n}\nint sum = Arrays.stream(nums).sum();\nprintf(\"sum of nums = %d\", sum);\n\nlet sum: i32 = nums.iter().sum();\nprintln!(\"sum of nums = {}\", sum);\n\ntakeaways:\n- variables declared with let\n- arrays called \"vectors\"*\n- .iter() seems to do Fun Iteration Things\n- i32 instead of int\n- print formatting done with {}\n32\n\n\foh no I'm not good with computer what does this me\n\u25cf let's try something.\nlet nums = vec![1, 3, 5, 7, 10];\nfor n in nums { println!(\"{}\", n); }\nfor (i, n) in nums.iter().enumerate() {\nprintln!(\"nums[{}] = {}\", i, n);\n}\n\nRust's compiler errors tend\nto be very verbose, but it's\nbecause it actually tries to\nhelp you fix the error!\n\nfollowing its help works here, and often does!\n33\n\n\fWhat I want you to do!\n\n34\n\n\fFor next class\u2026\n\u25cf On the course info page, find the Rust Programming Language book.\n\u25cf follow along with chapters 1-3 to install and play around with Rust.\no Windows users, use PowerShell or WSL. cmd.exe is dead.\n\u25cf you're already programmers so a lot of things will be obvious to you!\n\u25cf try this: just read the code examples and if you're confused, read\nthe text before it. that way you can skip the easy stuff.\n\n35\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}