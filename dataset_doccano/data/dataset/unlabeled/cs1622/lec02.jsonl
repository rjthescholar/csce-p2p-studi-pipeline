{"id": 222, "segment": "unlabeled", "course": "cs1622", "lec": "lec02", "text": "Rust, Strings, and Text\nCS/COE 1622\nJarrett Billingsley\n\n\fClass Announcements\n\u25cf I'm assuming, for this lecture, that you really did follow along with\nchapters 1-3 of the Rust book\n\u25cf also, if you didn\u2019t see the announcement yesterday\u2026\no go look :^)\n\u25cf the examples from today are in the examples repo\no see the materials page!\n\n2\n\n\fVectors\n\n3\n\n\fVectors!\n\u25cf Rust's Vec<T> can work like a Java T[] or ArrayList<T>.\nlet v = vec![1, 2, 3, 4, 5];\nthis creates a new, immutable (unchangeable) Vec.\n\nlet mut v = vec![1, 2, 3, 4, 5];\nthis one can be modified, appended, etc.\n\nfor the most part, they work like Java arrays/ArrayLists:\nlet x = v[3];\n\n// indexing\n\nlet l = v.len(); // length\n\nv.push(6);\n\n// appends a 6\n4\n\n\fIteration\n\u25cf Rust has a system similar to Java's Iterable/Iterator interfaces.\no .iter() is like Java's .iterator() method.\n\u25cf the for-in loop iterates over iterators.\nfor i in 0 .. 10 {}\nfor i in 1 ..= 10 {}\n\n// i = 0, 1, 2, \u2026, 8, 9\n// i = 1, 2, \u2026, 9, 10\n\nlet v = vec![1, 2, 3];\nfor val in v.iter() {} // iterate over values in v\nfor val in &v {}\n// same as above, but shorter\nfor (i, val) in v.iter().enumerate() {}\n\nthe last one shows calling a method on an iterator object to\nget a new iterator \u2013 this one gives the index and value.\n5\n\n\fan Extremely Common Pattern: Mapping\n\u25cf you have an array A.\n\u25cf you want to perform some transformation on each item in A.\n\u25cf you want to put the results of those transformations into an array B.\nint[] B = new int[A.length()];\nfor(int i = 0; i < A.length(); i++) {\nB[i] = A[i] * 2;\n}\nthis operation is called mapping, and it's so, so common.\nin Rust, it looks like this:\n\nlet B = A.iter().map(|x| x * 2).collect();\nthis is a function literal, or\nanonymous function, or \"lambda.\"\n6\n\n\fAlgebraic Data Types\nand Structs\ntime check: \u2264 35 min\n\n7\n\n\fNot the same as ADTs (abstract data types)\n\u25cf primitive types contain a single value, e.g. i32, f32, bool, char\u2026\n\u25cf algebraic types let us combine types into larger ones.\nProduct Types bundle\nvalues \"side-by-side\".\n\nSum Types hold one of\nseveral choices or variants.\n\nclass Point {\nint x;\nint y;\n}\n\nboolean b;\nb = true;\nb = false;\n// that's it.\n\nJava classes are product\ntypes. each Point can\nhold any combination\nof two integers.\n\nJava's boolean can only\nbe one of two possibilities,\nbut that's built into the\nlanguage for you.\n8\n\n\fRust's product types: Structs\n\u25cf structs are the main kind. (there are also \"tuples.\")\nstruct Point {\nx: i32,\ny: i32,\n}\n\nthey're like Java classes, but no\ninheritance, no interfaces, no\nmethods, just fields.\n\nlet p = Point { x: 10, y: 20 };\nyou construct a struct by listing the values for each field.\nprintln!(\"{}, {}\", p.x, p.y);\nand you access fields with . just like in Java, C, etc.\nother than privacy (put pub on a field to make it public), that's it.\n9\n\n\f\"Constructors\" and \"methods\"\n\u25cf Rust does not have classes and is not an OOP language.\n\u25cf but it does let us add methods to any type, with impl.\nimpl Point {\nfn new(x: i32, y: i32) -> Point {\nPoint { x, y }\n}\nfn flip_x(&self) -> Point {\nPoint { x: -self.x, y: self.y }\n}\n}\n\na Rust convention is\nto have a constructor\nfunction named new.\n\nmethods are made\nby writing &self as\nthe first argument.\n\nnow we can access these as\nPoint::new() and p.flip_x().\n10\n\n\fA side note - :: vs .\n\u25cf in Java, you use . to access all \"things inside other things\".\no e.g. java.util.Arrays, Integer.parseInt()\n\u25cf in Rust, the . operator is only used on objects.\no when you see . it always means \"get a field from a struct\" or \"call a\nmethod on some value.\"\n\u25cf for anything else, you use ::\no e.g. std::cmp::Ordering, Point::new()\no I like to think of :: as being like the (back)slashes in file paths\n\u25aa C:\\Windows\\system32\n\u25aa /bin/sh\n\n11\n\n\fFlavors of 'self'\n\u25cf inside an impl there are a few kinds of functions:\nimpl MyStruct {\nfn new() -> MyStruct\nwith no self argument, it's an associated function.\nconstructors are the most common example.\n\nfn method(&self)\nwith a &self, it's a method, but cannot change any fields\nin the object it's called on.\n\nfn mutator(&mut self)\nwith a &mut self, it's a method that can change the\nobject, but can only be called on mut variables.\n12\n\n\fSum Types\ntime check: \u2264 65 min\n\n13\n\n\fA motivating example\n\u25cf the classic Animal class hierarchy might look like this in Java:\nabstract class Animal {\nan Animal variable\nabstract void speak();\nwould be able to hold an\n}\ninstance of any of these.\nclass Cat extends Animal {\nvoid speak() { println(\"meow!\"); }\ncommon fields and\n}\nmethods go in Animal;\nclass Dog extends Animal {\nunique things go in the\nvoid speak() { println(\"woof!\"); }\nsubclasses.\n}\nclass Camel extends Animal {\nvoid speak() { println(\"ghhghhg!\"); }\n}\n14\n\n\fThe equivalent (?) Rust\n\u25cf when you want to have a choice of types, you use an enum.\nenum Animal {\nCat, Dog, Camel\n}\n\nwhat's happening here is not really\nlike the Java code, though.\n\nit's much more like a boolean: a fixed set\nimpl Animal {\nof possible values, and an Animal\nfn speak(&self) {\nuse Animal::*;\nvariable can only take on those values.\nmatch self {\nCat\n=> println!(\"meow!\"),\nbut unlike Java, we get\nDog\n=> println!(\"woof!\"),\nto define our own types\nCamel => println!(\"ghhghhg!\"),\nlike this in Rust.\n}\n}\n}\n15\n\n\fCommonalities and differences\n\u25cf in OOP, we can reuse code/fields by putting them in the base class\u2026\no and we can specialize code/fields in the subclasses.\nabstract class Animal {\nfloat weight;\nAnimal(float w) { weight = w; }\nvoid printWeight() { println(weight); }\n}\nclass Cat extends Animal {\nhere, weight is common to\nString pattern;\nall Animals, but pattern is\nCat(float w, String p) {\nunique to Cats.\nsuper(w); pattern = p;\n}\nvoid printPattern() { println(pattern); }\n}\n16\n\n\fWhen a struct and an enum love each other very\nmuch\n\n\u25cf in Rust, this can be represented with this pattern that has no name:\nstruct Animal {\nweight: f32,\nkind:\nAnimalKind,\n}\n\ncommon fields appear in this\nAnimal struct. but it also has a\nkind field which is an enum.\n\nenum AnimalKind {\nCat\n{ pattern: String },\nDog\n{ loudness: i32 },\nCamel { num_humps: i32 },\n}\n\nunique fields appear in the\nenum variants.\n\nthis pattern is going to show up over and over!\nit definitely looks different than the Java code, but\nthe same concepts are coming into play.\n17\n\n\fLooking inside enums\n\u25cf there are two ways to see what's inside the enum:\n// \"if k is an AnimalKind::Cat,\n// extract its data and assign it to 'pattern'.\"\nif let AnimalKind::Cat { pattern } = &self.kind {\nprintln!(\"cat with pattern: '{}'\", pattern);\n}\nmatch &self.kind { .. means \"throw away\" or \"I don't care\"\nAnimalKind::Cat{..} => println!(\"meow!\"),\nAnimalKind::Dog{..} => println!(\"woof!\"),\n_\n=> println!(\"???\"),\n}\n18\n\n\fNullPointerException? Never heard of it\n\u25cf there is no such thing as null in Rust! \ud83c\udf89 \ud83c\udf89 \ud83c\udf89 \ud83c\udf89\n\u25cf well, there's something like it, but it's opt-in, not forced on you.\n\u25cf it's an enum called Option.\nlet nullable_ints: Vec<Option<i32>> = vec![\nSome(1), Some(45), None, Some(7) ];\nfor i in nullable_ints {\nif let Some(v) = i { println!(\"{}\", v); }\n}\n\nOption is so widely used that it's built into the compiler.\nyou don't have to write Option::None, for instance.\n\n19\n\n\fStrings and Unicode\ntime check: \u2264 90 min\n\n20\n\n\fSoooo easy\n\u25cf lexing is the process of splitting the source text into tokens.\n\u25cf that means we'll have to deal with strings as the input to our lexer.\nif you're a native English speaker, you're probably\nused to thinking of strings as working like this:\n\n0\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\nh\n\ne\n\nl\n\nl\n\no\n\n! \\n :\n\n) \\n\n\n104\n\n101\n\n108\n\n108\n\n111\n\n33\n\n41\n\n10\n\n7\n\n58\n\n8\n\n9\n\n10\n\na string is an array of characters, where each\ncharacter is encoded as a small integer. easy, right?\n21\n\n\fThose dang human languages\n\u25cf the reality is: it's way more complicated than that.\n\u25cf see StringWeirdness.java for some\u2026 string weirdness.\nString s = \"t\u00e9st\";\nString t = \"t\u00e9st\";\nSystem.out.println(s.length()); // 4\nSystem.out.println(s.charAt(1)); // \u00e9\nSystem.out.println(t.length()); // 5??\nSystem.out.println(t.charAt(1)); // e??\n\nwelcome to the wonderful world of Unicode!!!\n\n22\n\n\fUnicode\n\u25cf Unicode is The String Encoding that the whole world* uses now.\n\u25cf it attempts to map every written character in every human language\nto a number, its codepoint.\n\u25cf but it's more complicated than that, because human writing systems.\n\n\u00e9 = [U+00E9]\ne\u0301 = [U+0065, U+0301]\ne + \u00b4\n\nthis is a combining mark: it\nmodifies the previous glyph.\n23\n\n\fUTF-8? UTF-16? UTF-32? BE? LE?\n\u25cf each codepoint is conceptually a 21-bit number.\n\u25cf Unicode text is encoded into one of a few transformation formats.\n\u25cf the encodings of [U+0074, U+00E9, U+0073, U+0074]:\nUTF-32: each codepoint\nis a 32-bit int. simple,\nbut wastes space.\n\nLE 74 00 00 00 e9 00 00 00 73 00 00 00 74 00 00 00\nBE 00 00 00 74 00 00 00 e9 00 00 00 73 00 00 00 74\n\nUTF-16: each is a 16-bit int\u2026\nunless it's in a certain range, in\nwhich case it's two 16-bit ints.\nUTF-8: ASCII characters are 1 byte;\nall others are 2, 3, or 4 bytes long.\n\nLE\n\n74 00 e9 00 73 00 74 00\n\nBE\n\n00 74 00 e9 00 73 00 74\n\n74 c3 a9 73 74\n\nUTF-8 has become the dominant encoding.\n24\n\n\fSuch sights to show you\n\u25cf Rust uses UTF-8 strings (and so do many other languages).\n\u25cf Unicode and UTF-8 mean you have to abandon many of your\nassumptions about how strings work.\nwhat is this string's length?\n\nt\u3042\u030ast\n\n74 e3 81 82 cc 8a 73 74\nin bytes? 0\n1 2 3 4 5 6 7 len=8\nin codepoints? 0\n1\n2\n3 4 len=5\nin \"grapheme 0\nlen=4\n1\n2\n3\nclusters?\"\nalso, because each codepoint is a different number of bytes,\nindexing by codepoints is not necessarily O(1)!\n\n25\n\n\fOh god\n\u25cf what about getting a substring?\n\u25cf what about reversing strings?\n\u25cf what about toUpper/toLower?\n\u25cf if we loop over a string, do we see bytes, codepoints, or clusters?\n\u25cf should the \"e with acute\" precomposed character compare equal to\nthe \"e followed by combining acute\" character pair?\n\u25cf what about collating (\"alphabetizing\")?\n\u25cf what if there are multiple combining marks on a character? does\nthe order of those marks affect its display or meaning?\n\nit's not Unicode's fault, it's ours.\n26\n\n\fWhat about Java?\n\u25cf Java adopted Unicode early! \u2026maybe a little too early.\n\u25cf in Java, String is UTF-16, and char is 16 bits (2 bytes).\no at the time Java was created, that's what Unicode was.\n\u25cf but Unicode was extended to 21 bits after Java adopted it. so\u2026\no .charAt() is O(1), nice!\no \u2026but you might only get half a character??\n\u25cf see, codepoints above U+FFFF are encoded as two Java chars\no e.g. many emoji are in this range\n\u25cf so, \"proper\" codepoint indexing is O(n) in Java too\no there is a .codePointAt() method to help, at least\no and a .codePoints() iterator\n\n27\n\n\fLiving in a post-ASCII world\n\u25cf do not assume:\no \u2026that your program will only be used by English speakers.\no \u2026that your program will only be fed ASCII text.\no \u2026that there is one definition of \"string length.\"\no \u2026that string indexing/substring is a constant-time operation.\n\u25cf do:\no trust the people who do this stuff for a living.\no read about how your programming language handles text.\no write your text processing to be language-agnostic.\no prefer iterating over strings instead of indexing them, if possible.\no look into canonicalization if you're dealing with thorny issues.\no accept that some Rust string stuff looks weird/complicated for a\nvery good reason: text is weird/complicated.\n28\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}