{"id": 239, "segment": "unlabeled", "course": "cs1622", "lec": "lec04", "text": "CFGs and ASTs\nCS/COE 1622\nJarrett Billingsley\n\n\fClass Announcements\n\u25cf did you start the project yet?\no a fair number of you haven\u2019t accepted the assignment on Github\u2026\no do iiiiiiit >:V\n\n2\n\n\fBeyond Regular\nGrammars\n\n3\n\n\fRegular?\n\u25cf lexing grammars describe regular languages. what's that mean?\nProgram: (WS? Token)* WS? '<eof>'\nWS:\n' ' | '\\t' | '\\n'\nit's a little nonobvious, but if we\nToken:\n'(' | ')' | Id | IntLit start at the start rule, Program,\nId:\nIdStart IdCont*\nthe right-hand sides of every\nIdStart: <alphabetic> | '_'\nrule never take us in a loop to\nIdCont: IdStart | <digit>\nthe same rule twice.\nIntLit: <digit>+\n\nthis puts strict limitations on the kinds of strings\nthese grammars can recognize\u2026\n\u2026but it does make these languages easier to\nreason about and implement.\n4\n\n\fAnother way to look at it\n\u25cf if we look at the dependency graph of these rules:\nProgram\n\nToken\n\nId\n\nIdStart\n\nWs\n\nIntLit\n\nIdCont\n\nnow it becomes more obvious that\nthere are no cycles in this graph.\n(this is called a DAG: a directed acyclic graph.\nit's like a tree, but nodes can share parents.)\n\nbut\u2026 what happens if we remove that requirement?\n5\n\n\fA whole new world\n\u25cf let's say our alphabet is A = { '(', ')', 'e' }.\n\u25cf and our grammar rule is Exp: 'e' | '(' Exp ')'\n\u25cf valid strings would be e, (e), ((e)), etc. for any number of parens.\none l o o p y b o i is all it\ntakes to give us this power.\n\nExp\n\nbut power comes at a cost: this kind of language is strictly\nmore complex than regular languages and requires more\ncomplex algorithms to implement.\nonce you allow these kinds of recursive rules, you are\nnow in the land of context-free languages!\n6\n\n\fSo what can they do?\n\u25cf context-free grammars (CFGs) can represent nesting of any depth.\n\u25cf this happens to map very nicely onto our intuition (instinct?) about how\nlanguage works in general.\nin human languages, we can nest phrases inside other ones.\n\nthe cat (on the bed (in that room))\nwith CFGs, we can nest\nexpressions\u2026\nf(x * (y + 3))\n\nand statements!\n\nif x == 10 {\nif y == 20 {\nf();\n}\n}\n7\n\n\fBut what can't they do?\n\u25cf there are a lot of kinds of languages they can't represent.\n\u25cf but for most computer languages, this isn't really a problem.\n\u25cf unlike natural human languages, computer languages\u2026\no are designed up front, rather than emerging naturally\no are meant to be unambiguous\no are meant to be easy to read and maintain\n\u25cf so something simpler than human languages is a good thing.\n\u25cf THERE'S STILL THIS THING THOUGH\n\nint y = x >> 3;\nList<List<String>> l;\n\nto properly parse this requires a\ncontext-sensitive grammar (CSG)\u2026\nbut the ambiguity here is simple\nenough that we can fake it using a\nCFG and some parsing kludges.\n8\n\n\fASTs\n\n9\n\n\fFrom lexical to syntactic\n\u25cf the lexer was responsible for splitting the source into \"words.\"\n\u25cf the parser looks at those words and extracts the syntactic structure\nfrom them, building a tree representation of your program.\nsource\ncode\n\nLexer\n\ntokens\n\nParser\n\ntree\n\nthe parser typically implements a CFG whose alphabet (the set of\nterminals) is the tokens that were produced by the parser.\nin doing so it checks your syntax \u2013 to make sure you\nwrote something that, well, looks like a program.\n10\n\n\fA tree of the syntax, which is abstract\n\u25cf the abstract syntax tree (AST) is the structure the parser builds.\n\u25cf trees are much easier to work with than lists of characters or tokens.\n\nif(x) y(2);\nelse return;\n\nIfElseStmt\ncond\n\nIdentExp\nname\n\nT\n\nF\n\nCallExp\n\n\"x\"\n\ncallee\n\nReturnStmt\n\nargs[]\n\nvalue\n\n\u00f8\nIdentExp\nname\n\n\"y\"\n\nIntExp\nvalue\n\n2\n11\n\n\fWhy is it called \"abstract\"?\n\u25cf because we can change the syntax of our language but the AST\nrepresentation doesn't have to change. it decouples them.\nJava/C if(x) y(2); else return;\n\nIfElse\n\nRust if x { y(2); } else { return }\n\nLua if x then y(2) else return end\nRuby if x\nPython if x:\ny 2\ny(2)\nelse\nelse:\nreturn\nreturn\nendif\n\nIdent\n\nCall\n\nIdent\n\nReturn\nInt\n\nof course, these languages work differently,\nbut the point is that the syntax is just fluff.\n12\n\n\fValues, expressions, and statements\n\u25cf computation is the act of transforming values into different values.\no values are just things like ints, strings, objects, etc.\nwhen you execute an\nexpression, you get a value.\n2.8\n\nx + y\n\nsin(2 * ang)\narr[i] + \";\"\n\nobj.field\n\nwhen you execute a\nstatement, you\u2026 don't.\n\nreturn;\n\nif(\u2026) \u2026\nelse \u2026\n\nprintf(\"hi!\\n\");\n{ \u2026statements\u2026 }\n\nbut there are many exceptions, and not\nevery language makes this distinction.\nit's good to know the terms though, cause\nthey come up a lot in parsing and semantics.\n\n13\n\n\fWhat about Rust?\n\u25cf actually, Rust only has expressions. everything can give a value.\nlet x = if y { 10 } else { 20 };\nfn radix(c: char) -> Base {\nprintln!(\"in radix\");\nmatch c {\nthis demonstrates a sort of\n'x' | 'X' => Base::Hex,\nconfusing rule: you can omit\n'b' | 'B' => Base::Bin,\nreturn if you're in the last\n_\n=> Base::Dec,\nexpression in the function.\n}\n}\nthis match is the last expression, so whatever\nvalue it gives becomes the return value!\nbut this is confusing, so I won\u2019t use it this term. :)\n14\n\n\fTrees in Rust\n\n15\n\n\fIn Java\u2026\n\u25cf you may have learned about trees (or their one-dimensional cousins,\nlinked lists) and seen them written like this:\nclass Node<T> {\nNode<T> left, right;\nT value;\nNode(T t) { value = t; }\n}\n\nNode<Integer> a = new Node<>(5);\na.left = new Node<>(2);\na.right = new Node<>(7);\n\nleft and right have two special properties that\nmake this representation work:\n1. they are references: they refer indirectly to\nNode objects.\n2. they can optionally hold null to indicate that\nthey are not pointing to anything.\n\n5\n2\n\n7\n\n16\n\n\fDoing it in Rust?\n\u25cf if we try to do this, we get an error:\nstruct Node<T> {\nleft: Node<T>,\nright: Node<T>,\nvalue: T,\n}\n\nit says this type has\ninfinite size, but it\ngives us a hint:\nstruct Node<T> {\nleft: Box<Node<T>>,\nright: Box<Node<T>>,\nvalue: T,\n}\n\ngreat, it compiles! what the heck does it mean tho\n17\n\n\fI would not eat them with a fox\n\u25cf a Box is the simplest kind of reference in Rust: it allocates an object\non the heap (just like Java's new) and points to it indirectly.\n\u25cf you create a boxed object with Box::new():\nlet x = 10;\n// an int on the stack\nlet b = Box::new(20); // an int on the heap\nCall Stack\n\nHeap\n\nx\n\nthe Box\n\nb\n\n10\n\n20\n\nI mean, normally you wouldn't box an\nint, but it's just for the example.\n\nokay, let's make a\nNode<T> then!\n\n18\n\n\fCurses! Foiled again!\n\u25cf when you make a struct, you have to give values for all the fields.\nstruct Node<T> {\nleft: Box<Node<T>>,\nright: Box<Node<T>>,\nvalue: T,\n}\n\nlet a = Node {\nvalue: 5,\nleft: Box::new(Node {\nvalue: 2,\nleft: \u2026\u2026\u2026uhhhhhhhh\n\n5\n2\n\n7\n\nwhat do we write for left, here? 2 has no left child.\nwhat we've made here is a type that is impossible to construct!\n\nso we need something to satisfy the other important property\nof the Java Node<T> variables: the possibility of being null.\nthe solution is to use Option<Box<Node<T>>>.\n19\n\n\fOption<Box<Node<T>>>? That's\u2026 verbose\n\u25cf a little, yeah. but this comes up less often than you\u2019d think.\n\u25cf add a constructor and it becomes easy to use:\nstruct Node<T> {\nleft: Option<Box<Node<T>>>,\nright: Option<Box<Node<T>>>,\nvalue: T,\n}\n\nlet mut a = Node::new(5);\na.left = Some(Node::new(2));\na.right = Some(Node::new(7));\n\nand now we have something very similar to the\noriginal Java, except we have to use Some(..) to\nindicate the opposite of None (aka null).\n\n5\n2\n\n7\n\nthis code is in the rust_trees example.\n20\n\n\fA brief digression on Option\n\u25cf let\u2019s look at another example, rust_option!\n\u25cf Option gives you something like Java\u2019s null, but it\u2019s opt-in, and\nworks on any type, not just object references.\n\u25cf there are a few ways of \u201cgetting the value out of\u201d an Option, but\u2026\no .unwrap() is the most risky, cause it could crash your program!\n\n21\n\n\fDefining and using an\nAST\n\n22\n\n\fBefore we get to a real language\u2026\n\u25cf let's start with something simple.\n\u25cf maybe we're writing some calculator software and want to represent\nwhat the user types in symbolically, instead of just evaluating it.\n\u00d7\n\nhow we get from what was\ntyped in at the bottom to\nthe tree up top is a topic for\nan upcoming lecture, but\u2026\n\n\u00f7\n\n+\n2\n\n3\n\n5\n\n-40\n\nif the expression is a tree,\nwe can have fun with it!\n\n(2 / -(3 + 5)) * -40\n23\n\n\fRepresenting this tree\n\u25cf we've got a few kinds of AST node here:\no constants (2, 3, 5, -40)\no negation (-x)\no addition, subtraction, multiplication, division\n\u25aa we can group these under a single kind: binary operators\n\u25aa not binary as in the base, binary as in \"has two operands\"\n\n\u25cf when you have choices of a type, the thing to use is an enum.\n\u25cf this enum appears in the ast_math example:\nenum AstNode {\nConst { val: f64 },\nNegate { lhs: Box<AstNode> },\nBinary { op: BinOp, lhs: Box<AstNode>, rhs: Box<AstNode> },\n}\n\nlook, no Options!\n24\n\n\fRecursion Refresher\n\u25cf recursion is a programming technique where a function calls itself.\n\u25cf there is an important fact about recursion that a lot of people are\nhazy on, even as juniors and seniors:\n\nlocal variables are duplicated for each recursive call.\nfn sum(x: i32) -> i32 {\nif x <= 1 {\nreturn x;\n} else {\nreturn x + sum(x \u2013 1);\n}\n}\nif I call sum(5), every recursion gets its\n\nown copy of x, and the in-progress\nrecursions do not \u201cshare\u201d that variable.\n\nStack\nsum(5) x = 5\nsum(4) x = 4\nsum(3) x = 3\nsum(2) x = 2\nsum(1) x = 1\n\n25\n\n\fTrees \u2665 Recursion\n\u25cf forget Fibonacci: recursion is exactly what you need for trees.\n\u25cf we have this tree, and a variable pointing to the root.\nhow do you evaluate a multiplication?\n\u00d7\n\n\u00f7\n\n-40\n\nthe first two steps are done as recursive\ncalls to evaluate the two children.\n\n-\n\n2\n\n+\n3\n\n1. evaluate the left-hand side (LHS)\n2. evaluate the right-hand side (RHS)\n3. multiply them together\n\n5\n\nthat's it. that's how you write a recursive\nalgorithm over a tree. (see AstNode::eval)\n26\n\n\fWhat else could you do with them?\n\u25cf you could apply transformations to the tree.\n\u25cf maybe we have a calculator feature to get the reciprocal.\ndoing \"one over\" means\nadding two new nodes and\nmaking the division the root.\n\n\u00f7\n+\n3\n\n7\n\n1\n\n+\n3\n\nof course, if the input is a\ndivision, we can special-case it.\n\n\u00f7\n\n\u00f7\n2\n\n7\n\n5\n\n5\n\nthis is what AstNode::recip in the example does!\n\n2\n27\n\n\fWhat if the programmer could do that?\n\u25cf some languages have macros: things that look like functions, but\nwhich operate on the AST at compile-time.\no that\u2019s really what println!() is!\no the details of how println!() works are beyond the scope of this\nlecture but that's why it yells: it's a macro, not a function. it\ngenerates different ASTs based on what arguments you give it.\n\u25cf if you've experienced C's preprocessor macros (#define), those are\nsimilar, but they operate on tokens instead of the AST.\no still, you can do some impressive stuff with them!\n\n28\n\n\fOk, but, how does the AST get built\n\u25cf uhhhhhhhhhhhhhhhh wellll\no parsing!!!!!!\no parsing is definitely more complicated than lexing\no which is why we have the next two lectures dedicated to it.\n\u25cf but that's all for today. good luck on the project, have a nice break,\nand see you in a week!\n\n29\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}