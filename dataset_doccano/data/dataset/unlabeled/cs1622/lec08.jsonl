{"id": 214, "segment": "unlabeled", "course": "cs1622", "lec": "lec08", "text": "Scoping and Naming\nCS 1622\nJarrett Billingsley\n\n\fClass Announcements\n\u25cf how\u2019s project 2 coming along (:\n\n2\n\n\fSymbol Tables and\nScope Trees\n\n3\n\n\fScoping it out\n\u25cf the first phase of semantic analysis is name-checking, which:\no matches names to the things they refer to; and\no checks for scoping violations.\n\u25aa remember that the scope of a name is where it can be seen.\n\u25cf so how do we do this stuff?\no well, like many other things we've talked about, it's about\nformalizing our intuition: taking rules that we kind of know\nalready, and turning them into an algorithm.\n\u25cf we also need a data structure or two\u2026\no we need to remember where each name is declared\no and we need some mapping from names to referents\n\u25cf so let\u2019s start with\u2026\n\n4\n\n\fSymbol tables\n\u25cf a symbol table maps from names to the \"things\" they refer to.\no symbol means anything that can have a name: variables,\nfunctions, classes, modules, packages, interfaces, macros, etc. etc.\n\u25cf as you declare things, they are added to the symbol table.\nName\nReferent\nclass A {\n\"A\"\n<class A>\nstatic int x = 5;\nstatic void main() {\n\"x\"\n<int x>\nfoo(x);\n\"main\"\n<void main()>\n}\n\"foo\"\n<void foo()>\nstatic void foo(int y) {\nS.o.println(y);\n\"y\"\n<int y>\n}\n}\nbut you can't see y from main\u2026 so should it be in this table?\n5\n\n\fInstead of ONE symbol table\u2026\n\u25cf we nest the symbol tables in a tree. there's one for each scope.\nclass A {\nstatic int x = 5;\nstatic void main() {\nfoo(x);\n}\n\nstatic void foo(int y) {\nS.o.println(y);\n}\n}\n\nthis outermost (global) scope\nis where e.g. System lives. A is\ninserted there too.\nthe class A gets a scope to\nhold its members, like its\nvariables and methods. this\nscope is a child of the\nglobal scope.\n\nthen each method gets its\nown scope, both of which\nare children of A's scope.\n6\n\n\fThe scope tree data structure\n\u25cf it's a tree, where each node is a scope, which has a symbol table.\n\u25cf the symbol tables map from names to the nodes in the AST which\ndefine those names.*\n\"The AST\"\n<global scope>\n\n\"A\"\n\"System\"\n\nA's scope\n\nmain's scope\n\nclass A {\nstatic int x = 5;\nstatic void main() {\nfoo(x);\n\n\"x\"\n\"main\"\n\n}\n\n\"foo\"\n\nstatic void foo(int y) {\nS.o.println(y);\n\n<empty>\n\n}\n}\n\nfoo's scope\n\n\"y\"\n7\n\n\fParent scopes\n\u25cf each child scope also needs to know which scope is its parent.\no (this is used in the name resolution algorithm.)\n\u25cf that means we've got bidirectional links between the scopes.\n<global scope>\n\nA's scope\n\nmain's scope\n\nfoo's scope\n\nthis is going to have implications\nfor the way we implement this\ndata structure in Rust\u2026\nbut then each scope has a symbol\ntable which somehow points into the\nAST? how do we deal with that?\nmaybe we could integrate\nthis into the AST??\nWELL, NO\u2026\u2026..\n\n8\n\n\fSyntax, not semantics\n\u25cf since the scopes more or less follow the syntax ({} \u2245 scope)\u2026\no we might be tempted to jam the scope tree into the AST somehow.\no this is a really bad idea.\n\u25cf the AST is an abstract syntax tree, but we're moving beyond syntax.\no the relationships established by name resolution can crisscross the\nwhole program and form any shape of graph, including cycles.\no and as we get further into semantic analysis \u2013 and then into\noptimization and code generation \u2013 the syntax will become less\nand less relevant.\n\u25cf so, the scope tree data structure should exist in parallel to the AST.\no we'll represent the links between the two data structures in an\nindirect way, as we'll see\u2026\n\n9\n\n\fName Resolution\ntime check \u2264 20\n\n10\n\n\fDeclaration vs. use\n\u25cf when we declare classes, variables, functions etc. that makes the\nname available for use by other pieces of code.\no a declaration essentially inserts a name into a symbol table.\n\nint x = 0;\nx = x + 1;\nprintln(x);\nx = f();\nreturn x;\n\nthis is the declaration of x. it puts x\ninto this scope\u2019s symbol table.\nall of these other places where we\nrefer to x by name are called uses.\n\nfor each of these uses, we have to perform name\nresolution: determining which symbol the use refers to.\n\nthe scope tree/symbol tables and the scoping rules are\nwhat we'll use to implement name resolution!\n11\n\n\fClimbing the tree (animated)\n\u25cf the name resolution algorithm is actually pretty straightforward.\n<global scope>\n\n\"A\"\n\"System\"\n\nA's scope\n\n\"x\"\n\"main\"\n\"foo\"\n\nfoo's scope\n\n3. go to the parent scope of\nthat one. is System there?\nyes! name resolved.\n\n2. go to the foo's parent\nscope. is System there?\n\n\"y\"\n\nstatic void foo(int y) {\nSystem.out.println(y);\n}\n\nstill no?\n\n1. is System declared in foo's scope?\n\nthis use of System appears in foo's scope. let's start there.\n\nno?\n\n12\n\n\fWhat if it fails?\n\u25cf what if we get up to the global scope and there's no match?\no well, that's an error. that's when your compiler says \"unresolved\nsymbol\" or \"undefined name\" or whatever.\n\u25cf but it could \"fail\" in another way:\nint x = System + 5;\no assuming I didn't declare a variable named System\u2026\no this is nonsense. how do you add a class and an integer?\n\u25cf well, don't worry about it. not at this stage, anyway.\no name resolution only cares about matching names to the things\nthat declared them.\no this example is a type error and will be caught further on during a\nsubsequent phase of semantic analysis.\n\n13\n\n\fKeeping track of resolved names\n\u25cf we could perform name resolution every time we need to know the\nreferent during subsequent compiler phases.\no but real-world experience (by other people) has shown that these\nresolutions happen a lot and that can waste a lot of time.\n\u25cf since the referent never changes, it makes sense to remember that.\n\nint x = 0;\nx = x + 1;\nprintln(x);\nx = f();\nreturn x;\n\nwe can do this by keeping a map which maps\nfrom the AST nodes which use a name to the\nnode which declares it. this is yet another data\nstructure that I call the use map.\n\nit\u2019s a bit like drawing arrows all over the code.\nagain, we'll see how to implement this soon\u2026\n14\n\n\fAccessing names inside things\n\u25cf this piece of code presents another interesting scenario:\nSystem.out.println(y);\nis this also a name resolution??\nwell, yes! this is saying \"access out from the System scope.\"\nbut there's a complication: we may not be able to\nperform the resolution until after we do typechecking:\nobj.x = 10;\n\nhere, we have to know what type obj is to\nknow if x is a valid name inside of that type.\n\nthen we will have to check that the type of x is actually valid\nfor this assignment! wow! very circular!!\nfortunately this is a relatively limited situation that can be resolved later\u2026\n15\n\n\fForward/mutual references\n\u25cf a forward reference is when the use of a name occurs before its\ndeclaration in the source code.\nclass A { B b; } this is a forward reference, because B is\nclass B {}\ndeclared later.\nif we did all the name stuff in one pass, we would get an\nerror here because B doesn\u2019t exist in the symbol table yet!\nthis means we have to do name stuff in two passes:\non the first pass, we build the scope tree and insert\ndeclarations into each scope\u2019s symbol table;\n\nthen on the second pass, we can do the name\nresolution using the already-built symbol tables.\n16\n\n\f\u2026but that doesn\u2019t work for locals\n\u25cf consider this code:\n\nstatic void func() {\nyou know that this is wrong. but why?\nS.o.println(x);\nint x = 10;\n}\nthe code in a function executes in order, including local\nvariable declarations. so on the first line, x has no value yet.\nthere are two ways to solve this:\n1. introduce a new scope that begins after each local\ndeclaration and ends at the enclosing close-brace; or\n2. do the name resolution at the same time as scopebuilding, but only for the code within functions.\n17\n\n\fAnnotating the AST\ntime check \u2264 55\n\n18\n\n\fThrowing arrows all over the place\n\u25cf we've now got two things that want to draw arrows all over the AST:\no symbol tables want to point at declarations\no name resolution wants to make AST nodes point at other ones\n\u25cf in a language like Java, \"arrows\" are object reference variables, and\nwe might be tempted to start throwing those everywhere.\no \u201cadd a field to Identifier AST nodes so they can point at the\ndeclarations they refer to!\u201d\no \u201cadd fields to { Block Statement } AST nodes to hold scope info!\u201d\n\u25cf OOP makes it really easy to start doing this\u2026\no but it's very difficult to stop once you've started, because it\ncreates tight coupling between the two \"ends\" of the arrow.\n\u25cf since we'll only be adding more info from now on (typechecking!), it\nmakes sense to reconsider how we \"add information\" to the AST.\n19\n\n\fNametags, not arrows\n\u25cf first, let's make a small change to our AST.\n\u25cf every AST node is given a unique identifier when it is created.\no this can be as simple as an int that's incremented for each node.\nf(y + 2)\n\nthis lets us create relationships\nwithout adding any arrows.\n\nCallExp:5\ncallee\n\nargs[]\n\nIdentExp:1\n\nAddExp:4\n\nname\n\nlhs\n\n\"f\"\n\nlet's say the name f resolves to\na function declared by node 49.\nthen in our name resolution\nmap, we add an entry with a\nkey of 1 and a value of 49.\n\nrhs\n\nIdentExp:2\n\nIntExp:3\n\nname\n\nvalue\n\n\"y\"\n\n2\n\n20\n\n\fWh.. but\u2026 why? Why not just point to the node?\n\u25cf decoupling is good practice. it gives you a cleaner design.\n\u25cf we can add arbitrarily many pieces of data to an AST node, without\nhaving to change the AST node types at all!\no we just add more maps that use the node IDs as keys.\no this lets us add new compilation passes and modularize the\ncompiler much more easily.\n\u25cf it improves compiler compile times by not requiring a recompile of\nthe entire compiler every time you change the AST type.\no and real compilers can be massive, so this is a big timesaver!\n\u25cf it can improve performance by exploiting physical locality.\no the cache in your CPU likes arrays and small structs.\no the AST node struct stays small, meaning it'll likely fit into cache.\no associated data can even be stored in a contiguous array.\n21\n\n\fAnother reason\n\u25cf we are also nudged towards this design by Rust.\nin Java, each object reference is\nan arrow, and there are no\nrestrictions on them.\nclass Node { Node[] others; }\n1\n\n2\n\n3\n\nin Rust, there are multiple kinds\nof pointers, but Box cannot be\nused to make cycles.\nstruct Node { others: Vec<Box<Node>> }\n1\n\n5\n\n4\n\n2\n\n3\n\n5\n\n4\n\nthis \"no cycles allowed\" thing is a central part of Rust's\nownership, borrowing, and memory safety semantics.\n\n22\n\n\fWhat??!? You can't have cycles in Rust?\n\u25cf well, you can, but it's discouraged by the language and libraries.\no Rc<T> is another kind of pointer that, with some care, can let you\nrepresent certain kinds of cyclical data structures.\n\u25cf it's not the Rust designer's fault that they made it harder to represent\ncyclical data structures.\no it's that cyclical data structures are just weird, and a lot of other\nlanguages don't really make that fact obvious.\no they either hide it, or don\u2019t give you the tools to manage it!\n\u25cf this restriction does give Rust some great advantages in memory\nsafety and multithreaded code correctness!\no which is kind of Rust's whole deal\n\u25cf but it does mean you have to stretch your mind a little.\no and interestingly, many of the solutions around this restriction end\nup being faster and easier to reason about.\n23\n\n\fImplementation Details\ntime check \u2264 85\n\n24\n\n\fWell Actually\n\u25cf in practice, it\u2019s a good idea to represent symbols as objects.\nclass A {\nstatic int x = 5;\nstatic void main() {\nfoo(x);\n}\nstatic void foo(int y) {\nS.o.println(y);\n}\n}\n\nID\n\nAST\n\nScope Name\n\nKind\n\n\u2026\n\n1\n\n3\n\n0\n\nA\n\nclass\n\n\u2026\n\n2\n\n7\n\n1\n\nx\n\nstatic var\n\n\u2026\n\n3\n\n12\n\n1\n\nmain\n\nstatic func\n\n\u2026\n\n4\n\n22\n\n1\n\nfoo\n\nstatic func\n\n...\n\n5\n\n24\n\n3\n\ny\n\nlocal var\n\n\u2026\n\n\u2026\n\n\u2026\n\n\u2026\n\n\u2026\n\n\u2026\n\n\u2026\n\nevery name declared in the program gets its own\nsymbol object with a unique symbol ID.\nextracting this info from the AST is time-consuming, so we only\ndo it once. these are what the symbol tables actually refer to.\n\n25\n\n\fBidirectionally linked scopes\n\u25cf an easy way to solve this is to keep all scopes in a vector, and have\nthem refer to each other by their index into the vector.\n<global scope>\nparent:\nNone\nchildren: [1]\nsymbols:\n\"A\"\n\n1\n\n\"System\"\n\n33\n\nindex:\n\n0\n\nA's scope\nparent:\nSome(0)\nchildren: [2, 3]\nsymbols:\n\"x\"\n\n2\n\n\"main\"\n\n3\n\n\"foo\"\n\n4\n\n1\n\nthis neatly dodges\nthe \"no cycles\" rule,\nand in practice isn\u2019t\nmuch harder to use\nthan direct pointers\n(Box<T>).\n\u2026\n\n2\n\n\u2026\n\n3\n26\n\n\fThe declaration and use maps\n\u25cf since we now represent symbols as their own \u201cthing,\u201d the declaration\nmap maps from AST nodes that declare a symbol, to that symbol.\n\u25cf the use map maps from AST nodes to the symbol they use.\n\nint x = 0;\nx = x + 1;\nprintln(x);\nx = f();\nreturn x;\nthe actual maps\nmap from Node IDs\nto Symbol IDs.\n\nID\n\nAST\n\n\u2026\n\n\u2026\n\n\u2026\n\n17\n\n54\n\n\u2026\n\n\u2026\n\nDecls\n\nScope Name\n\nKind\n\n\u2026\n\n\u2026\n\n\u2026\n\n\u2026\n\n3\n\nx\n\nlocal var\n\n\u2026\n\n\u2026\n\n\u2026\n\n\u2026\n\n\u2026\n\nUses\n\nAST\n\nSym\n\nAST\n\nSym\n\n74\n\n17\n\n76\n\n17\n\n\u2026\n\n\u2026\n\n78\n\n17\n\n\u2026\n\n\u2026\n27\n\n\fBundling it all up\n\u25cf the symbols, scope tree, declaration map, and use map are all\npackaged into one big object, the name context.\n\u25cf this can be used in later phases of the compiler!\nAST\n\nName\nchecking\n\nname context\nAST\n\nType\nchecking\n\ntype\ncontext\n\u2026?\n\neach phase of semantic analysis generates more information\nabout the program which later phases use.\nfor now, the AST will remain the central representation of\nthe program, but that may change later in compilation\u2026\n28\n\n\fBuilding the scope tree and symbol tables\n\u25cf the actual algorithm for building the scope tree is surprisingly simple.\n\u25cf the idea is like this:\no we recursively visit each node in the AST.\no if we take a function declaration node as an example\u2026\n\u25aa it will create a new scope as a child of the current scope\u2026\n\u25aa then visit its children (arguments and code) within that scope.\no something similar happens for { Block Statements }, classes etc.\no and when we see a declaration AST node, we insert a symbol into\nthe current scope.\n\u25aa this also inserts an entry into the declaration map.\n\u25cf and that\u2019s about it!\no there\u2019s the \u201cforward reference\u201d thing we talked about, and the stuff\nabout local variables, but those are just tweaks to this algorithm.\n29\n\n\fName resolution and building the use map\n\u25cf finally, name resolution is another recursive AST visit.\n\u25cf if this is done simultaneously with building the scope tree\u2026\no it\u2019s very simple: whenever you see an Identifier AST node, you\nperform name resolution starting at the current scope.\no if the name exists, add an entry to the use map.\no if it doesn\u2019t, it\u2019s an error.\n\u25cf if you built the scope tree in one pass and then do name resolution\nin a second pass after it\u2026\no there\u2019s some bookkeeping to make sure you start the name\nresolution in the correct scope, but it\u2019s otherwise the same.\n\u25cf and at the end, you now have all your data structures built and\nname-checking is complete!\no name-checking is the easiest semantic analysis pass, and things\nonly get harder from here (:\n30\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}