{"id": 242, "segment": "unlabeled", "course": "cs1622", "lec": "lec09", "text": "Typing\nCS 1622\nJarrett Billingsley\n\n\fClass Announcements\n\u25cf I may hold some Extra Office Hours on Friday\u2026 what time would be\nbest for those of you who think you may need them?\n\n2\n\n\fA little Type Theory\n\n3\n\n\fRemember what a type is?\n\u25cf a type is:\no a set of valid values, plus:\no a set of valid operations on those values\n\u25cf think about ints:\no there's a range of valid values of an int variable\no and a set of operators and other things you can use on them\n\u25cf type theory is a branch of mathematics\no it might seem kind of abstract and confusing (as most math does)\no but it has had profound impacts on the design and behaviors of\nprogramming languages, especially in the past 30 years\n\u25cf without rigorous type theory, you get C \ud83d\ude2c\n\n4\n\n\fI'll Curry YOUR Howards, isomorphically\n\u25cf remember from the beginning of the term: programs are proofs.\n\u25cf type systems are essentially proof justifications.\nthese justifications are saying,\n\"look, I'm using only valid\noperations on these values!\"\nsimilarly, when you say \"this\nvariable is an int,\" the compiler\nuses that information to justify\nthe steps of your program.\nif it can't\u2026 that's a type error!\n5\n\n\fType Safety = Progress + Preservation\n\u25cf type safety means that you know exactly what will happen at every\nstep of your program, because you know the types of everything.\nprogress means that at every step of computation:\n\u2026or there is exactly one\nthing that can happen.\neither the program halts\u2026\n\nint[] a = { 1, 2, 3 };\na[4] = 10; // halts\n\nint[] a = { 1, 2, 3 };\na[0] = 10; // assigns\n\npreservation means that you know the type of every value, at\nevery step of computation. (you never \"leave the walls\" of the type system.)\nJava is a type-safe language, so I can't give an example of that.\nbut what about the most popular language used for programming our operating\nsystems, device drivers, embedded device firmware etc.? \ud83d\ude43\n\n6\n\n\fA very unsafe language\n\u25cf in C, the type system was an afterthought.\n\nfloat f = 3.4;\nint a[10];\na[10] = 0xDEADBEEF;\nprintf(\"%f\\n\", f);\n\nthis line of code violates both\nprogress and preservation.\n\nit violates progress because accessing an array out-of-bounds is\n\"undefined behavior\" (UB), which means \"anything could happen.\"\nit violates preservation because one of the things that could happen\nis that this line overwrites the value in f, violating its type.\ndepending on the platform and compilation settings, this printf\nmight show 3.4 or -6259853398707798016.000000!\n7\n\n\fSafety has to be built-in\n\u25cf once you step into UB, you cannot guarantee anything.\no it's like writing a proof with an incorrect step.\no all the steps after may or may not be invalid!\no HLLs are a set of abstractions, and type-unsafety lets you ruin\nthose abstractions entirely.\n\u25cf you can't make C safe. this has big consequences:\no you can't do automatic memory management, because that\nrequires you to know the types of every value in the program.\no you can't prove that a C program is correct, because there are\nmany \"correct\" programs which actually violate type safety.\n\u25cf you can't be superhuman. sorry, but no amount of \"just write the\ncode correctly\" is going to lead to correct C code. mistakes happen.\no this is why languages like Java and Rust exist!\n8\n\n\fDecidability\n\u25cf decidable means: \"can this question be answered in finite time?\"\n\u25cf type-checking is an algorithm, so it can be undecidable.\no we can make our type system so powerful that we'd have to solve\nthe halting problem to check our program's types!\n\u25aa which maybe seems like a bad thing, right?\n\u25cf there's this other related thing that I think is related to decidability?\no you can't predict the future.\no that means sometimes you can't know what type something is\nuntil runtime, no matter how clever your type system is.\n\u25cf so if you want programmers to have that (very useful!) ability, you\nhave to design your type system to allow for it in a safe way.\no we'll see some examples shortly.\n\n9\n\n\fType systems\n\n10\n\n\fThe primitive types\n\u25cf a language's problem domain is the problems it's designed to solve.\no most languages try to be \"general purpose\" and therefore give you\nrelatively few, simple primitive types, like int, char, bool, etc.\n\u25cf the hardware also dictates what primitives are available.\no e.g. on GPUs, 4-element vectors and 4x4 matrices are primitives!\n\u25cf domain-specific languages (DSLs) are designed to do one job well.\no these might have many primitive types, including types which don't\nseem very \"primitive\" at all.\no for example, a shell scripting language may have primitive types\nlike files, processes, and terminal emulators.\n\u25cf the set of primitive types is really a product of what problems you\nwant your language to be able to solve easily.\n\n11\n\n\fStatic vs. Dynamic typing\n\u25cf remember: static =\"before runtime;\" dynamic = \"at runtime.\"\nstatically typed languages\nassociate types with variables.\n\ndynamically typed languages\nassociate types with values.\n\nlet mut a = 10;\na = 20;\n// ok\na = \"hello\"; // bad\na = a / 2;\n// ok\n\nlet a = 10; // JS\na = 20;\n// ok\na = \"hello\"; // ok!\na = a / 2;\n// bad\n\nin dynamically typed languages, type errors\ncannot be found until you run the program.\nbut this is a spectrum: many statically-typed\nlanguages include dynamically-typed features too!\n12\n\n\fDynamic types in static languages\n\u25cf sometimes it's useful not to know the type until runtime.\nclass A { String toString() { return \"A\"; } }\nclass B { String toString() { return \"B\"; } }\n\nObject o;\nif(user types A)\no = new A();\nelse\no = new B();\no.toString();\n\nthis works because of Java's subtyping\nrules and virtual methods.\n\ncalling toString() is a valid operation on any\nObject, and every class instance is an Object.\nthis is a form of existential polymorphism: we\ndon't know what type it is until runtime, but we\nat least know that it will support this operation!\n13\n\n\fType coercion (\"punning\") and conversion\n\u25cf type coercion is when the language will let you use the \"wrong\"\ntype and it will automatically turn it into the \"right\" one.\n\u25cf type conversion creates a new value of a different type.\no some type coercions do a type conversion; some don't!\nimplicit conversions like these can\n// Java\nmake code shorter and more readable\u2026\nint x = 10;\nbut they can be confusing too:\nfloat f = x;\n// now f == 10.0\n// JavaScript\nint x = 10;\nlet x = 10 + \"20\";\nString s = \"x = \" + x;\nlet y = 10 \u2013 \"20\";\n// now s is \"x = 10\"\n// x == \"1020\"\n// y == -10 ?!\n14\n\n\fStrong vs. Weak typing\n\u25cf different people use \u201cstrong\u201d and \u201cweak\u201d to mean different things.\none definition is basically the\nsame as type safety: it says\nthat weakly-typed languages\nlet you \u201cstep around\u201d the type\nsystem, while strongly-typed\nlanguages keep you in.\n// C\nbool b = true;\nint* p = (int*)&b;\n*p = 700; // wat.\n\nanother definition is that weaklytyped languages do lots of\nimplicit conversions and almost\nnever give type errors, instead\nchoosing to \u201cdo something else.\u201d\n// JavaScript again\nalert([] + []); // \"\"\nalert({} + {}); // NaN\nalert({} + []); // 0\nalert([] + {}); // {}\n\nI like to think \u201dweakly-typed\u201d means \u201cthe language doesn\u2019t\ncare about types, for some value of \u2018doesn\u2019t care\u2019\u201d lol\n\n15\n\n\fThe typing alignment chart\n\u25cf if we treat strong/weak and static/dynamic as axes on a spectrum\u2026\nstrong\nPython\nRust Fortran\nJava\nTypeScript\ndynamic\n\nstatic\n\nC++\n\nJS\n\nPHP\nweak\n\nC\n16\n\n\fType inference\n\u25cf type inference automatically determines what type something is.\n\u25cf you may not know it, but you've been using it for years.\n\nint x = 10;\nint y = x + 5;\n\nthe compiler implicitly determines the\ntypes of the parts of the expressions, and\nwhich addition operation to do.\n\nimagine having to write this\u2026\n\nint x = 10:int;\nint y = x:int +:int 5:int;\ntype inference can go further, too, like variables in Rust!\n\nlet x = 10;\n// x: i32\nlet y = Some(x); // y: Option<i32>\n17\n\n\fDefining Type Systems\n\n18\n\n\fTerms and types\n\u25cf a term is a thing that has a value.\no it's either a value itself, or it can be evaluated to get one.\n\u25aa (that sounds a lot like an expression\u2026)\n\u25cf every value has a type, and therefore every term has a type.\nPL theory writes this relation like so:\nterm:Type\nlike:\nx:i32\nand now you know why Rust uses this syntax.\n\n19\n\n\fInference rules\n\u25cf a type system's inference rules explain how to give a type to a term.\n\u25cf some rules are axiomatic: they are the \"ground truth\" of the types.\n\u25cf others say how to determine the type of a more complex term.\nhere's an axiomatic rule that says all\ninteger literals are of type int:\n\nand here's a rule for\ninteger addition:\n\n<IntExp>:int\n\nt:int u:int\nt + u :int\n\n(where IntExp is the kind of AST\nnode that represents integer literals.)\n\n\"if t is an int and u is an int,\nthen (t+u) is an int.\"\n\nour type checking algorithm will be driven by these rules.\nif no rule can be applied, it's a type error!\n20\n\n\fThe type context\n\u25cf in addition to the axiomatic rules, we also need some context to\nassign types to some terms, like variables.\n\nint x = 10;\nhow do we know what type x is?\nint y = x + 5;\n\nwe have to look back to its declaration.\n\nfortunately, name resolution has already\ndetermined which symbol x refers to!\nthe type context is another mapping: it associates\nsymbols in the symbol table with types.\nhere, int x explicitly associates x with the type int\u2026\nbut in languages with type inference, the type of the\ninitializer would have to be determined first.\n21\n\n\fTruss's type system\n\u25cf let's examine the type system of this toy language to get familiar\nwith how these concepts play out.\n\u25cf first, it has a set of four primitive types.\no int: a signed 32-bit integer\no bool: a truth value, true or false\no string: an immutable sequence of 0 or more codepoints\no (): the absence of a type, called void\n\u25aa this is only used for function return types.\n\u25cf it might not look like it, but we've sort of implicitly defined the sets\nof valid values for each type.\no there are 232 valid values for int\u2026\no 2 valid values for bool\u2026\no and so on.\n22\n\n\fFunction Types\n\u25cf any language that has functions will also need a type for them.\n\u25cf or to be more accurate, a type constructor for them.\nTruss writes its function types like: fn(A0, A1, \u2026): R,\nwhere A0, A1 etc. are the arguments and R is the return type.\nfunctions can have any number of arguments, which is\nwhy the argument types are written like that.\n\nhere are some valid function types:\nfn(): ()\nfn(int): int\nfn(string, string): bool\nfn(fn():()): ()\n\nthe last one is a higher\norder function: it takes a\nfunction as an argument!\n\nTruss also has structs, but we'll come back for those later\u2026\n\n23\n\n\fInference rules\n\u25cf we need rules for every operation in the language. examples:\nt:int u:int\nfor any op in { +, -, *, /, % }\nt op u :int\nt:string u:string\n(this is for string concatenation!)\nt + u :string\nt:int u:int\nfor any op in { ==, !=, <, <=, >, >= }\nt op u :bool\nt:bool u:bool\nfor any op in { and, or }\nt op u :bool\nf:fn(A\ud835\udfce ,A\ud835\udfcf ,\u2026 ):R a\ud835\udfce :A\ud835\udfce a\ud835\udfcf:A\ud835\udfcf\nf(a\ud835\udfce , a\ud835\udfcf, \u2026):R\n\n\u2026\n\nthis says, \"the type of a function call is the function's return type.\"\n24\n\n\fWhat about statements?\n\u25cf statements have gotten left out of the discussion, because they\ndon't evaluate to a value, and therefore have no type.\n\u25cf but statements can interact with the type system nonetheless.\nwhat type does the condition have to be, in Java?\n\nif(x < 10)\nprintln(\"yep\");\n\nboolean.\n\nsimilar things apply for loops, switches (and Rust matches),\nreturn statements, and so on.\n(we could also say that statements have a type like () or void,\nbut it isn't strictly necessary to do this.)\n25\n\n\fImplementation Details\n\n26\n\n\fData structures needed\n\u25cf we'll need to represent types in the compiler.\no this can be as simple as a Rust enum, very similar to how we\nrepresent the kinds of AST nodes.\n\u25cf we'll also need the type context like we said before.\no we said we needed this to map from symbols to types\u2026\no but we're going to extend this to all AST nodes that can have\ntypes, because subsequent compiler passes will need this info.\no this will get filled in as we do type checking.\n\u25cf finally, we need a way to represent the terms\u2026\no wait, don't we have that already?\n\n27\n\n\fOH, right, the AST!\n\u25cf the AST encodes terms as trees.\n\u25cf this implies a relatively straightforward way to check for types:\n1. do a depth-first traversal\nto typecheck the leaves,\nusing the axiomatic rules\nand type context;\n2. typecheck the internal\nnodes according to the\ntypes of their children,\nusing the inference rules.\n\nCallExp\n\ncallee\n\nargs[]\n\nIdentExp\nname\n\nf(y+2)\n:()\n\nAddExp\n\n\"f\"\n\nlhs\n\nrhs\n\ny+2\n:int\n\nf:fn(int):()\nIdentExp\nname\n\n\"y\"\n\ny:int\n\nIntExp\nvalue\n\n2\n\n2:int\n\n28\n\n\fImplementing the inference rules\n\u25cf the inference rules are easier to implement than they might seem.\n\u25cf most of the checks boil down to: is this type equal to that type?\n\u25cf for instance in this rule:\nt:int u:int\no\nfor any op in { ==, !=, <, <=, >, >= }\nt op u :bool\n\u25cf if I am looking at an AST node for a ==, the check goes like this:\n1. check that LHS's type equals int, and give an error if not.\n2. check that RHS's type equals int, and give an error if not.\n3. set this == AST node's type to bool in the type context.\n\u25cf that's it. some of the rules are more involved, but it's rarely much\nmore complex than just checking type equality.\n\n29\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}