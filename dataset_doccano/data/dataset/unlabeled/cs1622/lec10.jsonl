{"id": 229, "segment": "unlabeled", "course": "cs1622", "lec": "lec10", "text": "Advanced Typing\nCS 1622\nJarrett Billingsley\n\n\fClass Announcements\n\u25cf the exam is on Monday, don\u2019t forget!\no we\u2019ll do a little review before we start.\no it will be taken on Canvas, but in person, so bring a computer.\no also do not use Safari, mac users! issues with Canvas exams!\n\u25cf now let\u2019s do some ADVANCED TYPING\n\n2\n\n\fPolymorphism\n\n3\n\n\fPoly = Many, Morph = Shape\n\u25cf abstraction is about ignoring concrete details.\n\u25cf polymorphism lets us write abstract code once, that can work on\nmany types of values, without having to change the code.\n\u25cf it covers a wide range of techniques and language features, like\u2026\no subclasses in Java, C++, Python\no interfaces in Java, Go and traits in Rust\no generics in Java, Rust\no templates in C++\no function name overloading in Java, C++\no operator overloading in C++, Rust, Python\no unions and void pointers in C\no duck typing in most dynamically-typed languages\no anything with \"late binding\" in the name\n4\n\n\fDon't repeat yourself.\n\u25cf repeating code is a cardinal sin. encode your thoughts once.\n\u25cf polymorphism lets us avoid repeating code.\n\nArrayList<Integer> i = new ArrayList<>();\nArrayList<String> s = new ArrayList<>();\nthe task of keeping an array-based list of things doesn't\nchange depending on what type of things are in the array.\nwe don\u2019t have to make a new ArrayList class for\nevery type of value we want to store. we wrote it\nonce, and now it will work for any type of value.\n\nwe can even make functions which operate on any type of ArrayList:\n\n<T> void foo(ArrayList<T> list)\n5\n\n\fWhat type is it?\n\u25cf the basic idea is that polymorphism lets us make values which can\nhave more than one possible type.\nObject\nBase\nA\n\nB\n\nwith this class hierarchy, I can make a Base\nvariable which can hold 3 different types.\n\nvoid print(int i);\nvoid print(String s);\nwhat type is this print method?\n\nI guess it's a set of types\u2026?\n\n6\n\n\f\"Ad-Hoc\" Polymorphism\n\n7\n\n\fYou know about this: overloading!\n\u25cf this is something you can do in Java (but not Rust):\nvoid print(int i);\nvoid print(String s);\n\u25cf now when I call print(x)\u2026\no which version, or overload, is used is decided statically based on\nthe type of the argument.\n\u25cf each overload can do different things, which can be useful!\no \u2026but if they're all doing basically the same thing, it feels silly.\no have a look at java.util.Arrays for an example of what I mean.\n\u25cf it's called ad-hoc because you just add overloads as you need them,\nand the compiler figures out what you mean.\n\u25cf so how would this be handled by a compiler?\n\n8\n\n\fImplementing overloading in a compiler\n\u25cf essentially, we're just extending the symbol table.\nas the user adds more overloads,\nthe set can be extended.\n\nName\n\nReferent\n\n\"A\"\n\n<class A>\n\n\"print\"\n\n<overload set>\n\nSignature\n\nReferent\n\nnow a name can refer to either\na single symbol or a set of\nsymbols with the same name.\n\nvoid(int)\n\n<print 1>\n\nvoid(char)\n\n<print 2>\n\nvoid(String)\n\n<print 3>\n\nnow, when print is called, it searches for the\nright signature in the overload set, and gives an\nerror if none match or more than one match.\n9\n\n\fMore than one can match??\n\u25cf overloading is complicated by implicit type conversions.\n\u25cf for example, Java will implicitly convert ints to floats.\n\nstatic void print(int i, float f)...\nstatic void print(float f, int i)...\nprint(10, 10);\n10 can be implicitly converted to float, so this use of print could\nmean either overload. the compiler says this is ambiguous.\n\nyou don't even wanna know how ugly this gets in languages\nlike C++ where you can define your own implicit conversions.\n\n10\n\n\fName mangling\n\u25cf for practical reasons (linkers, debuggers, etc), these overloaded\nfunctions must be given unique names in the output object files.\n\u25cf name mangling encodes the function's signature \u2013 its argument\nand return types \u2013 into a textual form that these other tools can use.\n\nvoid print(int i, float f)\n=> \"_Z5printif\"\n(g++)\n=> \"?print@@YAXHM@Z\" (msvc++)\nvoid print(float f, int i)\n=> \"_Z5printfi\"\n(g++)\n=> \"?print@@YAXMH@Z\" (msvc++)\nnow you know what these horrid things are, if they\never show up in error messages\u2026\n11\n\n\fSubtype Polymorphism\n\n12\n\n\fYou know about this one too!\n\u25cf in subtype polymorphism, types can be placed in a hierarchy, where\nsubtypes are more specialized than their base types.\n\u25cf the important feature is: anywhere a base type is expected, a\nsubtype can be used in its place.\n\nvoid print(Object o) {\nSystem.out.println(o.toString());\n}\nany object type can be passed to this function, because all\nobject types are, directly or transitively, subtypes of Object.\nanother way of thinking of it is that the set of operations of each\nobject type is a superset of the set of operations of Object.\n13\n\n\fInterfaces\n\u25cf Java also has interfaces. every type can extend one class but can\nimplement any number of interfaces.\nObject\n\nBase\n\nComparable\n\nCloneable\n\nnow Base is a subtype of\nthree other types.\n\nwe write these relations as Base <: Object\n(or Object :> Base), Base <: Comparable,\nand Base <: Cloneable.\n\nbut interfaces exist \"outside\" the class hierarchy, letting us group\ntypes by their capabilities, not just their inheritance.\n\n14\n\n\fImplementing subtyping in a compiler\n\u25cf the compiler has to keep track of the subtype relations between\nclasses and interfaces.\no it also has to ensure that there are no cycles in the subtypes, like:\nclass A extends B {}\nclass B extends A {} // how??\n\u25cf then when doing typechecking, it will allow any type or its subtype to\nbe put into a variable, argument, array slot etc.\no Object o = new A(); is valid because A is a subtype of Object\no A a = new Object(); is not, because the opposite is not true.\n\u25cf it really is that straightforward!\no \u2026. ha ha ha sure yeah right\n\n15\n\n\fBut it's got\u2026 issues.\n\u25cf subtyping comes at a cost: complexity.\n\u25cf it interacts with every other feature of a language, often in non-trivial\nways, and even making some type systems undecidable.\nvoid print(Object o)...\nvoid print(A a)...\n\ndoes this make sense? is\nthis what you'd expect?\n\nthis happens because Java's\nA a = new A();\nad-hoc polymorphism is\n// calls print(A)\nstatically resolved, but its\nprint(a);\nsubtype polymorphism is\nObject o = a;\ndynamically resolved.\n// calls print(Object)\nprint(o);\nother languages have other ideas about\nthis \u2013 look up multiple dispatch.\n16\n\n\fImplementing subtyping at runtime\n\u25cf we won't get into the details for a few weeks, but\u2026\n\u25cf each class gets a data layout and a virtual method table (vtable).\n\u25cf subclasses' layouts and vtables are prefixed by their superclasses'.\nclass Object\n\nclass A { int x; void foo() {} }\n\nlayout\n\nvtable\n\nlayout\n\nvtable\n\nvtable\n\n<Object>\n\nvtable\n\n<A>\n\nmonitor\n\nclone()\n\nmonitor\n\nclone()\n\nequals()\n\nx\n\nequals()\n\ntoString()\n\ntoString()\nfoo()\n\nany A reference therefore points to a piece of memory\nwhich looks identical to an Object at the beginning.\n17\n\n\fSubtyping in Rust\n\u25cf Rust has no OOP, but it does support a form of subtyping and\ndynamic dispatch using traits, which are similar to Java interfaces.\ntrait Base {\nnow any type which implements\nfn base(&self);\nDerived must also implement Base.\n}\n// Derived is called a\nyou can also have variables of\n// supertrait of Base\ntype Box<dyn Base>, which are\ntrait Derived: Base {\nlike Java's interface variables.\nfn derived(&self) {\n// we can use\nthey can hold any type which\n// methods of Base\nimplements Base, and their methods\nself.base();\nwill be dispatched at runtime.\n}\n}\n\n18\n\n\fParametric Polymorphism\n\n19\n\n\fStatic and Dynamic\n\u25cf ad-hoc polymorphism is statically dispatched.\n\u25cf subtype polymorphism is (mostly) dynamically dispatched.\n\u25cf but dynamic dispatch is actually kind of costly on modern CPUs\u2026\n\no.toString();\n\nlw a0, 4(sp) # a0 = o\nlw t0, 0(a0) # t0 = o.vtbl\nlw t0, 16(t0) # t0 = o.vtbl[4]\njalr t0\n# indirect call\n\nthree dependent loads from three totally different places\nin memory make the pipeline and cache very unhappy.\nand then you have an indirect jump, which can confuse\nthe branch predictor and stall the instruction pipeline!\n20\n\n\fParametric polymorphism to the rescue\n\u25cf parametric polymorphism is a more explicit kind of polymorphism,\nwhere the types are a sort of \"fill in the blank.\"\n\u25cf the types themselves become an argument.\n\nfn id<T>(t: T) -> T {\nreturn t;\n}\n\nthis is a silly function which just returns its\nargument. \"id\" means \"identity.\" it's math stuff.\n\nthis is not one function. this is an entire family of\nfunctions, which take a T and return a T, for all types T.\nthis is universal quantification.\nwe're saying \u2200T, you can get an id function of type T\u2192T\n(a function that maps from T to T).\nwhat \"type\" is id, then?\n21\n\n\fUsing parametrically polymorphic functions\n\u25cf Rust lets you either explicitly or implicitly specify the type arguments.\n\nlet x: i32 = id::<i32>(10);\nlet y: i32 = id(20);\nlet z = id(30);\n\nthe ::<> operator is\ncalled \"turbofish.\" \ud83d\udc1f\ud83d\udca8\n\nin the second line, the compiler is able to infer\nwhat type should be passed as the type argument.\nin the third line, it infers the type of the variable too!\nall three lines use the same implementation of id, id::<i32>.\n22\n\n\fMonomorphization\n\u25cf but CPUs don't understand polymorphic code.\n\u25cf monomorphization converts each use of a polymorphic function\ninto a concrete, monomorphic (\"one-shape\") version of itself.\n\nlet x = id(10i32);\nlet y = id(3.5f64);\nlet z = id(\"hello\");\n\nid::<i32>\nid::<f64>\nid::<&str>\n\nthe compiler looks at every use of the function across the\nentire program to determine the implementations needed.\nit will reuse implementations if used in multiple locations\n(like if id::<i32> is used 100 times).\nessentially, it's automatically generating\nall the ad-hoc overloads for us!\n\n23\n\n\fGenerics without monomorphization\n\u25cf monomorphization gives you the best possible performance\u2026\no but it can slow compilation, and produce a larger executable.\n\u25cf so, in Java, generics are not monomorphized!\no if you have ArrayList<Integer> and ArrayList<String>, the\ncompiler treats them as separate types, but\u2026\no both of those use the exact same code at runtime.\no under the hood, all versions of ArrayList just use Object\nvariables and downcasts and instanceof to make it work.\n\u25cf this has advantages in compilation time and code size\u2026 but it comes\nat two big costs.\no one, you cannot use non-object types in Java generics.\n\u25aa this is why ArrayList<int> is invalid!\no two, the performance is mediocre.\n\u25aa but that's not really a main goal for Java so whatever!\n24\n\n\fBounded Quantification\n(or, \"making Parametric Polymorphism actually useful\")\n\n25\n\n\f\u2200 only gets you so far.\n\u25cf remember, a type has a set of values and a set of operations.\n\u25cf what operations can you do with a variable that can be any type?\no can you add it? index it? even print it out?\no well\u2026 no. because you don't know if the type will support those\noperations.\no about all you can do is copy values around (put them in variables,\npass them as arguments, return them) and that's not too useful.\n\u25cf well if we can make universal types, what about \u2203 existential types?\n\u25cf an existential type (or bounded quantification) gives you the\nflexibility to accept multiple types\u2026\no while saying, \"they need to support at least this set of operations.\"\n\u25cf it's a little easier to demonstrate than explain.\n\n26\n\n\fBounded quantification in Java\n\u25cf remember extends in generics?\n\n<T extends Comparable<T>> T max(T a, T b) {\nreturn (a.compareTo(b) > 0) ? a : b;\n}\nthis works for any type T as long as that type implements the\nComparable interface (against other values of the same type).\n\nSystem.out.println(max(3, 4));\n// prints 4\nSystem.out.println(max(\"a\", \"b\")); // prints b\nwithout the extends Comparable<T>, we wouldn't\nbe able to call .compareTo() in the method.\n27\n\n\fBounded quantification in Rust\n\u25cf Rust's traits do the same job as Java's interfaces here.\n\nfn max<T: PartialOrd>(a: T, b: T) -> T {\nif a > b { a } else { b }\n}\nPartialOrd is the closest thing Rust has to Java's Comparable,\nand the resulting function can be used the same way:\n\nprintln!(\"{}\", max(3, 4));\n// prints 4\nprintln!(\"{}\", max(3.3, 4.4)); // prints 4.4\n\n28\n\n\fBut what about using subtype polymorphism?\n\u25cf couldn't we just make our Java function take two Comparables?\n\u25cf well yes, but\u2026\n\nComparable max(Comparable a, Comparable b) {\nreturn (a.compareTo(b) > 0) ? a : b;\n}\nnow this nonsense code compiles and runs,\nand we get a runtime error instead:\n\nSystem.out.println(max(3, \"a\"));\nparametric polymorphism moves the type\nchecking into the compiler, allowing us to catch\nerrors without having to run the code, and without\nthe performance penalty of runtime type-checking*.\n29\n\n\fSummary\n\n30\n\n\fThe kinds of polymorphism\n\u25cf ad-hoc polymorphism is also called function overloading.\no it lets you define multiple versions of the same function with\ndifferent type signatures.\no the version that will be used is selected at compile time.\n\u25cf parametric polymorphism is also called generics or templates.\no it lets you define \"fill-in-the-blanks\" classes, structs, functions etc.\no the blanks can be filled in with any type\u2026 or with bounded\nquantification, only types which satisfy some condition.\no the types are filled in and checked at compile time.\no the generated code may or may not be monomorphized.\n\u25cf finally, subtype polymorphism is a feature of classes and interfaces.\no a derived value can be used anywhere a base type is required.\no when a virtual method is called, the version that is used is selected\nat runtime, based on the type of the object.\n31\n\n\fThe limits of typing and type systems\n\u25cf it doesn't matter how fancy your type system is\u2026\no it will never allow all correct programs.\nwe saw this previously when talking about Box in Rust.\n\nthis seemingly-simple object graph is impossible to directly\nrepresent in Rust because of its type system.\nbut that's the point. type systems limit what we can do,\nbecause unlimited ability leads to mistakes.\n32\n\n\fColoring inside the lines\n\u25cf type systems force us to work within a set of limitations, which can\nsometimes be annoying\u2026\no but it can also lead to simpler, more elegant solutions.\n\u25cf because static type systems are automatically checked by the\ncompiler, playing by their rules can avoid many silly mistakes.\no programming is hard. you need all the help you can get!\n\u25cf and with that\u2026\no we're done with the material before the exam \u00f6\n\n33\n\n\f", "label": [[-2, -1, "Concept"]], "Comments": []}