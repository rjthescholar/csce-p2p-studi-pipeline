['train_set', 'labeled']|cs0007|lec10
-DOCSTART- -X- -X- O

CS _ _ O
0007 _ _ O
: _ _ O
Introduction _ _ O
to _ _ O
Java _ _ O
Lecture _ _ O
10 _ _ O
Nathan _ _ O
Ong _ _ O
University _ _ O
of _ _ O
Pittsburgh _ _ O
October _ _ O
4 _ _ O
, _ _ O
2016 _ _ O

if _ _ O
( _ _ O
) _ _ O
recap _ _ O
/ _ _ O
/ _ _ O
always _ _ O
run _ _ O
this _ _ O
code _ _ O
if _ _ O
( _ _ O
condition1 _ _ O
is _ _ O
true _ _ O
) _ _ O
{ _ _ O
/ _ _ O
/ _ _ O
run _ _ O
this _ _ O
code _ _ O
} _ _ O
else _ _ O
if _ _ O
( _ _ O
condition2 _ _ O
is _ _ O
true _ _ O
) _ _ O
{ _ _ O
/ _ _ O
/ _ _ O
run _ _ O
this _ _ O
code _ _ O
} _ _ O
else _ _ O
if _ _ O
( _ _ O
condition3 _ _ O
is _ _ O
true _ _ O
) _ _ O
{ _ _ O
… _ _ O
} _ _ O
… _ _ O
else _ _ O
/ _ _ O
/ _ _ O
if _ _ O
conditions _ _ O
1…n _ _ O
were _ _ O
not _ _ O
satisfied _ _ O
{ _ _ O
/ _ _ O
/ _ _ O
run _ _ O
this _ _ O
code _ _ O
} _ _ O
/ _ _ O
/ _ _ O
always _ _ O
run _ _ O
this _ _ O
code _ _ O

Revisiting _ _ O
Scope _ _ B-Concept
• _ _ O
Scope _ _ B-Concept
works _ _ O
by _ _ O
curly _ _ O
brackets _ _ O
. _ _ O
• _ _ O
Curly _ _ O
brackets _ _ O
surround _ _ O
all _ _ O
newly _ _ O
declared _ _ O
information _ _ O
, _ _ O
keeping _ _ O
it _ _ O
hidden _ _ O
from _ _ O
code _ _ O
outside _ _ O
of _ _ O
the _ _ O
curly _ _ O
brackets _ _ O
. _ _ O

Scope _ _ B-Concept
Confidential _ _ B-Concept
Secret _ _ B-Concept
Top _ _ B-Concept
Secret _ _ I-Concept

Scope _ _ B-Concept
public _ _ O
class _ _ O
ScopeExample _ _ O
public _ _ O
static _ _ O
void _ _ O
main _ _ O
public _ _ O
static _ _ O
void _ _ O
func _ _ O
if _ _ O
if _ _ O
if _ _ O
else _ _ O
if _ _ O
Darker _ _ O
shades _ _ O
can _ _ O
see _ _ O
lighter _ _ O
shades _ _ O
, _ _ O
but _ _ O
not _ _ O
vice _ _ O
versa _ _ O

Scope _ _ O
in _ _ O
Code _ _ O
public _ _ O
class _ _ O
Name _ _ O
{ _ _ O
public _ _ O
static _ _ O
void _ _ O
main _ _ O
( _ _ O
String _ _ O
[ _ _ O
] _ _ O
args _ _ O
) _ _ O
{ _ _ O
int _ _ O
x _ _ O
= _ _ O
0 _ _ O
; _ _ O
/ _ _ O
/ _ _ O
x _ _ O
= _ _ O
= _ _ O
0 _ _ O
, _ _ O
y _ _ O
is _ _ O
undefined _ _ O
if _ _ O
( _ _ O
x _ _ O
= _ _ O
= _ _ O
0 _ _ O
) _ _ O
{ _ _ O
int _ _ O
y _ _ O
= _ _ O
10 _ _ O
; _ _ O
x _ _ O
= _ _ O
15 _ _ O
; _ _ O
/ _ _ O
/ _ _ O
x _ _ O
= _ _ O
= _ _ O
15 _ _ O
, _ _ O
y _ _ O
= _ _ O
= _ _ O
10 _ _ O
} _ _ O
/ _ _ O
/ _ _ O
x _ _ O
= _ _ O
= _ _ O
15 _ _ O
, _ _ O
y _ _ O
is _ _ O
undefined _ _ O
} _ _ O
/ _ _ O
/ _ _ O
end _ _ O
method _ _ O
main _ _ O
} _ _ O
/ _ _ O
/ _ _ O
End _ _ O
class _ _ O
Name _ _ O

A _ _ O
Special _ _ O
Annoying _ _ O
Case _ _ O
Scanner _ _ O
scanner _ _ O
= _ _ O
new _ _ O
Scanner _ _ O
( _ _ O
System.in _ _ O
) _ _ O
; _ _ O
int _ _ O
numTrees _ _ O
= _ _ O
scanner.nextInt _ _ O
( _ _ O
) _ _ O
; _ _ O
if _ _ O
( _ _ O
numTrees _ _ O
= _ _ O
= _ _ O
0 _ _ O
) _ _ O
{ _ _ O
System.out.println _ _ O
( _ _ O
"Desert _ _ O
" _ _ O
) _ _ O
; _ _ O
} _ _ O
else _ _ O
if _ _ O
( _ _ O
numTrees _ _ O
= _ _ O
= _ _ O
1 _ _ O
) _ _ O
{ _ _ O
System.out.println _ _ O
( _ _ O
"Island _ _ O
" _ _ O
) _ _ O
; _ _ O
} _ _ O
else _ _ O
if _ _ O
( _ _ O
numTrees _ _ O
= _ _ O
= _ _ O
2 _ _ O
) _ _ O
{ _ _ O
System.out.println _ _ O
( _ _ O
"Beach _ _ O
" _ _ O
) _ _ O
; _ _ O
} _ _ O
else _ _ O
if _ _ O
( _ _ O
numTrees _ _ O
= _ _ O
= _ _ O
3 _ _ O
) _ _ O
{ _ _ O
System.out.println _ _ O
( _ _ O
"Forest _ _ O
" _ _ O
) _ _ O
; _ _ O
} _ _ O
else _ _ O
{ _ _ O
System.out.println _ _ O
( _ _ O
"Jungle _ _ O
" _ _ O
) _ _ O
; _ _ O
} _ _ O

Switch-Case _ _ B-Concept
• _ _ O
A _ _ O
Switch-Case _ _ B-Concept
statement _ _ O
is _ _ O
like _ _ O
a _ _ O
long _ _ O
if _ _ O
, _ _ O
elseif _ _ O
, _ _ O
else _ _ O
block _ _ O
concerning _ _ O
only _ _ O
one _ _ O
variable _ _ O
and _ _ O
several _ _ O
possible _ _ O
discrete _ _ O
values _ _ O
( _ _ O
not _ _ O
ranges _ _ O
) _ _ O
. _ _ O
• _ _ O
This _ _ O
increases _ _ O
readability _ _ O
, _ _ O
but _ _ O
they _ _ O
act _ _ O
similarly _ _ O
. _ _ O
• _ _ O
Works _ _ O
for _ _ O
byte _ _ O
, _ _ O
char _ _ O
, _ _ O
short _ _ O
, _ _ O
int _ _ O
, _ _ O
and _ _ O
String _ _ O
. _ _ O
( _ _ O
Any _ _ O
others _ _ O
out _ _ O
of _ _ O
scope _ _ O
) _ _ O
• _ _ O
For _ _ O
every _ _ O
case _ _ O
possibility _ _ O
, _ _ O
you _ _ O
need _ _ O
a _ _ O
break _ _ O
statement _ _ O
, _ _ O
unless _ _ O
you _ _ O
wanted _ _ O
to _ _ O
combine _ _ O
several _ _ O
cases _ _ O
together _ _ O
. _ _ O

A _ _ O
Special _ _ O
Annoying _ _ O
Case _ _ O
Scanner _ _ O
scanner _ _ O
= _ _ O
new _ _ O
Scanner _ _ O
( _ _ O
System.in _ _ O
) _ _ O
; _ _ O
int _ _ O
numTrees _ _ O
= _ _ O
scanner.nextInt _ _ O
( _ _ O
) _ _ O
; _ _ O
switch _ _ O
( _ _ O
numTrees _ _ O
) _ _ O
{ _ _ O
case _ _ O
0 _ _ O
: _ _ O
System.out.println _ _ O
( _ _ O
"Desert _ _ O
" _ _ O
) _ _ O
; _ _ O
break _ _ O
; _ _ O
case _ _ O
1 _ _ O
: _ _ O
System.out.println _ _ O
( _ _ O
"Island _ _ O
" _ _ O
) _ _ O
; _ _ O
break _ _ O
; _ _ O
case _ _ O
2 _ _ O
: _ _ O
System.out.println _ _ O
( _ _ O
"Beach _ _ O
" _ _ O
) _ _ O
; _ _ O
break _ _ O
; _ _ O
case _ _ O
3 _ _ O
: _ _ O
System.out.println _ _ O
( _ _ O
"Forest _ _ O
" _ _ O
) _ _ O
; _ _ O
break _ _ O
; _ _ O
default _ _ O
: _ _ O
System.out.println _ _ O
( _ _ O
"Jungle _ _ O
" _ _ O
) _ _ O
; _ _ O
break _ _ O
; _ _ O
} _ _ O

ARRAYS _ _ B-Concept
, _ _ O
LOOPS _ _ B-Concept
, _ _ O
AND _ _ O
RECURSION _ _ B-Concept

A _ _ O
Sudden _ _ O
Need _ _ O
• _ _ O
I _ _ O
need _ _ O
a _ _ O
function _ _ O
that _ _ O
returns _ _ O
the _ _ O
first _ _ O
100 _ _ O
terms _ _ O
of _ _ O
the _ _ O
harmonic _ _ O
series _ _ O
. _ _ O
• _ _ O
Harmonic _ _ O
series _ _ O
: _ _ O
 _ _ O
1 _ _ O
1 _ _ O
1 _ _ O
 _ _ O
n _ _ O
1 _ _ O
 _ _ O
2 _ _ O
 _ _ O
3 _ _ O
 _ _ O
... _ _ O
n _ _ O
1 _ _ O

The _ _ O
Dumb _ _ O
Way _ _ O
public _ _ O
static _ _ O
void _ _ O
main _ _ O
( _ _ O
String _ _ O
[ _ _ O
] _ _ O
args _ _ O
) _ _ O
{ _ _ O
double _ _ O
term0 _ _ O
= _ _ O
1.0 _ _ O
; _ _ O
double _ _ O
term1 _ _ O
= _ _ O
1.0 _ _ O
/ _ _ O
2.0 _ _ O
; _ _ O
double _ _ O
term2 _ _ O
= _ _ O
1.0 _ _ O
/ _ _ O
3.0 _ _ O
; _ _ O
… _ _ O
} _ _ O

Lists _ _ B-Concept
• _ _ O
How _ _ O
do _ _ O
we _ _ O
do _ _ O
lists _ _ B-Concept
? _ _ O
• _ _ O
Using _ _ O
100 _ _ O
variables _ _ O
as _ _ O
a _ _ O
list _ _ O
is _ _ O
not _ _ O
scalable _ _ O
! _ _ O
What _ _ O
if _ _ O
we _ _ O
need _ _ O
more _ _ O
? _ _ O
What _ _ O
if _ _ O
I _ _ O
change _ _ O
the _ _ O
names _ _ O
? _ _ O
What _ _ O
if _ _ O
I _ _ O
wanted _ _ O
a _ _ O
different _ _ O
series _ _ O
? _ _ O
• _ _ O
A _ _ O
WILD _ _ O
STRUCTURE _ _ O
APPEARS _ _ O

Arrays _ _ B-Concept
• _ _ O
Arrays _ _ B-Concept
are _ _ O
ordered _ _ O
lists _ _ O
of _ _ O
things _ _ O
depending _ _ O
on _ _ O
the _ _ O
type _ _ O
you _ _ O
specify _ _ O
• _ _ O
How _ _ O
do _ _ O
you _ _ O
make _ _ O
one _ _ O
? _ _ O

Type _ _ O
[ _ _ O
] _ _ O
name _ _ O
= _ _ O
new _ _ O
Type _ _ O
[ _ _ O
size _ _ O
] _ _ O
; _ _ O

int _ _ O
[ _ _ O
] _ _ O
empty _ _ O
= _ _ O
new _ _ O
int _ _ O
[ _ _ O
10 _ _ O
] _ _ O
; _ _ O

Type _ _ O
[ _ _ O
] _ _ O
name _ _ O
= _ _ O
values _ _ O
; _ _ O

int _ _ O
[ _ _ O
] _ _ O
list _ _ O
= _ _ O
{ _ _ O
1 _ _ O
, _ _ O
2 _ _ O
, _ _ O
3 _ _ O
, _ _ O
4 _ _ O
} _ _ O
; _ _ O

Now _ _ O
What _ _ O
? _ _ O
• _ _ O
I _ _ O
want _ _ O
the _ _ O
first _ _ O
element _ _ O
• _ _ O
list _ _ O
[ _ _ O
0 _ _ O
] _ _ O
• _ _ O
I _ _ O
want _ _ O
the _ _ O
last _ _ O
element _ _ O
• _ _ O
list _ _ O
[ _ _ O
3 _ _ O
] _ _ O
• _ _ O
I _ _ O
want _ _ O
the _ _ O
length _ _ O
• _ _ O
list.length _ _ O
= _ _ O
= _ _ O
4 _ _ O
• _ _ O
All _ _ O
operations _ _ O
for _ _ O
int _ _ O
are _ _ O
allowed _ _ O
for _ _ O
an _ _ O
individual _ _ O
element _ _ O
• _ _ O
list _ _ O
[ _ _ O
0 _ _ O
] _ _ O
+ _ _ O
list _ _ O
[ _ _ O
2 _ _ O
] _ _ O
= _ _ O
= _ _ O
list _ _ O
[ _ _ O
3 _ _ O
] _ _ O

How _ _ O
do _ _ O
I _ _ O
get _ _ O
every _ _ O
element _ _ O
so _ _ O
I _ _ O
can _ _ O
print _ _ O
it _ _ O
? _ _ O
• _ _ O
Reference _ _ O
every _ _ O
element _ _ O
• _ _ O
Many _ _ O
if _ _ O
statements _ _ O
! _ _ O
! _ _ O
! _ _ O
! _ _ O
! _ _ O
! _ _ O
YAAAAAAAAYYYY _ _ O
• _ _ O
No _ _ O
please _ _ O
do _ _ O
n't _ _ O
• _ _ O
But _ _ O
what _ _ O
else _ _ O
can _ _ O
we _ _ O
do _ _ O
? _ _ O
• _ _ O
WILD _ _ O
KEYWORD _ _ O
APPEARS _ _ O

while _ _ B-Concept
( _ _ O
) _ _ O
{ _ _ O
… _ _ O
} _ _ O
• _ _ O
While _ _ B-Concept
a _ _ O
condition _ _ O
is _ _ O
true _ _ O
, _ _ O
run _ _ O
the _ _ O
block _ _ O
• _ _ O
While _ _ B-Concept
not _ _ O
at _ _ O
the _ _ O
end _ _ O
of _ _ O
the _ _ O
list _ _ O
, _ _ O
print _ _ O
out _ _ O
the _ _ O
next _ _ O
element _ _ O
while _ _ B-Concept
( _ _ O
not _ _ O
at _ _ O
end _ _ O
of _ _ O
list _ _ O
) _ _ O
{ _ _ O
System.out.println _ _ O
( _ _ O
next _ _ O
element _ _ O
) _ _ O
; _ _ O
} _ _ O
/ _ _ O
/ _ _ O
end _ _ O
loop _ _ O
while _ _ O
( _ _ O
not _ _ O
at _ _ O
end _ _ O
of _ _ O
list _ _ O
) _ _ O

not _ _ O
at _ _ O
end _ _ O
of _ _ O
list _ _ O
• _ _ O
How _ _ O
do _ _ O
we _ _ O
know _ _ O
we _ _ O
're _ _ O
at _ _ O
the _ _ O
end _ _ O
of _ _ O
the _ _ O
list _ _ O
? _ _ O
• _ _ O
list.length _ _ O
• _ _ O
How _ _ O
do _ _ O
we _ _ O
know _ _ O
which _ _ O
one _ _ O
we _ _ O
're _ _ O
at _ _ O
? _ _ O
– _ _ O
We _ _ O
need _ _ O
to _ _ O
keep _ _ O
track _ _ O
int _ _ O
currElement _ _ O
= _ _ O
0 _ _ O
; _ _ O
– _ _ O
starts _ _ O
at _ _ O
0 _ _ O
– _ _ O
not _ _ O
equal _ _ O
to _ _ O
the _ _ O
end _ _ O
! _ _ O
currElement _ _ O
! _ _ O
= _ _ O
list.length _ _ O

while _ _ B-Concept
( _ _ O
) _ _ O
{ _ _ O
… _ _ O
} _ _ O
• _ _ O
While _ _ B-Concept
not _ _ O
at _ _ O
the _ _ O
end _ _ O
of _ _ O
the _ _ O
list _ _ O
, _ _ O
print _ _ O
out _ _ O
the _ _ O
next _ _ O
element _ _ O
int _ _ O
currElement _ _ O
= _ _ O
0 _ _ O
; _ _ O
while _ _ O
( _ _ O
currElement _ _ O
! _ _ O
= _ _ O
list.length _ _ O
) _ _ O
{ _ _ O
System.out.println _ _ O
( _ _ O
< _ _ O
next _ _ O
element _ _ O
> _ _ O
) _ _ O
; _ _ O
} _ _ O
/ _ _ O
/ _ _ O
end _ _ O
loop _ _ O
while _ _ O
( _ _ O
currElement _ _ O
! _ _ O
=list.length _ _ O
) _ _ O



