['train_set', 'labeled']|cs0447|lec15
-DOCSTART- -X- -X- O

# _ _ O
15 _ _ O
CS _ _ O
0447 _ _ O
Introduction _ _ O
to _ _ O
Computer _ _ O
Programming _ _ O
Multicycle _ _ B-Concept
Design _ _ I-Concept
Original _ _ O
slides _ _ O
by _ _ O
: _ _ O
David _ _ O
Wilkinson _ _ O
Modified _ _ O
with _ _ O
bits _ _ O
from _ _ O
: _ _ O
Bruce _ _ O
Childers _ _ O
, _ _ O
and _ _ O
Jarrett _ _ O
Billingsley _ _ O
Luís _ _ O
Oliveira _ _ O
Fall _ _ O
2020 _ _ O

Multicycle _ _ B-Concept
2 _ _ O

Multicycle _ _ B-Concept
Design _ _ O
● _ _ O
Simply _ _ O
put _ _ O
: _ _ O
let _ _ O
instructions _ _ O
take _ _ O
more _ _ O
than _ _ O
one _ _ O
clock _ _ O
cycle _ _ O
to _ _ O
complete _ _ O
. _ _ O
Single-cycle _ _ B-Concept
PHOTO _ _ O
: _ _ O
https _ _ O
: _ _ O
/ _ _ O
/ _ _ O
www.straitstimes.com _ _ O
/ _ _ O
asia _ _ O
/ _ _ O
east-asia _ _ O
/ _ _ O
china-scrambles-to-tame-rental-bike-chaos _ _ O
Multicycle _ _ B-Concept
? _ _ O
3 _ _ O

Chop _ _ O
chop _ _ O
● _ _ O
Not _ _ O
all _ _ O
instructions _ _ O
take _ _ O
the _ _ O
same _ _ O
amount _ _ O
of _ _ O
time _ _ O
, _ _ O
so _ _ O
… _ _ O
● _ _ O
Make _ _ O
different _ _ O
instructions _ _ O
take _ _ O
different _ _ O
amounts _ _ O
of _ _ O
time _ _ O
! _ _ O
o _ _ O
And _ _ O
by _ _ O
that _ _ O
, _ _ O
we _ _ O
mean _ _ O
different _ _ O
numbers _ _ O
of _ _ O
clock _ _ O
cycles _ _ O
3 _ _ O
cycles _ _ O
j _ _ O
j _ _ O
4 _ _ O
cycles _ _ O
or _ _ O
or _ _ O
or _ _ O
or _ _ O
or _ _ O
100 _ _ O
cycles _ _ O
lw _ _ O
lw _ _ O
lw _ _ O
j _ _ O
lw _ _ O
lw _ _ O
lw _ _ O
lw _ _ O
lw _ _ O
lw _ _ O
lw _ _ O
lw _ _ O
lw _ _ O
lw _ _ O
l _ _ O
4 _ _ O

The _ _ O
instructions _ _ O
' _ _ O
steps _ _ O
● _ _ O
Why _ _ O
would _ _ O
some _ _ O
instructions _ _ O
take _ _ O
less _ _ O
time _ _ O
? _ _ O
● _ _ O
Recall _ _ O
the _ _ O
five _ _ O
phases _ _ O
of _ _ O
execution _ _ O
? _ _ O
● _ _ O
All _ _ O
instructions _ _ O
have _ _ O
IF _ _ O
, _ _ O
ID _ _ O
, _ _ O
EX _ _ O
, _ _ O
but _ _ O
only _ _ O
some _ _ O
write _ _ O
to _ _ O
memory _ _ O
/ _ _ O
regs _ _ O
o _ _ O
We _ _ O
’re _ _ O
managing _ _ O
their _ _ O
complexity _ _ O
with _ _ O
respect _ _ O
to _ _ O
time _ _ O
. _ _ O
beq _ _ O
/ _ _ O
j _ _ O
F _ _ O
D _ _ O
X _ _ O
add _ _ O
/ _ _ O
sub _ _ O
etc _ _ O
. _ _ O
F _ _ O
D _ _ O
X _ _ O
W _ _ O
lw _ _ O
F _ _ O
D _ _ O
X _ _ O
M _ _ O
M _ _ O
… _ _ O
… _ _ O
.. _ _ O
M _ _ O
M _ _ O
W _ _ O
Memory _ _ O
is _ _ O
slooooooow _ _ O
5 _ _ O

The _ _ O
instructions _ _ O
' _ _ O
steps _ _ O
● _ _ O
Why _ _ O
would _ _ O
some _ _ O
instructions _ _ O
take _ _ O
less _ _ O
time _ _ O
? _ _ O
● _ _ O
Recall _ _ O
the _ _ O
five _ _ B-Concept
phases _ _ I-Concept
of _ _ I-Concept
execution _ _ I-Concept
? _ _ O
● _ _ O
All _ _ O
instructions _ _ O
have _ _ O
IF _ _ O
, _ _ O
ID _ _ O
, _ _ O
EX _ _ O
, _ _ O
but _ _ O
only _ _ O
some _ _ O
write _ _ O
to _ _ O
memory _ _ O
/ _ _ O
regs _ _ O
o _ _ O
We _ _ O
’re _ _ O
managing _ _ O
their _ _ O
complexity _ _ O
with _ _ O
respect _ _ O
to _ _ O
time _ _ O
. _ _ O
beq _ _ O
/ _ _ O
j _ _ O
IF _ _ O
ID _ _ O
EX _ _ O
add _ _ O
/ _ _ O
sub _ _ O
etc _ _ O
. _ _ O
IF _ _ O
ID _ _ O
EX _ _ O
WB _ _ O
lw _ _ O
IF _ _ O
ID _ _ O
EX _ _ O
M _ _ O
WB _ _ O
( _ _ O
let _ _ O
's _ _ O
just _ _ O
say _ _ O
lw _ _ O
is _ _ O
5 _ _ O
cycles _ _ O
:) _ _ O
6 _ _ O

Multi-cycle _ _ B-Concept
CPU _ _ I-Concept
Calculate _ _ O
clock _ _ O
to _ _ O
accommodate _ _ O
a _ _ O
single _ _ O
phase _ _ O
. _ _ O
● _ _ O
Chop _ _ O
instructions _ _ O
and _ _ O
make _ _ O
the _ _ O
clock _ _ O
faster _ _ O
● _ _ O
Less _ _ O
time _ _ O
wasted _ _ O
by _ _ O
faster _ _ O
instructions _ _ O
! _ _ O
→ _ _ O
Reduces _ _ O
latency _ _ O
Time _ _ O
0 _ _ O
1 _ _ O
lw _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
t1 _ _ O
) _ _ O
Mem _ _ O
Reg _ _ O
add _ _ O
t2 _ _ O
, _ _ O
t2 _ _ O
, _ _ O
t3 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
Mem _ _ O
Reg _ _ O
5 _ _ O
6 _ _ O
Mem _ _ O
Reg _ _ O
7 _ _ O
8 _ _ O
Reg _ _ O
7 _ _ O

Not _ _ O
all _ _ O
stages _ _ O
are _ _ O
the _ _ O
same _ _ O
 _ _ O
In _ _ O
the _ _ O
multi-cycle _ _ B-Concept
design _ _ I-Concept
: _ _ O
Slowest _ _ O
stage _ _ O
limits _ _ O
the _ _ O
rate _ _ O
Balanced _ _ O
stages _ _ O
are _ _ O
desired _ _ O
E.g. _ _ O
split _ _ O
the _ _ O
memory _ _ O
operation _ _ O
into _ _ O
multiple _ _ O
clock _ _ O
cycles _ _ O
Time _ _ O
lw _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
t1 _ _ O
) _ _ O
0 _ _ O
1 _ _ O
Mem _ _ O
Reg _ _ O
Mem _ _ O
Reg _ _ O
2 _ _ O
3 _ _ O
Mem _ _ O
Mem _ _ O
4 _ _ O
Reg _ _ O
Reg _ _ O
8 _ _ O

The _ _ O
multicycle _ _ O
datapath _ _ O
from _ _ O
a _ _ O
bird _ _ O
' _ _ O
s-eye _ _ O
view _ _ O
● _ _ O
Each _ _ O
phase _ _ O
of _ _ O
execution _ _ O
has _ _ O
its _ _ O
own _ _ O
functional _ _ O
unit _ _ O
● _ _ O
between _ _ O
phases _ _ O
, _ _ O
we _ _ O
insert _ _ O
registers _ _ O
to _ _ O
hold _ _ O
onto _ _ O
the _ _ O
data _ _ O
for _ _ O
the _ _ O
next _ _ O
phase _ _ O
. _ _ O
( _ _ O
Recall _ _ O
registers _ _ O
➔ _ _ O
sequential _ _ O
logic _ _ O
) _ _ O
Instruction _ _ O
Memory _ _ O
D _ _ O
Control _ _ O
F _ _ O
X _ _ O
M _ _ O
Register _ _ O
File _ _ O
Data _ _ O
Memory _ _ O
W _ _ O
9 _ _ O

Watching _ _ O
an _ _ O
add _ _ O
( _ _ O
animated _ _ O
) _ _ O
● _ _ O
Let _ _ O
's _ _ O
watch _ _ O
an _ _ O
add _ _ O
instruction _ _ O
flow _ _ O
through _ _ O
the _ _ O
datapath _ _ O
! _ _ O
F _ _ O
Clock _ _ O
! _ _ O
D _ _ O
Clock _ _ O
! _ _ O
set _ _ O
all _ _ O
control _ _ O
signals _ _ O
... _ _ O
X _ _ O
Clock _ _ O
! _ _ O
M _ _ O
add _ _ O
... _ _ O
Instruction _ _ O
Memory _ _ O
Control _ _ O
add _ _ O
Register _ _ O
File _ _ O
Data _ _ O
Memory _ _ O
Clock _ _ O
! _ _ O
W _ _ O
data _ _ O
flows _ _ O
back _ _ O
to _ _ O
registers _ _ O
... _ _ O
10 _ _ O

Watching _ _ O
a _ _ O
lw _ _ O
( _ _ O
animated _ _ O
) _ _ O
● _ _ O
Let _ _ O
's _ _ O
watch _ _ O
a _ _ O
lw _ _ O
instruction _ _ O
flow _ _ O
through _ _ O
the _ _ O
datapath _ _ O
! _ _ O
F _ _ O
Clock _ _ O
! _ _ O
D _ _ O
Clock _ _ O
! _ _ O
set _ _ O
all _ _ O
control _ _ O
signals _ _ O
... _ _ O
X _ _ O
Clock _ _ O
! _ _ O
add _ _ O
... _ _ O
M _ _ O
Clock _ _ O
! _ _ O
load _ _ O
... _ _ O
Instruction _ _ O
Memory _ _ O
Control _ _ O
lw _ _ O
Register _ _ O
File _ _ O
Data _ _ O
Memory _ _ O
W _ _ O
data _ _ O
flows _ _ O
back _ _ O
to _ _ O
registers _ _ O
... _ _ O
11 _ _ O

CPI _ _ B-Concept
( _ _ O
and _ _ O
IPC _ _ B-Concept
) _ _ O
● _ _ O
CPI _ _ B-Concept
( _ _ O
Cycles _ _ O
Per _ _ O
Instruction _ _ O
) _ _ O
measures _ _ O
the _ _ O
average _ _ O
number _ _ O
of _ _ O
cycles _ _ O
it _ _ O
takes _ _ O
to _ _ O
complete _ _ O
one _ _ O
instruction _ _ O
● _ _ O
IPC _ _ B-Concept
( _ _ O
instructions _ _ O
per _ _ O
cycle _ _ O
) _ _ O
is _ _ O
its _ _ O
reciprocal _ _ O
o _ _ O
multi-issue _ _ O
CPUs _ _ O
can _ _ O
execute _ _ O
multiple _ _ O
instructions _ _ O
in _ _ O
one _ _ O
clock _ _ O
cycle _ _ O
! _ _ O
WOAH _ _ O
8O _ _ O
● _ _ O
So _ _ O
, _ _ O
what _ _ O
's _ _ O
the _ _ O
CPI _ _ B-Concept
for _ _ O
the _ _ O
single-cycle _ _ B-Concept
implementation _ _ O
? _ _ O
o _ _ O
uh _ _ O
, _ _ O
1 _ _ O
. _ _ O
o _ _ O
By _ _ O
, _ _ O
yanno _ _ O
, _ _ O
definition _ _ O
. _ _ O
● _ _ O
What _ _ O
about _ _ O
for _ _ O
a _ _ O
multicycle _ _ B-Concept
implementation _ _ O
? _ _ O
o _ _ O
… _ _ O
… _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
hmmm _ _ O
12 _ _ O

So _ _ O
what _ _ O
the _ _ O
heck _ _ O
has _ _ O
this _ _ O
bought _ _ O
us _ _ O
? _ _ O
● _ _ O
Let _ _ O
's _ _ O
say _ _ O
our _ _ O
clock _ _ O
cycle _ _ O
time _ _ O
decreased _ _ O
from _ _ O
5ns _ _ O
to _ _ O
1ns _ _ O
! _ _ O
o _ _ O
that _ _ O
's _ _ O
from _ _ O
200 _ _ O
MHz _ _ O
to _ _ O
1 _ _ O
GHz _ _ O
! _ _ O
:D _ _ O
● _ _ O
... _ _ O
buuut _ _ O
our _ _ O
CPI _ _ B-Concept
( _ _ O
cycles _ _ O
per _ _ O
instruction _ _ O
) _ _ O
increased _ _ O
a _ _ O
lot _ _ O
. _ _ O
o _ _ O
with _ _ O
the _ _ O
single-cycle _ _ O
datapath _ _ O
, _ _ O
CPI _ _ B-Concept
was _ _ O
always _ _ O
1 _ _ O
. _ _ O
o _ _ O
now _ _ O
the _ _ O
CPI _ _ B-Concept
is _ _ O
... _ _ O
well _ _ O
... _ _ O
uh _ _ O
... _ _ O
variable _ _ O
? _ _ O
beq _ _ O
/ _ _ O
j _ _ O
IF _ _ O
ID _ _ O
EX _ _ O
add _ _ O
/ _ _ O
sub _ _ O
etc _ _ O
. _ _ O
IF _ _ O
ID _ _ O
EX _ _ O
WB _ _ O
lw _ _ O
IF _ _ O
ID _ _ O
EX _ _ O
M _ _ O
if _ _ O
instructions _ _ O
vary _ _ O
in _ _ O
length _ _ O
, _ _ O
how _ _ O
do _ _ O
we _ _ O
calculate _ _ O
CPI _ _ O
? _ _ O
WB _ _ O
13 _ _ O

Calculating _ _ O
Average _ _ B-Concept
CPI _ _ I-Concept
● _ _ O
Every _ _ O
program _ _ O
is _ _ O
different _ _ O
, _ _ O
and _ _ O
every _ _ O
program _ _ O
has _ _ O
a _ _ O
different _ _ O
instruction _ _ O
mix _ _ O
– _ _ O
how _ _ O
many _ _ O
of _ _ O
each _ _ O
kind _ _ O
of _ _ O
instruction _ _ O
it _ _ O
uses _ _ O
● _ _ O
Let _ _ O
's _ _ O
say _ _ O
we _ _ O
have _ _ O
a _ _ O
program _ _ O
where _ _ O
60 _ _ O
% _ _ O
of _ _ O
the _ _ O
instructions _ _ O
are _ _ O
ALU _ _ O
, _ _ O
20 _ _ O
% _ _ O
are _ _ O
branches _ _ O
, _ _ O
15 _ _ O
% _ _ O
are _ _ O
loads _ _ O
, _ _ O
and _ _ O
5 _ _ O
% _ _ O
are _ _ O
stores _ _ O
. _ _ O
ALU _ _ O
Branches _ _ O
Loads _ _ O
Stores _ _ O
% _ _ O
60 _ _ O
% _ _ O
20 _ _ O
% _ _ O
15 _ _ O
% _ _ O
5 _ _ O
% _ _ O
Cycles _ _ O
4 _ _ O
3 _ _ O
5 _ _ O
4 _ _ O
2 _ _ O
. _ _ O
Now _ _ O
sum _ _ O
the _ _ O
CPIs _ _ B-Concept
CPI _ _ B-Concept
2.4 _ _ O
0.2 _ _ O
= _ _ O
3.95 _ _ O
+ _ _ O
0.6 _ _ O
+ _ _ O
0.75 _ _ O
1 _ _ O
. _ _ O
for _ _ O
each _ _ O
category _ _ O
, _ _ O
multiply _ _ O
the _ _ O
proportion _ _ O
( _ _ O
percentage _ _ O
) _ _ O
by _ _ O
the _ _ O
number _ _ O
of _ _ O
cycles _ _ O
for _ _ O
that _ _ O
category _ _ O
to _ _ O
get _ _ O
the _ _ O
per-category _ _ O
CPI _ _ O
+ _ _ O
this _ _ O
is _ _ O
the _ _ O
Average _ _ B-Concept
CPI _ _ I-Concept
for _ _ O
THIS _ _ O
program _ _ O
. _ _ O
different _ _ O
mixes _ _ O
give _ _ O
different _ _ O
CPIs _ _ B-Concept
! _ _ O
14 _ _ O

The _ _ O
performance _ _ O
equation _ _ O
● _ _ O
If _ _ O
we _ _ O
have _ _ O
n _ _ O
instructions _ _ O
, _ _ O
and _ _ O
each _ _ O
instruction _ _ O
takes _ _ O
CPI _ _ B-Concept
cycles _ _ O
, _ _ O
and _ _ O
each _ _ O
cycle _ _ O
takes _ _ O
t _ _ O
seconds _ _ O
, _ _ O
how _ _ O
long _ _ O
does _ _ O
it _ _ O
take _ _ O
to _ _ O
execute _ _ O
all _ _ O
the _ _ O
instructions _ _ O
? _ _ O
𝐶𝑃𝐼 _ _ B-Concept
cycles _ _ O
𝑡 _ _ O
seconds _ _ O
Total _ _ O
time _ _ O
= _ _ O
𝑛 _ _ O
instructions _ _ O
× _ _ O
× _ _ O
instruction _ _ O
cycle _ _ O
= _ _ O
𝑛 _ _ O
× _ _ O
𝐶𝑃𝐼 _ _ O
× _ _ O
𝑡 _ _ O
seconds _ _ O
or _ _ O
in _ _ O
English _ _ O
, _ _ O
it _ _ O
's _ _ O
the _ _ O
product _ _ O
of _ _ O
the _ _ O
instruction _ _ O
count _ _ O
, _ _ O
the _ _ O
CPI _ _ O
, _ _ O
and _ _ O
the _ _ O
length _ _ O
of _ _ O
one _ _ O
clock _ _ O
cycle _ _ O
15 _ _ O

So _ _ O
how _ _ O
much _ _ O
better _ _ O
is _ _ O
it _ _ O
? _ _ O
! _ _ O
? _ _ O
? _ _ O
! _ _ O
? _ _ O
● _ _ O
Say _ _ O
we _ _ O
execute _ _ O
500 _ _ O
mega _ _ O
( _ _ O
500 _ _ O
× _ _ O
106 _ _ O
) _ _ O
instructions _ _ O
● _ _ O
For _ _ O
the _ _ O
single-cycle _ _ O
datapath _ _ O
: _ _ O
o _ _ O
CPI _ _ B-Concept
= _ _ O
1 _ _ O
o _ _ O
cycle _ _ O
time _ _ O
= _ _ O
5ns _ _ O
( _ _ O
5 _ _ O
x _ _ O
10 _ _ O
- _ _ O
9 _ _ O
s _ _ O
) _ _ O
o _ _ O
total _ _ O
time _ _ O
= _ _ O
n _ _ O
× _ _ O
CPI _ _ B-Concept
× _ _ O
cycle _ _ B-Concept
time _ _ I-Concept
▪ _ _ O
= _ _ O
( _ _ O
500 _ _ O
× _ _ O
106 _ _ O
) _ _ O
× _ _ O
( _ _ O
1 _ _ O
) _ _ O
× _ _ O
( _ _ O
5 _ _ O
× _ _ O
10 _ _ O
- _ _ O
9 _ _ O
) _ _ O
▪ _ _ O
= _ _ O
2.5 _ _ O
seconds _ _ O
. _ _ O
● _ _ O
For _ _ O
the _ _ O
multicycle _ _ O
datapath _ _ O
: _ _ O
o _ _ O
CPI _ _ O
= _ _ O
3.95 _ _ O
( _ _ O
much _ _ O
higher _ _ O
! _ _ O
) _ _ O
( _ _ O
again _ _ O
, _ _ O
this _ _ O
CPI _ _ O
is _ _ O
only _ _ O
for _ _ O
this _ _ O
program _ _ O
) _ _ O
o _ _ O
cycle _ _ O
time _ _ O
= _ _ O
1ns _ _ O
( _ _ O
much _ _ O
lower _ _ O
! _ _ O
) _ _ O
o _ _ O
total _ _ O
time _ _ O
= _ _ O
( _ _ O
500 _ _ O
× _ _ O
106 _ _ O
) _ _ O
× _ _ O
( _ _ O
3.95 _ _ O
) _ _ O
× _ _ O
( _ _ O
1 _ _ O
× _ _ O
10 _ _ O
- _ _ O
9 _ _ O
) _ _ O
o _ _ O
= _ _ O
1.975 _ _ O
seconds _ _ O
! _ _ O
16 _ _ O

How _ _ O
does _ _ O
it _ _ O
look _ _ O
like _ _ O
? _ _ O
17 _ _ O

Multicycle _ _ B-Concept
Datapath _ _ I-Concept
+ _ _ O
Control _ _ O
( _ _ O
no _ _ O
control _ _ O
flow _ _ O
) _ _ O
● _ _ O
A _ _ O
potential _ _ O
example _ _ O
of _ _ O
a _ _ O
multicycle _ _ O
control _ _ O
for _ _ O
MIPS _ _ O
: _ _ O
o _ _ O
Additional _ _ O
registers _ _ O
and _ _ O
multiplexers _ _ O
hold _ _ O
and _ _ O
then _ _ O
direct _ _ O
temporary _ _ O
data _ _ O
. _ _ O
A _ _ O
single _ _ O
ALU _ _ O
A _ _ O
single _ _ O
Shared _ _ O
Memory _ _ O
Figure _ _ O
5.26 _ _ O
in _ _ O
P _ _ O
& _ _ O
H _ _ O
3e _ _ O
18 _ _ O

Multicycle _ _ B-Concept
Datapath _ _ I-Concept
+ _ _ O
Control _ _ O
( _ _ O
no _ _ O
control _ _ O
flow _ _ O
) _ _ O
● _ _ O
A _ _ O
potential _ _ O
example _ _ O
of _ _ O
a _ _ O
multicycle _ _ O
control _ _ O
for _ _ O
MIPS _ _ O
: _ _ O
o _ _ O
Additional _ _ O
registers _ _ O
and _ _ O
multiplexers _ _ O
hold _ _ O
and _ _ O
then _ _ O
direct _ _ O
temporary _ _ O
data _ _ O
. _ _ O
Registers _ _ O
are _ _ O
added _ _ O
between _ _ O
functional _ _ O
units _ _ O
to _ _ O
store _ _ O
data _ _ O
That _ _ O
needs _ _ O
to _ _ O
be _ _ O
used _ _ O
in _ _ O
the _ _ O
following _ _ O
clock _ _ O
cycle _ _ O
Figure _ _ O
5.26 _ _ O
in _ _ O
P _ _ O
& _ _ O
H _ _ O
3e _ _ O
19 _ _ O

Multicycle _ _ B-Concept
Datapath _ _ I-Concept
+ _ _ O
Control _ _ O
( _ _ O
no _ _ O
control _ _ O
flow _ _ O
) _ _ O
● _ _ O
A _ _ O
potential _ _ O
example _ _ O
of _ _ O
a _ _ O
multicycle _ _ O
control _ _ O
for _ _ O
MIPS _ _ O
: _ _ O
o _ _ O
Additional _ _ O
registers _ _ O
and _ _ O
multiplexers _ _ O
hold _ _ O
and _ _ O
then _ _ O
direct _ _ O
temporary _ _ O
data _ _ O
. _ _ O
A _ _ O
MUX _ _ O
to _ _ O
connect _ _ O
either _ _ O
the _ _ O
PC _ _ O
or _ _ O
the _ _ O
Register _ _ O
File _ _ O
Using _ _ O
a _ _ O
single _ _ O
ALU _ _ O
requires _ _ O
a _ _ O
change _ _ O
in _ _ O
the _ _ O
hardware _ _ O
design _ _ O
. _ _ O
A _ _ O
larger _ _ O
MUX _ _ O
to _ _ O
include _ _ O
PC _ _ O
increment _ _ O
and _ _ O
adding _ _ O
the _ _ O
branch _ _ O
offsets _ _ O
Figure _ _ O
5.26 _ _ O
in _ _ O
P _ _ O
& _ _ O
H _ _ O
3e _ _ O
20 _ _ O

Multicycle _ _ B-Concept
Datapath _ _ I-Concept
+ _ _ O
Control _ _ O
( _ _ O
with _ _ O
control _ _ O
flow _ _ O
) _ _ O
Now _ _ O
we _ _ O
support _ _ O
jump _ _ O
instructions _ _ O
☺ _ _ O
Figure _ _ O
5.28 _ _ O
in _ _ O
P _ _ O
& _ _ O
H _ _ O
3e _ _ O
21 _ _ O

Multicycle _ _ B-Concept
Datapath _ _ I-Concept
+ _ _ O
Control _ _ O
( _ _ O
with _ _ O
control _ _ O
flow _ _ O
) _ _ O
Figure _ _ O
5.28 _ _ O
in _ _ O
P _ _ O
& _ _ O
H _ _ O
3e _ _ O
22 _ _ O

Signals _ _ O
Signal _ _ O
Effect _ _ O
MemRead _ _ O
Read _ _ O
from _ _ O
memory _ _ O
➔ _ _ O
0 _ _ O
: _ _ O
Do _ _ O
n’t _ _ O
read _ _ O
; _ _ O
1 _ _ O
: _ _ O
Read _ _ O
MemWrite _ _ O
Write _ _ O
to _ _ O
memory _ _ O
➔ _ _ O
0 _ _ O
: _ _ O
Do _ _ O
n’t _ _ O
write _ _ O
; _ _ O
1 _ _ O
: _ _ O
Write _ _ O
ALUSelA _ _ O
Select _ _ O
input _ _ O
of _ _ O
ALU _ _ O
input _ _ O
A _ _ O
➔ _ _ O
0 _ _ O
: _ _ O
$ _ _ O
pc _ _ O
; _ _ O
1 _ _ O
: _ _ O
register _ _ O
A _ _ O
RegDst _ _ O
Select _ _ O
destination _ _ O
register _ _ O
➔ _ _ O
0 _ _ O
: _ _ O
$ _ _ O
rt _ _ O
( _ _ O
I-Type _ _ O
) _ _ O
; _ _ O
1 _ _ O
: _ _ O
$ _ _ O
rd _ _ O
( _ _ O
R-Type _ _ O
) _ _ O
RegWrite _ _ O
Register-file _ _ O
write _ _ O
enable _ _ O
➔ _ _ O
0 _ _ O
: _ _ O
Do _ _ O
n’t _ _ O
write _ _ O
; _ _ O
1 _ _ O
: _ _ O
Write _ _ O
MemToReg _ _ O
Select _ _ O
data _ _ O
to _ _ O
write _ _ O
to _ _ O
the _ _ O
register-file _ _ O
➔ _ _ O
0 _ _ O
: _ _ O
ALU _ _ O
; _ _ O
1 _ _ O
: _ _ O
Memory _ _ O
IorD _ _ O
Select _ _ O
the _ _ O
source _ _ O
for _ _ O
the _ _ O
memory _ _ O
address _ _ O
to _ _ O
be _ _ O
accessed _ _ O
➔ _ _ O
0 _ _ O
: _ _ O
PC _ _ O
( _ _ O
instruction _ _ O
) _ _ O
; _ _ O
1 _ _ O
: _ _ O
ALU _ _ O
( _ _ O
lw _ _ O
/ _ _ O
sw _ _ O
/ _ _ O
lh _ _ O
/ _ _ O
lhu _ _ O
/ _ _ O
sh _ _ O
/ _ _ O
lb _ _ O
/ _ _ O
lbu _ _ O
/ _ _ O
sb _ _ O
) _ _ O
IRWrite _ _ O
Instruction _ _ O
register _ _ O
write _ _ O
enable _ _ O
➔ _ _ O
0 _ _ O
: _ _ O
Do _ _ O
n’t _ _ O
write _ _ O
; _ _ O
1 _ _ O
: _ _ O
Write _ _ O
PCWrite _ _ O
PC _ _ O
unconditional _ _ O
write _ _ O
enable _ _ O
( _ _ O
jumps _ _ O
/ _ _ O
PC=PC+4 _ _ O
) _ _ O
➔ _ _ O
0 _ _ O
: _ _ O
No _ _ O
effect _ _ O
; _ _ O
1 _ _ O
: _ _ O
Jump _ _ O
PCWriteCond _ _ O
PC _ _ O
conditional _ _ O
write _ _ O
enable _ _ O
( _ _ O
branches _ _ O
) _ _ O
➔ _ _ O
0 _ _ O
: _ _ O
No _ _ O
effect _ _ O
; _ _ O
1 _ _ O
: _ _ O
Jump _ _ O
conditionally _ _ O
23 _ _ O

( _ _ O
More _ _ O
) _ _ O
signals _ _ O
Signal _ _ O
ALUSelB _ _ O
ALUOp _ _ O
PCSource _ _ O
Effect _ _ O
00 _ _ O
ALU _ _ O
input _ _ O
B _ _ O
comes _ _ O
from _ _ O
$ _ _ O
rt _ _ O
01 _ _ O
ALU _ _ O
input _ _ O
B _ _ O
is _ _ O
the _ _ O
constant _ _ O
4 _ _ O
10 _ _ O
ALU _ _ O
input _ _ O
B _ _ O
comes _ _ O
from _ _ O
the _ _ O
Immediate _ _ O
field _ _ O
11 _ _ O
ALU _ _ O
input _ _ O
B _ _ O
comes _ _ O
from _ _ O
the _ _ O
Immediate _ _ O
field _ _ O
shifted _ _ O
left _ _ O
2 _ _ O
( _ _ O
branch _ _ O
) _ _ O
00 _ _ O
ALU _ _ O
does _ _ O
an _ _ O
addition _ _ O
01 _ _ O
ALU _ _ O
does _ _ O
an _ _ O
subtraction _ _ O
10 _ _ O
ALU _ _ O
behaviour _ _ O
depends _ _ O
on _ _ O
the _ _ O
function _ _ O
field _ _ O
( _ _ O
R-Type _ _ O
) _ _ O
00 _ _ O
PC _ _ O
is _ _ O
updated _ _ O
with _ _ O
the _ _ O
result _ _ O
of _ _ O
the _ _ O
ALU _ _ O
( _ _ O
Fetch _ _ O
: _ _ O
PC+4 _ _ O
) _ _ O
01 _ _ O
PC _ _ O
is _ _ O
updated _ _ O
with _ _ O
the _ _ O
result _ _ O
of _ _ O
the _ _ O
ALU _ _ O
( _ _ O
PC _ _ O
= _ _ O
PC _ _ O
+ _ _ O
branch _ _ O
offset _ _ O
) _ _ O
10 _ _ O
PC _ _ O
is _ _ O
updated _ _ O
with _ _ O
the _ _ O
Jump _ _ O
target _ _ O
( _ _ O
jump _ _ O
) _ _ O
24 _ _ O

Fetch _ _ O
and _ _ O
decode _ _ O
25 _ _ O

Fetch _ _ O
Instruction _ _ O
00 _ _ O
Increment _ _ O
PC _ _ O
Read _ _ O
instruction _ _ O
from _ _ O
memory _ _ O
01 _ _ O
00 _ _ O
26 _ _ O

Decode _ _ O
Instruction _ _ O
Controller _ _ O
does _ _ O
its _ _ O
thing _ _ O
00 _ _ O
Maybe _ _ O
it _ _ O
’s _ _ O
a _ _ O
branch _ _ O
? _ _ O
11 _ _ O
ALU _ _ O
adds _ _ O
PC _ _ O
( _ _ O
incremented _ _ O
in _ _ O
IF _ _ O
) _ _ O
to _ _ O
potential _ _ O
branch _ _ O
offset _ _ O
. _ _ O
Just _ _ O
in _ _ O
case _ _ O
! _ _ O
00 _ _ O
27 _ _ O

R-Type _ _ O
28 _ _ O

Execute _ _ O
Instruction _ _ O
00 _ _ O
ALU _ _ O
adds _ _ O
registers _ _ O
A _ _ O
and _ _ O
B _ _ O
00 _ _ O
add _ _ O
s0 _ _ O
, _ _ O
s1 _ _ O
, _ _ O
s2 _ _ O
10 _ _ O
29 _ _ O

Write _ _ O
Back _ _ O
00 _ _ O
ALU _ _ O
result _ _ O
is _ _ O
written _ _ O
back _ _ O
into _ _ O
the _ _ O
Register _ _ O
File _ _ O
00 _ _ O
add _ _ O
s0 _ _ O
, _ _ O
s1 _ _ O
, _ _ O
s2 _ _ O
00 _ _ O
30 _ _ O

I-Type _ _ O
lw _ _ O
31 _ _ O

Execute _ _ O
Instruction _ _ O
00 _ _ O
ALU _ _ O
adds _ _ O
registers _ _ O
A _ _ O
and _ _ O
Imm _ _ O
to _ _ O
calculate _ _ O
effective _ _ O
address _ _ O
10 _ _ O
lw _ _ O
s0 _ _ O
, _ _ O
4 _ _ O
( _ _ O
s1 _ _ O
) _ _ O
00 _ _ O
32 _ _ O

Memory _ _ O
access _ _ O
00 _ _ O
ALU _ _ O
result _ _ O
is _ _ O
used _ _ O
as _ _ O
the _ _ O
address _ _ O
. _ _ O
Memory _ _ O
is _ _ O
read _ _ O
. _ _ O
00 _ _ O
lw _ _ O
s0 _ _ O
, _ _ O
4 _ _ O
( _ _ O
s1 _ _ O
) _ _ O
00 _ _ O
33 _ _ O

Write _ _ O
back _ _ O
00 _ _ O
Data _ _ O
read _ _ O
from _ _ O
memory _ _ O
is _ _ O
written _ _ O
into _ _ O
the _ _ O
Register _ _ O
File _ _ O
lw _ _ O
s0 _ _ O
, _ _ O
4 _ _ O
( _ _ O
s1 _ _ O
) _ _ O
00 _ _ O
00 _ _ O
34 _ _ O

I-Type _ _ O
beq _ _ O
35 _ _ O

Execute _ _ O
Instruction _ _ O
– _ _ O
Branch _ _ O
conclusion _ _ O
01 _ _ O
ALU _ _ O
subtracts _ _ O
registers _ _ O
A _ _ O
and _ _ O
B _ _ O
if _ _ O
the _ _ O
result _ _ O
is _ _ O
zero _ _ O
, _ _ O
then _ _ O
branch _ _ O
00 _ _ O
beq _ _ O
s0 _ _ O
, _ _ O
s1 _ _ O
, _ _ O
label _ _ O
01 _ _ O
36 _ _ O

J-Type _ _ O
jump _ _ O
37 _ _ O

Execute _ _ O
Instruction _ _ O
– _ _ O
Jump _ _ O
10 _ _ O
Jump _ _ O
00 _ _ O
j _ _ O
target _ _ O
00 _ _ O
38 _ _ O

Multicycle _ _ O
Control _ _ O
● _ _ O
How _ _ O
are _ _ O
control _ _ O
signals _ _ O
generated _ _ O
on _ _ O
each _ _ O
cycle _ _ O
? _ _ O
o _ _ O
Single-cycle _ _ O
: _ _ O
Signals _ _ O
do _ _ O
n’t _ _ O
change _ _ O
during _ _ O
each _ _ O
instruction _ _ O
▪ _ _ O
Combinational _ _ O
circuit _ _ O
o _ _ O
Multi-cycle _ _ O
: _ _ O
Signals _ _ O
change _ _ O
during _ _ O
each _ _ O
instruction _ _ O
▪ _ _ O
Different _ _ O
signals _ _ O
each _ _ O
clock _ _ O
cycle _ _ O
Sequential _ _ O
circuit _ _ O
→ _ _ O
Needs _ _ O
to _ _ O
remember _ _ O
what _ _ O
it _ _ O
did _ _ O
before _ _ O
● _ _ O
What _ _ O
are _ _ O
the _ _ O
transitions _ _ O
between _ _ O
cycles _ _ O
? _ _ O
o _ _ O
( _ _ O
i.e. _ _ O
, _ _ O
what _ _ O
happens _ _ O
next _ _ O
? _ _ O
) _ _ O
● _ _ O
How _ _ O
to _ _ O
describe _ _ O
this _ _ O
behaviour _ _ O
? _ _ O
o _ _ O
State _ _ O
machine _ _ O
! _ _ O
39 _ _ O

Tick-tock _ _ O
D _ _ O
opcode _ _ O
transition _ _ O
logic _ _ O
RegWrite _ _ O
… _ _ O
. _ _ O
IRWrite _ _ O
Q _ _ O
state _ _ O
register _ _ O
ALUSrcA _ _ O
output _ _ O
logic _ _ O
40 _ _ O

Multicycle _ _ O
Control _ _ O
Finite _ _ O
State _ _ O
Machine _ _ O
Each _ _ O
Cycle _ _ O
: _ _ O
Advance _ _ O
one _ _ O
state _ _ O
Whilst _ _ O
in _ _ O
a _ _ O
State _ _ O
: _ _ O
• _ _ O
Set _ _ O
datapath _ _ O
control _ _ O
• _ _ O
Make _ _ O
decision _ _ O
based _ _ O
on _ _ O
opcode _ _ O
• _ _ O
Control _ _ O
is _ _ O
different _ _ O
after _ _ O
Decode _ _ O
DECODE _ _ O
/ _ _ O
REG _ _ O
. _ _ O
READ _ _ O
FETCH _ _ O
R-Type _ _ O
load _ _ O
/ _ _ O
store _ _ O
CALC _ _ O
. _ _ O
ADDR _ _ O
. _ _ O
load _ _ O
READ _ _ O
MEM _ _ O
WRITE _ _ O
BACK _ _ O
MEM _ _ O
EXEC _ _ O
. _ _ O
ALU _ _ O
branch _ _ O
BRANCH _ _ O
COMPL _ _ O
. _ _ O
jump _ _ O
JUMP _ _ O
COMPL _ _ O
. _ _ O
store _ _ O
WRITE _ _ O
MEM _ _ O
WRITE _ _ O
BACK _ _ O
ALU _ _ O
MIPS _ _ O
has _ _ O
> _ _ O
100 _ _ O
instructions _ _ O
Some _ _ O
can _ _ O
take _ _ O
> _ _ O
20 _ _ O
clock _ _ O
cycles _ _ O
! _ _ O
! _ _ O
Making _ _ O
the _ _ O
state _ _ O
machine _ _ O
a _ _ O
bit _ _ O
more _ _ O
complex _ _ O
☺ _ _ O
41 _ _ O

Performance _ _ O
42 _ _ O

The _ _ O
layman _ _ O
's _ _ O
understanding _ _ O
● _ _ O
your _ _ O
ancient _ _ O
computer _ _ O
takes _ _ O
30 _ _ O
seconds _ _ O
to _ _ O
open _ _ O
the _ _ O
browser _ _ O
● _ _ O
you _ _ O
get _ _ O
a _ _ O
new _ _ O
computer _ _ O
. _ _ O
it _ _ O
opens _ _ O
the _ _ O
browser _ _ O
in _ _ O
3 _ _ O
seconds _ _ O
. _ _ O
o _ _ O
which _ _ O
computer _ _ O
is _ _ O
faster _ _ O
? _ _ O
yeah _ _ O
but _ _ O
this _ _ O
is _ _ O
computer _ _ O
science _ _ O
, _ _ O
not _ _ O
computer _ _ O
guessing _ _ O
. _ _ O
43 _ _ O

Old _ _ O
stuff _ _ O
! _ _ O
! _ _ O
● _ _ O
you _ _ O
wanna _ _ O
copy _ _ O
a _ _ O
CD _ _ O
as _ _ O
many _ _ O
times _ _ O
as _ _ O
you _ _ O
can _ _ O
in _ _ O
12 _ _ O
minutes _ _ O
● _ _ O
both _ _ O
the _ _ O
PC _ _ O
and _ _ O
this _ _ O
... _ _ O
thing _ _ O
take _ _ O
4 _ _ O
minutes _ _ O
to _ _ O
copy _ _ O
● _ _ O
which _ _ O
device _ _ O
will _ _ O
make _ _ O
more _ _ O
copies _ _ O
in _ _ O
12 _ _ O
minutes _ _ O
? _ _ O
why _ _ O
? _ _ O
o _ _ O
numbers _ _ O
usually _ _ O
mean _ _ O
we _ _ O
're _ _ O
getting _ _ O
more _ _ O
science-y _ _ O
, _ _ O
right _ _ O
? _ _ O
44 _ _ O

Response _ _ O
time _ _ O
and _ _ O
throughput _ _ O
● _ _ O
response _ _ O
time _ _ O
is _ _ O
the _ _ O
length _ _ O
of _ _ O
time _ _ O
from _ _ O
start _ _ O
to _ _ O
finish _ _ O
● _ _ O
throughput _ _ O
is _ _ O
the _ _ O
amount _ _ O
of _ _ O
work _ _ O
you _ _ O
can _ _ O
do _ _ O
in _ _ O
a _ _ O
span _ _ O
of _ _ O
time _ _ O
response _ _ O
time _ _ O
( _ _ O
time _ _ O
per _ _ O
task _ _ O
) _ _ O
3s _ _ O
30 _ _ O
seconds _ _ O
they _ _ O
're _ _ O
not _ _ O
quite _ _ O
reciprocals _ _ O
of _ _ O
each _ _ O
other _ _ O
; _ _ O
their _ _ O
relationship _ _ O
is _ _ O
a _ _ O
little _ _ O
more _ _ O
complex _ _ O
throughput _ _ O
( _ _ O
tasks _ _ O
per _ _ O
time _ _ O
) _ _ O
12 _ _ O
minutes _ _ O
45 _ _ O

Response _ _ O
time _ _ O
can _ _ O
improve _ _ O
throughput _ _ O
! _ _ O
● _ _ O
you _ _ O
put _ _ O
a _ _ O
brand _ _ O
new _ _ O
52X _ _ O
CD _ _ O
burner _ _ O
in _ _ O
your _ _ O
sweet _ _ O
Dell _ _ O
. _ _ O
it _ _ O
burns _ _ O
a _ _ O
CD _ _ O
in _ _ O
only _ _ O
2 _ _ O
minutes _ _ O
. _ _ O
4min _ _ O
4min _ _ O
4min _ _ O
2min _ _ O
2min _ _ O
2min _ _ O
2min _ _ O
2min _ _ O
2min _ _ O
● _ _ O
the _ _ O
response _ _ O
time _ _ O
for _ _ O
a _ _ O
single _ _ O
CD _ _ O
burn _ _ O
is _ _ O
improved _ _ O
, _ _ O
but _ _ O
this _ _ O
also _ _ O
causes _ _ O
our _ _ O
throughput _ _ O
to _ _ O
double _ _ O
! _ _ O
● _ _ O
this _ _ O
is _ _ O
because _ _ O
the _ _ O
measurement _ _ O
period _ _ O
stayed _ _ O
the _ _ O
same _ _ O
( _ _ O
12min _ _ O
) _ _ O
46 _ _ O

Throughput _ _ O
can _ _ O
improve _ _ O
response _ _ O
time _ _ O
! _ _ O
● _ _ O
someone _ _ O
wants _ _ O
you _ _ O
to _ _ O
make _ _ O
them _ _ O
20 _ _ O
copies _ _ O
ASAP _ _ O
● _ _ O
how _ _ O
long _ _ O
would _ _ O
it _ _ O
take _ _ O
with _ _ O
one _ _ O
CD _ _ O
duplicator _ _ O
? _ _ O
● _ _ O
how _ _ O
long _ _ O
would _ _ O
it _ _ O
take _ _ O
with _ _ O
two _ _ O
? _ _ O
4min _ _ O
4min _ _ O
4min _ _ O
4min _ _ O
4min _ _ O
4min _ _ O
4min _ _ O
4min _ _ O
4min _ _ O
4min _ _ O
4min _ _ O
4min _ _ O
4min _ _ O
4min _ _ O
4min _ _ O
with _ _ O
one _ _ O
: _ _ O
20min _ _ O
4min _ _ O
4min _ _ O
4min _ _ O
4min _ _ O
4min _ _ O
4min _ _ O
4min _ _ O
4min _ _ O
4min _ _ O
4min _ _ O
4min _ _ O
4min _ _ O
4min _ _ O
with _ _ O
two _ _ O
: _ _ O
12min _ _ O
this _ _ O
is _ _ O
because _ _ O
the _ _ O
workload _ _ O
stayed _ _ O
the _ _ O
same _ _ O
( _ _ O
20 _ _ O
copies _ _ O
) _ _ O
47 _ _ O

Applying _ _ O
it _ _ O
to _ _ O
a _ _ O
CPU _ _ O
● _ _ O
the _ _ O
CPU _ _ O
's _ _ O
job _ _ O
is _ _ O
to _ _ O
run _ _ O
instructions _ _ O
. _ _ O
so _ _ O
we _ _ O
could _ _ O
… _ _ O
o _ _ O
do _ _ O
each _ _ O
instruction _ _ O
faster _ _ O
( _ _ O
i.e. _ _ O
reduce _ _ O
latency _ _ O
) _ _ O
o _ _ O
do _ _ O
more _ _ O
instructions _ _ O
at _ _ O
once _ _ O
( _ _ O
i.e. _ _ O
increase _ _ O
throughput _ _ O
) _ _ O
● _ _ O
for _ _ O
a _ _ O
long _ _ O
time _ _ O
, _ _ O
we _ _ O
did _ _ O
the _ _ O
former _ _ O
… _ _ O
o _ _ O
clock _ _ O
speeds _ _ O
increased _ _ O
by _ _ O
2 _ _ O
orders _ _ O
of _ _ O
magnitude _ _ O
since _ _ O
~1990 _ _ O
▪ _ _ O
I _ _ O
had _ _ O
a _ _ O
33MHz _ _ O
! _ _ O
80486 _ _ O
PC _ _ O
● _ _ O
but _ _ O
then _ _ O
we _ _ O
hit _ _ O
a _ _ O
wall _ _ O
. _ _ O
o _ _ O
and _ _ O
that _ _ O
's _ _ O
when _ _ O
multi-core _ _ O
CPUs _ _ O
became _ _ O
common _ _ O
. _ _ O
48 _ _ O

Reducing _ _ O
latency _ _ O
● _ _ O
you _ _ O
put _ _ O
a _ _ O
new _ _ O
Pentium _ _ O
4 _ _ O
in _ _ O
your _ _ O
sweet _ _ O
Dell _ _ O
. _ _ O
it _ _ O
executes _ _ O
a _ _ O
single _ _ O
instruction _ _ O
in _ _ O
only _ _ O
0.8 _ _ O
nanoseconds _ _ O
. _ _ O
1.6ns _ _ O
.8ns _ _ O
.8ns _ _ O
if _ _ O
each _ _ O
instruction _ _ O
takes _ _ O
only _ _ O
0.8ns _ _ O
, _ _ O
that _ _ O
means _ _ O
0.8ns _ _ O
between _ _ O
clock _ _ O
pulses _ _ O
. _ _ O
How _ _ O
fast _ _ O
is _ _ O
the _ _ O
clock _ _ O
running _ _ O
? _ _ O
1.6ns _ _ O
.8ns _ _ O
.8ns _ _ O
1 _ _ O
0.8 _ _ O
× _ _ O
10−9 _ _ O
𝑠 _ _ O
1.6ns _ _ O
.8ns _ _ O
.8ns _ _ O
= _ _ O
1.25 _ _ O
× _ _ O
109 _ _ O
𝐻𝑧 _ _ O
= _ _ O
1.25 _ _ O
𝐺𝐻𝑧 _ _ O
49 _ _ O

But _ _ O
is _ _ O
this _ _ O
efficient _ _ O
? _ _ O
50 _ _ O

Multi-cycle _ _ O
lw _ _ O
( _ _ O
animated _ _ O
) _ _ O
● _ _ O
Let _ _ O
's _ _ O
watch _ _ O
a _ _ O
lw _ _ O
instruction _ _ O
flow _ _ O
through _ _ O
the _ _ O
datapath _ _ O
! _ _ O
lw _ _ O
Instruction _ _ O
Memory _ _ O
D _ _ O
Clock _ _ O
! _ _ O
R _ _ O
e _ _ O
g _ _ O
i _ _ O
s _ _ O
t _ _ O
e _ _ O
r _ _ O
s _ _ O
set _ _ O
all _ _ O
control _ _ O
signals _ _ O
... _ _ O
Control _ _ O
F _ _ O
Register _ _ O
File _ _ O
Clock _ _ O
! _ _ O
R _ _ O
e _ _ O
g _ _ O
i _ _ O
s _ _ O
t _ _ O
e _ _ O
r _ _ O
s _ _ O
Clock _ _ O
count _ _ O
: _ _ O
3 _ _ O
4 _ _ O
5 _ _ O
0 _ _ O
1 _ _ O
2 _ _ O
X _ _ O
Clock _ _ O
! _ _ O
Calculate _ _ O
eff _ _ O
addr _ _ O
... _ _ O
R _ _ O
M _ _ O
load _ _ O
... _ _ O
e _ _ O
g _ _ O
i _ _ O
s _ _ O
t _ _ O
e _ _ O
r _ _ O
s _ _ O
Data _ _ O
Memory _ _ O
Clock _ _ O
! _ _ O
R _ _ O
e _ _ O
g _ _ O
i _ _ O
s _ _ O
t _ _ O
e _ _ O
r _ _ O
s _ _ O
W _ _ O
data _ _ O
flows _ _ O
back _ _ O
to _ _ O
registers _ _ O
... _ _ O
51 _ _ O

Real-World _ _ O
Analysis _ _ O
52 _ _ O

Another _ _ O
example _ _ O
.data _ _ O
A _ _ O
: _ _ O
B _ _ O
: _ _ O
.text _ _ O
loop _ _ O
: _ _ O
.word _ _ O
10 _ _ O
, _ _ O
20 _ _ O
, _ _ O
30 _ _ O
, _ _ O
40 _ _ O
, _ _ O
50 _ _ O
, _ _ O
60 _ _ O
, _ _ O
70 _ _ O
, _ _ O
80 _ _ O
, _ _ O
90 _ _ O
, _ _ O
100 _ _ O
.word _ _ O
0 _ _ O
, _ _ O
0 _ _ O
, _ _ O
0 _ _ O
, _ _ O
0 _ _ O
, _ _ O
0 _ _ O
, _ _ O
0 _ _ O
, _ _ O
0 _ _ O
, _ _ O
0 _ _ O
, _ _ O
0 _ _ O
, _ _ O
0 _ _ O
la _ _ O
$ _ _ O
s0 _ _ O
, _ _ O
A _ _ O
li _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
10 _ _ O
li _ _ O
$ _ _ O
s2 _ _ O
, _ _ O
10 _ _ O
lw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s0 _ _ O
) _ _ O
mul _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
$t0 _ _ O
, _ _ O
$s1 _ _ O
sw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
40 _ _ O
( _ _ O
$s0 _ _ O
) _ _ O
addi _ _ O
$ _ _ O
s0 _ _ O
, _ _ O
$s0 _ _ O
, _ _ O
4 _ _ O
addi _ _ O
$ _ _ O
s2 _ _ O
, _ _ O
$s2 _ _ O
, _ _ O
-1 _ _ O
bne _ _ O
$ _ _ O
s2 _ _ O
, _ _ O
$0 _ _ O
, _ _ O
loop _ _ O
li _ _ O
$ _ _ O
v0 _ _ O
, _ _ O
10 _ _ O
syscall _ _ O
# _ _ O
address _ _ O
of _ _ O
A _ _ O
# _ _ O
A _ _ O
[ _ _ O
i _ _ O
] _ _ O
* _ _ O
10 _ _ O
# _ _ O
iteration _ _ O
# _ _ O
read _ _ O
A _ _ O
[ _ _ O
i _ _ O
] _ _ O
# _ _ O
$ _ _ O
t0=A _ _ O
[ _ _ O
i _ _ O
] _ _ O
*10 _ _ O
# _ _ O
update _ _ O
A _ _ O
[ _ _ O
i _ _ O
] _ _ O
# _ _ O
next _ _ O
element _ _ O
# _ _ O
dec _ _ O
iteration _ _ O
# _ _ O
done _ _ O
? _ _ O
# _ _ O
exit _ _ O
syscall _ _ O
# _ _ O
syscall _ _ O
53 _ _ O

Another _ _ O
example _ _ O
.data _ _ O
A _ _ O
: _ _ O
B _ _ O
: _ _ O
.text _ _ O
loop _ _ O
: _ _ O
.word _ _ O
10 _ _ O
, _ _ O
20 _ _ O
, _ _ O
30 _ _ O
, _ _ O
40 _ _ O
, _ _ O
50 _ _ O
, _ _ O
60 _ _ O
, _ _ O
70 _ _ O
, _ _ O
80 _ _ O
, _ _ O
90 _ _ O
, _ _ O
100 _ _ O
.word _ _ O
0 _ _ O
, _ _ O
0 _ _ O
, _ _ O
0 _ _ O
, _ _ O
0 _ _ O
, _ _ O
0 _ _ O
, _ _ O
0 _ _ O
, _ _ O
0 _ _ O
, _ _ O
0 _ _ O
, _ _ O
0 _ _ O
, _ _ O
0 _ _ O
# _ _ O
la _ _ O
$ _ _ O
s0 _ _ O
, _ _ O
A _ _ O
# _ _ O
address _ _ O
of _ _ O
A _ _ O
li _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
10 _ _ O
# _ _ O
A _ _ O
[ _ _ O
i _ _ O
] _ _ O
* _ _ O
10 _ _ O
li _ _ O
$ _ _ O
s2 _ _ O
, _ _ O
10 _ _ O
# _ _ O
iteration _ _ O
lw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s0 _ _ O
) _ _ O
# _ _ O
read _ _ O
A _ _ O
[ _ _ O
i _ _ O
] _ _ O
mul _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
$t0 _ _ O
, _ _ O
$s1 _ _ O
# _ _ O
$ _ _ O
t0=A _ _ O
[ _ _ O
i _ _ O
] _ _ O
*10 _ _ O
sw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
40 _ _ O
( _ _ O
$s0 _ _ O
) _ _ O
# _ _ O
update _ _ O
A _ _ O
[ _ _ O
i _ _ O
] _ _ O
addi _ _ O
$ _ _ O
s0 _ _ O
, _ _ O
$s0 _ _ O
, _ _ O
4 _ _ O
# _ _ O
next _ _ O
element _ _ O
addi _ _ O
$ _ _ O
s2 _ _ O
, _ _ O
$s2 _ _ O
, _ _ O
-1 _ _ O
# _ _ O
dec _ _ O
iteration _ _ O
bne _ _ O
$ _ _ O
s2 _ _ O
, _ _ O
$0 _ _ O
, _ _ O
loop _ _ O
# _ _ O
done _ _ O
? _ _ O
li _ _ O
$ _ _ O
v0 _ _ O
, _ _ O
10 _ _ O
# _ _ O
exit _ _ O
syscall _ _ O
syscall _ _ O
# _ _ O
syscall _ _ O
instr _ _ O
. _ _ O
count _ _ O
2 _ _ O
1 _ _ O
1 _ _ O
10 _ _ O
10 _ _ O
10 _ _ O
10 _ _ O
10 _ _ O
10 _ _ O
1 _ _ O
1 _ _ O
54 _ _ O

Another _ _ O
example _ _ O
● _ _ O
Let _ _ O
’s _ _ O
analyze _ _ O
the _ _ O
program _ _ O
. _ _ O
● _ _ O
How _ _ O
much _ _ O
time _ _ O
with _ _ O
a _ _ O
Single-Cycle _ _ O
design _ _ O
? _ _ O
1 _ _ O
. _ _ O
What _ _ O
’s _ _ O
the _ _ O
clock _ _ O
length _ _ O
? _ _ O
▪ _ _ O
Assume _ _ O
a _ _ O
clock _ _ O
speed _ _ O
of _ _ O
100 _ _ O
MHz _ _ O
( _ _ O
cycle _ _ O
length _ _ O
is _ _ O
1 _ _ O
/ _ _ O
100MHz _ _ O
, _ _ O
or _ _ O
10ns _ _ O
) _ _ O
2 _ _ O
. _ _ O
What _ _ O
’s _ _ O
the _ _ O
cycles _ _ O
per _ _ O
instruction _ _ O
? _ _ O
▪ _ _ O
CPI _ _ O
: _ _ O
1 _ _ O
( _ _ O
single-cycle _ _ O
! _ _ O
yay _ _ O
! _ _ O
) _ _ O
● _ _ O
Thus _ _ O
this _ _ O
program _ _ O
executes _ _ O
in _ _ O
this _ _ O
much _ _ O
time _ _ O
: _ _ O
o _ _ O
66 _ _ O
instructions _ _ O
* _ _ O
1 _ _ O
CPI _ _ O
* _ _ O
10 _ _ O
ns _ _ O
= _ _ O
660ns _ _ O
55 _ _ O

Another _ _ O
example _ _ O
● _ _ O
How _ _ O
much _ _ O
time _ _ O
with _ _ O
a _ _ O
Multicycle _ _ O
design _ _ O
? _ _ O
1 _ _ O
. _ _ O
We _ _ O
need _ _ O
to _ _ O
know _ _ O
the _ _ O
clock _ _ O
length _ _ O
( _ _ O
what _ _ O
is _ _ O
the _ _ O
clock _ _ O
speed _ _ O
? _ _ O
) _ _ O
Let _ _ O
’s _ _ O
just _ _ O
assume _ _ O
the _ _ O
ideal _ _ O
efficiency _ _ O
: _ _ O
divide _ _ O
the _ _ O
clock _ _ O
length _ _ O
by _ _ O
5 _ _ O
. _ _ O
▪ _ _ O
( _ _ O
Because _ _ O
we _ _ O
said _ _ O
loads _ _ O
, _ _ O
the _ _ O
slowest _ _ O
, _ _ O
take _ _ O
5 _ _ O
cycles _ _ O
while _ _ O
arithmetic _ _ O
takes _ _ O
4 _ _ O
) _ _ O
▪ _ _ O
AKA _ _ O
multiply _ _ O
the _ _ O
clock _ _ O
speed _ _ O
by _ _ O
5 _ _ O
to _ _ O
500 _ _ O
MHz _ _ O
▪ _ _ O
Either _ _ O
way _ _ O
, _ _ O
the _ _ O
clock _ _ O
length _ _ O
is _ _ O
10ns _ _ O
/ _ _ O
5 _ _ O
= _ _ O
2ns _ _ O
2 _ _ O
. _ _ O
What _ _ O
’s _ _ O
the _ _ O
CPI _ _ O
? _ _ O
▪ _ _ O
We _ _ O
need _ _ O
to _ _ O
know _ _ O
how _ _ O
many _ _ O
of _ _ O
each _ _ O
type _ _ O
there _ _ O
are _ _ O
. _ _ O
Look _ _ O
at _ _ O
the _ _ O
program _ _ O
. _ _ O
▪ _ _ O
Arithmetic _ _ O
: _ _ O
36 _ _ O
, _ _ O
Branches _ _ O
: _ _ O
10 _ _ O
, _ _ O
Loads _ _ O
: _ _ O
10 _ _ O
, _ _ O
Stores _ _ O
: _ _ O
10 _ _ O
▪ _ _ O
There _ _ O
’s _ _ O
a _ _ O
different _ _ O
# _ _ O
of _ _ O
cycles _ _ O
per _ _ O
each _ _ O
type _ _ O
( _ _ O
4 _ _ O
, _ _ O
3 _ _ O
, _ _ O
5 _ _ O
, _ _ O
and _ _ O
4 _ _ O
respectively _ _ O
) _ _ O
● _ _ O
Thus _ _ O
this _ _ O
program _ _ O
executes _ _ O
in _ _ O
this _ _ O
much _ _ O
time _ _ O
: _ _ O
o _ _ O
36*4*2ns _ _ O
+ _ _ O
10*3*2ns _ _ O
+ _ _ O
10*5*2ns _ _ O
+ _ _ O
10*4*2ns _ _ O
= _ _ O
528ns _ _ O
● _ _ O
Multicycle _ _ O
, _ _ O
here _ _ O
, _ _ O
let _ _ O
’s _ _ O
us _ _ O
improve _ _ O
our _ _ O
program _ _ O
execution _ _ O
from _ _ O
660ns _ _ O
to _ _ O
528ns _ _ O
( _ _ O
20 _ _ O
% _ _ O
reduction _ _ O
! _ _ O
) _ _ O
56 _ _ O

doo-doo-doo _ _ O
doo-doo-doo-doo-doo _ _ O
● _ _ O
not _ _ O
bad _ _ O
! _ _ O
I _ _ O
guess _ _ O
? _ _ O
I _ _ O
mean _ _ O
, _ _ O
we _ _ O
increased _ _ O
the _ _ O
clock _ _ O
speed _ _ O
by _ _ O
a _ _ O
factor _ _ O
of _ _ O
5 _ _ O
... _ _ O
and _ _ O
we _ _ O
only _ _ O
got _ _ O
20 _ _ O
% _ _ O
reduction _ _ O
on _ _ O
execution _ _ O
time _ _ O
if _ _ O
our _ _ O
CPI _ _ B-Concept
were _ _ O
also _ _ O
close _ _ O
to _ _ O
1 _ _ O
, _ _ O
it _ _ O
'd _ _ O
be _ _ O
10 _ _ O
times _ _ O
as _ _ O
fast _ _ O
as _ _ O
the _ _ O
single-cycle _ _ B-Concept
machine _ _ O
... _ _ O
▪ _ _ O
How _ _ O
do _ _ O
we _ _ O
increase _ _ O
throughput _ _ O
… _ _ O
▪ _ _ O
HMMMMMMMMMMMMMMMMMMMMMM _ _ O
… _ _ O
57 _ _ O



