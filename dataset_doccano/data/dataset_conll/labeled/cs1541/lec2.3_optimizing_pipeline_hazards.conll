['train_set', 'labeled']|cs1541|lec2.3_optimizing_pipeline_hazards
-DOCSTART- -X- -X- O

Optimizing _ _ O
Pipeline _ _ B-Concept
Hazards _ _ I-Concept
CS _ _ O
1541 _ _ O
Wonsun _ _ O
Ahn _ _ O

Solving _ _ O
Structural _ _ B-Concept
Hazards _ _ I-Concept
2 _ _ O

Structural _ _ B-Concept
Hazard _ _ I-Concept
on _ _ O
Memory _ _ B-Concept
● _ _ O
Two _ _ O
instructions _ _ O
need _ _ O
to _ _ O
use _ _ O
the _ _ O
same _ _ O
hardware _ _ O
at _ _ O
the _ _ O
same _ _ O
time _ _ O
. _ _ O
Time _ _ O
0 _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
lw _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$0 _ _ O
) _ _ O
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
lw _ _ O
t1 _ _ O
, _ _ O
4 _ _ O
( _ _ O
$0 _ _ O
) _ _ O
lw _ _ O
t2 _ _ O
, _ _ O
8 _ _ O
( _ _ O
$0 _ _ O
) _ _ O
lw _ _ O
t3 _ _ O
, _ _ O
12 _ _ O
( _ _ O
$0 _ _ O
) _ _ O
5 _ _ O
6 _ _ O
7 _ _ O
WB _ _ B-Concept
3 _ _ O

What _ _ O
could _ _ O
we _ _ O
do _ _ O
? _ _ O
? _ _ O
● _ _ O
Two _ _ O
people _ _ O
need _ _ O
to _ _ O
use _ _ O
one _ _ O
sink _ _ O
at _ _ O
the _ _ O
same _ _ O
time _ _ O
o _ _ O
Well _ _ O
, _ _ O
in _ _ O
this _ _ O
case _ _ O
, _ _ O
it _ _ O
’s _ _ O
memory _ _ B-Concept
but _ _ O
same _ _ O
idea _ _ O
4 _ _ O

We _ _ O
can _ _ O
do _ _ O
something _ _ O
similar _ _ O
! _ _ O
● _ _ O
One _ _ O
option _ _ O
is _ _ O
to _ _ O
wait _ _ O
( _ _ O
a.k.a _ _ O
. _ _ O
stall _ _ B-Concept
) _ _ O
. _ _ O
Time _ _ O
0 _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
lw _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$0 _ _ O
) _ _ O
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
You _ _ O
know _ _ O
what _ _ O
’s _ _ O
worse _ _ O
? _ _ O
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
lw _ _ O
t2 _ _ O
, _ _ O
8 _ _ O
( _ _ O
$0 _ _ O
) _ _ O
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
lw _ _ O
t3 _ _ O
, _ _ O
12 _ _ O
( _ _ O
$0 _ _ O
) _ _ O
The _ _ O
pattern _ _ O
is _ _ O
going _ _ O
to _ _ O
repeat _ _ O
WAIT _ _ O
! _ _ O
IF _ _ B-Concept
WAIT _ _ O
! _ _ O
WAIT _ _ O
! _ _ O
lw _ _ O
t1 _ _ O
, _ _ O
4 _ _ O
( _ _ O
$0 _ _ O
) _ _ O
5 _ _ O
6 _ _ O
7 _ _ O
WB _ _ B-Concept
IF _ _ B-Concept
5 _ _ O

Or _ _ O
we _ _ O
could _ _ O
throw _ _ O
in _ _ O
more _ _ O
hardware _ _ O
! _ _ O
● _ _ O
For _ _ O
less _ _ O
commonly _ _ O
used _ _ O
CPU _ _ O
resources _ _ O
, _ _ O
stalling _ _ B-Concept
can _ _ O
work _ _ O
fine _ _ O
● _ _ O
But _ _ O
memory _ _ B-Concept
( _ _ O
and _ _ O
some _ _ O
other _ _ O
things _ _ O
) _ _ O
is _ _ O
used _ _ O
CONSTANTLY _ _ O
● _ _ O
How _ _ O
do _ _ O
the _ _ O
bathrooms _ _ O
solve _ _ O
this _ _ O
problem _ _ O
? _ _ O
o _ _ O
Throw _ _ O
in _ _ O
lots _ _ O
of _ _ O
sinks _ _ O
! _ _ O
o _ _ O
In _ _ O
other _ _ O
words _ _ O
, _ _ O
throw _ _ O
more _ _ O
hardware _ _ O
at _ _ O
the _ _ O
problem _ _ O
! _ _ O
● _ _ O
Memory _ _ B-Concept
's _ _ I-Concept
a _ _ O
resource _ _ O
with _ _ O
a _ _ O
lot _ _ O
of _ _ O
contention _ _ B-Concept
o _ _ O
So _ _ O
have _ _ O
two _ _ O
memories _ _ B-Concept
, _ _ O
one _ _ O
for _ _ O
instructions _ _ O
, _ _ O
and _ _ O
one _ _ O
for _ _ O
data _ _ O
! _ _ O
o _ _ O
Not _ _ O
literally _ _ O
but _ _ O
CPUs _ _ O
have _ _ O
separate _ _ B-Concept
instruction _ _ I-Concept
and _ _ I-Concept
data _ _ I-Concept
caches _ _ I-Concept
6 _ _ O

Structural _ _ B-Concept
Hazard _ _ I-Concept
removed _ _ O
with _ _ O
two _ _ O
Memories _ _ B-Concept
● _ _ O
With _ _ O
separate _ _ O
i-cache _ _ B-Concept
and _ _ O
d-cache _ _ B-Concept
, _ _ I-Concept
MEM _ _ B-Concept
and _ _ O
IF _ _ B-Concept
can _ _ O
work _ _ O
in _ _ O
parallel _ _ O
Time _ _ O
0 _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
lw _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$0 _ _ O
) _ _ O
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
lw _ _ O
t1 _ _ O
, _ _ O
4 _ _ O
( _ _ O
$0 _ _ O
) _ _ O
lw _ _ O
t2 _ _ O
, _ _ O
8 _ _ O
( _ _ O
$0 _ _ O
) _ _ O
lw _ _ O
t3 _ _ O
, _ _ O
12 _ _ O
( _ _ O
$0 _ _ O
) _ _ O
5 _ _ O
6 _ _ O
7 _ _ O
WB _ _ B-Concept
7 _ _ O

Structural _ _ B-Concept
Hazard _ _ I-Concept
removed _ _ O
with _ _ O
two _ _ O
Memories _ _ B-Concept
● _ _ O
But _ _ O
is _ _ O
that _ _ O
the _ _ O
only _ _ O
hardware _ _ B-Concept
duplication _ _ I-Concept
going _ _ O
on _ _ O
here _ _ O
? _ _ O
Instruction _ _ B-Concept
Memory _ _ I-Concept
Ins _ _ B-Concept
. _ _ I-Concept
Decoder _ _ I-Concept
PC _ _ B-Concept
PCSrc _ _ O
+ _ _ O
4 _ _ O
+ _ _ O
imm _ _ O
field _ _ O
dst _ _ O
src1 _ _ O
src2 _ _ O
RegDataSrc _ _ O
Data _ _ B-Concept
Memory _ _ I-Concept
Register _ _ B-Concept
File _ _ I-Concept
RegWrite _ _ O
imm _ _ O
field _ _ O
sxt _ _ O
MemWrite _ _ O
ALUSrc _ _ O
ALUOp _ _ O
8 _ _ O

Structural _ _ B-Concept
Hazards _ _ I-Concept
removed _ _ O
with _ _ O
Multiple _ _ O
Adders _ _ O
● _ _ O
Why _ _ O
do _ _ O
we _ _ O
need _ _ O
3 _ _ O
adders _ _ O
? _ _ O
To _ _ O
avoid _ _ O
stalls _ _ B-Concept
due _ _ O
to _ _ O
contention _ _ B-Concept
on _ _ O
ALU _ _ B-Concept
! _ _ O
EX _ _ B-Concept
Stage _ _ O
Instruction _ _ B-Concept
Memory _ _ I-Concept
Ins _ _ B-Concept
. _ _ I-Concept
Decoder _ _ I-Concept
PC _ _ B-Concept
PCSrc _ _ O
+ _ _ O
4 _ _ O
+ _ _ O
imm _ _ O
field _ _ O
IF _ _ O
Stage _ _ O
dst _ _ O
src1 _ _ O
src2 _ _ O
RegDataSrc _ _ O
Data _ _ B-Concept
Memory _ _ I-Concept
Register _ _ B-Concept
File _ _ I-Concept
RegWrite _ _ O
imm _ _ O
field _ _ O
sxt _ _ O
MemWrite _ _ O
ALUSrc _ _ O
ALUOp _ _ O
9 _ _ O

Solving _ _ O
Structural _ _ B-Concept
Hazards _ _ I-Concept
● _ _ O
There _ _ O
are _ _ O
mainly _ _ O
two _ _ O
ways _ _ O
to _ _ O
throw _ _ O
more _ _ O
hardware _ _ O
at _ _ O
the _ _ O
problem _ _ O
1 _ _ O
. _ _ O
Duplicate _ _ B-Concept
contentious _ _ I-Concept
resource _ _ I-Concept
o _ _ O
One _ _ O
memory _ _ B-Concept
can _ _ O
not _ _ O
sustain _ _ O
MEM _ _ B-Concept
+ _ _ O
IF _ _ B-Concept
stage _ _ O
at _ _ O
same _ _ O
cycle _ _ B-Concept
→ _ _ O
Duplicate _ _ O
into _ _ O
one _ _ O
instruction _ _ B-Concept
memory _ _ I-Concept
, _ _ O
one _ _ O
data _ _ B-Concept
memory _ _ I-Concept
o _ _ O
One _ _ O
ALU _ _ B-Concept
can _ _ O
not _ _ O
sustain _ _ O
IF _ _ B-Concept
+ _ _ O
EX _ _ B-Concept
stage _ _ O
at _ _ O
same _ _ O
cycle _ _ O
→ _ _ O
Duplicate _ _ O
into _ _ O
one _ _ O
ALU _ _ B-Concept
and _ _ O
two _ _ O
simple _ _ O
adders _ _ O
2 _ _ O
. _ _ O
Add _ _ O
ports _ _ B-Concept
to _ _ O
a _ _ O
single _ _ O
shared _ _ O
memory _ _ O
resource _ _ O
o _ _ O
Port _ _ B-Concept
: _ _ O
Circuitry _ _ O
that _ _ O
allows _ _ O
either _ _ O
read _ _ O
or _ _ O
write _ _ O
access _ _ O
to _ _ O
memory _ _ B-Concept
o _ _ O
If _ _ O
current _ _ O
number _ _ O
of _ _ O
ports _ _ B-Concept
can _ _ O
not _ _ O
sustain _ _ O
rate _ _ O
of _ _ O
access _ _ O
per _ _ O
cycle _ _ B-Concept
→ _ _ O
Add _ _ O
more _ _ O
ports _ _ B-Concept
to _ _ O
memory _ _ B-Concept
structure _ _ I-Concept
for _ _ O
simultaneous _ _ O
access _ _ O
10 _ _ O

Two _ _ O
Register _ _ O
Read _ _ B-Concept
Ports _ _ I-Concept
● _ _ O
By _ _ O
adding _ _ O
more _ _ O
MUXes _ _ B-Concept
, _ _ O
you _ _ O
can _ _ O
add _ _ O
even _ _ O
more _ _ O
read _ _ B-Concept
ports _ _ I-Concept
11 _ _ O

One _ _ O
Register _ _ O
Write _ _ B-Concept
Port _ _ I-Concept
● _ _ O
By _ _ O
adding _ _ O
more _ _ O
decoders _ _ B-Concept
, _ _ O
you _ _ O
can _ _ O
add _ _ O
more _ _ O
write _ _ B-Concept
ports _ _ I-Concept
12 _ _ O

Two _ _ B-Concept
Register _ _ I-Concept
Write _ _ I-Concept
+ _ _ I-Concept
Two _ _ I-Concept
Register _ _ I-Concept
Read _ _ I-Concept
Ports _ _ I-Concept
Dave _ _ O
Tweed _ _ O
( _ _ O
https _ _ O
: _ _ O
/ _ _ O
/ _ _ O
electronics.stackexchange.com _ _ O
/ _ _ O
users _ _ O
/ _ _ O
11683 _ _ O
/ _ _ O
dave-tweed _ _ O
) _ _ O
, _ _ O
Build _ _ O
A _ _ O
Two _ _ O
Port _ _ B-Concept
Write _ _ O
and _ _ O
Two _ _ O
Port _ _ B-Concept
Read _ _ O
Register _ _ O
File _ _ O
with _ _ O
4 _ _ O
Registers _ _ O
, _ _ O
URL _ _ O
( _ _ O
version _ _ O
: _ _ O
2017 _ _ O
- _ _ O
02 _ _ O
- _ _ O
21 _ _ O
) _ _ O
: _ _ O
https _ _ O
: _ _ O
/ _ _ O
/ _ _ O
electronics.stackexchange.com _ _ O
/ _ _ O
q _ _ O
/ _ _ O
273002 _ _ O
13 _ _ O

Two _ _ O
read _ _ B-Concept
ports _ _ I-Concept
and _ _ O
one _ _ O
write _ _ B-Concept
port _ _ I-Concept
is _ _ O
the _ _ O
minimum _ _ O
● _ _ O
2 _ _ O
read _ _ B-Concept
ports _ _ I-Concept
for _ _ O
2 _ _ O
source _ _ O
registers _ _ O
, _ _ O
1 _ _ O
write _ _ B-Concept
port _ _ I-Concept
for _ _ O
dest _ _ O
register _ _ O
o _ _ O
Enough _ _ O
to _ _ O
sustain _ _ O
one _ _ O
ID _ _ B-Concept
and _ _ O
one _ _ O
WB _ _ B-Concept
stage _ _ O
per _ _ O
cycle _ _ O
o _ _ O
Enough _ _ O
to _ _ O
sustain _ _ O
CPI _ _ B-Concept
= _ _ O
1 _ _ O
( _ _ O
or _ _ O
in _ _ O
other _ _ O
words _ _ O
IPC _ _ O
= _ _ O
1 _ _ O
) _ _ O
● _ _ O
But _ _ O
what _ _ O
if _ _ O
we _ _ O
want _ _ O
an _ _ O
IPC _ _ O
> _ _ O
1 _ _ O
? _ _ O
( _ _ O
a.k.a _ _ O
superscalar _ _ B-Concept
processor _ _ I-Concept
) _ _ O
o _ _ O
Must _ _ O
sustain _ _ O
more _ _ O
than _ _ O
one _ _ O
ID _ _ B-Concept
/ _ _ O
WB _ _ B-Concept
stage _ _ O
per _ _ O
cycle _ _ B-Concept
o _ _ O
Need _ _ O
more _ _ O
register _ _ O
read _ _ B-Concept
ports _ _ I-Concept
and _ _ O
write _ _ B-Concept
ports _ _ I-Concept
! _ _ O
o _ _ O
Not _ _ O
only _ _ O
registers _ _ O
, _ _ O
( _ _ O
cache _ _ B-Concept
) _ _ O
memory _ _ B-Concept
would _ _ O
need _ _ O
more _ _ O
ports _ _ B-Concept
too _ _ O
! _ _ O
→ _ _ O
Muxes _ _ B-Concept
, _ _ O
decoders _ _ B-Concept
increase _ _ O
critical _ _ B-Concept
path _ _ I-Concept
( _ _ O
lowers _ _ O
frequency _ _ B-Concept
) _ _ O
→ _ _ O
Extra _ _ O
circuitry _ _ O
consumes _ _ O
more _ _ O
power _ _ B-Concept
● _ _ O
We _ _ O
’ll _ _ O
talk _ _ O
more _ _ O
about _ _ O
this _ _ O
when _ _ O
we _ _ O
discuss _ _ O
superscalars _ _ O
14 _ _ O

Solving _ _ O
Data _ _ B-Concept
Hazards _ _ I-Concept
15 _ _ O

Data _ _ B-Concept
Hazards _ _ I-Concept
● _ _ O
An _ _ O
instruction _ _ O
depends _ _ O
on _ _ O
the _ _ O
output _ _ O
of _ _ O
a _ _ O
previous _ _ O
one _ _ O
. _ _ O
Time _ _ O
0 _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
add _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t2 _ _ O
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
sub _ _ O
s0 _ _ O
, _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
5 _ _ O
6 _ _ O
7 _ _ O
WB _ _ B-Concept
● _ _ O
When _ _ O
does _ _ O
add _ _ O
finish _ _ O
computing _ _ O
its _ _ O
sum _ _ O
? _ _ O
● _ _ O
Well _ _ O
then _ _ O
... _ _ O
why _ _ O
not _ _ O
just _ _ O
use _ _ O
the _ _ O
sum _ _ O
when _ _ O
we _ _ O
need _ _ O
it _ _ O
? _ _ O
16 _ _ O

Solution _ _ O
1 _ _ O
: _ _ O
Data _ _ B-Concept
Forwarding _ _ I-Concept
● _ _ O
Since _ _ O
we _ _ O
've _ _ O
pipelined _ _ B-Concept
control _ _ B-Concept
signals _ _ I-Concept
, _ _ O
we _ _ O
can _ _ O
check _ _ O
if _ _ O
instructions _ _ O
in _ _ O
the _ _ O
pipeline _ _ B-Concept
depend _ _ O
on _ _ O
each _ _ O
other _ _ O
( _ _ O
see _ _ O
if _ _ O
registers _ _ O
match _ _ O
) _ _ O
. _ _ O
● _ _ O
If _ _ O
we _ _ O
detect _ _ O
any _ _ O
dependencies _ _ B-Concept
, _ _ O
we _ _ O
can _ _ O
forward _ _ B-Concept
the _ _ O
needed _ _ O
data _ _ O
. _ _ O
Time _ _ O
0 _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
add _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t2 _ _ O
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
sub _ _ O
s0 _ _ O
, _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
5 _ _ O
6 _ _ O
7 _ _ O
WB _ _ B-Concept
● _ _ O
This _ _ O
handles _ _ O
one _ _ O
kind _ _ O
of _ _ O
data _ _ B-Concept
forwarding _ _ I-Concept
... _ _ O
● _ _ O
Where _ _ O
else _ _ O
can _ _ O
data _ _ O
come _ _ O
from _ _ O
and _ _ O
be _ _ O
written _ _ O
into _ _ O
registers _ _ O
? _ _ O
● _ _ O
Memory _ _ B-Concept
! _ _ O
17 _ _ O

Data _ _ B-Concept
Forwarding _ _ I-Concept
from _ _ O
Memory _ _ B-Concept
● _ _ O
Well _ _ O
memory _ _ O
accesses _ _ O
happen _ _ O
a _ _ O
cycle _ _ B-Concept
later _ _ O
... _ _ O
● _ _ O
What _ _ O
are _ _ O
we _ _ O
going _ _ O
to _ _ O
have _ _ O
to _ _ O
do _ _ O
? _ _ O
Time _ _ O
0 _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
lw _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
t4 _ _ O
) _ _ O
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
IF _ _ B-Concept
ID _ _ B-Concept
sub _ _ O
s0 _ _ O
, _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
WAIT _ _ O
! _ _ O
EX _ _ B-Concept
5 _ _ O
6 _ _ O
MEM _ _ B-Concept
WB _ _ B-Concept
7 _ _ O
● _ _ O
This _ _ O
kind _ _ O
of _ _ O
stall _ _ B-Concept
is _ _ O
unavoidable _ _ O
in _ _ O
our _ _ O
current _ _ O
pipeline _ _ O
18 _ _ O

Forwarding _ _ B-Concept
Unit _ _ I-Concept
and _ _ O
Use-after-load-hazard _ _ B-Concept
If _ _ O
dependent _ _ O
on _ _ O
MemRead _ _ O
( _ _ O
load _ _ O
) _ _ O
instruction _ _ O
, _ _ O
even _ _ O
forwarding _ _ B-Concept
unit _ _ I-Concept
ca _ _ O
n’t _ _ O
avoid _ _ O
stall _ _ B-Concept
19 _ _ O

Forwarding _ _ B-Concept
Unit _ _ I-Concept
● _ _ O
Just _ _ O
like _ _ O
the _ _ O
HDU _ _ B-Concept
, _ _ O
the _ _ O
Forwarding _ _ B-Concept
Unit _ _ I-Concept
is _ _ O
power _ _ O
hungry _ _ O
● _ _ O
Number _ _ O
of _ _ O
forwarding _ _ O
wires _ _ O
∝ _ _ O
( _ _ O
pipeline _ _ B-Concept
stages _ _ I-Concept
) _ _ O
2 _ _ O
o _ _ O
Why _ _ O
the _ _ O
quadratic _ _ O
relationship _ _ O
? _ _ O
o _ _ O
Per _ _ O
pipeline _ _ B-Concept
stage _ _ I-Concept
, _ _ O
N _ _ O
stages _ _ B-Concept
after _ _ O
it _ _ O
from _ _ O
which _ _ O
data _ _ O
is _ _ O
forwarded _ _ B-Concept
▪ _ _ O
In _ _ O
previous _ _ O
picture _ _ O
, _ _ O
see _ _ O
number _ _ O
of _ _ O
inputs _ _ O
to _ _ O
MUX _ _ B-Concept
before _ _ O
ALU _ _ B-Concept
! _ _ O
o _ _ O
And _ _ O
there _ _ O
are _ _ O
N _ _ O
stages _ _ B-Concept
to _ _ O
which _ _ O
data _ _ O
must _ _ O
be _ _ O
forwarded _ _ O
▪ _ _ O
In _ _ O
previous _ _ O
picture _ _ O
, _ _ O
only _ _ O
one _ _ O
EX _ _ B-Concept
stage _ _ B-Concept
is _ _ O
shown _ _ O
, _ _ O
but _ _ O
if _ _ O
there _ _ O
are _ _ O
multiple _ _ O
stages _ _ B-Concept
, _ _ O
need _ _ O
MUXes _ _ B-Concept
in _ _ O
all _ _ O
those _ _ O
stages _ _ B-Concept
● _ _ O
Deep _ _ B-Concept
pipelining _ _ I-Concept
has _ _ O
diminishing _ _ O
returns _ _ O
on _ _ O
power _ _ O
investment _ _ O
o _ _ O
Cycle _ _ O
time _ _ O
improves _ _ O
by _ _ O
a _ _ O
factor _ _ O
of _ _ O
N _ _ O
o _ _ O
Power _ _ O
consumption _ _ O
increases _ _ O
by _ _ O
a _ _ O
factor _ _ O
of _ _ O
N2 _ _ O
( _ _ O
or _ _ O
more _ _ O
) _ _ O
o _ _ O
Not _ _ O
the _ _ O
only _ _ O
problem _ _ O
with _ _ O
deep _ _ O
pipelining _ _ O
that _ _ O
we _ _ O
will _ _ O
see _ _ O
20 _ _ O

Solution _ _ O
2 _ _ O
: _ _ O
Avoid _ _ O
stalls _ _ B-Concept
by _ _ O
reordering _ _ B-Concept
● _ _ O
Let _ _ O
’s _ _ O
say _ _ O
the _ _ O
following _ _ O
is _ _ O
your _ _ O
morning _ _ O
routine _ _ O
( _ _ O
2 _ _ O
hours _ _ O
total _ _ O
) _ _ O
1 _ _ O
. _ _ O
Have _ _ O
laundry _ _ O
running _ _ O
in _ _ O
washing _ _ O
machine _ _ O
( _ _ O
30 _ _ O
minutes _ _ O
) _ _ O
2 _ _ O
. _ _ O
Have _ _ O
laundry _ _ O
running _ _ O
in _ _ O
dryer _ _ O
( _ _ O
30 _ _ O
minutes _ _ O
) _ _ O
3 _ _ O
. _ _ O
Have _ _ O
some _ _ O
tea _ _ O
boiling _ _ O
in _ _ O
the _ _ O
pot _ _ O
( _ _ O
30 _ _ O
minutes _ _ O
) _ _ O
4 _ _ O
. _ _ O
Drink _ _ O
tea _ _ O
( _ _ O
30 _ _ O
minutes _ _ O
) _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
● _ _ O
Can _ _ O
you _ _ O
make _ _ O
this _ _ O
shorter _ _ O
? _ _ O
Yes _ _ O
! _ _ O
( _ _ O
1 _ _ O
hour _ _ O
total _ _ O
) _ _ O
1 _ _ O
. _ _ O
Have _ _ O
washing _ _ O
machine _ _ O
running _ _ O
and _ _ O
3 _ _ O
. _ _ O
Tea _ _ O
boiling _ _ O
( _ _ O
30 _ _ O
minutes _ _ O
) _ _ O
2 _ _ O
. _ _ O
Have _ _ O
dryer _ _ O
running _ _ O
and _ _ O
4 _ _ O
. _ _ O
Drink _ _ O
tea _ _ O
( _ _ O
30 _ _ O
minutes _ _ O
) _ _ O
● _ _ O
How _ _ O
? _ _ O
By _ _ O
simply _ _ O
by _ _ O
reordering _ _ B-Concept
our _ _ O
actions _ _ O
o _ _ O
Steps _ _ O
1 _ _ O
→ _ _ O
2 _ _ O
and _ _ O
3 _ _ O
→ _ _ O
4 _ _ O
have _ _ O
data _ _ O
dependencies _ _ O
o _ _ O
Other _ _ O
steps _ _ O
can _ _ O
be _ _ O
freely _ _ O
reordered _ _ B-Concept
with _ _ O
each _ _ O
other _ _ O
1 _ _ O
3 _ _ O
2 _ _ O
4 _ _ O
21 _ _ O

Data _ _ B-Concept
Hazard _ _ I-Concept
removed _ _ O
through _ _ O
Compiler _ _ B-Concept
Reordering _ _ I-Concept
● _ _ O
If _ _ O
the _ _ O
compiler _ _ O
has _ _ O
knowledge _ _ O
of _ _ O
how _ _ O
the _ _ O
pipeline _ _ B-Concept
works _ _ O
, _ _ O
it _ _ O
can _ _ O
reorder _ _ B-Concept
instructions _ _ O
to _ _ O
let _ _ O
loads _ _ O
complete _ _ O
before _ _ O
using _ _ O
their _ _ O
data _ _ O
. _ _ O
Time _ _ O
0 _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
5 _ _ O
6 _ _ O
7 _ _ O
lw _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
t4 _ _ O
) _ _ O
sub _ _ O
s0 _ _ O
, _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
lw _ _ O
t2 _ _ O
, _ _ O
4 _ _ O
( _ _ O
t4 _ _ O
) _ _ O
sub _ _ O
s1 _ _ O
, _ _ O
t2 _ _ O
, _ _ O
t3 _ _ O
22 _ _ O

Data _ _ B-Concept
Hazard _ _ I-Concept
removed _ _ O
through _ _ O
Compiler _ _ B-Concept
Reordering _ _ I-Concept
● _ _ O
If _ _ O
the _ _ O
compiler _ _ O
has _ _ O
knowledge _ _ O
of _ _ O
how _ _ O
the _ _ O
pipeline _ _ B-Concept
works _ _ O
, _ _ O
it _ _ O
can _ _ O
reorder _ _ B-Concept
instructions _ _ O
to _ _ O
let _ _ O
loads _ _ O
complete _ _ O
before _ _ O
using _ _ O
their _ _ O
data _ _ O
. _ _ O
Time _ _ O
0 _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
lw _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
t4 _ _ O
) _ _ O
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
lw _ _ O
t2 _ _ O
, _ _ O
4 _ _ O
( _ _ O
t4 _ _ O
) _ _ O
sub _ _ O
s0 _ _ O
, _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
sub _ _ O
s1 _ _ O
, _ _ O
t2 _ _ O
, _ _ O
t3 _ _ O
5 _ _ O
6 _ _ O
7 _ _ O
WB _ _ B-Concept
23 _ _ O

Limits _ _ O
of _ _ O
Static _ _ B-Concept
Scheduling _ _ I-Concept
● _ _ O
Reordering _ _ B-Concept
done _ _ O
by _ _ O
the _ _ O
compiler _ _ B-Concept
is _ _ O
called _ _ O
static _ _ B-Concept
scheduling _ _ I-Concept
● _ _ O
Static _ _ B-Concept
scheduling _ _ I-Concept
is _ _ O
a _ _ O
powerful _ _ O
tool _ _ O
but _ _ O
is _ _ O
in _ _ O
some _ _ O
ways _ _ O
limited _ _ O
o _ _ O
Again _ _ O
, _ _ O
compiler _ _ O
must _ _ O
make _ _ O
assumptions _ _ O
about _ _ O
pipeline _ _ B-Concept
▪ _ _ O
Length _ _ O
of _ _ O
MEM _ _ B-Concept
stage _ _ O
is _ _ O
very _ _ O
hard _ _ O
to _ _ O
predict _ _ O
by _ _ O
the _ _ O
compiler _ _ O
▪ _ _ O
Remember _ _ O
the _ _ O
Memory _ _ B-Concept
Wall _ _ I-Concept
? _ _ O
o _ _ O
Data _ _ B-Concept
dependencies _ _ I-Concept
are _ _ O
hard _ _ O
to _ _ O
figure _ _ O
out _ _ O
by _ _ O
a _ _ O
compiler _ _ O
▪ _ _ O
When _ _ O
data _ _ O
is _ _ O
in _ _ O
registers _ _ O
, _ _ O
trivial _ _ O
to _ _ O
figure _ _ O
out _ _ O
▪ _ _ O
When _ _ O
data _ _ O
is _ _ O
in _ _ O
memory _ _ O
locations _ _ O
, _ _ O
more _ _ O
difficult _ _ O
. _ _ O
Given _ _ O
: _ _ O
lw _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
t4 _ _ O
) _ _ O
sw _ _ O
s0 _ _ O
, _ _ O
8 _ _ O
( _ _ O
t0 _ _ O
) _ _ O
We _ _ O
want _ _ O
to _ _ O
reorder _ _ O
to _ _ O
remove _ _ O
the _ _ O
data _ _ O
hazard _ _ O
. _ _ O
lw _ _ O
t2 _ _ O
, _ _ O
4 _ _ O
( _ _ O
t4 _ _ O
) _ _ O
But _ _ O
what _ _ O
if _ _ O
8 _ _ O
( _ _ O
t0 _ _ O
) _ _ O
and _ _ O
4 _ _ O
( _ _ O
t4 _ _ O
) _ _ O
are _ _ O
the _ _ O
same _ _ O
addresses _ _ O
? _ _ O
This _ _ O
involves _ _ O
pointer _ _ B-Concept
analysis _ _ I-Concept
, _ _ O
a _ _ O
notoriously _ _ O
difficult _ _ O
analysis _ _ O
! _ _ O
24 _ _ O

Dynamic _ _ B-Concept
scheduling _ _ I-Concept
is _ _ O
another _ _ O
option _ _ O
● _ _ O
Dynamic _ _ B-Concept
scheduling _ _ I-Concept
is _ _ O
scheduling _ _ O
done _ _ O
by _ _ O
the _ _ O
CPU _ _ O
● _ _ O
It _ _ O
does _ _ O
n’t _ _ O
have _ _ O
the _ _ O
limitations _ _ O
of _ _ O
static _ _ B-Concept
scheduling _ _ I-Concept
o _ _ O
It _ _ O
does _ _ O
n’t _ _ O
have _ _ O
to _ _ O
predict _ _ O
memory _ _ O
latency _ _ O
▪ _ _ O
It _ _ O
can _ _ O
adapt _ _ O
as _ _ O
things _ _ O
unfold _ _ O
o _ _ O
It _ _ O
’s _ _ O
easy _ _ O
to _ _ O
figure _ _ O
out _ _ O
data _ _ B-Concept
dependencies _ _ I-Concept
, _ _ O
even _ _ O
memory _ _ O
ones _ _ O
▪ _ _ O
At _ _ O
runtime _ _ O
, _ _ O
addresses _ _ O
of _ _ O
8 _ _ O
( _ _ O
t0 _ _ O
) _ _ O
and _ _ O
4 _ _ O
( _ _ O
t4 _ _ O
) _ _ O
are _ _ O
easily _ _ O
calculated _ _ O
● _ _ O
But _ _ O
at _ _ O
runtime _ _ O
it _ _ O
uses _ _ O
lots _ _ O
of _ _ O
power _ _ O
for _ _ O
the _ _ O
data _ _ O
analysis _ _ O
o _ _ O
… _ _ O
which _ _ O
again _ _ O
causes _ _ O
problems _ _ O
with _ _ O
the _ _ O
Power _ _ B-Concept
Wall _ _ I-Concept
o _ _ O
But _ _ O
more _ _ O
on _ _ O
this _ _ O
later _ _ O
25 _ _ O

Solving _ _ O
Control _ _ B-Concept
Hazards _ _ I-Concept
26 _ _ O

Loops _ _ O
● _ _ O
Loops _ _ O
happen _ _ O
all _ _ O
the _ _ O
time _ _ O
in _ _ O
programs _ _ O
. _ _ O
for _ _ O
( _ _ O
s0 _ _ O
= _ _ O
0 _ _ O
.. _ _ O
10 _ _ O
) _ _ O
print _ _ O
( _ _ O
s0 _ _ O
) _ _ O
; _ _ O
printf _ _ O
( _ _ O
"done _ _ O
" _ _ O
) _ _ O
; _ _ O
How _ _ O
often _ _ O
does _ _ O
this _ _ O
blt _ _ O
instruction _ _ O
go _ _ O
to _ _ O
top _ _ O
? _ _ O
How _ _ O
often _ _ O
does _ _ O
it _ _ O
go _ _ O
to _ _ O
the _ _ O
following _ _ O
la _ _ O
instruction _ _ O
? _ _ O
li _ _ O
s0 _ _ O
, _ _ O
0 _ _ O
top _ _ O
: _ _ O
move _ _ O
a0 _ _ O
, _ _ O
s0 _ _ O
jal _ _ O
print _ _ O
addi _ _ O
s0 _ _ O
, _ _ O
s0 _ _ O
, _ _ O
1 _ _ O
blt _ _ O
s0 _ _ O
, _ _ O
10 _ _ O
, _ _ O
top _ _ O
la _ _ O
jal _ _ O
a0 _ _ O
, _ _ O
done_msg _ _ O
printf _ _ O
27 _ _ O

Pipeline _ _ B-Concept
Flushes _ _ B-Concept
at _ _ O
Every _ _ O
Loop _ _ O
Iteration _ _ O
● _ _ O
The _ _ O
pipeline _ _ B-Concept
must _ _ O
be _ _ O
flushed _ _ B-Concept
every _ _ O
time _ _ O
the _ _ O
code _ _ O
loops _ _ O
back _ _ O
! _ _ O
Time _ _ O
blt _ _ O
s0 _ _ O
, _ _ O
10 _ _ O
, _ _ O
top _ _ O
la _ _ O
a0 _ _ O
, _ _ O
done_msg _ _ O
jal _ _ O
printf _ _ O
s0 _ _ O
< _ _ O
10 _ _ O
... _ _ O
OOPS _ _ O
! _ _ O
move _ _ O
a0 _ _ O
, _ _ O
s0 _ _ O
0 _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
IF _ _ B-Concept
ID _ _ B-Concept
IF _ _ B-Concept
ID _ _ B-Concept
5 _ _ O
6 _ _ O
7 _ _ O
EX _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
IF _ _ B-Concept
28 _ _ O

Performance _ _ O
Impact _ _ O
from _ _ O
Control _ _ B-Concept
Hazards _ _ I-Concept
● _ _ O
Frequency _ _ B-Concept
of _ _ O
flushes _ _ B-Concept
∝ _ _ O
frequency _ _ O
of _ _ O
branches _ _ O
o _ _ O
If _ _ O
we _ _ O
have _ _ O
a _ _ O
tight _ _ O
loop _ _ O
, _ _ O
branches _ _ O
happen _ _ O
every _ _ O
few _ _ O
instructions _ _ O
o _ _ O
Typically _ _ O
, _ _ O
branches _ _ O
account _ _ O
for _ _ O
15~20 _ _ O
% _ _ O
of _ _ O
all _ _ O
instructions _ _ O
● _ _ O
Penalty _ _ O
from _ _ O
one _ _ O
flush _ _ O
∝ _ _ O
depth _ _ O
of _ _ O
pipeline _ _ O
o _ _ O
Number _ _ O
of _ _ O
flushed _ _ O
instructions _ _ O
= _ _ O
= _ _ O
distance _ _ O
from _ _ O
IF _ _ O
to _ _ O
EX _ _ O
o _ _ O
What _ _ O
if _ _ O
3 _ _ O
IF _ _ O
stages _ _ O
, _ _ O
4 _ _ O
ID _ _ O
stages _ _ O
, _ _ O
and _ _ O
3 _ _ O
EX _ _ O
stages _ _ O
? _ _ O
Penalty _ _ O
= _ _ O
= _ _ O
10 _ _ O
! _ _ O
● _ _ O
Current _ _ O
architectures _ _ O
can _ _ O
have _ _ O
more _ _ O
than _ _ O
20 _ _ O
stages _ _ O
! _ _ O
o _ _ O
May _ _ O
spend _ _ O
more _ _ O
time _ _ O
just _ _ O
flushing _ _ O
instructions _ _ O
than _ _ O
doing _ _ O
work _ _ O
! _ _ O
o _ _ O
Another _ _ O
reason _ _ O
why _ _ O
deep _ _ O
pipelines _ _ O
are _ _ O
problematic _ _ O
29 _ _ O

Performance _ _ O
Impact _ _ O
from _ _ O
Control _ _ B-Concept
Hazards _ _ I-Concept
● _ _ O
CPI _ _ O
= _ _ O
CPInch _ _ O
+ _ _ O
a _ _ O
* _ _ O
p _ _ O
* _ _ O
K _ _ O
o _ _ O
CPInch _ _ O
: _ _ O
CPI _ _ O
with _ _ O
no _ _ O
control _ _ O
hazard _ _ O
o _ _ O
a _ _ O
: _ _ O
fraction _ _ O
of _ _ O
branch _ _ O
instructions _ _ O
in _ _ O
the _ _ O
instruction _ _ O
mix _ _ O
o _ _ O
p _ _ O
: _ _ O
probability _ _ O
a _ _ O
branch _ _ O
is _ _ O
actually _ _ O
taken _ _ O
o _ _ O
K _ _ O
: _ _ O
penalty _ _ O
per _ _ O
pipeline _ _ O
flush _ _ O
Example _ _ O
: _ _ O
If _ _ O
20 _ _ O
% _ _ O
of _ _ O
instructions _ _ O
are _ _ O
branches _ _ O
and _ _ O
the _ _ O
probability _ _ O
that _ _ O
a _ _ O
branch _ _ O
is _ _ O
taken _ _ O
is _ _ O
50 _ _ O
% _ _ O
, _ _ O
and _ _ O
pipeline _ _ O
flush _ _ O
penalty _ _ O
7 _ _ O
cycles _ _ O
, _ _ O
then _ _ O
: _ _ O
CPI _ _ O
= _ _ O
CPInch _ _ O
+ _ _ O
0.2 _ _ O
* _ _ O
0.5 _ _ O
* _ _ O
7 _ _ O
= _ _ O
CPInch _ _ O
+ _ _ O
0.7 _ _ O
cycles _ _ O
per _ _ O
instruction _ _ O
● _ _ O
What _ _ O
if _ _ O
we _ _ O
had _ _ O
a _ _ O
compiler _ _ O
insert _ _ O
no-ops _ _ B-Concept
, _ _ O
with _ _ O
no _ _ O
HDU _ _ B-Concept
? _ _ O
o _ _ O
It _ _ O
’s _ _ O
even _ _ O
worse _ _ O
, _ _ O
as _ _ O
we _ _ O
will _ _ O
soon _ _ O
see _ _ O
. _ _ O
30 _ _ O

Compiler _ _ O
avoiding _ _ O
the _ _ O
control _ _ B-Concept
hazard _ _ I-Concept
without _ _ O
HDU _ _ B-Concept
● _ _ O
Since _ _ O
compiler _ _ O
does _ _ O
not _ _ O
know _ _ O
direction _ _ O
, _ _ O
must _ _ O
always _ _ O
insert _ _ O
two _ _ O
nops _ _ B-Concept
Cycle _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
5 _ _ O
blt _ _ O
s0 _ _ O
, _ _ O
10 _ _ O
, _ _ O
top _ _ O
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
bubble _ _ B-Concept
bubble _ _ B-Concept
bubble _ _ B-Concept
bubble _ _ B-Concept
bubble _ _ B-Concept
bubble _ _ B-Concept
bubble _ _ B-Concept
bubble _ _ B-Concept
bubble _ _ B-Concept
bubble _ _ B-Concept
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
nop _ _ B-Concept
nop _ _ B-Concept
move _ _ O
a0 _ _ O
, _ _ O
s0 _ _ O
6 _ _ O
7 _ _ O
8 _ _ O
WB _ _ B-Concept
31 _ _ O

Performance _ _ O
Impact _ _ O
without _ _ O
Hazard _ _ B-Concept
Detection _ _ I-Concept
Unit _ _ I-Concept
● _ _ O
CPI _ _ B-Concept
= _ _ O
CPInch _ _ O
+ _ _ O
a _ _ O
* _ _ O
K _ _ O
o _ _ O
CPInch _ _ O
: _ _ O
CPI _ _ B-Concept
with _ _ O
no _ _ O
control _ _ B-Concept
hazard _ _ I-Concept
o _ _ O
a _ _ O
: _ _ O
fraction _ _ O
of _ _ O
branch _ _ O
instructions _ _ O
in _ _ O
the _ _ O
instruction _ _ O
mix _ _ O
o _ _ O
K _ _ O
: _ _ O
no-ops _ _ B-Concept
inserted _ _ O
after _ _ O
each _ _ O
branch _ _ O
Example _ _ O
: _ _ O
If _ _ O
20 _ _ O
% _ _ O
of _ _ O
instructions _ _ O
are _ _ O
branches _ _ O
and _ _ O
the _ _ O
probability _ _ O
that _ _ O
a _ _ O
branch _ _ O
is _ _ O
taken _ _ O
is _ _ O
50 _ _ O
% _ _ O
, _ _ O
and _ _ O
branch _ _ O
resolution _ _ O
delay _ _ O
of _ _ O
7 _ _ O
no-ops _ _ B-Concept
, _ _ O
then _ _ O
: _ _ O
CPI _ _ O
= _ _ O
CPInch _ _ O
+ _ _ O
0.2 _ _ O
* _ _ O
7 _ _ O
= _ _ O
CPInch _ _ O
+ _ _ O
1.4 _ _ O
cycles _ _ O
per _ _ O
instruction _ _ O
o _ _ O
Branch-taken _ _ O
rate _ _ O
is _ _ O
irrelevant _ _ O
- _ _ O
compiler _ _ O
always _ _ O
inserts _ _ O
two _ _ O
nops _ _ B-Concept
● _ _ O
Is _ _ O
there _ _ O
a _ _ O
way _ _ O
to _ _ O
minimize _ _ O
the _ _ O
performance _ _ O
impact _ _ O
? _ _ O
32 _ _ O

Solution _ _ O
1 _ _ O
: _ _ O
Delay _ _ B-Concept
Slots _ _ I-Concept
● _ _ O
Idea _ _ O
: _ _ O
Use _ _ O
compiler _ _ O
static _ _ B-Concept
scheduling _ _ I-Concept
to _ _ O
fill _ _ O
no-ops _ _ B-Concept
with _ _ O
useful _ _ O
work _ _ O
o _ _ O
Remember _ _ O
? _ _ O
We _ _ O
did _ _ O
the _ _ O
same _ _ O
for _ _ O
no-ops _ _ B-Concept
due _ _ O
to _ _ O
data _ _ B-Concept
hazards _ _ I-Concept
. _ _ O
● _ _ O
Delay _ _ B-Concept
slot _ _ I-Concept
: _ _ O
One _ _ O
or _ _ O
more _ _ O
instructions _ _ O
immediately _ _ O
following _ _ O
a _ _ O
branch _ _ O
instruction _ _ O
that _ _ O
executes _ _ O
regardless _ _ O
of _ _ O
branch _ _ O
direction _ _ O
o _ _ O
Processor _ _ O
never _ _ O
needs _ _ O
to _ _ O
flush _ _ O
these _ _ O
instructions _ _ O
! _ _ O
o _ _ O
ISA _ _ O
must _ _ O
be _ _ O
modified _ _ O
to _ _ O
support _ _ O
this _ _ O
branch _ _ O
semantic _ _ O
o _ _ O
It _ _ O
’s _ _ O
compiler _ _ O
’s _ _ O
job _ _ O
to _ _ O
fill _ _ O
delay _ _ B-Concept
slots _ _ I-Concept
as _ _ O
best _ _ O
as _ _ O
it _ _ O
can _ _ O
, _ _ O
with _ _ O
instructions _ _ O
not _ _ O
control _ _ O
dependent _ _ O
on _ _ O
the _ _ O
branch _ _ O
33 _ _ O

Compiler _ _ O
static _ _ B-Concept
scheduling _ _ I-Concept
using _ _ O
delay _ _ O
slots _ _ O
blt _ _ O
s0 _ _ O
, _ _ O
10 _ _ O
, _ _ O
else _ _ O
nop _ _ O
# _ _ O
Delay _ _ O
slot _ _ O
then _ _ O
: _ _ O
add _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t0 _ _ O
j _ _ O
merge _ _ O
else _ _ O
: _ _ O
add _ _ O
t1 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t0 _ _ O
merge _ _ O
: _ _ O
addi _ _ O
t2 _ _ O
, _ _ O
t2 _ _ O
, _ _ O
1 _ _ O
blt _ _ O
s0 _ _ O
, _ _ O
10 _ _ O
, _ _ O
else _ _ O
addi _ _ O
t2 _ _ O
, _ _ O
t2 _ _ O
, _ _ O
1 _ _ O
# _ _ O
Slot _ _ O
then _ _ O
: _ _ O
add _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t0 _ _ O
j _ _ O
merge _ _ O
else _ _ O
: _ _ O
add _ _ O
t1 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t0 _ _ O
merge _ _ O
: _ _ O
… _ _ O
• _ _ O
The _ _ O
addi _ _ O
instruction _ _ O
is _ _ O
moved _ _ O
into _ _ O
delay _ _ B-Concept
slot _ _ I-Concept
o _ _ O
It _ _ O
is _ _ O
not _ _ O
control _ _ O
dependent _ _ O
on _ _ O
the _ _ O
branch _ _ O
outcome _ _ O
of _ _ O
blt _ _ O
o _ _ O
It _ _ O
is _ _ O
not _ _ O
data _ _ O
dependent _ _ O
on _ _ O
registers _ _ O
t0 _ _ O
or _ _ O
t1 _ _ O
34 _ _ O

Delay _ _ B-Concept
slots _ _ I-Concept
are _ _ O
losing _ _ O
popularity _ _ O
● _ _ O
Sounded _ _ O
like _ _ O
a _ _ O
good _ _ O
idea _ _ O
on _ _ O
paper _ _ O
but _ _ O
did _ _ O
n’t _ _ O
work _ _ O
well _ _ O
in _ _ O
practice _ _ O
1 _ _ O
. _ _ O
Turns _ _ O
out _ _ O
filling _ _ O
delay _ _ B-Concept
slots _ _ I-Concept
with _ _ O
the _ _ O
compiler _ _ O
is _ _ O
not _ _ O
always _ _ O
easy _ _ O
o _ _ O
Often _ _ O
data _ _ O
and _ _ O
control _ _ O
independent _ _ O
instructions _ _ O
do _ _ O
n’t _ _ O
exist _ _ O
2 _ _ O
. _ _ O
Delay _ _ B-Concept
slots _ _ I-Concept
baked _ _ O
into _ _ O
the _ _ O
ISA _ _ O
were _ _ O
not _ _ O
future _ _ O
proof _ _ O
o _ _ O
Number _ _ O
of _ _ O
delay _ _ B-Concept
slots _ _ I-Concept
did _ _ O
not _ _ O
match _ _ O
new _ _ O
generation _ _ O
of _ _ O
CPUs _ _ O
o _ _ O
New _ _ O
generation _ _ O
of _ _ O
CPUs _ _ O
had _ _ O
fancier _ _ O
ways _ _ O
to _ _ O
avoid _ _ O
bubbles _ _ B-Concept
o _ _ O
Delays _ _ B-Concept
slots _ _ I-Concept
ended _ _ O
up _ _ O
being _ _ O
a _ _ O
hindrance _ _ O
● _ _ O
Next _ _ O
idea _ _ O
please _ _ O
! _ _ O
35 _ _ O

Solution _ _ O
2 _ _ O
: _ _ O
MORE _ _ O
SINKS _ _ O
! _ _ O
( _ _ O
a.k.a _ _ O
. _ _ O
hardware _ _ O
) _ _ O
36 _ _ O

Do _ _ O
we _ _ O
reeeally _ _ O
need _ _ O
to _ _ O
compare _ _ O
at _ _ O
EX _ _ B-Concept
stage _ _ O
? _ _ O
● _ _ O
What _ _ O
if _ _ O
branch _ _ O
comparison _ _ O
was _ _ O
done _ _ O
at _ _ O
the _ _ O
ID _ _ B-Concept
stage _ _ O
, _ _ O
not _ _ O
EX _ _ B-Concept
stage _ _ O
? _ _ O
Time _ _ O
blt _ _ O
s0 _ _ O
, _ _ O
10 _ _ O
, _ _ O
top _ _ O
la _ _ O
a0 _ _ O
, _ _ O
done_msg _ _ O
s0 _ _ O
< _ _ O
10 _ _ O
... _ _ O
OOPS _ _ O
! _ _ O
move _ _ O
a0 _ _ O
, _ _ O
s0 _ _ O
0 _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
5 _ _ O
6 _ _ O
MEM _ _ B-Concept
WB _ _ B-Concept
7 _ _ O
IF _ _ O
● _ _ O
Reduced _ _ O
penalty _ _ O
from _ _ O
2 _ _ O
cycles _ _ O
→ _ _ O
1 _ _ O
cycle _ _ O
! _ _ O
● _ _ O
But _ _ O
of _ _ O
course _ _ O
that _ _ O
means _ _ O
we _ _ O
need _ _ O
a _ _ O
comparator _ _ B-Concept
at _ _ O
the _ _ O
ID _ _ B-Concept
stage _ _ O
37 _ _ O

Solution _ _ O
2 _ _ O
: _ _ O
MORE _ _ O
SINKS _ _ O
! _ _ O
( _ _ O
a.k.a _ _ O
. _ _ O
hardware _ _ O
) _ _ O
Extra _ _ O
comparator _ _ B-Concept
to _ _ O
determine _ _ O
branch _ _ O
direction _ _ O
Instead _ _ O
of _ _ O
doing _ _ O
it _ _ O
here _ _ O
38 _ _ O

Not _ _ O
all _ _ O
sunshine _ _ O
and _ _ O
rainbows _ _ O
● _ _ O
Extra _ _ O
delay _ _ O
on _ _ O
data _ _ B-Concept
hazards _ _ I-Concept
. _ _ O
Used _ _ O
to _ _ O
have _ _ O
no _ _ O
delay _ _ O
: _ _ O
Time _ _ O
0 _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
sub _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t2 _ _ O
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
beq _ _ O
t0 _ _ O
, _ _ O
$0 _ _ O
, _ _ O
end _ _ O
5 _ _ O
6 _ _ O
7 _ _ O
5 _ _ O
6 _ _ O
7 _ _ O
MEM _ _ B-Concept
WB _ _ B-Concept
WB _ _ B-Concept
● _ _ O
Now _ _ O
we _ _ O
need _ _ O
to _ _ O
insert _ _ O
one _ _ O
bubble _ _ B-Concept
even _ _ O
with _ _ O
forwarding _ _ B-Concept
: _ _ O
Time _ _ O
0 _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
sub _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t2 _ _ O
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
IF _ _ B-Concept
ID _ _ B-Concept
WAIT _ _ O
! _ _ O
ID _ _ B-Concept
EX _ _ B-Concept
beq _ _ O
t0 _ _ O
, _ _ O
$0 _ _ O
, _ _ O
end _ _ O
39 _ _ O

Not _ _ O
all _ _ O
sunshine _ _ O
and _ _ O
rainbows _ _ O
● _ _ O
Extra _ _ O
delay _ _ O
on _ _ O
data _ _ B-Concept
forwarded _ _ I-Concept
from _ _ O
lw _ _ O
also _ _ O
: _ _ O
Time _ _ O
0 _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
lw _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$t1 _ _ O
) _ _ O
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
IF _ _ B-Concept
ID _ _ B-Concept
WAIT _ _ O
! _ _ O
ID _ _ B-Concept
WAIT _ _ O
! _ _ O
ID _ _ B-Concept
beq _ _ O
t0 _ _ O
, _ _ O
$0 _ _ O
, _ _ O
end _ _ O
5 _ _ O
6 _ _ O
7 _ _ O
EX _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
● _ _ O
Now _ _ O
we _ _ O
must _ _ O
insert _ _ O
two _ _ O
bubbles _ _ B-Concept
instead _ _ O
of _ _ O
one _ _ O
! _ _ O
● _ _ O
Not _ _ O
to _ _ O
mention _ _ O
we _ _ O
must _ _ O
now _ _ O
add _ _ O
more _ _ O
forwarding _ _ B-Concept
paths _ _ I-Concept
: _ _ O
● _ _ O
EX _ _ B-Concept
→ _ _ O
ID _ _ B-Concept
, _ _ O
MEM _ _ B-Concept
→ _ _ O
ID _ _ B-Concept
● _ _ O
We _ _ O
also _ _ O
need _ _ O
to _ _ O
add _ _ O
MUXes _ _ B-Concept
before _ _ O
our _ _ O
new _ _ O
comparator _ _ B-Concept
40 _ _ O

Textbook _ _ O
figure _ _ O
correction _ _ O
The _ _ O
figure _ _ O
in _ _ O
textbook _ _ O
is _ _ O
incomplete _ _ O
. _ _ O
Needs _ _ O
MUXes _ _ B-Concept
and _ _ O
forwarding _ _ B-Concept
lines _ _ I-Concept
just _ _ O
like _ _ O
the _ _ O
ALU _ _ B-Concept
. _ _ O
41 _ _ O



