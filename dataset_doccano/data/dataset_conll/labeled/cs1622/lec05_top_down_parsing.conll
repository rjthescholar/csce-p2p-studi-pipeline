['train_set', 'labeled']|cs1622|lec05_top_down_parsing
-DOCSTART- -X- -X- O

Top-down _ _ B-Concept
Parsing _ _ I-Concept
CS _ _ O
1622 _ _ O
Jarrett _ _ O
Billingsley _ _ O

Class _ _ O
Announcements _ _ O
● _ _ O
how _ _ O
was _ _ O
your _ _ O
weekeeeeend _ _ O
● _ _ O
project _ _ O
2 _ _ O
will _ _ O
come _ _ O
out _ _ O
this _ _ O
weekend _ _ O
so _ _ O
you _ _ O
’ll _ _ O
have _ _ O
2 _ _ O
weeks _ _ O
for _ _ O
it _ _ O
2 _ _ O

Parsing _ _ B-Concept
3 _ _ O

A _ _ O
generative _ _ O
view _ _ O
● _ _ O
one _ _ O
way _ _ O
to _ _ O
use _ _ O
a _ _ O
grammar _ _ B-Concept
is _ _ O
to _ _ O
produce _ _ B-Concept
sentences _ _ B-Concept
in _ _ O
the _ _ O
language _ _ O
. _ _ O
Exp _ _ O
: _ _ O
I _ _ O
d _ _ O
| _ _ O
Num _ _ O
| _ _ O
Parens _ _ O
Parens _ _ O
: _ _ O
' _ _ O
( _ _ O
' _ _ O
Exp+ _ _ O
' _ _ O
) _ _ O
' _ _ O
I _ _ O
d _ _ O
: _ _ O
< _ _ O
i _ _ O
d _ _ O
token _ _ O
> _ _ O
Num _ _ O
: _ _ O
< _ _ O
int _ _ O
literal _ _ O
token _ _ O
> _ _ O
we _ _ O
can _ _ O
produce _ _ O
valid _ _ O
sentences _ _ B-Concept
by _ _ O
starting _ _ O
at _ _ O
the _ _ O
root _ _ B-Concept
rule _ _ I-Concept
and _ _ O
repeatedly _ _ O
replacing _ _ O
nonterminals _ _ B-Concept
with _ _ O
their _ _ O
right-hand _ _ O
sides _ _ O
. _ _ O
Exp _ _ O
= _ _ O
> _ _ O
Parens _ _ O
= _ _ O
> _ _ O
' _ _ O
( _ _ O
' _ _ O
Exp+ _ _ O
' _ _ O
) _ _ O
' _ _ O
= _ _ O
> _ _ O
' _ _ O
( _ _ O
' _ _ O
Exp _ _ O
Exp _ _ O
Exp _ _ O
' _ _ O
) _ _ O
' _ _ O
= _ _ O
> _ _ O
' _ _ O
( _ _ O
' _ _ O
I _ _ O
d _ _ O
I _ _ O
d _ _ O
Num _ _ O
' _ _ O
) _ _ O
' _ _ O
= _ _ O
> _ _ O
' _ _ O
( _ _ O
' _ _ O
' _ _ O
add _ _ O
' _ _ O
I _ _ O
d _ _ O
Num _ _ O
' _ _ O
) _ _ O
' _ _ O
= _ _ O
> _ _ O
' _ _ O
( _ _ O
' _ _ O
' _ _ O
add _ _ O
' _ _ O
' _ _ O
x _ _ O
' _ _ O
Num _ _ O
' _ _ O
) _ _ O
' _ _ O
= _ _ O
> _ _ O
' _ _ O
( _ _ O
' _ _ O
' _ _ O
add _ _ O
' _ _ O
' _ _ O
x _ _ O
' _ _ O
' _ _ O
3 _ _ O
' _ _ O
' _ _ O
) _ _ O
' _ _ O
this _ _ O
sequence _ _ O
is _ _ O
called _ _ O
a _ _ O
derivation _ _ B-Concept
. _ _ O
now _ _ O
suppose _ _ O
we _ _ O
were _ _ O
given _ _ O
( _ _ O
add _ _ O
x _ _ O
3 _ _ O
) _ _ O
as _ _ O
our _ _ O
input _ _ O
. _ _ O
could _ _ O
we _ _ O
work _ _ O
backwards _ _ O
to _ _ O
figure _ _ O
out _ _ O
how _ _ O
to _ _ O
get _ _ O
to _ _ O
Exp _ _ O
? _ _ O
4 _ _ O

That _ _ O
's _ _ O
what _ _ O
parsing _ _ B-Concept
is _ _ O
. _ _ O
● _ _ O
given _ _ O
a _ _ O
grammar _ _ B-Concept
and _ _ O
an _ _ O
input _ _ O
string _ _ O
… _ _ O
● _ _ O
parsing _ _ B-Concept
is _ _ O
figuring _ _ O
out _ _ O
the _ _ O
derivation _ _ B-Concept
that _ _ O
was _ _ O
needed _ _ O
to _ _ O
produce _ _ O
the _ _ O
input _ _ O
string _ _ O
. _ _ O
( _ _ O
and _ _ O
if _ _ O
there _ _ O
is _ _ O
no _ _ O
such _ _ O
derivation _ _ B-Concept
, _ _ O
it _ _ O
's _ _ O
an _ _ O
error _ _ O
! _ _ O
) _ _ O
● _ _ O
we _ _ O
represent _ _ O
the _ _ O
derivation _ _ B-Concept
as _ _ O
... _ _ O
an _ _ O
abstract _ _ B-Concept
syntax _ _ I-Concept
tree _ _ I-Concept
! _ _ O
Exp _ _ O
: _ _ O
I _ _ O
d _ _ O
| _ _ O
Num _ _ O
| _ _ O
Parens _ _ O
Parens _ _ O
: _ _ O
' _ _ O
( _ _ O
' _ _ O
Exp+ _ _ O
' _ _ O
) _ _ O
' _ _ O
I _ _ O
d _ _ O
: _ _ O
< _ _ O
i _ _ O
d _ _ O
token _ _ O
> _ _ O
Num _ _ O
: _ _ O
< _ _ O
int _ _ O
token _ _ O
> _ _ O
Input _ _ O
e _ _ O
( _ _ O
e _ _ O
) _ _ O
( _ _ O
1 _ _ O
2 _ _ O
) _ _ O
( _ _ O
e _ _ O
e _ _ O
) _ _ O
( _ _ O
) _ _ O
Output _ _ O
AST _ _ B-Concept
Id _ _ O
( _ _ O
"e _ _ O
" _ _ O
) _ _ O
Parens _ _ O
( _ _ O
Id _ _ O
( _ _ O
"e _ _ O
" _ _ O
) _ _ O
) _ _ O
Parens _ _ O
( _ _ O
Num _ _ O
( _ _ O
1 _ _ O
) _ _ O
, _ _ O
Num _ _ O
( _ _ O
2 _ _ O
) _ _ O
) _ _ O
error _ _ B-Concept
! _ _ O
error _ _ B-Concept
! _ _ O
error _ _ B-Concept
! _ _ O
the _ _ O
last _ _ O
three _ _ O
would _ _ O
benefit _ _ O
from _ _ O
some _ _ O
error _ _ B-Concept
messages _ _ I-Concept
that _ _ O
help _ _ O
the _ _ O
programmer _ _ O
. _ _ O
5 _ _ O

Okay _ _ O
what _ _ O
is _ _ O
this _ _ O
language _ _ O
? _ _ O
● _ _ O
this _ _ O
is _ _ O
a _ _ O
variety _ _ O
of _ _ O
Lisp _ _ B-Concept
, _ _ O
a _ _ O
language _ _ O
family _ _ O
that _ _ O
started _ _ O
in _ _ O
1958 _ _ O
. _ _ O
● _ _ O
we _ _ O
're _ _ O
not _ _ O
going _ _ O
to _ _ O
get _ _ O
into _ _ O
what _ _ O
it _ _ O
means _ _ O
, _ _ O
but _ _ O
it _ _ O
's _ _ O
a _ _ O
very _ _ O
easy-toparse _ _ B-Concept
example _ _ O
language _ _ O
. _ _ O
( _ _ O
) _ _ O
( _ _ O
defun _ _ O
fact _ _ O
( _ _ O
x _ _ O
) _ _ O
( _ _ O
if _ _ O
( _ _ O
eq _ _ O
x _ _ O
0 _ _ O
) _ _ O
defun _ _ O
1 _ _ O
( _ _ O
mul _ _ O
x _ _ O
( _ _ O
fact _ _ O
( _ _ O
sub _ _ O
x _ _ O
1 _ _ O
) _ _ O
) _ _ O
) _ _ O
) _ _ O
) _ _ O
fact _ _ O
Lisp _ _ O
code _ _ O
is _ _ O
basically _ _ O
an _ _ O
AST _ _ B-Concept
already _ _ O
; _ _ O
parentheses _ _ O
group _ _ O
children _ _ O
. _ _ O
( _ _ O
) _ _ O
x _ _ O
( _ _ O
) _ _ O
if _ _ O
eq _ _ O
( _ _ O
) _ _ O
x _ _ O
0 _ _ O
this _ _ O
is _ _ O
going _ _ O
to _ _ O
make _ _ O
our _ _ O
job _ _ O
of _ _ O
parsing _ _ B-Concept
much _ _ O
easier _ _ O
. _ _ O
1 _ _ O
( _ _ O
) _ _ O
mul _ _ O
x _ _ O
( _ _ O
) _ _ O
fact _ _ O
( _ _ O
) _ _ O
sub _ _ O
x _ _ O
1 _ _ O
6 _ _ O

So _ _ O
how _ _ O
do _ _ O
we _ _ O
do _ _ O
it _ _ O
? _ _ O
● _ _ O
well _ _ O
it _ _ O
's _ _ O
a _ _ O
bit _ _ O
like _ _ O
lexing _ _ B-Concept
: _ _ O
o _ _ O
we _ _ O
start _ _ O
at _ _ O
the _ _ O
beginning _ _ O
, _ _ O
looking _ _ O
at _ _ O
tokens _ _ B-Concept
one-by-one _ _ O
. _ _ O
o _ _ O
based _ _ O
on _ _ O
the _ _ O
token _ _ O
, _ _ O
we _ _ O
decide _ _ O
which _ _ O
rule _ _ O
we _ _ O
should _ _ O
use _ _ O
. _ _ O
o _ _ O
if _ _ O
none _ _ O
of _ _ O
the _ _ O
rules _ _ O
apply _ _ O
, _ _ O
or _ _ O
if _ _ O
we _ _ O
see _ _ O
something _ _ O
that _ _ O
we _ _ O
do _ _ O
n't _ _ O
expect _ _ O
, _ _ O
we _ _ O
can _ _ O
give _ _ O
an _ _ O
error _ _ O
. _ _ O
● _ _ O
speaking _ _ O
of _ _ O
which _ _ O
… _ _ O
7 _ _ O

Error _ _ B-Concept
Handling _ _ I-Concept
in _ _ O
Rust _ _ O
time _ _ O
check _ _ O
: _ _ O
≤ _ _ O
17 _ _ O
8 _ _ O

The _ _ O
Result _ _ B-Concept
type _ _ O
● _ _ O
Rust _ _ B-Concept
does _ _ O
n't _ _ O
have _ _ O
exceptions _ _ O
like _ _ O
Java _ _ O
does _ _ O
. _ _ O
● _ _ O
if _ _ O
your _ _ O
function _ _ O
needs _ _ O
to _ _ O
indicate _ _ O
failure _ _ O
, _ _ O
it _ _ O
returns _ _ O
a _ _ O
Result _ _ B-Concept
. _ _ O
Result _ _ B-Concept
< _ _ O
T _ _ O
, _ _ O
E _ _ O
> _ _ O
T _ _ O
is _ _ O
the _ _ O
type _ _ O
of _ _ O
value _ _ O
returned _ _ O
on _ _ O
success _ _ O
. _ _ O
if _ _ O
the _ _ O
function _ _ O
does _ _ O
n't _ _ O
return _ _ O
any _ _ O
value _ _ O
on _ _ O
success _ _ O
, _ _ O
you _ _ O
can _ _ O
use _ _ O
( _ _ O
) _ _ O
– _ _ O
this _ _ O
is _ _ O
Rust _ _ B-Concept
's _ _ I-Concept
void _ _ O
. _ _ O
E _ _ O
is _ _ O
the _ _ O
type _ _ O
of _ _ O
value _ _ O
returned _ _ O
for _ _ O
errors _ _ B-Concept
. _ _ O
any _ _ O
type _ _ O
can _ _ O
be _ _ O
used _ _ O
for _ _ O
errors _ _ B-Concept
, _ _ O
but _ _ O
typically _ _ O
it _ _ O
's _ _ O
an _ _ O
enum _ _ O
. _ _ O
Result _ _ B-Concept
< _ _ O
Box _ _ O
< _ _ O
AstNode _ _ O
> _ _ O
, _ _ O
ParseError _ _ O
> _ _ O
this _ _ O
is _ _ O
a _ _ O
bit _ _ O
unwieldy _ _ O
, _ _ O
so _ _ O
we _ _ O
can _ _ O
use _ _ O
a _ _ O
type _ _ O
alias _ _ O
to _ _ O
shorten _ _ O
it _ _ O
: _ _ O
type _ _ O
ParseResult _ _ O
= _ _ O
Result _ _ B-Concept
< _ _ O
Box _ _ O
< _ _ O
AstNode _ _ O
> _ _ O
, _ _ O
ParseError _ _ O
> _ _ O
; _ _ O
9 _ _ O

Err _ _ B-Concept
, _ _ O
ok _ _ O
… _ _ O
● _ _ O
you _ _ O
create _ _ O
Results _ _ B-Concept
with _ _ O
the _ _ O
Ok _ _ B-Concept
( _ _ O
) _ _ O
and _ _ O
Err _ _ B-Concept
( _ _ O
) _ _ O
constructors _ _ O
. _ _ O
if _ _ O
thing.is_bad _ _ O
( _ _ O
) _ _ O
{ _ _ O
/ _ _ O
/ _ _ O
common _ _ O
to _ _ O
use _ _ O
' _ _ O
return _ _ O
' _ _ O
to _ _ O
immediately _ _ O
/ _ _ O
/ _ _ O
leave _ _ O
the _ _ O
function _ _ O
. _ _ O
kinda _ _ O
like _ _ O
throwing _ _ O
return _ _ O
Err _ _ B-Concept
( _ _ O
ParseError _ _ O
: _ _ O
: _ _ O
whatever _ _ O
( _ _ O
) _ _ O
) _ _ O
; _ _ O
} _ _ O
you _ _ O
can _ _ O
match _ _ B-Concept
on _ _ O
a _ _ O
Result _ _ B-Concept
using _ _ O
Ok _ _ B-Concept
( _ _ O
) _ _ O
and _ _ O
Err _ _ B-Concept
( _ _ O
) _ _ O
: _ _ O
match _ _ B-Concept
parse_thing _ _ B-Concept
( _ _ O
input _ _ O
) _ _ O
{ _ _ O
Ok _ _ B-Concept
( _ _ O
ast _ _ B-Concept
) _ _ O
= _ _ O
> _ _ O
{ _ _ O
println _ _ O
! _ _ O
( _ _ O
" _ _ O
{ _ _ O
: _ _ O
? _ _ O
} _ _ O
" _ _ O
, _ _ O
ast _ _ B-Concept
) _ _ O
; _ _ O
} _ _ O
Err _ _ B-Concept
( _ _ O
e _ _ O
) _ _ O
= _ _ O
> _ _ O
{ _ _ O
println _ _ O
! _ _ O
( _ _ O
"o _ _ O
no _ _ O
: _ _ O
{ _ _ O
} _ _ O
" _ _ O
, _ _ O
e _ _ O
) _ _ O
; _ _ O
} _ _ O
} _ _ O
match _ _ B-Concept
patterns _ _ O
declare _ _ O
local _ _ O
variables _ _ O
usable _ _ O
in _ _ O
their _ _ O
code _ _ O
blocks _ _ O
, _ _ O
if _ _ O
that _ _ O
was _ _ O
unclear _ _ O
before _ _ O
. _ _ O
10 _ _ O

? _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
● _ _ O
when _ _ O
using _ _ O
Result-returning _ _ B-Concept
functions _ _ O
, _ _ O
a _ _ O
really _ _ O
ugly _ _ O
pattern _ _ O
appears _ _ O
: _ _ O
match _ _ B-Concept
step_one _ _ O
( _ _ O
input _ _ O
) _ _ O
{ _ _ O
Ok _ _ B-Concept
( _ _ O
a _ _ O
) _ _ O
= _ _ O
> _ _ O
{ _ _ O
match _ _ B-Concept
step_two _ _ O
( _ _ O
a _ _ O
) _ _ O
{ _ _ O
Ok _ _ B-Concept
( _ _ O
b _ _ O
) _ _ O
= _ _ O
> _ _ O
{ _ _ O
match _ _ B-Concept
step_three _ _ O
( _ _ O
b _ _ O
) _ _ O
{ _ _ O
Ok _ _ B-Concept
( _ _ O
c _ _ O
) _ _ O
= _ _ O
> _ _ O
{ _ _ O
return _ _ O
Ok _ _ B-Concept
( _ _ O
c.to_string _ _ O
( _ _ O
) _ _ O
) _ _ O
; _ _ O
} _ _ O
Err _ _ B-Concept
( _ _ O
e _ _ O
) _ _ O
= _ _ O
> _ _ O
{ _ _ O
return _ _ O
Err _ _ B-Concept
( _ _ O
e _ _ O
) _ _ O
; _ _ O
} _ _ O
} _ _ O
} _ _ O
Err _ _ B-Concept
( _ _ O
e _ _ O
) _ _ O
= _ _ O
> _ _ O
{ _ _ O
return _ _ O
Err _ _ B-Concept
( _ _ O
e _ _ O
) _ _ O
; _ _ O
} _ _ O
} _ _ O
} _ _ O
Err _ _ B-Concept
( _ _ O
e _ _ O
) _ _ O
= _ _ O
> _ _ O
{ _ _ O
return _ _ O
Err _ _ B-Concept
( _ _ O
e _ _ O
) _ _ O
; _ _ O
} _ _ O
} _ _ O
this _ _ O
is _ _ O
terrible _ _ O
. _ _ O
instead _ _ O
: _ _ O
let _ _ O
a _ _ O
= _ _ O
step_one _ _ O
( _ _ O
input _ _ O
) _ _ O
? _ _ O
; _ _ O
let _ _ O
b _ _ O
= _ _ O
step_two _ _ O
( _ _ O
a _ _ O
) _ _ O
? _ _ O
; _ _ O
let _ _ O
c _ _ O
= _ _ O
step_three _ _ O
( _ _ O
b _ _ O
) _ _ O
? _ _ O
; _ _ O
Ok _ _ B-Concept
( _ _ O
c.to_string _ _ O
( _ _ O
) _ _ O
) _ _ O
x _ _ B-Concept
? _ _ I-Concept
means _ _ O
, _ _ O
" _ _ O
if _ _ O
x _ _ O
is _ _ O
an _ _ O
error _ _ O
, _ _ O
return _ _ O
it _ _ O
; _ _ O
otherwise _ _ O
, _ _ O
give _ _ O
me _ _ O
the _ _ O
success _ _ O
value _ _ O
. _ _ O
we _ _ O
'll _ _ O
be _ _ O
seeing _ _ O
this _ _ O
a _ _ O
lot _ _ O
in _ _ O
parsing _ _ O
code _ _ O
! _ _ O
11 _ _ O

Recursive _ _ B-Concept
Descent _ _ I-Concept
time _ _ O
check _ _ O
: _ _ O
≤ _ _ O
34 _ _ O
12 _ _ O

Can _ _ O
we _ _ O
intuit _ _ O
our _ _ O
way _ _ O
through _ _ O
this _ _ O
? _ _ O
● _ _ O
with _ _ O
this _ _ O
grammar _ _ B-Concept
, _ _ O
and _ _ O
this _ _ O
sequence _ _ O
of _ _ O
tokens _ _ B-Concept
as _ _ O
our _ _ O
input _ _ O
… _ _ O
' _ _ O
( _ _ O
' _ _ O
, _ _ O
' _ _ O
( _ _ O
' _ _ O
, _ _ O
' _ _ O
hi _ _ O
' _ _ O
, _ _ O
' _ _ O
5 _ _ O
' _ _ O
, _ _ O
' _ _ O
) _ _ O
' _ _ O
, _ _ O
' _ _ O
) _ _ O
' _ _ O
Exp _ _ O
: _ _ O
I _ _ O
d _ _ O
| _ _ O
Num _ _ O
| _ _ O
Parens _ _ O
Parens _ _ O
: _ _ O
' _ _ O
( _ _ O
' _ _ O
Exp+ _ _ O
' _ _ O
) _ _ O
' _ _ O
I _ _ O
d _ _ O
: _ _ O
< _ _ O
i _ _ O
d _ _ O
token _ _ O
> _ _ O
Num _ _ O
: _ _ O
< _ _ O
int _ _ O
literal _ _ O
token _ _ O
> _ _ O
we _ _ O
are _ _ O
here _ _ O
. _ _ O
our _ _ O
ultimate _ _ O
goal _ _ O
is _ _ O
to _ _ O
build _ _ O
an _ _ O
Exp _ _ O
. _ _ O
this _ _ O
token _ _ O
is _ _ O
a _ _ O
left-paren _ _ O
, _ _ O
so _ _ O
which _ _ O
rule _ _ B-Concept
do _ _ O
we _ _ O
think _ _ O
applies _ _ O
here _ _ O
? _ _ O
Parens _ _ O
! _ _ O
after _ _ O
the _ _ O
left-paren _ _ O
, _ _ O
we _ _ O
should _ _ O
see _ _ O
one _ _ O
or _ _ O
more _ _ O
Exps _ _ O
, _ _ O
followed _ _ O
by _ _ O
a _ _ O
right-paren _ _ O
. _ _ O
but _ _ O
we _ _ O
're _ _ O
already _ _ O
trying _ _ O
to _ _ O
parse _ _ O
an _ _ O
Exp _ _ O
. _ _ O
how _ _ O
do _ _ O
we _ _ O
parse _ _ O
a _ _ O
new _ _ O
Exp _ _ O
without _ _ O
finishing _ _ O
this _ _ O
one _ _ O
? _ _ O
13 _ _ O

The _ _ O
rules _ _ O
are _ _ O
recursive _ _ B-Concept
, _ _ O
so _ _ O
… _ _ O
● _ _ O
recall _ _ O
that _ _ O
all _ _ O
CFGs _ _ B-Concept
have _ _ O
this _ _ O
recursive _ _ B-Concept
rule _ _ B-Concept
structure _ _ O
. _ _ O
● _ _ O
well _ _ O
if _ _ O
the _ _ O
dependencies _ _ O
between _ _ O
the _ _ O
rules _ _ B-Concept
are _ _ O
recursive _ _ B-Concept
… _ _ O
o _ _ O
why _ _ O
not _ _ O
use _ _ O
recursive _ _ B-Concept
functions _ _ O
to _ _ O
model _ _ O
the _ _ O
rules _ _ O
? _ _ O
Exp _ _ O
: _ _ O
I _ _ O
d _ _ O
| _ _ O
Num _ _ O
| _ _ O
Parens _ _ O
Parens _ _ O
: _ _ O
' _ _ O
( _ _ O
' _ _ O
Exp+ _ _ O
' _ _ O
) _ _ O
' _ _ O
I _ _ O
d _ _ O
: _ _ O
< _ _ O
i _ _ O
d _ _ O
token _ _ O
> _ _ O
Num _ _ O
: _ _ O
< _ _ O
int _ _ O
token _ _ O
> _ _ O
let _ _ O
's _ _ O
write _ _ O
some _ _ O
pseudocode _ _ O
to _ _ O
get _ _ O
our _ _ O
thoughts _ _ O
down _ _ O
. _ _ O
fn _ _ O
parse_exp _ _ O
( _ _ O
) _ _ O
{ _ _ O
match _ _ O
self.cur _ _ O
( _ _ O
) _ _ O
{ _ _ O
I _ _ O
d _ _ O
= _ _ O
> _ _ O
parse_id _ _ O
( _ _ O
) _ _ O
, _ _ O
IntLit _ _ O
= _ _ O
> _ _ O
parse_num _ _ O
( _ _ O
) _ _ O
, _ _ O
LParen _ _ O
= _ _ O
> _ _ O
parse_parens _ _ O
( _ _ O
) _ _ O
, _ _ O
} _ _ O
} _ _ O
fn _ _ O
parse_parens _ _ O
( _ _ O
) _ _ O
{ _ _ O
eat_an_lparen _ _ O
( _ _ O
) _ _ O
; _ _ O
let _ _ O
exps _ _ O
= _ _ O
… _ _ O
parse_exp _ _ O
( _ _ O
) _ _ O
… _ _ O
eat_an_rparen _ _ O
( _ _ O
) _ _ O
; _ _ O
return _ _ O
Parens _ _ O
( _ _ O
exps _ _ O
) _ _ O
; _ _ O
} _ _ O
( _ _ O
looping _ _ O
happens _ _ O
here _ _ O
) _ _ O
14 _ _ O

Believe _ _ O
it _ _ O
or _ _ O
not _ _ O
, _ _ O
that _ _ O
's _ _ O
pretty _ _ O
much _ _ O
right _ _ O
! _ _ O
● _ _ O
what _ _ O
we _ _ O
've _ _ O
just _ _ O
( _ _ O
pseudo- _ _ O
) _ _ O
written _ _ O
is _ _ O
a _ _ O
recursive _ _ B-Concept
descent _ _ I-Concept
parser _ _ I-Concept
: _ _ O
o _ _ O
recursive _ _ B-Concept
, _ _ O
because _ _ O
uh _ _ O
, _ _ O
it _ _ O
is _ _ O
! _ _ O
o _ _ O
and _ _ O
descent _ _ O
, _ _ O
because _ _ O
we _ _ O
start _ _ O
at _ _ O
the _ _ O
root _ _ B-Concept
rule _ _ I-Concept
, _ _ O
and _ _ O
descend _ _ O
into _ _ O
the _ _ O
other _ _ O
rules _ _ B-Concept
until _ _ O
we _ _ O
get _ _ O
to _ _ O
the _ _ O
terminals _ _ O
. _ _ O
● _ _ O
the _ _ O
issue _ _ O
with _ _ O
" _ _ O
trying _ _ O
to _ _ O
parse _ _ O
an _ _ O
Exp _ _ O
while _ _ O
parsing _ _ O
an _ _ O
Exp _ _ O
" _ _ O
is _ _ O
solved _ _ O
by _ _ O
using _ _ O
recursion _ _ O
o _ _ O
when _ _ O
you _ _ O
recurse _ _ O
, _ _ O
the _ _ O
caller _ _ O
rule _ _ O
's _ _ O
execution _ _ O
is _ _ O
paused _ _ O
, _ _ O
and _ _ O
it _ _ O
remembers _ _ O
its _ _ O
place _ _ O
in _ _ O
the _ _ O
rule _ _ O
. _ _ O
o _ _ O
it _ _ O
can _ _ O
then _ _ O
resume _ _ O
parsing _ _ O
after _ _ O
the _ _ O
callee _ _ O
rule _ _ O
has _ _ O
done _ _ O
its _ _ O
work _ _ O
. _ _ O
● _ _ O
so _ _ O
how _ _ O
can _ _ O
we _ _ O
be _ _ O
a _ _ O
little _ _ O
less _ _ O
" _ _ O
pseudo _ _ O
" _ _ O
about _ _ O
this _ _ O
code _ _ O
? _ _ O
15 _ _ O

From _ _ O
Rules _ _ B-Concept
to _ _ O
Rust _ _ O
● _ _ O
each _ _ O
grammar _ _ B-Concept
rule _ _ I-Concept
is _ _ O
really _ _ O
a _ _ O
list _ _ O
of _ _ O
steps _ _ O
, _ _ O
and _ _ O
translating _ _ O
them _ _ O
to _ _ O
real _ _ O
code _ _ O
is _ _ O
relatively _ _ O
straightforward _ _ O
: _ _ O
Parens _ _ O
: _ _ O
' _ _ O
( _ _ O
' _ _ O
Exp+ _ _ O
' _ _ O
) _ _ O
' _ _ O
this _ _ O
says _ _ O
that _ _ O
to _ _ O
parse _ _ O
a _ _ O
Parens _ _ O
: _ _ O
1 _ _ O
. _ _ O
expect _ _ O
a _ _ O
' _ _ O
( _ _ O
' _ _ O
token _ _ O
and _ _ O
skip _ _ O
it _ _ O
. _ _ O
2 _ _ O
. _ _ O
parse _ _ O
one _ _ O
Exp _ _ O
, _ _ O
since _ _ O
that _ _ O
's _ _ O
the _ _ O
minimum _ _ O
number _ _ O
. _ _ O
3 _ _ O
. _ _ O
while _ _ O
we _ _ O
do _ _ O
n't _ _ O
see _ _ O
a _ _ O
' _ _ O
) _ _ O
' _ _ O
token _ _ O
, _ _ O
• _ _ O
keep _ _ O
parsing _ _ O
Exps _ _ O
and _ _ O
put _ _ O
them _ _ O
into _ _ O
a _ _ O
list _ _ O
. _ _ O
4 _ _ O
. _ _ O
expect _ _ O
a _ _ O
' _ _ O
) _ _ O
' _ _ O
token _ _ O
and _ _ O
skip _ _ O
it _ _ O
. _ _ O
if _ _ O
all _ _ O
of _ _ O
these _ _ O
steps _ _ O
succeed _ _ O
, _ _ O
we _ _ O
can _ _ O
create _ _ O
an _ _ O
Parens _ _ O
AST _ _ O
node _ _ O
and _ _ O
return _ _ O
it _ _ O
! _ _ O
16 _ _ O

Other _ _ O
metalanguage _ _ O
rule _ _ B-Concept
correspondences _ _ O
● _ _ O
there _ _ O
's _ _ O
a _ _ O
nice _ _ O
correspondence _ _ O
between _ _ O
the _ _ O
things _ _ O
we _ _ O
see _ _ O
in _ _ O
the _ _ O
grammar _ _ B-Concept
metalanguage _ _ O
and _ _ O
the _ _ O
patterns _ _ O
we _ _ O
use _ _ O
in _ _ O
our _ _ O
code _ _ O
. _ _ O
A _ _ O
B _ _ O
A _ _ O
| _ _ O
B _ _ O
sequencing _ _ B-Concept
: _ _ O
parse _ _ B-Concept
an _ _ O
A _ _ O
; _ _ O
if _ _ O
that _ _ O
succeeds _ _ O
, _ _ O
then _ _ O
parse _ _ B-Concept
a _ _ O
B. _ _ O
alternation _ _ B-Concept
: _ _ O
an _ _ O
if-else _ _ O
( _ _ O
or _ _ O
a _ _ O
match _ _ O
) _ _ O
; _ _ O
either _ _ O
parse _ _ B-Concept
an _ _ O
A _ _ O
or _ _ O
parse _ _ B-Concept
a _ _ O
B. _ _ O
A _ _ O
* _ _ O
0 _ _ B-Concept
+ _ _ I-Concept
repetition _ _ I-Concept
: _ _ O
while _ _ O
the _ _ O
next _ _ O
token _ _ O
looks _ _ O
like _ _ O
an _ _ O
A _ _ O
, _ _ O
keep _ _ O
parsing _ _ B-Concept
As _ _ O
. _ _ O
A+ _ _ O
1 _ _ O
+ _ _ O
repetition _ _ O
: _ _ O
parse _ _ O
an _ _ O
A _ _ O
, _ _ O
then _ _ O
do _ _ O
a _ _ O
while _ _ O
loop _ _ O
like _ _ O
for _ _ O
0 _ _ O
+ _ _ O
. _ _ O
A _ _ O
? _ _ O
optional _ _ O
: _ _ O
if _ _ O
the _ _ O
next _ _ O
token _ _ O
looks _ _ O
like _ _ O
an _ _ O
A _ _ O
, _ _ O
parse _ _ O
it _ _ O
. _ _ O
17 _ _ O

From _ _ O
rules _ _ B-Concept
to _ _ O
AST _ _ B-Concept
nodes _ _ I-Concept
● _ _ O
similarly _ _ O
, _ _ O
when _ _ O
we _ _ O
design _ _ O
our _ _ O
AST _ _ B-Concept
nodes _ _ I-Concept
, _ _ O
these _ _ O
metalanguage _ _ O
rules _ _ B-Concept
imply _ _ O
different _ _ O
data _ _ O
structures _ _ O
: _ _ O
A _ _ O
B _ _ O
A _ _ O
| _ _ O
B _ _ O
a _ _ O
struct _ _ B-Concept
, _ _ O
with _ _ O
an _ _ O
A _ _ O
field _ _ O
and _ _ O
a _ _ O
B _ _ O
field _ _ O
. _ _ O
an _ _ O
enum _ _ B-Concept
, _ _ O
where _ _ O
A _ _ O
and _ _ O
B _ _ O
are _ _ O
two _ _ O
variants _ _ O
. _ _ O
A _ _ O
* _ _ O
A+ _ _ O
an _ _ B-Concept
array _ _ I-Concept
/ _ _ I-Concept
vector _ _ I-Concept
, _ _ O
whose _ _ O
length _ _ O
is _ _ O
the _ _ O
number _ _ O
of _ _ O
repetitions _ _ O
. _ _ O
A _ _ O
? _ _ O
an _ _ O
Option _ _ B-Concept
< _ _ I-Concept
A _ _ I-Concept
> _ _ I-Concept
field _ _ O
, _ _ O
since _ _ O
it _ _ O
might _ _ O
not _ _ O
exist _ _ O
. _ _ O
18 _ _ O

The _ _ O
example _ _ O
● _ _ O
now _ _ O
let _ _ O
's _ _ O
have _ _ O
a _ _ O
look _ _ O
at _ _ O
the _ _ O
new _ _ O
parsing_lisp _ _ O
example _ _ O
I _ _ O
added _ _ O
. _ _ O
o _ _ O
src _ _ O
/ _ _ O
lib.rs _ _ O
is _ _ O
where _ _ O
all _ _ O
the _ _ O
goodies _ _ O
are _ _ O
. _ _ O
o _ _ O
the _ _ O
Token _ _ B-Concept
and _ _ O
AstNode _ _ B-Concept
types _ _ O
are _ _ O
familiar _ _ O
to _ _ O
you _ _ O
by _ _ O
now _ _ O
. _ _ O
▪ _ _ O
there _ _ O
's _ _ O
an _ _ O
extra _ _ O
Program _ _ O
rule _ _ O
in _ _ O
the _ _ O
grammar _ _ O
though _ _ O
. _ _ O
o _ _ O
ParseError _ _ B-Concept
is _ _ O
an _ _ O
example _ _ O
of _ _ O
an _ _ O
error _ _ O
enum _ _ O
. _ _ O
o _ _ O
Parser _ _ B-Concept
looks _ _ O
a _ _ O
lot _ _ O
like _ _ O
Lexer _ _ B-Concept
from _ _ O
your _ _ O
project _ _ O
… _ _ O
▪ _ _ O
except _ _ O
it _ _ O
iterates _ _ O
over _ _ O
Tokens _ _ B-Concept
, _ _ O
not _ _ O
chars _ _ O
. _ _ O
o _ _ O
and _ _ O
there _ _ O
are _ _ O
three _ _ O
parsing _ _ B-Concept
methods _ _ O
for _ _ O
the _ _ O
three _ _ O
main _ _ O
rules _ _ O
. _ _ O
● _ _ O
this _ _ O
real _ _ O
parser _ _ B-Concept
handles _ _ O
errors _ _ B-Concept
, _ _ O
too _ _ O
. _ _ O
o _ _ O
the _ _ O
expect_blah _ _ O
methods _ _ O
and _ _ O
the _ _ O
match _ _ O
in _ _ O
parse_exp _ _ O
deal _ _ O
with _ _ O
unexpected _ _ O
terminals _ _ B-Concept
( _ _ O
tokens _ _ B-Concept
) _ _ O
in _ _ O
various _ _ O
positions _ _ O
. _ _ O
▪ _ _ O
they _ _ O
also _ _ O
give _ _ O
customized _ _ O
errors _ _ B-Concept
for _ _ O
each _ _ O
of _ _ O
these _ _ O
possibilities _ _ O
. _ _ O
▪ _ _ O
there _ _ O
's _ _ O
no _ _ O
location _ _ O
info _ _ O
, _ _ O
because _ _ O
it _ _ O
's _ _ O
an _ _ O
example _ _ O
. _ _ O
: _ _ O
B _ _ O
19 _ _ O

Limits _ _ B-Concept
of _ _ I-Concept
Recursive _ _ I-Concept
Descent _ _ I-Concept
time _ _ O
check _ _ O
: _ _ O
≤ _ _ O
68 _ _ O
20 _ _ O

If _ _ O
it _ _ O
works _ _ O
so _ _ O
well _ _ O
, _ _ O
why _ _ O
not _ _ O
use _ _ O
it _ _ O
for _ _ O
everything _ _ O
? _ _ O
● _ _ O
there _ _ O
are _ _ O
lots _ _ O
of _ _ O
cases _ _ O
where _ _ O
recursive _ _ B-Concept
descent _ _ I-Concept
works _ _ O
great _ _ O
! _ _ O
o _ _ O
import _ _ O
java.util.Arrays _ _ O
; _ _ O
o _ _ O
use _ _ O
std _ _ O
: _ _ O
: _ _ O
blah _ _ O
; _ _ O
o _ _ O
fn _ _ O
name _ _ O
( _ _ O
) _ _ O
{ _ _ O
… _ _ O
} _ _ O
o _ _ O
class _ _ O
A _ _ O
{ _ _ O
… _ _ O
} _ _ O
o _ _ O
if _ _ O
x _ _ O
= _ _ O
= _ _ O
y _ _ O
{ _ _ O
… _ _ O
} _ _ O
o _ _ O
match _ _ O
value _ _ O
{ _ _ O
… _ _ O
} _ _ O
● _ _ O
but _ _ O
there _ _ O
's _ _ O
something _ _ O
all _ _ O
of _ _ O
these _ _ O
things _ _ O
have _ _ O
in _ _ O
common _ _ O
: _ _ O
o _ _ O
they _ _ O
all _ _ O
start _ _ O
with _ _ O
a _ _ O
token _ _ B-Concept
that _ _ O
unambiguously _ _ B-Concept
indicates _ _ O
which _ _ O
rule _ _ B-Concept
should _ _ O
be _ _ O
used _ _ O
to _ _ O
parse _ _ B-Concept
them _ _ O
. _ _ O
o _ _ O
if _ _ O
you _ _ O
do _ _ O
n't _ _ O
have _ _ O
that _ _ O
, _ _ O
recursive _ _ B-Concept
descent _ _ I-Concept
gets _ _ O
a _ _ O
lot _ _ O
harder _ _ O
to _ _ O
use _ _ O
. _ _ O
● _ _ O
but _ _ O
, _ _ O
what _ _ O
kind _ _ O
of _ _ O
code _ _ O
looks _ _ O
like _ _ O
that _ _ O
? _ _ O
21 _ _ O

Expressions _ _ B-Concept
! _ _ O
● _ _ O
we _ _ O
want _ _ O
to _ _ O
be _ _ O
able _ _ O
to _ _ O
write _ _ O
expressions _ _ B-Concept
like _ _ O
we _ _ O
do _ _ O
in _ _ O
math _ _ O
. _ _ O
o _ _ O
that _ _ O
is _ _ O
, _ _ O
we _ _ O
want _ _ O
4 _ _ O
+ _ _ O
5 _ _ O
, _ _ O
not _ _ O
( _ _ O
add _ _ O
4 _ _ O
5 _ _ O
) _ _ O
. _ _ O
● _ _ O
but _ _ O
this _ _ O
presents _ _ O
a _ _ O
few _ _ O
problems _ _ O
. _ _ O
Input _ _ O
Output _ _ O
x _ _ O
+ _ _ O
y _ _ O
+ _ _ O
z _ _ O
( _ _ O
x _ _ O
+ _ _ O
y _ _ O
) _ _ O
+ _ _ O
z _ _ O
or _ _ O
either _ _ O
is _ _ O
fine _ _ O
.. _ _ O
? _ _ O
what _ _ O
x _ _ O
+ _ _ O
( _ _ O
y _ _ O
+ _ _ O
z _ _ O
) _ _ O
? _ _ O
if _ _ O
it _ _ O
were _ _ O
* _ _ O
, _ _ O
- _ _ O
, _ _ O
or _ _ O
/ _ _ O
? _ _ O
x _ _ O
+ _ _ O
4 _ _ O
* _ _ O
y _ _ O
( _ _ O
x _ _ O
+ _ _ O
4 _ _ O
) _ _ O
* _ _ O
y _ _ O
or _ _ O
x _ _ O
+ _ _ O
( _ _ O
4 _ _ O
* _ _ O
y _ _ O
) _ _ O
? _ _ O
the _ _ O
second _ _ O
one _ _ O
is _ _ O
right _ _ O
. _ _ O
and _ _ O
if _ _ O
we _ _ O
allow _ _ O
* _ _ O
* _ _ O
for _ _ O
exponents _ _ O
, _ _ O
like _ _ O
Python _ _ O
: _ _ O
2 _ _ O
* _ _ O
* _ _ O
x _ _ O
* _ _ O
* _ _ O
2 _ _ O
( _ _ O
2 _ _ O
* _ _ O
* _ _ O
x _ _ O
) _ _ O
* _ _ O
* _ _ O
2 _ _ O
or _ _ O
2 _ _ O
* _ _ O
* _ _ O
( _ _ O
x _ _ O
* _ _ O
* _ _ O
2 _ _ O
) _ _ O
? _ _ O
the _ _ O
second _ _ O
one _ _ O
is _ _ O
right _ _ O
. _ _ O
22 _ _ O

Even _ _ O
worse _ _ O
… _ _ O
● _ _ O
how _ _ O
do _ _ O
we _ _ O
know _ _ O
what _ _ O
kind _ _ O
of _ _ O
expression _ _ B-Concept
we _ _ O
're _ _ O
looking _ _ O
at _ _ O
? _ _ O
( _ _ O
3 _ _ O
+ _ _ O
x _ _ O
+ _ _ O
y _ _ O
* _ _ O
2 _ _ O
) _ _ O
/ _ _ O
50 _ _ O
let _ _ O
's _ _ O
say _ _ O
our _ _ O
parser _ _ B-Concept
is _ _ O
looking _ _ O
at _ _ O
this _ _ O
token _ _ B-Concept
… _ _ O
. _ _ O
… _ _ O
how _ _ O
will _ _ O
it _ _ O
know _ _ O
it _ _ O
's _ _ O
a _ _ O
division _ _ O
until _ _ O
it _ _ O
gets _ _ O
here _ _ O
? _ _ O
so _ _ O
what _ _ O
do _ _ O
we _ _ O
do _ _ O
? _ _ O
look _ _ O
ahead _ _ O
? _ _ O
how _ _ O
many _ _ O
tokens _ _ O
? _ _ O
5 _ _ O
? _ _ O
10 _ _ O
? _ _ O
is _ _ O
there _ _ O
a _ _ O
limit _ _ O
? _ _ O
what _ _ O
we _ _ O
would _ _ O
have _ _ O
to _ _ O
do _ _ O
here _ _ O
is _ _ O
try _ _ O
each _ _ O
possible _ _ O
parse _ _ B-Concept
, _ _ O
and _ _ O
backtrack _ _ B-Concept
if _ _ O
we _ _ O
mess _ _ O
up _ _ O
. _ _ O
23 _ _ O

OH _ _ O
NO _ _ O
, _ _ O
BACKTRACKING _ _ B-Concept
● _ _ O
this _ _ O
is _ _ O
an _ _ O
exponential _ _ B-Concept
time _ _ I-Concept
( _ _ O
O _ _ O
( _ _ O
2n _ _ O
) _ _ O
) _ _ O
algorithm _ _ O
! _ _ O
just _ _ O
awful _ _ O
! _ _ O
o _ _ O
and _ _ O
from _ _ O
an _ _ O
intuitive _ _ O
sense _ _ O
, _ _ O
it _ _ O
feels _ _ O
kind _ _ O
of _ _ O
silly _ _ O
to _ _ O
commit _ _ O
to _ _ O
parsing _ _ B-Concept
something _ _ O
when _ _ O
you _ _ O
do _ _ O
n't _ _ O
actually _ _ O
have _ _ O
enough _ _ O
information _ _ O
yet _ _ O
to _ _ O
parse _ _ B-Concept
it _ _ O
. _ _ O
● _ _ O
so _ _ O
for _ _ O
these _ _ O
( _ _ O
and _ _ O
other _ _ O
similar _ _ O
) _ _ O
situations _ _ O
, _ _ O
there _ _ O
is _ _ O
another _ _ O
way _ _ O
to _ _ O
parse _ _ O
that _ _ O
's _ _ O
a _ _ O
little _ _ O
more _ _ O
mind-bending _ _ O
, _ _ O
but _ _ O
more _ _ O
powerful _ _ O
. _ _ O
o _ _ O
that _ _ O
's _ _ O
for _ _ O
next _ _ O
time _ _ O
! _ _ O
24 _ _ O

Error _ _ B-Concept
Reporting _ _ I-Concept
time _ _ O
check _ _ O
: _ _ O
≤ _ _ O
85 _ _ O
25 _ _ O

Compilers _ _ B-Concept
have _ _ O
a _ _ O
bit _ _ O
of _ _ O
a _ _ O
reputation _ _ O
● _ _ O
how _ _ O
many _ _ O
times _ _ O
have _ _ O
you _ _ O
gotten _ _ O
compiler _ _ B-Concept
errors _ _ I-Concept
that _ _ O
: _ _ O
o _ _ O
seemed _ _ O
totally _ _ O
confused _ _ O
by _ _ O
very _ _ O
simple _ _ O
/ _ _ O
common _ _ O
typos _ _ O
, _ _ O
like _ _ O
missing _ _ O
a _ _ O
semicolon _ _ O
or _ _ O
comma _ _ O
or _ _ O
closing _ _ O
brace _ _ O
? _ _ O
o _ _ O
pointed _ _ O
100 _ _ O
lines _ _ O
after _ _ O
where _ _ O
the _ _ O
actual _ _ O
error _ _ O
was _ _ O
? _ _ O
o _ _ O
used _ _ O
weird _ _ O
terminology _ _ O
, _ _ O
like _ _ O
" _ _ O
specifier-qualifier-list _ _ O
" _ _ O
? _ _ O
o _ _ O
gave _ _ O
almost _ _ O
no _ _ O
information _ _ O
, _ _ O
like _ _ O
" _ _ O
syntax _ _ B-Concept
error _ _ I-Concept
" _ _ O
? _ _ O
● _ _ O
is _ _ O
it _ _ O
because _ _ O
the _ _ O
compiler _ _ O
writers _ _ O
suck _ _ O
? _ _ O
o _ _ O
no _ _ O
o _ _ O
good _ _ O
error _ _ B-Concept
reporting _ _ I-Concept
is _ _ O
really _ _ O
hard _ _ O
to _ _ O
do _ _ O
right _ _ O
, _ _ O
okay _ _ O
, _ _ O
26 _ _ O

Who _ _ O
are _ _ O
error _ _ B-Concept
messages _ _ I-Concept
for _ _ O
? _ _ O
● _ _ O
I _ _ O
've _ _ O
said _ _ O
it _ _ O
many _ _ O
times _ _ O
: _ _ O
programming _ _ O
languages _ _ O
exist _ _ O
for _ _ O
humans _ _ O
. _ _ O
● _ _ O
so _ _ O
when _ _ O
a _ _ O
compiler _ _ B-Concept
gives _ _ O
errors _ _ B-Concept
, _ _ O
they _ _ O
should _ _ O
be _ _ O
… _ _ O
for _ _ O
humans _ _ O
! _ _ O
● _ _ O
but _ _ O
there _ _ O
are _ _ O
two _ _ O
things _ _ O
working _ _ O
against _ _ O
us _ _ O
here _ _ O
. _ _ O
the _ _ O
compiler _ _ B-Concept
is _ _ O
a _ _ O
dumb _ _ O
algorithm _ _ O
that _ _ O
does _ _ O
n't _ _ O
understand _ _ O
our _ _ O
human _ _ O
mistakes _ _ O
f _ _ O
( _ _ O
3 _ _ O
4 _ _ O
) _ _ O
----^ _ _ O
expected _ _ O
` _ _ O
) _ _ O
' _ _ O
or _ _ O
` _ _ O
, _ _ O
' _ _ O
in _ _ O
argument-list _ _ O
, _ _ O
not _ _ O
` _ _ O
4 _ _ O
' _ _ O
people _ _ O
who _ _ O
write _ _ O
compilers _ _ B-Concept
tend _ _ O
to _ _ O
forget _ _ O
that _ _ O
other _ _ O
people _ _ O
do _ _ O
n't _ _ O
know _ _ O
how _ _ O
they _ _ O
work _ _ O
( _ _ O
substitution _ _ O
of _ _ O
deduced _ _ O
template _ _ O
arguments _ _ O
resulted _ _ O
in _ _ O
errors _ _ O
seen _ _ O
above _ _ O
) _ _ O
27 _ _ O

Carry _ _ O
on _ _ O
, _ _ O
my _ _ O
wayward _ _ O
son _ _ O
● _ _ O
you _ _ O
know _ _ O
how _ _ O
you _ _ O
sometimes _ _ O
get _ _ O
like _ _ O
1000 _ _ O
error _ _ B-Concept
messages _ _ I-Concept
? _ _ O
o _ _ O
and _ _ O
it _ _ O
's _ _ O
all _ _ O
because _ _ O
you _ _ O
forgot _ _ O
ONE _ _ O
closing _ _ O
brace _ _ O
? _ _ O
● _ _ O
this _ _ O
is _ _ O
error _ _ B-Concept
recovery _ _ I-Concept
: _ _ I-Concept
instead _ _ O
of _ _ O
stopping _ _ O
at _ _ O
the _ _ O
first _ _ O
error _ _ O
, _ _ O
the _ _ O
compiler _ _ B-Concept
tries _ _ O
to _ _ O
keep _ _ O
going _ _ O
. _ _ O
enum _ _ O
E _ _ O
{ _ _ O
X _ _ O
, _ _ O
Y _ _ O
/ _ _ O
/ _ _ O
uh _ _ O
oh _ _ O
. _ _ O
but _ _ O
how _ _ O
would _ _ O
you _ _ O
algorithmically _ _ O
determine _ _ O
where _ _ O
the _ _ O
closing _ _ O
brace _ _ O
should _ _ O
go _ _ O
? _ _ O
fn _ _ O
func _ _ O
( _ _ O
) _ _ O
{ _ _ O
let _ _ O
x _ _ O
= _ _ O
E _ _ O
: _ _ O
: _ _ O
X _ _ O
/ _ _ O
/ _ _ O
oops _ _ O
( _ _ O
blah _ _ O
) _ _ O
.y _ _ O
( _ _ O
) _ _ O
; _ _ O
} _ _ O
this _ _ O
could _ _ O
even _ _ O
parse _ _ B-Concept
differently _ _ O
depending _ _ O
on _ _ O
where _ _ O
we _ _ O
infer _ _ O
the _ _ O
semicolon _ _ O
" _ _ O
should _ _ O
" _ _ O
be _ _ O
. _ _ O
28 _ _ O

To _ _ O
recover _ _ B-Concept
or _ _ O
not _ _ O
? _ _ O
● _ _ O
in _ _ O
the _ _ O
past _ _ O
, _ _ O
languages _ _ O
were _ _ O
simpler _ _ O
, _ _ O
and _ _ O
so _ _ O
was _ _ O
error _ _ B-Concept
recovery _ _ I-Concept
. _ _ I-Concept
o _ _ O
compilers _ _ B-Concept
also _ _ O
ran _ _ O
on _ _ O
huge _ _ O
computers _ _ O
in _ _ O
batch _ _ O
jobs _ _ O
. _ _ O
o _ _ O
since _ _ O
a _ _ O
compile _ _ B-Concept
might _ _ O
take _ _ O
hours _ _ O
, _ _ O
it _ _ O
was _ _ O
useful _ _ O
to _ _ O
report _ _ O
as _ _ O
many _ _ O
errors _ _ O
as _ _ O
possible _ _ O
. _ _ O
● _ _ O
but _ _ O
now _ _ O
, _ _ O
a _ _ O
really _ _ O
, _ _ O
really _ _ O
common _ _ O
thing _ _ O
to _ _ O
do _ _ O
is _ _ O
: _ _ O
o _ _ O
compile _ _ B-Concept
, _ _ O
fix _ _ O
the _ _ O
first _ _ O
error _ _ B-Concept
, _ _ O
repeat _ _ O
▪ _ _ O
( _ _ O
I _ _ O
really _ _ O
recommend _ _ O
you _ _ O
do _ _ O
this _ _ O
if _ _ O
you _ _ O
do _ _ O
n't _ _ O
already _ _ O
) _ _ O
● _ _ O
so _ _ O
maybe _ _ O
stopping _ _ O
at _ _ O
the _ _ O
first _ _ O
error _ _ B-Concept
is _ _ O
fine _ _ O
? _ _ O
o _ _ O
but _ _ O
what _ _ O
about _ _ O
IDEs _ _ O
? _ _ O
o _ _ O
they _ _ O
can _ _ O
show _ _ O
multiple _ _ O
errors _ _ B-Concept
inline _ _ O
with _ _ O
the _ _ O
code _ _ O
o _ _ O
so _ _ O
maybe _ _ O
there _ _ O
's _ _ O
still _ _ O
some _ _ O
use _ _ O
to _ _ O
it _ _ O
? _ _ O
▪ _ _ O
or _ _ O
does _ _ O
it _ _ O
just _ _ O
make _ _ O
using _ _ O
an _ _ O
IDE _ _ O
more _ _ O
annoying _ _ O
? _ _ O
: _ _ O
^ _ _ O
) _ _ O
● _ _ O
personally _ _ O
I _ _ O
think _ _ O
lexing _ _ O
/ _ _ O
parsing _ _ O
error _ _ O
recovery _ _ O
is _ _ O
pointless _ _ O
, _ _ O
but _ _ O
giving _ _ O
multiple _ _ O
semantic _ _ O
errors _ _ O
can _ _ O
still _ _ O
be _ _ O
useful _ _ O
. _ _ O
sometimes _ _ O
. _ _ O
29 _ _ O

A _ _ O
philosophy _ _ O
for _ _ O
good _ _ O
errors _ _ O
● _ _ O
there _ _ O
are _ _ O
three _ _ O
ways _ _ O
to _ _ O
improve _ _ O
error _ _ B-Concept
messages _ _ I-Concept
. _ _ O
1 _ _ O
. _ _ O
say _ _ O
where _ _ O
it _ _ O
is _ _ O
test.foo _ _ O
( _ _ O
9 _ _ O
: _ _ O
17 _ _ O
) _ _ O
bare _ _ O
minimum _ _ O
… _ _ O
test.foo _ _ O
( _ _ O
9 _ _ O
: _ _ O
17 _ _ O
) _ _ O
: _ _ O
for _ _ O
num _ _ O
in _ _ O
10 _ _ O
{ _ _ O
^ _ _ O
here _ _ O
better _ _ O
! _ _ O
2 _ _ O
. _ _ O
give _ _ O
a _ _ O
unique _ _ O
message _ _ O
for _ _ O
that _ _ O
particular _ _ O
error _ _ O
expected _ _ O
' _ _ O
, _ _ O
' _ _ O
, _ _ O
not _ _ O
' _ _ O
{ _ _ O
' _ _ O
ehh _ _ O
… _ _ O
for-loop _ _ O
missing _ _ O
upper _ _ O
bound _ _ O
better _ _ O
! _ _ O
3 _ _ O
. _ _ O
extra _ _ O
credit _ _ O
: _ _ O
tell _ _ O
the _ _ O
user _ _ O
how _ _ O
they _ _ O
might _ _ O
fix _ _ O
it _ _ O
help _ _ O
: _ _ O
maybe _ _ O
you _ _ O
meant _ _ O
" _ _ O
for _ _ O
num _ _ O
in _ _ O
10 _ _ O
, _ _ O
something _ _ O
" _ _ O
? _ _ O
^^^^^^^^^^^ _ _ O
30 _ _ O

First _ _ O
: _ _ O
location _ _ B-Concept
information _ _ I-Concept
● _ _ O
the _ _ O
lexer _ _ B-Concept
can _ _ O
associate _ _ O
a _ _ O
line _ _ B-Concept
and _ _ O
column _ _ B-Concept
with _ _ O
each _ _ O
token _ _ B-Concept
. _ _ O
o _ _ O
well _ _ O
, _ _ O
some _ _ O
tokens _ _ B-Concept
span _ _ O
more _ _ O
than _ _ O
one _ _ O
column _ _ B-Concept
… _ _ O
o _ _ O
or _ _ O
even _ _ O
more _ _ O
than _ _ O
one _ _ O
line _ _ B-Concept
, _ _ O
if _ _ O
you _ _ O
allow _ _ O
multi-line _ _ O
strings _ _ O
! _ _ O
o _ _ O
so _ _ O
maybe _ _ O
each _ _ O
token _ _ B-Concept
should _ _ O
have _ _ O
a _ _ O
range _ _ O
of _ _ O
locations _ _ O
? _ _ O
hmm _ _ O
● _ _ O
when _ _ O
parsing _ _ B-Concept
, _ _ O
that _ _ O
info _ _ O
can _ _ O
be _ _ O
carried _ _ O
from _ _ O
the _ _ O
tokens _ _ B-Concept
into _ _ O
the _ _ O
AST _ _ B-Concept
. _ _ O
o _ _ O
that _ _ O
way _ _ O
, _ _ O
we _ _ O
can _ _ O
report _ _ O
errors _ _ B-Concept
during _ _ O
semantic _ _ B-Concept
analysis _ _ I-Concept
. _ _ O
o _ _ O
or _ _ O
maybe _ _ O
we _ _ O
want _ _ O
to _ _ O
refer _ _ O
back _ _ O
to _ _ O
the _ _ O
token _ _ B-Concept
list _ _ O
somehow _ _ O
… _ _ O
? _ _ O
▪ _ _ O
there _ _ O
are _ _ O
lots _ _ O
of _ _ O
ways _ _ O
to _ _ O
implement _ _ O
this _ _ O
! _ _ O
31 _ _ O

Second _ _ O
: _ _ O
accurate _ _ B-Concept
error _ _ I-Concept
messages _ _ I-Concept
● _ _ O
it _ _ O
's _ _ O
really _ _ O
easy _ _ O
to _ _ O
make _ _ O
unhelpful _ _ O
, _ _ O
uninformative _ _ O
messages _ _ O
, _ _ O
sadly _ _ O
! _ _ O
● _ _ O
giving _ _ O
accurate _ _ B-Concept
errors _ _ I-Concept
is _ _ O
largely _ _ O
about _ _ O
customizing _ _ O
the _ _ O
error _ _ O
messages _ _ O
for _ _ O
each _ _ O
place _ _ O
an _ _ O
error _ _ O
could _ _ O
happen _ _ O
. _ _ O
o _ _ O
looking _ _ O
through _ _ O
the _ _ O
parser _ _ O
code _ _ O
, _ _ O
every _ _ O
? _ _ O
is _ _ O
a _ _ O
potential _ _ O
error _ _ O
spot _ _ O
. _ _ O
o _ _ O
in _ _ O
parse_paren_exp _ _ O
, _ _ O
there _ _ O
are _ _ O
several _ _ O
of _ _ O
these _ _ O
. _ _ O
● _ _ O
matches _ _ O
are _ _ O
another _ _ O
place _ _ O
ripe _ _ O
for _ _ O
better _ _ O
errors _ _ O
: _ _ O
o _ _ O
in _ _ O
parse_exp _ _ O
, _ _ O
there _ _ O
are _ _ O
a _ _ O
number _ _ O
of _ _ O
possible _ _ O
options _ _ O
, _ _ O
so _ _ O
we _ _ O
should _ _ O
list _ _ O
the _ _ O
options _ _ O
in _ _ O
the _ _ O
error _ _ O
message _ _ O
, _ _ O
like _ _ O
" _ _ O
expected _ _ O
identifier _ _ O
, _ _ O
integer _ _ O
, _ _ O
or _ _ O
parenthesized _ _ O
expression _ _ O
, _ _ O
not _ _ O
blah _ _ O
blah _ _ O
" _ _ O
● _ _ O
one _ _ O
possibility _ _ O
is _ _ O
to _ _ O
pass _ _ O
some _ _ O
kind _ _ O
of _ _ O
" _ _ O
error _ _ O
context _ _ O
" _ _ O
to _ _ O
the _ _ O
parsing _ _ O
functions _ _ O
which _ _ O
can _ _ O
be _ _ O
used _ _ O
to _ _ O
tailor _ _ O
the _ _ O
messages _ _ O
better _ _ O
o _ _ O
since _ _ O
parse_exp _ _ O
is _ _ O
called _ _ O
from _ _ O
multiple _ _ O
places _ _ O
, _ _ O
the _ _ O
error _ _ O
message _ _ O
might _ _ O
be _ _ O
different _ _ O
depending _ _ O
on _ _ O
who _ _ O
calls _ _ O
it _ _ O
. _ _ O
32 _ _ O

Third _ _ O
: _ _ O
giving _ _ O
help _ _ O
● _ _ O
this _ _ O
is _ _ O
extremely _ _ O
broad _ _ O
and _ _ O
it _ _ O
's _ _ O
up _ _ O
to _ _ O
you _ _ O
what _ _ O
to _ _ O
say _ _ O
. _ _ O
o _ _ O
it _ _ O
's _ _ O
really _ _ O
kind _ _ O
of _ _ O
an _ _ O
extension _ _ O
of _ _ O
the _ _ O
previous _ _ O
rule _ _ O
. _ _ O
● _ _ O
have _ _ O
a _ _ O
look _ _ O
at _ _ O
the _ _ O
error _ _ B-Concept
messages _ _ I-Concept
Rust _ _ B-Concept
gives _ _ O
. _ _ O
o _ _ O
sometimes _ _ O
it _ _ O
's _ _ O
as _ _ O
simple _ _ O
as _ _ O
" _ _ O
remove _ _ O
this _ _ O
semicolon _ _ O
. _ _ O
" _ _ O
o _ _ O
sometimes _ _ O
it _ _ O
links _ _ O
to _ _ O
the _ _ O
appropriate _ _ O
part _ _ O
of _ _ O
the _ _ O
docs _ _ O
. _ _ O
o _ _ O
sometimes _ _ O
it _ _ O
even _ _ O
detects _ _ O
common _ _ O
mistakes _ _ O
and _ _ O
explains _ _ O
why _ _ O
they _ _ O
wo _ _ O
n't _ _ O
work _ _ O
. _ _ O
it _ _ O
's _ _ O
amazing _ _ O
! _ _ O
33 _ _ O



