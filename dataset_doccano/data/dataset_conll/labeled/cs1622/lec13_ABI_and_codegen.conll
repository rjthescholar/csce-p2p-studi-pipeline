['train_set', 'labeled']|cs1622|lec13_ABI_and_codegen
-DOCSTART- -X- -X- O

ABI _ _ B-Concept
and _ _ O
Codegen _ _ B-Concept
CS _ _ O
1622 _ _ O
Jarrett _ _ O
Billingsley _ _ O

Class _ _ O
Announcements _ _ O
● _ _ O
how _ _ O
's _ _ O
the _ _ O
project _ _ O
? _ _ O
● _ _ O
project _ _ O
2 _ _ O
grades _ _ O
will _ _ O
be _ _ O
posted _ _ O
today _ _ O
! _ _ O
2 _ _ O

Application _ _ B-Concept
Binary _ _ I-Concept
Interfaces _ _ I-Concept
( _ _ O
ABIs _ _ B-Concept
) _ _ O
3 _ _ O

Like _ _ O
API _ _ B-Concept
, _ _ O
but _ _ O
with _ _ O
a _ _ O
B _ _ O
instead _ _ O
of _ _ O
a _ _ O
P _ _ O
● _ _ O
the _ _ O
backend _ _ B-Concept
converts _ _ O
the _ _ O
concept _ _ O
of _ _ O
" _ _ O
a _ _ O
program _ _ O
" _ _ O
into _ _ O
something _ _ O
the _ _ O
CPU _ _ O
can _ _ O
actually _ _ O
execute _ _ O
– _ _ O
machine _ _ B-Concept
code _ _ I-Concept
. _ _ O
● _ _ O
an _ _ O
Application _ _ B-Concept
Binary _ _ I-Concept
Interface _ _ I-Concept
is _ _ O
a _ _ O
set _ _ O
of _ _ O
rules _ _ O
that _ _ O
sets _ _ O
the _ _ O
standards _ _ O
for _ _ O
how _ _ O
machine _ _ B-Concept
code _ _ I-Concept
programs _ _ O
look _ _ O
and _ _ O
work _ _ O
. _ _ O
o _ _ O
so _ _ O
, _ _ O
the _ _ O
ABI _ _ B-Concept
will _ _ O
guide _ _ O
how _ _ O
we _ _ O
actually _ _ O
generate _ _ O
the _ _ O
code _ _ O
. _ _ O
to _ _ O
make _ _ O
things _ _ O
more _ _ O
interesting _ _ O
, _ _ O
" _ _ O
the _ _ O
" _ _ O
ABI _ _ B-Concept
is _ _ O
probably _ _ O
composed _ _ O
of _ _ O
multiple _ _ O
layers _ _ O
of _ _ O
rules _ _ O
. _ _ O
things _ _ O
can _ _ O
get _ _ O
very _ _ O
interesting _ _ O
at _ _ O
the _ _ O
boundaries _ _ O
between _ _ O
these _ _ O
layers _ _ O
… _ _ O
Language _ _ B-Concept
ABI _ _ I-Concept
OS _ _ B-Concept
ABI _ _ I-Concept
Architectural _ _ B-Concept
ABI _ _ I-Concept
4 _ _ O

The _ _ O
lowest _ _ O
layer _ _ O
: _ _ O
the _ _ O
Architectural _ _ B-Concept
ABI _ _ I-Concept
● _ _ O
the _ _ O
designers _ _ O
of _ _ O
an _ _ O
ISA _ _ B-Concept
may _ _ O
define _ _ O
an _ _ O
ABI _ _ B-Concept
to _ _ O
go _ _ O
with _ _ O
it _ _ O
. _ _ O
o _ _ O
as _ _ O
the _ _ O
designers _ _ O
, _ _ O
they _ _ O
may _ _ O
have _ _ O
included _ _ O
special _ _ O
features _ _ O
for _ _ O
e.g. _ _ O
making _ _ O
function _ _ O
calls _ _ O
faster _ _ O
if _ _ O
you _ _ O
use _ _ O
those _ _ O
features _ _ O
as _ _ O
intended _ _ O
. _ _ O
● _ _ O
these _ _ O
may _ _ O
be _ _ O
bare-bones _ _ O
, _ _ O
including _ _ O
rules _ _ O
on _ _ O
how _ _ O
to _ _ O
do _ _ O
function _ _ O
calls _ _ O
and _ _ O
object _ _ O
file _ _ O
formats _ _ O
, _ _ O
and _ _ O
not _ _ O
much _ _ O
else _ _ O
. _ _ O
these _ _ O
are _ _ O
widely _ _ O
used _ _ O
on _ _ O
embedded _ _ O
devices _ _ O
where _ _ O
there _ _ O
is _ _ O
no _ _ O
OS _ _ B-Concept
– _ _ O
your _ _ O
program _ _ O
runs _ _ O
" _ _ O
on _ _ O
the _ _ O
bare _ _ O
metal _ _ O
. _ _ O
" _ _ O
5 _ _ O

But _ _ O
Operating _ _ B-Concept
Systems _ _ I-Concept
have _ _ O
opinions _ _ O
● _ _ O
the _ _ O
goal _ _ O
of _ _ O
an _ _ O
operating _ _ B-Concept
system _ _ I-Concept
is _ _ O
to _ _ O
control _ _ O
access _ _ O
to _ _ O
your _ _ O
computer _ _ O
's _ _ O
resources _ _ O
and _ _ O
make _ _ O
the _ _ O
programs _ _ O
share _ _ O
them _ _ O
. _ _ O
● _ _ O
so _ _ O
, _ _ O
the _ _ O
designers _ _ O
of _ _ O
OSes _ _ B-Concept
will _ _ O
define _ _ O
their _ _ O
own _ _ O
ABI _ _ B-Concept
which _ _ O
are _ _ O
much _ _ O
more _ _ O
extensive _ _ O
, _ _ O
including _ _ O
rules _ _ O
for _ _ O
: _ _ O
o _ _ O
how _ _ O
function _ _ B-Concept
calls _ _ I-Concept
work _ _ O
▪ _ _ O
this _ _ O
may _ _ O
be _ _ O
built _ _ O
on _ _ O
the _ _ O
architectural _ _ B-Concept
ABI _ _ I-Concept
, _ _ O
or _ _ O
it _ _ O
may _ _ O
be _ _ O
unique _ _ O
! _ _ O
o _ _ O
how _ _ O
system _ _ B-Concept
calls _ _ I-Concept
work _ _ O
, _ _ O
to _ _ O
ask _ _ O
the _ _ O
OS _ _ O
to _ _ O
do _ _ O
things _ _ O
for _ _ O
you _ _ O
o _ _ O
how _ _ O
asynchronous _ _ B-Concept
messages _ _ I-Concept
are _ _ O
delivered _ _ O
to _ _ O
running _ _ O
programs _ _ O
o _ _ O
how _ _ O
executables _ _ B-Concept
and _ _ O
shared _ _ B-Concept
libraries _ _ I-Concept
are _ _ O
packaged _ _ O
o _ _ O
how _ _ O
memory _ _ B-Concept
is _ _ O
laid _ _ O
out _ _ O
and _ _ O
where _ _ O
parts _ _ O
of _ _ O
your _ _ O
program _ _ O
exist _ _ O
● _ _ O
these _ _ O
are _ _ O
the _ _ O
kinds _ _ O
of _ _ O
ABIs _ _ B-Concept
most _ _ O
compilers _ _ B-Concept
are _ _ O
generating _ _ O
code _ _ O
for _ _ O
, _ _ O
most _ _ O
of _ _ O
the _ _ O
time _ _ O
. _ _ O
6 _ _ O

The _ _ O
highest _ _ O
layer _ _ O
: _ _ O
your _ _ O
language _ _ O
's _ _ O
own _ _ O
ABI _ _ B-Concept
● _ _ O
HLLs _ _ B-Concept
can _ _ O
have _ _ O
features _ _ O
which _ _ O
are _ _ O
not _ _ O
accounted _ _ O
for _ _ O
by _ _ O
either _ _ O
the _ _ O
architectural _ _ B-Concept
or _ _ I-Concept
OS _ _ I-Concept
ABIs _ _ I-Concept
, _ _ O
so _ _ O
they _ _ O
have _ _ O
to _ _ O
make _ _ O
their _ _ O
own _ _ O
rules _ _ O
. _ _ O
● _ _ O
this _ _ O
might _ _ O
include _ _ O
features _ _ O
like _ _ O
: _ _ O
exceptions _ _ B-Concept
! _ _ O
dynamic _ _ B-Concept
method _ _ I-Concept
dispatch _ _ I-Concept
! _ _ I-Concept
try _ _ O
{ _ _ O
... _ _ O
throw _ _ O
... _ _ O
} _ _ O
catch _ _ O
( _ _ O
... _ _ O
) _ _ O
{ _ _ O
... _ _ O
} _ _ O
finally _ _ O
{ _ _ O
... _ _ O
} _ _ O
String _ _ O
s _ _ O
= _ _ O
obj.toString _ _ O
( _ _ O
) _ _ O
; _ _ O
function _ _ O
closures _ _ O
! _ _ O
auto _ _ O
f _ _ O
= _ _ O
[ _ _ O
& _ _ O
] _ _ O
( _ _ O
) _ _ O
{ _ _ O
cout _ _ O
< _ _ O
< _ _ O
" _ _ O
wheee _ _ O
! _ _ O
\n _ _ O
" _ _ O
; _ _ O
} _ _ O
; _ _ O
however _ _ O
, _ _ O
if _ _ O
you _ _ O
're _ _ O
not _ _ O
careful _ _ O
defining _ _ O
your _ _ O
language _ _ O
, _ _ O
different _ _ O
compilers _ _ B-Concept
for _ _ O
the _ _ O
same _ _ O
language _ _ O
can _ _ O
use _ _ O
different _ _ O
ABIs _ _ B-Concept
… _ _ O
7 _ _ O

When _ _ O
ABIs _ _ B-Concept
collide _ _ O
● _ _ O
let _ _ O
's _ _ O
say _ _ O
a _ _ O
language _ _ O
has _ _ O
no _ _ O
standardized _ _ O
ABI _ _ B-Concept
for _ _ O
method _ _ B-Concept
calls _ _ I-Concept
. _ _ O
● _ _ O
then _ _ O
, _ _ O
different _ _ O
compilers _ _ B-Concept
may _ _ O
have _ _ O
their _ _ O
own _ _ O
incompatible _ _ O
ways _ _ O
of _ _ O
generating _ _ O
code _ _ O
for _ _ O
method _ _ O
calls _ _ O
, _ _ O
leading _ _ O
to _ _ O
really _ _ O
nasty _ _ O
situations _ _ O
. _ _ O
this _ _ O
program _ _ O
was _ _ O
compiled _ _ B-Concept
with _ _ O
Compiler _ _ B-Concept
A. _ _ O
you _ _ O
wrote _ _ O
a _ _ O
plugin _ _ O
in _ _ O
the _ _ O
same _ _ O
language _ _ O
, _ _ O
but _ _ O
you _ _ O
used _ _ O
Compiler _ _ B-Concept
B. _ _ O
Program _ _ O
Plugin _ _ O
plugin.getName _ _ O
( _ _ O
) _ _ O
the _ _ O
program _ _ O
tries _ _ O
to _ _ O
call _ _ O
a _ _ O
method _ _ O
in _ _ O
your _ _ O
plugin _ _ O
, _ _ O
and _ _ O
… _ _ O
what _ _ O
happens _ _ O
? _ _ O
who _ _ O
knows _ _ O
? _ _ O
it _ _ O
might _ _ O
silently _ _ O
fail _ _ O
, _ _ O
it _ _ O
might _ _ O
crash _ _ O
immediately _ _ O
, _ _ O
it _ _ O
might _ _ O
corrupt _ _ O
the _ _ O
stack _ _ O
or _ _ O
heap _ _ O
in _ _ O
more _ _ O
subtle _ _ O
ways _ _ O
, _ _ O
etc _ _ O
. _ _ O
8 _ _ O

Break _ _ O
the _ _ O
rules _ _ O
, _ _ O
get _ _ O
a _ _ O
broken _ _ O
program _ _ O
. _ _ O
● _ _ O
if _ _ O
two _ _ O
pieces _ _ O
of _ _ O
code _ _ O
use _ _ O
different _ _ O
ABIs _ _ B-Concept
… _ _ O
● _ _ O
or _ _ O
if _ _ O
your _ _ O
compiler _ _ B-Concept
generates _ _ O
code _ _ O
that _ _ O
does _ _ O
n't _ _ O
follow _ _ O
the _ _ O
ABI _ _ B-Concept
… _ _ O
● _ _ O
you _ _ O
lose _ _ O
all _ _ O
the _ _ O
nice _ _ O
abstraction _ _ O
guarantees _ _ O
of _ _ O
the _ _ O
HLL _ _ B-Concept
. _ _ O
● _ _ O
think _ _ O
back _ _ O
to _ _ O
when _ _ O
you _ _ O
were _ _ O
writing _ _ O
MIPS _ _ O
in _ _ O
447 _ _ O
. _ _ O
o _ _ O
do _ _ O
you _ _ O
really _ _ O
want _ _ O
to _ _ O
deal _ _ O
with _ _ O
those _ _ O
kinds _ _ O
of _ _ O
bugs _ _ O
again _ _ O
? _ _ O
● _ _ O
C _ _ O
– _ _ O
or _ _ O
rather _ _ O
its _ _ O
ABI _ _ B-Concept
– _ _ O
has _ _ O
remained _ _ O
popular _ _ O
for _ _ O
decades _ _ O
. _ _ O
why _ _ O
? _ _ O
o _ _ O
because _ _ O
it _ _ O
's _ _ O
super _ _ O
simple _ _ O
, _ _ O
meaning _ _ O
just _ _ O
about _ _ O
every _ _ O
OS _ _ B-Concept
and _ _ O
compiler _ _ B-Concept
can _ _ O
follow _ _ O
it _ _ O
without _ _ O
much _ _ O
difficulty _ _ O
. _ _ O
o _ _ O
with _ _ O
it _ _ O
, _ _ O
you _ _ O
can _ _ O
hook _ _ O
pieces _ _ O
of _ _ O
machine _ _ O
code _ _ O
together _ _ O
reliably _ _ O
. _ _ O
● _ _ O
but _ _ O
, _ _ O
its _ _ O
simplicity _ _ O
means _ _ O
it _ _ O
does _ _ O
n't _ _ O
support _ _ O
advanced _ _ O
features _ _ O
… _ _ O
o _ _ O
so _ _ O
it _ _ O
's _ _ O
up _ _ O
to _ _ O
you _ _ O
, _ _ O
as _ _ O
the _ _ O
language _ _ O
designer _ _ O
or _ _ O
compiler _ _ B-Concept
writer _ _ O
, _ _ O
to _ _ O
decide _ _ O
how _ _ O
those _ _ O
features _ _ O
are _ _ O
implemented _ _ O
. _ _ O
● _ _ O
so _ _ O
! _ _ O
what _ _ O
goes _ _ O
into _ _ O
an _ _ O
ABI _ _ B-Concept
, _ _ O
anyway _ _ O
? _ _ O
9 _ _ O

Parts _ _ O
of _ _ O
an _ _ O
ABI _ _ B-Concept
10 _ _ O

The _ _ O
call _ _ O
stack _ _ B-Concept
● _ _ O
any _ _ O
ISA _ _ B-Concept
from _ _ O
the _ _ O
last _ _ O
50 _ _ O
years _ _ O
or _ _ O
so _ _ O
will _ _ O
have _ _ O
provisions _ _ O
for _ _ O
a _ _ O
stack _ _ B-Concept
. _ _ O
Stack _ _ B-Concept
16 _ _ O
0 _ _ O
48580372 _ _ O
0 _ _ O
0 _ _ O
5 _ _ O
it _ _ O
'll _ _ O
have _ _ O
, _ _ O
at _ _ O
the _ _ O
very _ _ O
least _ _ O
, _ _ O
a _ _ O
register _ _ O
that _ _ O
points _ _ O
to _ _ O
the _ _ O
top _ _ O
of _ _ O
the _ _ O
stack _ _ B-Concept
… _ _ O
a _ _ O
stack _ _ B-Concept
pointer _ _ I-Concept
, _ _ O
if _ _ O
you _ _ O
will _ _ O
. _ _ O
( _ _ O
well _ _ O
, _ _ O
maybe _ _ O
it _ _ O
has _ _ O
two _ _ O
registers _ _ O
. _ _ O
we _ _ O
'll _ _ O
get _ _ O
to _ _ O
that _ _ O
. _ _ O
) _ _ O
sp _ _ B-Concept
it _ _ O
might _ _ O
have _ _ O
special _ _ O
instructions _ _ O
for _ _ O
pushing _ _ B-Concept
and _ _ O
popping _ _ B-Concept
things _ _ O
to _ _ O
this _ _ O
stack _ _ B-Concept
, _ _ I-Concept
or _ _ O
it _ _ O
might _ _ O
not _ _ O
. _ _ O
push _ _ O
eax _ _ O
pop _ _ O
ecx _ _ O
call _ _ O
func _ _ O
ret _ _ O
the _ _ O
ABI _ _ B-Concept
defines _ _ O
things _ _ O
like _ _ O
: _ _ O
the _ _ O
direction _ _ O
the _ _ O
stack _ _ B-Concept
grows _ _ O
; _ _ O
the _ _ O
size _ _ O
of _ _ O
each _ _ O
item _ _ O
on _ _ O
the _ _ O
stack _ _ B-Concept
; _ _ O
stack _ _ B-Concept
alignment _ _ B-Concept
( _ _ O
if _ _ O
the _ _ O
stack _ _ O
pointer _ _ O
must _ _ O
move _ _ O
in _ _ O
multiples _ _ O
of _ _ O
some _ _ O
number _ _ O
) _ _ O
; _ _ O
and _ _ O
so _ _ O
on _ _ O
. _ _ O
11 _ _ O

You _ _ O
ca _ _ O
n't _ _ O
stack _ _ B-Concept
things _ _ O
up _ _ O
forever _ _ O
… _ _ O
● _ _ O
statistically _ _ O
, _ _ O
most _ _ O
programs _ _ O
never _ _ O
need _ _ O
more _ _ O
than _ _ O
a _ _ O
few _ _ O
megabytes _ _ O
of _ _ O
stack _ _ B-Concept
space _ _ O
, _ _ O
and _ _ O
most _ _ O
use _ _ O
far _ _ O
, _ _ O
far _ _ O
less _ _ O
than _ _ O
that _ _ O
. _ _ O
● _ _ O
since _ _ O
the _ _ O
OS _ _ O
makes _ _ O
all _ _ O
the _ _ O
programs _ _ O
share _ _ O
resources _ _ O
, _ _ O
it _ _ O
may _ _ O
only _ _ O
allocate _ _ O
something _ _ O
like _ _ O
4 _ _ O
- _ _ O
16 _ _ O
MB _ _ O
of _ _ O
memory _ _ O
for _ _ O
your _ _ O
program _ _ O
. _ _ O
o _ _ O
this _ _ O
is _ _ O
allocated _ _ O
before _ _ O
your _ _ O
program _ _ O
starts _ _ O
; _ _ O
you _ _ O
do _ _ O
n't _ _ O
have _ _ O
to _ _ O
do _ _ O
anything _ _ O
to _ _ O
get _ _ O
it _ _ O
. _ _ O
● _ _ O
and _ _ O
what _ _ O
happens _ _ O
if _ _ O
you _ _ O
push _ _ O
more _ _ O
than _ _ O
that _ _ O
on _ _ O
the _ _ O
stack _ _ B-Concept
? _ _ O
o _ _ O
stack _ _ B-Concept
overflow _ _ I-Concept
! _ _ O
yay _ _ O
! _ _ O
● _ _ O
so _ _ O
, _ _ O
however _ _ O
we _ _ O
implement _ _ O
our _ _ O
language _ _ O
's _ _ O
ABI _ _ B-Concept
, _ _ O
it _ _ O
will _ _ O
have _ _ O
to _ _ O
work _ _ O
within _ _ O
this _ _ O
limit _ _ O
. _ _ O
12 _ _ O

The _ _ O
calling _ _ B-Concept
convention _ _ I-Concept
● _ _ O
this _ _ O
is _ _ O
the _ _ O
set _ _ O
of _ _ O
rules _ _ O
used _ _ O
to _ _ O
call _ _ O
and _ _ O
return _ _ O
from _ _ O
functions _ _ O
. _ _ O
● _ _ O
it _ _ O
defines _ _ O
things _ _ O
like _ _ O
: _ _ O
how _ _ O
arguments _ _ B-Concept
are _ _ O
passed _ _ O
; _ _ O
how _ _ O
the _ _ O
return _ _ B-Concept
address _ _ I-Concept
is _ _ O
calculated _ _ O
and _ _ O
where _ _ O
it _ _ O
's _ _ O
stored _ _ O
; _ _ O
fn _ _ O
add _ _ O
( _ _ O
x _ _ O
: _ _ O
int _ _ O
, _ _ O
y _ _ O
: _ _ O
int _ _ O
) _ _ O
: _ _ O
int _ _ O
{ _ _ O
let _ _ O
sum _ _ O
= _ _ O
x _ _ O
+ _ _ O
y _ _ O
; _ _ O
println_i _ _ O
( _ _ O
sum _ _ O
) _ _ O
; _ _ O
return _ _ O
sum _ _ O
; _ _ O
} _ _ O
how _ _ O
values _ _ O
are _ _ O
returned _ _ O
; _ _ O
which _ _ O
CPU _ _ O
registers _ _ O
must _ _ O
be _ _ O
saved _ _ O
, _ _ O
and _ _ O
which _ _ O
can _ _ O
be _ _ O
used _ _ O
freely _ _ O
. _ _ O
ra _ _ O
v0 _ _ O
s0 _ _ O
t0 _ _ O
a0 _ _ O
f0 _ _ O
fp _ _ O
13 _ _ O

Border _ _ O
conflicts _ _ O
● _ _ O
within _ _ O
your _ _ O
language _ _ O
, _ _ O
you _ _ O
can _ _ O
use _ _ O
any _ _ O
calling _ _ B-Concept
convention _ _ I-Concept
you _ _ O
like _ _ O
. _ _ O
o _ _ O
as _ _ O
long _ _ O
as _ _ O
every _ _ O
function _ _ O
uses _ _ O
the _ _ O
same _ _ O
rules _ _ O
, _ _ O
it _ _ O
will _ _ O
work _ _ O
fine _ _ O
. _ _ O
● _ _ O
it _ _ O
's _ _ O
at _ _ O
the _ _ O
boundaries _ _ O
where _ _ O
things _ _ O
get _ _ O
tricky _ _ O
. _ _ O
Your _ _ O
Language _ _ O
main _ _ O
init _ _ O
OS _ _ O
API _ _ O
prompt _ _ O
read _ _ O
println _ _ O
write _ _ O
functions _ _ O
from _ _ O
outside _ _ O
your _ _ O
language _ _ O
may _ _ O
use _ _ O
a _ _ O
different _ _ O
ABI _ _ B-Concept
, _ _ O
so _ _ O
your _ _ O
code _ _ B-Concept
generator _ _ I-Concept
must _ _ O
be _ _ O
very _ _ O
careful _ _ O
about _ _ O
it _ _ O
. _ _ O
it _ _ O
has _ _ O
to _ _ O
know _ _ O
what _ _ O
ABI _ _ B-Concept
each _ _ O
function _ _ O
uses _ _ O
, _ _ O
so _ _ O
it _ _ O
can _ _ O
use _ _ O
the _ _ O
right _ _ O
rules _ _ O
when _ _ O
calling _ _ O
them _ _ O
. _ _ O
or _ _ O
, _ _ O
we _ _ O
could _ _ O
punt _ _ O
it _ _ O
… _ _ O
14 _ _ O

If _ _ O
it _ _ O
hurts _ _ O
, _ _ O
do _ _ O
n't _ _ O
do _ _ O
it _ _ O
● _ _ O
you _ _ O
could _ _ O
make _ _ O
it _ _ O
so _ _ O
you _ _ O
ca _ _ O
n't _ _ O
directly _ _ O
call _ _ O
functions _ _ O
from _ _ O
other _ _ O
languages _ _ O
/ _ _ O
which _ _ O
use _ _ O
different _ _ O
ABIs _ _ B-Concept
. _ _ O
● _ _ O
Java _ _ O
does _ _ O
this _ _ O
. _ _ O
o _ _ O
public _ _ O
static _ _ O
native _ _ O
int _ _ O
someExternalFunction _ _ O
( _ _ O
) _ _ O
; _ _ O
o _ _ O
this _ _ O
function _ _ O
is _ _ O
not _ _ O
written _ _ O
in _ _ O
Java _ _ O
. _ _ O
o _ _ O
instead _ _ O
, _ _ O
it _ _ O
's _ _ O
probably _ _ O
written _ _ O
in _ _ O
C++ _ _ O
, _ _ O
and _ _ O
compiled _ _ O
into _ _ O
a _ _ O
plugin _ _ O
. _ _ O
o _ _ O
that _ _ O
plugin _ _ O
is _ _ O
then _ _ O
loaded _ _ O
into _ _ O
the _ _ O
JVM _ _ O
when _ _ O
your _ _ O
program _ _ O
runs _ _ O
. _ _ O
● _ _ O
this _ _ O
provides _ _ O
a _ _ O
controlled _ _ O
boundary _ _ O
between _ _ O
" _ _ O
the _ _ O
safe _ _ O
Java _ _ O
world _ _ O
" _ _ O
and _ _ O
" _ _ O
the _ _ O
scary _ _ O
non-Java _ _ O
world _ _ O
, _ _ O
" _ _ O
and _ _ O
lets _ _ O
Java _ _ O
programs _ _ O
call _ _ O
functions _ _ O
they _ _ O
would _ _ O
normally _ _ O
be _ _ O
unable _ _ O
to _ _ O
. _ _ O
● _ _ O
systems _ _ O
programming _ _ O
languages _ _ O
will _ _ O
give _ _ O
you _ _ O
a _ _ O
way _ _ O
to _ _ O
deal _ _ O
with _ _ O
calling _ _ B-Concept
conventions _ _ I-Concept
yourself _ _ O
. _ _ O
o _ _ O
but _ _ O
Java _ _ O
is _ _ O
n't _ _ O
a _ _ O
systems _ _ O
language _ _ O
, _ _ O
and _ _ O
there _ _ O
's _ _ O
no _ _ O
shame _ _ O
in _ _ O
saying _ _ O
" _ _ O
hey _ _ O
, _ _ O
it _ _ O
's _ _ O
not _ _ O
my _ _ O
language _ _ O
's _ _ O
responsibility _ _ O
! _ _ O
" _ _ O
15 _ _ O

Another _ _ O
kind _ _ O
of _ _ O
call _ _ O
, _ _ O
another _ _ O
calling _ _ B-Concept
convention _ _ I-Concept
● _ _ O
system _ _ B-Concept
calls _ _ I-Concept
are _ _ O
how _ _ O
your _ _ O
program _ _ O
asks _ _ O
the _ _ O
OS _ _ O
to _ _ O
do _ _ O
things _ _ O
on _ _ O
the _ _ O
program _ _ O
's _ _ O
behalf _ _ O
: _ _ O
I _ _ O
/ _ _ O
O _ _ O
, _ _ O
resource _ _ O
management _ _ O
, _ _ O
even _ _ O
exiting _ _ O
… _ _ O
o _ _ O
without _ _ O
syscalls _ _ B-Concept
, _ _ O
about _ _ O
all _ _ O
a _ _ O
program _ _ O
can _ _ O
do _ _ O
is _ _ O
make _ _ O
the _ _ O
CPU _ _ O
hot _ _ O
. _ _ O
● _ _ O
the _ _ O
ISA _ _ B-Concept
defines _ _ O
the _ _ O
system _ _ B-Concept
call _ _ I-Concept
( _ _ O
syscall _ _ B-Concept
) _ _ O
mechanism _ _ O
… _ _ O
o _ _ O
which _ _ O
usually _ _ O
requires _ _ O
using _ _ O
a _ _ O
special _ _ O
instruction _ _ O
. _ _ O
( _ _ O
like _ _ O
syscall _ _ B-Concept
. _ _ O
) _ _ O
o _ _ O
the _ _ O
OS _ _ O
will _ _ O
also _ _ O
define _ _ O
how _ _ O
values _ _ O
are _ _ O
passed _ _ O
into _ _ O
/ _ _ O
out _ _ O
of _ _ O
them _ _ O
. _ _ O
● _ _ O
essentially _ _ O
this _ _ O
is _ _ O
just _ _ O
another _ _ O
calling _ _ B-Concept
convention _ _ I-Concept
, _ _ O
meaning _ _ O
we _ _ O
will _ _ O
run _ _ O
into _ _ O
the _ _ O
same _ _ O
issues _ _ O
as _ _ O
before _ _ O
. _ _ O
o _ _ O
if _ _ O
a _ _ O
language _ _ O
can _ _ O
not _ _ O
use _ _ O
syscalls _ _ B-Concept
directly _ _ O
, _ _ O
it _ _ O
will _ _ O
have _ _ O
to _ _ O
rely _ _ O
on _ _ O
code _ _ O
written _ _ O
in _ _ O
some _ _ O
other _ _ O
language _ _ O
to _ _ O
do _ _ O
so _ _ O
. _ _ O
● _ _ O
it _ _ O
feels _ _ O
like _ _ O
this _ _ O
interface _ _ O
between _ _ O
our _ _ O
language _ _ O
and _ _ O
the _ _ O
OS _ _ O
is _ _ O
going _ _ O
to _ _ O
have _ _ O
to _ _ O
be _ _ O
somewhat _ _ O
… _ _ O
substantial _ _ O
. _ _ O
so _ _ O
let _ _ O
's _ _ O
talk _ _ O
about _ _ O
it _ _ O
. _ _ O
16 _ _ O

Standard _ _ B-Concept
and _ _ I-Concept
Runtime _ _ I-Concept
Libraries _ _ I-Concept
17 _ _ O

std _ _ O
: _ _ O
: _ _ O
● _ _ O
you _ _ O
kind _ _ O
of _ _ O
take _ _ O
the _ _ O
standard _ _ B-Concept
library _ _ I-Concept
( _ _ O
stdlib _ _ B-Concept
) _ _ O
for _ _ O
granted _ _ O
. _ _ O
o _ _ O
there _ _ O
are _ _ O
these _ _ O
functions _ _ O
and _ _ O
classes _ _ O
that _ _ O
are _ _ O
just _ _ O
… _ _ O
there _ _ O
! _ _ O
o _ _ O
System.out.println _ _ O
( _ _ O
) _ _ O
and _ _ O
ArrayList _ _ O
and _ _ O
Vec _ _ O
and _ _ O
so _ _ O
on _ _ O
. _ _ O
o _ _ O
but _ _ O
someone _ _ O
had _ _ O
to _ _ O
write _ _ O
them _ _ O
. _ _ O
and _ _ O
if _ _ O
you _ _ O
're _ _ O
making _ _ O
your _ _ O
own _ _ O
language _ _ O
, _ _ O
that _ _ O
" _ _ O
someone _ _ O
" _ _ O
is _ _ O
going _ _ O
to _ _ O
be _ _ O
you _ _ O
. _ _ O
● _ _ O
standard _ _ B-Concept
libraries _ _ I-Concept
are _ _ O
out _ _ O
of _ _ O
the _ _ O
scope _ _ O
of _ _ O
this _ _ O
course _ _ O
, _ _ O
but _ _ O
… _ _ O
o _ _ O
the _ _ O
standard _ _ B-Concept
library _ _ I-Concept
is _ _ O
going _ _ O
to _ _ O
have _ _ O
to _ _ O
make _ _ O
calls _ _ O
to _ _ O
OS _ _ O
APIs _ _ O
to _ _ O
do _ _ O
things _ _ O
like _ _ O
input _ _ O
and _ _ O
output _ _ O
, _ _ O
somehow _ _ O
. _ _ O
● _ _ O
and _ _ O
all _ _ O
code _ _ O
in _ _ O
your _ _ O
language _ _ O
will _ _ O
rely _ _ O
on _ _ O
some _ _ O
special _ _ O
hidden _ _ O
code _ _ O
to _ _ O
work _ _ O
properly _ _ O
at _ _ O
runtime _ _ O
. _ _ O
o _ _ O
and _ _ O
the _ _ O
compiler _ _ B-Concept
will _ _ O
be _ _ O
relying _ _ O
on _ _ O
that _ _ O
code _ _ O
as _ _ O
well _ _ O
! _ _ O
18 _ _ O

core _ _ O
: _ _ O
: _ _ O
● _ _ O
there _ _ O
are _ _ O
likely _ _ O
many _ _ O
operations _ _ O
in _ _ O
your _ _ O
HLL _ _ B-Concept
that _ _ O
do _ _ O
n't _ _ O
map _ _ O
neatly _ _ O
onto _ _ O
a _ _ O
few _ _ O
instructions _ _ O
in _ _ O
the _ _ O
target _ _ O
ISA _ _ B-Concept
. _ _ O
is _ _ O
there _ _ O
a _ _ O
MIPS _ _ O
instruction _ _ O
for _ _ O
string _ _ O
concatenation _ _ O
? _ _ O
how _ _ O
about _ _ O
for _ _ O
allocating _ _ O
objects _ _ O
on _ _ O
the _ _ O
heap _ _ O
? _ _ O
" _ _ O
hi _ _ O
" _ _ O
+ _ _ O
" _ _ O
bye _ _ O
" _ _ O
new _ _ O
Cat _ _ O
( _ _ O
) _ _ O
checking _ _ O
array _ _ O
bounds _ _ O
? _ _ O
throwing _ _ O
exceptions _ _ O
? _ _ O
A _ _ O
[ _ _ O
1000000000 _ _ O
] _ _ O
throw _ _ O
new _ _ O
OhMyGodWhyAreAllTheExcept _ _ O
ionNamesSoLongException _ _ O
( _ _ O
) _ _ O
; _ _ O
there _ _ O
are _ _ O
a _ _ O
lot _ _ O
of _ _ O
hidden _ _ O
operations _ _ O
going _ _ O
on _ _ O
in _ _ O
each _ _ O
of _ _ O
these _ _ O
cases _ _ O
, _ _ O
and _ _ O
it _ _ O
is _ _ O
the _ _ O
runtime _ _ B-Concept
library _ _ I-Concept
which _ _ O
implements _ _ O
them _ _ O
. _ _ O
19 _ _ O

The _ _ O
language _ _ O
runtime _ _ B-Concept
● _ _ O
a _ _ O
language _ _ O
's _ _ O
runtime _ _ B-Concept
library _ _ I-Concept
implements _ _ O
the _ _ O
features _ _ O
which _ _ O
would _ _ O
be _ _ O
difficult _ _ O
or _ _ O
impossible _ _ O
to _ _ O
codegen _ _ B-Concept
directly _ _ O
. _ _ O
● _ _ O
unlike _ _ O
the _ _ O
standard _ _ B-Concept
library _ _ I-Concept
, _ _ O
this _ _ O
is _ _ O
tied _ _ O
more _ _ O
closely _ _ O
to _ _ O
the _ _ O
compiler _ _ B-Concept
and _ _ O
how _ _ O
the _ _ O
compiler _ _ B-Concept
has _ _ O
decided _ _ O
to _ _ O
implement _ _ O
those _ _ O
features _ _ O
. _ _ O
o _ _ O
so _ _ O
, _ _ O
different _ _ O
compilers _ _ B-Concept
– _ _ O
and _ _ O
even _ _ O
different _ _ O
versions _ _ O
of _ _ O
the _ _ O
same _ _ O
compiler _ _ B-Concept
– _ _ O
can _ _ O
have _ _ O
different _ _ O
runtime _ _ B-Concept
libraries _ _ I-Concept
. _ _ O
o _ _ O
ever _ _ O
install _ _ O
the _ _ O
many _ _ O
versions _ _ O
of _ _ O
Visual _ _ O
C++ _ _ O
Redistributable _ _ O
? _ _ O
▪ _ _ O
thaaaaat _ _ O
's _ _ O
what _ _ O
it _ _ O
iiiiiiiis _ _ O
● _ _ O
the _ _ O
runtime _ _ B-Concept
may _ _ O
be _ _ O
written _ _ O
in _ _ O
a _ _ O
different _ _ O
language _ _ O
( _ _ O
like _ _ O
C _ _ O
or _ _ O
C++ _ _ O
) _ _ O
from _ _ O
the _ _ O
source _ _ O
language _ _ O
that _ _ O
the _ _ O
compiler _ _ B-Concept
compiles _ _ O
. _ _ O
o _ _ O
in _ _ O
our _ _ O
case _ _ O
, _ _ O
Truss _ _ O
's _ _ O
tiny _ _ O
runtime _ _ B-Concept
library _ _ I-Concept
is _ _ O
written _ _ O
in _ _ O
MIPS _ _ O
. _ _ O
( _ _ O
so _ _ O
is _ _ O
its _ _ O
" _ _ O
standard _ _ B-Concept
library _ _ I-Concept
" _ _ O
of _ _ O
a _ _ O
few _ _ O
print _ _ O
functions _ _ O
, _ _ O
lol _ _ O
. _ _ O
) _ _ O
20 _ _ O

The _ _ O
compiler _ _ B-Concept
's _ _ I-Concept
job _ _ O
● _ _ O
during _ _ O
codegen _ _ B-Concept
, _ _ O
the _ _ O
compiler _ _ B-Concept
is _ _ O
essentially _ _ O
going _ _ O
to _ _ O
turn _ _ O
some _ _ O
pieces _ _ O
of _ _ O
code _ _ O
into _ _ O
function _ _ B-Concept
calls _ _ I-Concept
into _ _ O
the _ _ O
runtime _ _ O
library _ _ O
. _ _ O
● _ _ O
if _ _ O
we _ _ O
take _ _ O
string _ _ O
concatenation _ _ O
as _ _ O
an _ _ O
example _ _ O
: _ _ O
source _ _ O
code _ _ O
: _ _ O
let _ _ O
msg _ _ O
= _ _ O
" _ _ O
hello _ _ O
, _ _ O
" _ _ O
+ _ _ O
name _ _ O
; _ _ O
codegen _ _ B-Concept
treats _ _ O
it _ _ O
as _ _ O
: _ _ O
let _ _ O
msg _ _ O
= _ _ O
rt$concat _ _ O
( _ _ O
"hello _ _ O
, _ _ O
" _ _ O
, _ _ O
name _ _ O
) _ _ O
; _ _ O
gets _ _ O
generated _ _ O
as _ _ O
: _ _ O
addi _ _ O
sp _ _ O
, _ _ O
sp _ _ O
, _ _ O
-8 _ _ O
la _ _ O
sw _ _ O
lw _ _ O
sw _ _ O
jal _ _ O
sw _ _ O
t0 _ _ O
, _ _ O
STRLIT$3 _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
sp _ _ O
) _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
fp _ _ O
) _ _ O
t0 _ _ O
, _ _ O
4 _ _ O
( _ _ O
sp _ _ O
) _ _ O
rt$concat _ _ O
v0 _ _ O
, _ _ O
-20 _ _ O
( _ _ O
fp _ _ O
) _ _ O
fp _ _ O
? _ _ O
what _ _ O
's _ _ O
that _ _ O
? _ _ O
? _ _ O
21 _ _ O

Truss _ _ B-Concept
's _ _ I-Concept
MIPS _ _ O
ABI _ _ B-Concept
22 _ _ O

Kind _ _ O
of _ _ O
standard _ _ O
, _ _ O
kind _ _ O
of _ _ O
not _ _ O
● _ _ O
Truss _ _ B-Concept
’s _ _ I-Concept
MIPS _ _ O
ABI _ _ B-Concept
is _ _ O
based _ _ O
on _ _ O
the _ _ O
standard _ _ O
MIPS _ _ O
ABI _ _ B-Concept
, _ _ O
but _ _ O
is _ _ O
more _ _ O
limited _ _ O
in _ _ O
some _ _ O
ways _ _ O
in _ _ O
order _ _ O
to _ _ O
make _ _ O
the _ _ O
codegen _ _ B-Concept
simpler _ _ O
. _ _ O
● _ _ O
we _ _ O
’re _ _ O
generating _ _ O
code _ _ O
for _ _ O
a _ _ O
slightly _ _ O
weird _ _ O
target _ _ O
, _ _ O
MARS _ _ O
, _ _ O
which _ _ O
: _ _ O
o _ _ O
has _ _ O
no _ _ O
operating _ _ O
system _ _ O
o _ _ O
has _ _ O
no _ _ O
executable _ _ O
format _ _ O
, _ _ O
only _ _ O
textual _ _ O
assembly _ _ O
as _ _ O
input _ _ O
● _ _ O
those _ _ O
aspects _ _ O
will _ _ O
also _ _ O
simplify _ _ O
our _ _ O
job _ _ O
! _ _ O
● _ _ O
a _ _ O
large _ _ O
part _ _ O
of _ _ O
the _ _ O
ABI _ _ B-Concept
is _ _ O
the _ _ O
calling _ _ B-Concept
convention _ _ I-Concept
, _ _ O
but _ _ O
first _ _ O
, _ _ O
we _ _ O
have _ _ O
to _ _ O
specify _ _ O
… _ _ O
23 _ _ O

Memory _ _ B-Concept
regions _ _ I-Concept
● _ _ O
there _ _ O
are _ _ O
three _ _ O
regions _ _ O
of _ _ O
memory _ _ O
. _ _ O
let _ _ O
g1 _ _ O
= _ _ O
10 _ _ O
; _ _ O
let _ _ O
g2 _ _ O
= _ _ O
" _ _ O
world _ _ O
" _ _ O
; _ _ O
the _ _ O
.data _ _ B-Concept
segment _ _ I-Concept
holds _ _ O
the _ _ O
global _ _ B-Concept
variables _ _ I-Concept
and _ _ O
any _ _ O
string _ _ O
literals _ _ O
. _ _ O
fn _ _ O
main _ _ O
( _ _ O
) _ _ O
{ _ _ O
println_i _ _ B-Concept
( _ _ O
g1 _ _ O
) _ _ O
; _ _ O
the _ _ O
heap _ _ B-Concept
holds _ _ O
dynamically _ _ B-Concept
allocated _ _ I-Concept
strings _ _ O
and _ _ O
structs _ _ O
let _ _ O
msg _ _ O
= _ _ O
" _ _ O
hi _ _ O
, _ _ O
" _ _ O
+ _ _ O
g2 _ _ O
; _ _ O
( _ _ O
like _ _ O
new _ _ O
Cat _ _ O
( _ _ O
) _ _ O
) _ _ O
. _ _ O
println_s _ _ O
( _ _ O
msg _ _ O
) _ _ O
; _ _ O
} _ _ O
the _ _ O
heap _ _ B-Concept
could _ _ O
be _ _ O
managed _ _ O
with _ _ O
the _ _ O
stack _ _ B-Concept
holds _ _ O
the _ _ O
a _ _ O
tracing _ _ B-Concept
garbage _ _ I-Concept
collector _ _ I-Concept
, _ _ O
if _ _ O
this _ _ O
local _ _ B-Concept
variables _ _ I-Concept
. _ _ O
were _ _ O
a _ _ O
real _ _ O
language _ _ O
. _ _ O
but _ _ O
our _ _ O
implementation _ _ O
wo _ _ O
n't _ _ O
. _ _ O
24 _ _ O

How _ _ O
global _ _ B-Concept
variables _ _ I-Concept
are _ _ O
generated _ _ O
● _ _ O
int _ _ O
and _ _ O
bool _ _ O
globals _ _ B-Concept
become _ _ O
.word _ _ O
and _ _ O
.byte _ _ O
variables _ _ O
, _ _ O
respectively _ _ O
. _ _ O
let _ _ O
ivar _ _ O
= _ _ O
10 _ _ O
; _ _ O
let _ _ O
bvar _ _ O
= _ _ O
true _ _ O
; _ _ O
strings _ _ O
are _ _ O
more _ _ O
subtle _ _ O
… _ _ O
let _ _ O
svar _ _ O
= _ _ O
" _ _ O
hi _ _ O
" _ _ O
; _ _ O
.data _ _ O
ivar _ _ O
: _ _ O
.word _ _ O
10 _ _ O
bvar _ _ O
: _ _ O
.byte _ _ O
1 _ _ O
.data _ _ O
STRLIT$0 _ _ O
: _ _ O
.asciiz _ _ O
" _ _ O
hi _ _ O
" _ _ O
svar _ _ O
: _ _ O
.word _ _ O
STRLIT$0 _ _ O
bools _ _ O
are _ _ O
represented _ _ O
with _ _ O
1 _ _ O
for _ _ O
true _ _ O
and _ _ O
0 _ _ O
for _ _ O
false _ _ O
. _ _ O
every _ _ O
string _ _ O
literal _ _ O
in _ _ O
the _ _ O
program _ _ O
gets _ _ O
a _ _ O
uniquely-named _ _ O
STRLIT _ _ O
label _ _ O
; _ _ O
string _ _ O
variables _ _ O
just _ _ O
point _ _ O
to _ _ O
strings _ _ O
. _ _ O
25 _ _ O

Runtime _ _ B-Concept
data _ _ I-Concept
representation _ _ I-Concept
● _ _ O
to _ _ O
be _ _ O
thorough _ _ O
we _ _ O
have _ _ O
to _ _ O
define _ _ O
how _ _ O
every _ _ O
type _ _ O
in _ _ O
the _ _ O
language _ _ O
is _ _ O
represented _ _ O
at _ _ O
runtime _ _ B-Concept
. _ _ O
fortunately _ _ O
, _ _ O
Truss _ _ B-Concept
does _ _ O
n’t _ _ O
have _ _ O
many _ _ O
! _ _ O
o _ _ O
we _ _ O
already _ _ O
saw _ _ O
int _ _ O
and _ _ O
bool _ _ O
on _ _ O
the _ _ O
previous _ _ O
slide _ _ O
. _ _ O
● _ _ O
strings _ _ O
, _ _ O
function _ _ O
pointers _ _ O
, _ _ O
and _ _ O
struct _ _ O
references _ _ O
are _ _ O
all _ _ O
reference _ _ O
types _ _ O
, _ _ O
meaning _ _ O
they _ _ O
are _ _ O
represented _ _ O
as _ _ O
a _ _ O
pointer _ _ O
, _ _ O
which _ _ O
is _ _ O
a _ _ O
word _ _ O
. _ _ O
● _ _ O
the _ _ O
data _ _ O
of _ _ O
a _ _ O
string _ _ O
is _ _ O
defined _ _ O
as _ _ O
zero-terminated _ _ O
ASCII _ _ O
, _ _ O
which _ _ O
is _ _ O
kind _ _ O
of _ _ O
a _ _ O
terrible _ _ O
string _ _ O
representation _ _ O
but _ _ O
is _ _ O
exactly _ _ O
what _ _ O
MARS _ _ O
wants _ _ O
, _ _ O
so _ _ O
. _ _ O
● _ _ O
the _ _ O
data _ _ O
of _ _ O
a _ _ O
struct _ _ O
is _ _ O
… _ _ O
well _ _ O
… _ _ O
we _ _ O
’ll _ _ O
come _ _ O
back _ _ O
to _ _ O
structs _ _ O
. _ _ O
; _ _ O
o _ _ O
26 _ _ O

Function _ _ B-Concept
calls _ _ I-Concept
● _ _ O
the _ _ O
caller _ _ B-Concept
has _ _ O
an _ _ O
easy _ _ O
time _ _ O
calling _ _ B-Concept
functions _ _ I-Concept
, _ _ O
but _ _ O
the _ _ O
protocol _ _ O
is _ _ O
a _ _ O
little _ _ O
different _ _ O
than _ _ O
you _ _ O
may _ _ O
remember _ _ O
from _ _ O
447 _ _ O
. _ _ O
● _ _ O
rather _ _ O
than _ _ O
using _ _ O
those _ _ O
a _ _ O
registers _ _ O
, _ _ O
all _ _ O
arguments _ _ B-Concept
are _ _ O
passed _ _ O
on _ _ O
the _ _ O
stack _ _ B-Concept
, _ _ O
in _ _ O
the _ _ O
same _ _ O
order _ _ O
they _ _ O
are _ _ O
written _ _ O
in _ _ O
the _ _ O
source _ _ O
. _ _ O
f _ _ O
( _ _ O
1 _ _ O
, _ _ O
2 _ _ O
) _ _ O
; _ _ O
each _ _ O
stack _ _ B-Concept
slot _ _ O
is _ _ O
4 _ _ O
bytes _ _ O
, _ _ O
so _ _ O
2 _ _ O
arguments _ _ B-Concept
requires _ _ O
8 _ _ O
bytes _ _ O
. _ _ O
addi _ _ O
sp _ _ B-Concept
, _ _ O
sp _ _ B-Concept
, _ _ O
-8 _ _ O
li _ _ O
t0 _ _ O
, _ _ O
1 _ _ O
sw _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
sp _ _ B-Concept
) _ _ O
li _ _ O
t0 _ _ O
, _ _ O
2 _ _ O
sw _ _ O
t0 _ _ O
, _ _ O
4 _ _ O
( _ _ O
sp _ _ B-Concept
) _ _ O
jal _ _ O
f _ _ O
recall _ _ O
this _ _ O
means _ _ O
0 _ _ O
+ _ _ O
sp _ _ O
. _ _ O
the _ _ O
second _ _ O
argument _ _ B-Concept
is _ _ O
at _ _ O
4 _ _ O
+ _ _ O
sp _ _ B-Concept
; _ _ O
the _ _ O
third _ _ O
at _ _ O
8 _ _ O
+ _ _ O
sp _ _ O
etc _ _ O
. _ _ O
27 _ _ O

After _ _ O
the _ _ O
call _ _ O
completes _ _ O
… _ _ O
● _ _ O
return _ _ B-Concept
values _ _ I-Concept
come _ _ O
out _ _ O
in _ _ O
v0 _ _ O
, _ _ O
like _ _ O
you _ _ O
learned _ _ O
before _ _ O
. _ _ O
● _ _ O
assuming _ _ O
glob _ _ O
is _ _ O
a _ _ O
global _ _ B-Concept
variable _ _ I-Concept
… _ _ O
glob _ _ O
= _ _ O
f _ _ O
( _ _ O
1 _ _ O
) _ _ O
; _ _ O
addi _ _ O
sp _ _ B-Concept
, _ _ O
sp _ _ B-Concept
, _ _ O
-4 _ _ O
li _ _ O
t0 _ _ O
, _ _ O
1 _ _ O
sw _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
sp _ _ B-Concept
) _ _ O
jal _ _ O
f _ _ O
sw _ _ O
v0 _ _ O
, _ _ O
glob _ _ O
notice _ _ O
: _ _ O
the _ _ O
caller _ _ B-Concept
changes _ _ O
sp _ _ O
before _ _ O
calling _ _ B-Concept
, _ _ O
but _ _ O
it _ _ O
does _ _ O
not _ _ O
change _ _ O
it _ _ O
after _ _ O
. _ _ O
we _ _ O
say _ _ O
the _ _ O
callee _ _ B-Concept
" _ _ O
cleans _ _ B-Concept
the _ _ I-Concept
stack _ _ I-Concept
" _ _ O
( _ _ O
as _ _ O
we _ _ O
'll _ _ O
see _ _ O
shortly _ _ O
) _ _ O
important _ _ O
: _ _ O
there _ _ O
is _ _ O
a _ _ O
line _ _ O
here _ _ O
. _ _ O
below _ _ O
this _ _ O
line _ _ O
, _ _ O
the _ _ O
contents _ _ O
of _ _ O
the _ _ O
a _ _ O
, _ _ O
t _ _ O
, _ _ O
and _ _ O
v _ _ O
registers _ _ O
may _ _ O
be _ _ O
different _ _ O
than _ _ O
they _ _ O
were _ _ O
before _ _ O
the _ _ O
jal _ _ O
. _ _ O
however _ _ O
, _ _ O
the _ _ O
contents _ _ O
of _ _ O
the _ _ O
s _ _ O
registers _ _ O
are _ _ O
guaranteed _ _ O
to _ _ O
be _ _ O
the _ _ O
same _ _ O
as _ _ O
before _ _ O
the _ _ O
jal _ _ O
. _ _ O
28 _ _ O

Stack _ _ B-Concept
Frames _ _ I-Concept
● _ _ O
every _ _ O
function _ _ O
in _ _ O
the _ _ O
program _ _ O
needs _ _ O
a _ _ O
stack _ _ B-Concept
frame _ _ I-Concept
: _ _ O
a _ _ O
way _ _ O
of _ _ O
storing _ _ O
all _ _ O
the _ _ O
arguments _ _ B-Concept
, _ _ O
variables _ _ B-Concept
, _ _ O
and _ _ O
saved _ _ B-Concept
registers _ _ I-Concept
on _ _ O
the _ _ O
stack _ _ B-Concept
. _ _ O
● _ _ O
let _ _ O
's _ _ O
look _ _ O
at _ _ O
a _ _ O
super _ _ O
simple _ _ O
function _ _ O
's _ _ O
stack _ _ B-Concept
frame _ _ I-Concept
first _ _ O
. _ _ O
fn _ _ O
simple _ _ O
( _ _ O
x _ _ O
: _ _ O
int _ _ O
) _ _ O
{ _ _ O
println_i _ _ O
( _ _ O
x _ _ O
) _ _ O
; _ _ O
} _ _ O
x _ _ O
ra _ _ O
there _ _ O
's _ _ O
the _ _ O
argument _ _ B-Concept
. _ _ O
it _ _ O
was _ _ O
pushed _ _ O
by _ _ O
the _ _ O
caller _ _ B-Concept
. _ _ O
we _ _ O
're _ _ O
going _ _ O
to _ _ O
push _ _ O
ra _ _ O
, _ _ O
the _ _ O
return _ _ B-Concept
address _ _ I-Concept
register _ _ O
, _ _ O
so _ _ O
we _ _ O
wo _ _ O
n't _ _ O
lose _ _ O
our _ _ O
way _ _ O
back _ _ O
to _ _ O
the _ _ O
caller _ _ O
when _ _ O
we _ _ O
call _ _ O
println_i _ _ O
. _ _ O
what _ _ O
about _ _ O
when _ _ O
we _ _ O
have _ _ O
local _ _ B-Concept
variables _ _ I-Concept
? _ _ O
29 _ _ O

Local _ _ B-Concept
variables _ _ I-Concept
● _ _ O
after _ _ O
pushing _ _ O
ra _ _ O
, _ _ O
we _ _ O
will _ _ O
then _ _ O
make _ _ O
space _ _ O
for _ _ O
the _ _ O
locals _ _ O
. _ _ O
fn _ _ O
more_complex _ _ O
( _ _ O
x _ _ O
: _ _ O
int _ _ O
) _ _ O
{ _ _ O
x _ _ O
let _ _ O
y _ _ O
= _ _ O
x _ _ O
+ _ _ O
10 _ _ O
; _ _ O
ra _ _ O
for _ _ O
i _ _ O
in _ _ O
0 _ _ O
, _ _ O
y _ _ O
{ _ _ O
println_i _ _ O
( _ _ O
i _ _ O
) _ _ O
; _ _ O
i _ _ O
} _ _ O
y _ _ O
} _ _ O
every _ _ O
local _ _ B-Concept
variable _ _ I-Concept
gets _ _ O
its _ _ O
own _ _ O
stack _ _ B-Concept
slot _ _ O
. _ _ O
12 _ _ O
( _ _ O
sp _ _ B-Concept
) _ _ O
4 _ _ O
( _ _ O
sp _ _ B-Concept
) _ _ O
0 _ _ O
( _ _ O
sp _ _ B-Concept
) _ _ O
since _ _ O
the _ _ O
stack _ _ B-Concept
pointer _ _ I-Concept
is _ _ O
pointing _ _ O
at _ _ O
the _ _ O
lowest _ _ O
slot _ _ O
, _ _ O
we _ _ O
can _ _ O
access _ _ O
the _ _ O
locals _ _ B-Concept
and _ _ O
arguments _ _ B-Concept
with _ _ O
offsets _ _ O
from _ _ O
it _ _ O
. _ _ O
but _ _ O
that _ _ O
's _ _ O
going _ _ O
to _ _ O
make _ _ O
things _ _ O
difficult _ _ O
for _ _ O
us _ _ O
when _ _ O
we _ _ O
want _ _ O
to _ _ O
actually _ _ O
call _ _ O
println_i _ _ O
… _ _ O
30 _ _ O

Shifting _ _ O
sands _ _ O
( _ _ O
animated _ _ O
) _ _ O
● _ _ O
let _ _ O
's _ _ O
say _ _ O
we _ _ O
're _ _ O
generating _ _ B-Concept
code _ _ I-Concept
for _ _ O
println_i _ _ O
( _ _ O
i _ _ O
) _ _ O
. _ _ O
fn _ _ O
more_complex _ _ O
( _ _ O
x _ _ O
: _ _ O
int _ _ O
) _ _ O
{ _ _ O
let _ _ O
y _ _ O
= _ _ O
x _ _ O
+ _ _ O
10 _ _ O
; _ _ O
for _ _ O
i _ _ O
in _ _ O
0 _ _ O
, _ _ O
y _ _ O
{ _ _ O
println_i _ _ O
( _ _ O
i _ _ O
) _ _ O
; _ _ O
} _ _ O
} _ _ O
x _ _ O
12 _ _ O
( _ _ O
sp _ _ B-Concept
) _ _ O
16 _ _ O
( _ _ O
sp _ _ B-Concept
) _ _ O
ra _ _ O
i _ _ O
4 _ _ O
( _ _ O
sp _ _ B-Concept
) _ _ O
8 _ _ O
( _ _ O
sp _ _ B-Concept
) _ _ O
y _ _ O
0 _ _ O
( _ _ O
sp _ _ B-Concept
) _ _ O
4 _ _ O
( _ _ O
sp _ _ B-Concept
) _ _ O
_ _ _ O
_ _ _ O
0 _ _ O
( _ _ O
sp _ _ B-Concept
) _ _ O
the _ _ O
first _ _ O
thing _ _ O
we _ _ O
do _ _ O
is _ _ O
make _ _ O
room _ _ O
for _ _ O
the _ _ O
argument _ _ B-Concept
. _ _ O
addi _ _ O
sp _ _ B-Concept
, _ _ O
sp _ _ B-Concept
, _ _ O
-4 _ _ O
but _ _ O
what _ _ O
does _ _ O
that _ _ O
do _ _ O
to _ _ O
the _ _ O
offsets _ _ O
from _ _ O
sp _ _ B-Concept
? _ _ O
? _ _ O
it _ _ O
's _ _ O
absolutely _ _ O
possible _ _ O
to _ _ O
keep _ _ O
track _ _ O
of _ _ O
the _ _ O
" _ _ O
virtual _ _ O
sp _ _ B-Concept
" _ _ O
and _ _ O
adjust _ _ O
the _ _ O
offsets _ _ O
accordingly _ _ O
. _ _ O
but _ _ O
I _ _ O
do _ _ O
n't _ _ O
waaaaanna _ _ O
what _ _ O
if _ _ O
we _ _ O
had _ _ O
a _ _ O
second _ _ O
stack _ _ B-Concept
pointer _ _ I-Concept
, _ _ O
one _ _ O
that _ _ O
did _ _ O
n't _ _ O
move _ _ O
around _ _ O
? _ _ O
31 _ _ O

The _ _ O
Frame _ _ B-Concept
Pointer _ _ I-Concept
register _ _ O
● _ _ O
MIPS _ _ O
has _ _ O
a _ _ O
second _ _ O
register _ _ O
for _ _ O
just _ _ O
this _ _ O
purpose _ _ O
, _ _ O
called _ _ O
fp _ _ B-Concept
. _ _ O
● _ _ O
this _ _ O
will _ _ O
point _ _ O
sort _ _ O
of _ _ O
weirdly _ _ O
into _ _ O
the _ _ O
middle _ _ O
of _ _ O
the _ _ O
stack _ _ B-Concept
frame _ _ I-Concept
, _ _ O
giving _ _ O
us _ _ O
a _ _ O
stationary _ _ O
reference _ _ O
point _ _ O
for _ _ O
accessing _ _ O
locals _ _ B-Concept
. _ _ O
● _ _ O
going _ _ O
back _ _ O
to _ _ O
the _ _ O
super _ _ O
simple _ _ O
function _ _ O
… _ _ O
fn _ _ O
simple _ _ O
( _ _ O
x _ _ O
: _ _ O
int _ _ O
) _ _ O
{ _ _ O
println_i _ _ O
( _ _ O
x _ _ O
) _ _ O
; _ _ O
} _ _ O
x _ _ O
fp _ _ O
fp _ _ O
ra _ _ O
sp _ _ O
we _ _ O
're _ _ O
going _ _ O
to _ _ O
push _ _ O
both _ _ O
fp _ _ B-Concept
and _ _ O
ra _ _ O
! _ _ O
fp _ _ B-Concept
points _ _ O
at _ _ O
the _ _ O
first _ _ O
argument _ _ O
, _ _ O
and _ _ O
sp _ _ B-Concept
still _ _ O
points _ _ O
at _ _ O
the _ _ O
top _ _ O
of _ _ O
the _ _ O
stack _ _ B-Concept
. _ _ O
and _ _ O
what _ _ O
about _ _ O
locals _ _ B-Concept
? _ _ O
32 _ _ O

The _ _ O
local _ _ B-Concept
problem _ _ O
, _ _ O
solved _ _ O
( _ _ O
animated _ _ O
) _ _ O
● _ _ O
you _ _ O
are _ _ O
n't _ _ O
restricted _ _ O
to _ _ O
positive _ _ O
offsets _ _ O
from _ _ O
the _ _ O
stack _ _ B-Concept
/ _ _ I-Concept
frame _ _ I-Concept
pointers _ _ I-Concept
! _ _ O
fn _ _ O
more_complex _ _ O
( _ _ O
x _ _ O
: _ _ O
int _ _ O
) _ _ O
{ _ _ O
let _ _ O
y _ _ O
= _ _ O
x _ _ O
+ _ _ O
10 _ _ O
; _ _ O
for _ _ O
i _ _ O
in _ _ O
0 _ _ O
, _ _ O
y _ _ O
{ _ _ O
println_i _ _ O
( _ _ O
i _ _ O
) _ _ O
; _ _ O
} _ _ O
} _ _ O
sp _ _ B-Concept
x _ _ O
0 _ _ O
( _ _ O
fp _ _ B-Concept
) _ _ O
fp _ _ B-Concept
ra _ _ O
i _ _ O
-12 _ _ O
( _ _ O
fp _ _ B-Concept
) _ _ O
y _ _ O
-16 _ _ O
( _ _ O
fp _ _ B-Concept
) _ _ O
_ _ _ O
_ _ _ O
now _ _ O
, _ _ O
even _ _ O
when _ _ O
sp _ _ B-Concept
moves _ _ O
around _ _ O
during _ _ O
the _ _ O
function _ _ O
, _ _ O
the _ _ O
offsets _ _ O
from _ _ O
fp _ _ B-Concept
never _ _ O
change _ _ O
. _ _ O
33 _ _ O

Function _ _ B-Concept
Prologue _ _ I-Concept
● _ _ O
the _ _ O
function _ _ B-Concept
prologue _ _ I-Concept
is _ _ O
the _ _ O
code _ _ O
that _ _ O
sets _ _ O
up _ _ O
the _ _ O
stack _ _ B-Concept
frame _ _ I-Concept
, _ _ O
essentially _ _ O
switching _ _ O
stack _ _ B-Concept
frames _ _ I-Concept
from _ _ O
the _ _ O
caller _ _ B-Concept
to _ _ O
the _ _ O
callee _ _ B-Concept
. _ _ O
● _ _ O
it _ _ O
looks _ _ O
like _ _ O
this _ _ O
: _ _ O
sw _ _ O
fp _ _ B-Concept
, _ _ O
-4 _ _ O
( _ _ O
sp _ _ B-Concept
) _ _ O
this _ _ O
pushes _ _ O
the _ _ O
caller _ _ B-Concept
's _ _ I-Concept
frame _ _ B-Concept
pointer _ _ I-Concept
, _ _ O
so _ _ O
we _ _ O
can _ _ O
get _ _ O
it _ _ O
back _ _ O
later _ _ O
. _ _ O
sw _ _ O
ra _ _ O
, _ _ O
-8 _ _ O
( _ _ O
sp _ _ B-Concept
) _ _ O
move _ _ O
fp _ _ B-Concept
, _ _ O
sp _ _ B-Concept
addi _ _ O
sp _ _ B-Concept
, _ _ O
sp _ _ B-Concept
, _ _ O
-n _ _ O
this _ _ O
pushes _ _ O
the _ _ O
callee _ _ B-Concept
's _ _ I-Concept
return _ _ B-Concept
address _ _ I-Concept
. _ _ O
this _ _ O
sets _ _ O
up _ _ O
the _ _ O
callee _ _ B-Concept
's _ _ I-Concept
frame _ _ B-Concept
pointer _ _ I-Concept
, _ _ O
so _ _ O
it _ _ O
points _ _ O
to _ _ O
the _ _ O
first _ _ O
argument _ _ B-Concept
( _ _ O
if _ _ O
any _ _ O
) _ _ O
. _ _ O
and _ _ O
finally _ _ O
, _ _ O
this _ _ O
sets _ _ O
up _ _ O
the _ _ O
callee _ _ B-Concept
's _ _ I-Concept
stack _ _ B-Concept
pointer _ _ I-Concept
, _ _ O
so _ _ O
we _ _ O
have _ _ O
room _ _ O
for _ _ O
the _ _ O
locals _ _ B-Concept
. _ _ O
here _ _ O
, _ _ O
n _ _ O
is _ _ O
the _ _ O
number _ _ O
of _ _ O
bytes _ _ O
needed _ _ O
for _ _ O
all _ _ O
the _ _ O
locals _ _ B-Concept
, _ _ O
plus _ _ O
the _ _ O
two _ _ O
saved _ _ B-Concept
registers _ _ I-Concept
from _ _ O
above _ _ O
. _ _ O
34 _ _ O

Function _ _ B-Concept
Epilogue _ _ I-Concept
● _ _ O
finally _ _ O
, _ _ O
the _ _ O
epilogue _ _ B-Concept
does _ _ O
the _ _ O
opposite _ _ O
: _ _ O
it _ _ O
restores _ _ O
the _ _ O
stack _ _ O
and _ _ O
required _ _ O
registers _ _ O
to _ _ O
the _ _ O
way _ _ O
they _ _ O
were _ _ O
when _ _ O
the _ _ O
function _ _ O
began _ _ O
. _ _ O
lw _ _ O
ra _ _ O
, _ _ O
-8 _ _ O
( _ _ O
fp _ _ O
) _ _ O
this _ _ O
restores _ _ O
our _ _ O
return _ _ O
address _ _ O
. _ _ O
lw _ _ O
fp _ _ O
, _ _ O
-4 _ _ O
( _ _ O
fp _ _ O
) _ _ O
this _ _ O
restores _ _ O
the _ _ O
caller _ _ O
's _ _ O
frame _ _ O
pointer _ _ O
. _ _ O
addi _ _ O
sp _ _ O
, _ _ O
sp _ _ O
, _ _ O
x _ _ O
this _ _ O
completely _ _ O
cleans _ _ O
the _ _ O
stack _ _ O
, _ _ O
removing _ _ O
the _ _ O
locals _ _ O
, _ _ O
saved _ _ O
regs _ _ O
, _ _ O
and _ _ O
all _ _ O
arguments _ _ O
. _ _ O
jr _ _ O
and _ _ O
this _ _ O
returns _ _ O
! _ _ O
ra _ _ O
35 _ _ O

What _ _ O
about _ _ O
the _ _ O
juicy _ _ O
middles _ _ O
? _ _ O
● _ _ O
it _ _ O
seems _ _ O
like _ _ O
a _ _ O
lot _ _ O
of _ _ O
buildup _ _ O
to _ _ O
only _ _ O
a _ _ O
handful _ _ O
of _ _ O
instructions _ _ O
, _ _ O
but _ _ O
… _ _ O
o _ _ O
this _ _ O
shit _ _ O
is _ _ O
important _ _ O
okay _ _ O
o _ _ O
we _ _ O
have _ _ O
to _ _ O
do _ _ O
this _ _ O
right _ _ O
or _ _ O
else _ _ O
our _ _ O
program _ _ O
falls _ _ O
apart _ _ O
! _ _ O
! _ _ O
● _ _ O
but _ _ O
by _ _ O
setting _ _ O
up _ _ O
our _ _ O
stack _ _ B-Concept
frame _ _ I-Concept
neatly _ _ O
like _ _ O
this _ _ O
, _ _ O
it _ _ O
will _ _ O
make _ _ O
generating _ _ B-Concept
the _ _ I-Concept
code _ _ I-Concept
inside _ _ O
the _ _ O
functions _ _ O
a _ _ O
lot _ _ O
more _ _ O
straightforward _ _ O
. _ _ O
o _ _ O
and _ _ O
that _ _ O
's _ _ O
what _ _ O
we _ _ O
'll _ _ O
talk _ _ O
about _ _ O
next _ _ O
time _ _ O
! _ _ O
36 _ _ O


