['train_set', 'labeled']|cs1622|lec15_structs_and_classes_oop
-DOCSTART- -X- -X- O

Structs _ _ B-Concept
and _ _ O
Classes _ _ B-Concept
, _ _ O
OOP _ _ B-Concept
CS _ _ O
1622 _ _ O
Jarrett _ _ O
Billingsley _ _ O

Class _ _ O
Announcements _ _ O
‚óè _ _ O
yet _ _ O
another _ _ O
" _ _ O
real _ _ O
example _ _ O
" _ _ O
of _ _ O
adding _ _ O
a _ _ O
language _ _ O
feature _ _ O
o _ _ O
though _ _ O
you _ _ O
already _ _ O
did _ _ O
the _ _ O
lexing _ _ B-Concept
, _ _ O
parsing _ _ B-Concept
, _ _ O
and _ _ O
some _ _ O
of _ _ O
the _ _ O
semantic _ _ B-Concept
analysis _ _ I-Concept
for _ _ O
this _ _ O
stuff _ _ O
in _ _ O
the _ _ O
projects _ _ O
‚Ä¶ _ _ O
o _ _ O
so _ _ O
we _ _ O
‚Äôll _ _ O
kinda _ _ O
skip _ _ O
that _ _ O
stuff _ _ O
! _ _ O
2 _ _ O

Structured _ _ B-Concept
types _ _ I-Concept
3 _ _ O

Type _ _ B-Concept
survey _ _ O
‚óè _ _ O
primitive _ _ O
types _ _ O
can _ _ O
only _ _ O
get _ _ O
you _ _ O
so _ _ O
far _ _ O
. _ _ O
o _ _ O
remember _ _ O
these _ _ O
are _ _ O
things _ _ O
like _ _ O
int _ _ O
, _ _ O
bool _ _ O
, _ _ O
and _ _ O
char _ _ O
. _ _ O
‚óè _ _ O
arrays _ _ B-Concept
give _ _ O
the _ _ O
programmer _ _ O
a _ _ O
lot _ _ O
of _ _ O
problem-solving _ _ O
power _ _ O
. _ _ O
o _ _ O
even _ _ O
in _ _ O
very _ _ O
simplistic _ _ O
languages _ _ O
( _ _ O
like _ _ O
old _ _ O
BASIC _ _ O
dialects _ _ O
) _ _ O
, _ _ O
arrays _ _ B-Concept
give _ _ O
you _ _ O
the _ _ O
power _ _ O
of _ _ O
indirection _ _ B-Concept
and _ _ O
dynamically-sized _ _ B-Concept
data _ _ I-Concept
structures _ _ I-Concept
, _ _ O
which _ _ O
you _ _ O
ca _ _ O
n't _ _ O
do _ _ O
with _ _ O
primitives _ _ O
. _ _ O
‚óè _ _ O
but _ _ O
more _ _ O
complex _ _ O
problems _ _ O
will _ _ O
require _ _ O
the _ _ O
user _ _ O
to _ _ O
define _ _ O
their _ _ O
own _ _ O
types _ _ B-Concept
suited _ _ O
to _ _ O
solving _ _ O
the _ _ O
problem _ _ O
. _ _ O
o _ _ O
and _ _ O
if _ _ O
we _ _ O
want _ _ O
to _ _ O
let _ _ O
the _ _ O
user _ _ O
define _ _ O
their _ _ O
own _ _ O
types _ _ B-Concept
, _ _ O
the _ _ O
most _ _ O
obvious _ _ O
place _ _ O
to _ _ O
start _ _ O
is _ _ O
with _ _ O
‚Ä¶ _ _ O
classes _ _ B-Concept
structs _ _ B-Concept
tuples _ _ O
! _ _ O
4 _ _ O

Tuples _ _ B-Concept
? _ _ O
? _ _ O
‚óè _ _ O
a _ _ O
tuple _ _ B-Concept
is _ _ O
an _ _ O
ordered _ _ O
sequence _ _ O
of _ _ O
heterogeneous _ _ O
types _ _ B-Concept
. _ _ O
o _ _ O
heterogeneous _ _ O
= _ _ O
" _ _ O
they _ _ O
can _ _ O
be _ _ O
different _ _ O
" _ _ O
‚óè _ _ O
typically _ _ O
, _ _ O
tuple _ _ B-Concept
types _ _ B-Concept
are _ _ O
written _ _ O
in _ _ O
parens _ _ O
, _ _ O
like _ _ O
( _ _ O
T1 _ _ O
, _ _ O
‚Ä¶ _ _ O
, _ _ O
Tn _ _ O
) _ _ O
‚óè _ _ O
you _ _ O
could _ _ O
use _ _ O
them _ _ O
to _ _ O
represent _ _ O
‚Ä¶ _ _ O
o _ _ O
coordinates _ _ O
in _ _ O
an _ _ O
n-dimensional _ _ O
space _ _ O
: _ _ O
( _ _ O
10 _ _ O
, _ _ O
4 _ _ O
) _ _ O
‚ñ™ _ _ O
this _ _ O
one _ _ O
's _ _ O
type _ _ B-Concept
is _ _ O
( _ _ O
int _ _ O
, _ _ O
int _ _ O
) _ _ O
o _ _ O
the _ _ O
absence _ _ O
of _ _ O
a _ _ O
value _ _ O
: _ _ O
( _ _ O
) _ _ O
‚ñ™ _ _ O
this _ _ O
is _ _ O
also _ _ O
called _ _ O
unit _ _ O
or _ _ O
, _ _ O
in _ _ O
our _ _ O
language _ _ O
, _ _ O
void _ _ O
o _ _ O
simple _ _ O
objects _ _ O
: _ _ O
( _ _ O
" _ _ O
Billingsley _ _ O
" _ _ O
, _ _ O
" _ _ O
Jarrett _ _ O
" _ _ O
, _ _ O
35 _ _ O
) _ _ O
‚ñ™ _ _ O
this _ _ O
one _ _ O
's _ _ O
type _ _ O
is _ _ O
( _ _ O
string _ _ O
, _ _ O
string _ _ O
, _ _ O
int _ _ O
) _ _ O
o _ _ O
maybe _ _ O
you _ _ O
can _ _ O
see _ _ O
where _ _ O
this _ _ O
is _ _ O
going _ _ O
‚Ä¶ _ _ O
5 _ _ O

Operations _ _ O
on _ _ O
tuples _ _ B-Concept
‚óè _ _ O
like _ _ O
arrays _ _ B-Concept
, _ _ O
we _ _ O
can _ _ O
index _ _ O
them _ _ O
to _ _ O
access _ _ O
their _ _ O
values _ _ O
: _ _ O
o _ _ O
t _ _ O
[ _ _ O
2 _ _ O
] _ _ O
= _ _ O
34 _ _ O
; _ _ O
‚óè _ _ O
unlike _ _ O
arrays _ _ B-Concept
, _ _ O
we _ _ O
know _ _ O
their _ _ O
length _ _ B-Concept
statically _ _ O
‚Ä¶ _ _ O
o _ _ O
but _ _ O
each _ _ O
element _ _ O
can _ _ O
be _ _ O
a _ _ O
different _ _ O
type _ _ O
! _ _ O
o _ _ O
therefore _ _ O
: _ _ O
we _ _ O
can _ _ O
only _ _ O
index _ _ O
them _ _ O
with _ _ O
constant _ _ O
values _ _ O
. _ _ O
‚óè _ _ O
what _ _ O
if _ _ O
we _ _ O
had _ _ O
a _ _ O
way _ _ O
of _ _ O
defining _ _ O
named _ _ O
constants _ _ O
? _ _ O
const _ _ O
LNAME _ _ O
= _ _ O
0 _ _ O
; _ _ O
const _ _ O
FNAME _ _ O
= _ _ O
1 _ _ O
; _ _ O
const _ _ O
AGE _ _ O
= _ _ O
2 _ _ O
; _ _ O
let _ _ O
me _ _ O
= _ _ O
( _ _ O
" _ _ O
Billingsley _ _ O
" _ _ O
, _ _ O
" _ _ O
Jarrett _ _ O
" _ _ O
, _ _ O
35 _ _ O
) _ _ O
; _ _ O
me _ _ O
[ _ _ O
AGE _ _ O
] _ _ O
= _ _ O
36 _ _ O
; _ _ O
/ _ _ O
/ _ _ O
next _ _ O
year _ _ O
.. _ _ O
‚óè _ _ O
ü§î _ _ O
6 _ _ O

‚Ä¶ _ _ O
yeah _ _ O
okay _ _ O
that _ _ O
's _ _ O
basically _ _ O
a _ _ O
struct _ _ B-Concept
is _ _ O
n't _ _ O
it _ _ O
‚óè _ _ O
a _ _ O
struct _ _ B-Concept
or _ _ O
record _ _ B-Concept
type _ _ I-Concept
is _ _ O
like _ _ O
a _ _ O
class _ _ B-Concept
that _ _ O
only _ _ O
has _ _ O
data _ _ O
. _ _ O
‚óè _ _ O
tuples _ _ B-Concept
and _ _ O
structs _ _ B-Concept
are _ _ O
almost _ _ O
the _ _ O
same _ _ O
thing _ _ O
, _ _ O
except _ _ O
‚Ä¶ _ _ O
o _ _ O
tuples _ _ B-Concept
' _ _ O
fields _ _ O
are _ _ O
anonymous _ _ B-Concept
while _ _ O
structs _ _ B-Concept
' _ _ O
fields _ _ O
are _ _ O
named _ _ B-Concept
. _ _ O
‚óè _ _ O
it _ _ O
's _ _ O
probably _ _ O
pretty _ _ O
obvious _ _ O
now _ _ O
how _ _ O
structs _ _ B-Concept
work _ _ O
: _ _ O
struct _ _ O
Point _ _ O
{ _ _ O
x _ _ O
: _ _ O
int _ _ O
, _ _ O
y _ _ O
: _ _ O
int _ _ O
} _ _ O
let _ _ O
p _ _ O
= _ _ O
new _ _ O
Point _ _ O
( _ _ O
3 _ _ O
, _ _ O
8) _ _ O
; _ _ O
p.x _ _ O
= _ _ O
p.x _ _ O
+ _ _ O
1 _ _ O
; _ _ O
‚âà _ _ O
‚âà _ _ O
let _ _ O
p _ _ O
= _ _ O
( _ _ O
3 _ _ O
, _ _ O
8) _ _ O
; _ _ O
p _ _ O
[ _ _ O
0 _ _ O
] _ _ O
= _ _ O
p _ _ O
[ _ _ O
0 _ _ O
] _ _ O
+ _ _ O
1 _ _ O
; _ _ O
‚âà _ _ O
( _ _ O
int _ _ O
, _ _ O
int _ _ O
) _ _ O
7 _ _ O

One _ _ O
important _ _ O
difference _ _ O
‚óè _ _ O
in _ _ O
most _ _ O
languages _ _ O
that _ _ O
have _ _ O
both _ _ O
structs _ _ B-Concept
and _ _ O
tuples _ _ B-Concept
: _ _ O
o _ _ O
tuples _ _ B-Concept
have _ _ O
structural _ _ B-Concept
identity _ _ I-Concept
, _ _ O
but _ _ O
structs _ _ B-Concept
have _ _ O
nominal _ _ B-Concept
identity _ _ I-Concept
‚óè _ _ O
what _ _ O
that _ _ O
means _ _ O
is _ _ O
: _ _ O
( _ _ O
int _ _ O
, _ _ O
int _ _ O
, _ _ O
int _ _ O
) _ _ O
‚âà _ _ O
struct _ _ O
Point3D _ _ O
{ _ _ O
x _ _ O
: _ _ O
int _ _ O
, _ _ O
y _ _ O
: _ _ O
int _ _ O
, _ _ O
z _ _ O
: _ _ O
int _ _ O
} _ _ O
same _ _ O
type _ _ O
! _ _ O
different _ _ O
types _ _ O
! _ _ O
( _ _ O
int _ _ O
, _ _ O
int _ _ O
, _ _ O
int _ _ O
) _ _ O
struct _ _ O
Color _ _ O
{ _ _ O
r _ _ O
: _ _ O
int _ _ O
, _ _ O
g _ _ O
: _ _ O
int _ _ O
, _ _ O
b _ _ O
: _ _ O
int _ _ O
} _ _ O
‚âà _ _ O
8 _ _ O

Value _ _ B-Concept
types _ _ I-Concept
and _ _ O
reference _ _ B-Concept
types _ _ I-Concept
‚óè _ _ O
all _ _ O
variables _ _ O
contain _ _ O
bit _ _ O
patterns _ _ O
. _ _ O
‚óè _ _ O
for _ _ O
value _ _ B-Concept
type _ _ I-Concept
variables _ _ O
, _ _ O
that _ _ O
bit _ _ O
pattern _ _ O
is _ _ O
the _ _ O
value _ _ O
. _ _ O
o _ _ O
examples _ _ O
include _ _ O
int _ _ O
, _ _ O
float _ _ O
, _ _ O
char _ _ O
, _ _ O
and _ _ O
bool _ _ O
. _ _ O
‚óè _ _ O
for _ _ O
reference _ _ B-Concept
type _ _ I-Concept
variables _ _ O
, _ _ O
that _ _ O
bit _ _ O
pattern _ _ O
is _ _ O
a _ _ O
memory _ _ O
address _ _ O
. _ _ O
o _ _ O
examples _ _ O
include _ _ O
Java _ _ O
arrays _ _ B-Concept
and _ _ O
objects _ _ O
. _ _ O
‚óè _ _ O
assigning _ _ O
from _ _ O
one _ _ O
variable _ _ O
to _ _ O
another _ _ O
copies _ _ O
the _ _ O
bit _ _ O
patterns _ _ O
. _ _ O
‚óè _ _ O
for _ _ O
value _ _ O
types _ _ O
, _ _ O
that _ _ O
means _ _ O
you _ _ O
copy _ _ O
the _ _ O
entire _ _ O
value _ _ O
. _ _ O
int _ _ O
x _ _ O
= _ _ O
5 _ _ O
; _ _ O
int _ _ O
y _ _ O
= _ _ O
x _ _ O
; _ _ O
/ _ _ O
/ _ _ O
now _ _ O
we _ _ O
have _ _ O
two _ _ O
5s _ _ O
! _ _ O
‚óè _ _ O
but _ _ O
for _ _ O
reference _ _ O
types _ _ O
, _ _ O
you _ _ O
only _ _ O
copy _ _ O
the _ _ O
address _ _ O
. _ _ O
Object _ _ O
x _ _ O
= _ _ O
new _ _ O
Object _ _ O
( _ _ O
) _ _ O
; _ _ O
Object _ _ O
y _ _ O
= _ _ O
x _ _ O
; _ _ O
/ _ _ O
/ _ _ O
still _ _ O
only _ _ O
one _ _ O
Object _ _ O
... _ _ O
9 _ _ O

Decision _ _ O
time _ _ O
! _ _ O
‚óè _ _ O
Rust _ _ O
, _ _ O
C _ _ O
, _ _ O
C++ _ _ O
, _ _ O
and _ _ O
C _ _ O
# _ _ O
consider _ _ O
structs _ _ O
to _ _ O
be _ _ O
value _ _ B-Concept
types _ _ I-Concept
. _ _ O
In _ _ O
Rust _ _ O
: _ _ O
let _ _ O
s _ _ O
= _ _ O
Point _ _ O
{ _ _ O
x _ _ O
: _ _ O
3 _ _ O
, _ _ O
y _ _ O
: _ _ O
8 _ _ O
} _ _ O
; _ _ O
let _ _ O
t _ _ O
= _ _ O
s _ _ O
; _ _ O
/ _ _ O
/ _ _ O
now _ _ O
we _ _ O
have _ _ O
two _ _ O
Points _ _ O
, _ _ O
both _ _ O
{ _ _ O
3 _ _ O
, _ _ O
8 _ _ O
} _ _ O
! _ _ O
‚óè _ _ O
in _ _ O
these _ _ O
languages _ _ O
, _ _ O
this _ _ O
is _ _ O
nonsense _ _ O
: _ _ O
struct _ _ B-Concept
Node _ _ O
{ _ _ O
next _ _ O
: _ _ O
Node _ _ O
} _ _ O
o _ _ O
how _ _ O
can _ _ O
something _ _ O
contain _ _ O
itself _ _ O
? _ _ O
? _ _ O
‚óè _ _ O
Java _ _ O
does _ _ O
n't _ _ O
let _ _ O
the _ _ O
programmer _ _ O
create _ _ O
their _ _ O
own _ _ O
value _ _ B-Concept
types _ _ I-Concept
. _ _ O
o _ _ O
so _ _ O
, _ _ O
this _ _ O
is _ _ O
fine _ _ O
: _ _ O
class _ _ B-Concept
Node _ _ O
{ _ _ O
Node _ _ O
next _ _ O
; _ _ O
} _ _ O
o _ _ O
because _ _ O
Node _ _ O
next _ _ O
; _ _ O
declares _ _ O
a _ _ O
reference _ _ B-Concept
variable _ _ I-Concept
. _ _ O
‚óè _ _ O
so _ _ O
: _ _ O
should _ _ O
Truss _ _ O
‚Äôs _ _ O
structs _ _ O
be _ _ O
value _ _ B-Concept
types _ _ I-Concept
, _ _ O
or _ _ O
reference _ _ B-Concept
types _ _ I-Concept
? _ _ O
‚óè _ _ O
well _ _ O
, _ _ O
for _ _ O
" _ _ O
simplicity _ _ O
, _ _ O
" _ _ O
let _ _ O
's _ _ O
stick _ _ O
with _ _ O
reference _ _ B-Concept
types _ _ I-Concept
. _ _ O
o _ _ O
reference _ _ B-Concept
types _ _ O
let _ _ O
us _ _ O
solve _ _ O
more _ _ O
problems _ _ O
than _ _ O
value _ _ B-Concept
types _ _ I-Concept
do _ _ O
, _ _ O
just _ _ O
sometimes _ _ O
with _ _ O
more _ _ O
space _ _ O
/ _ _ O
time _ _ O
overhead _ _ O
. _ _ O
‚óè _ _ O
but _ _ O
if _ _ O
we _ _ O
have _ _ O
references _ _ B-Concept
, _ _ O
then _ _ O
we _ _ O
probably _ _ O
need _ _ O
‚Ä¶ _ _ O
null _ _ B-Concept
. _ _ O
10 _ _ O

The _ _ O
billion _ _ O
dollar _ _ O
mistake _ _ O
: _ _ O
null _ _ B-Concept
‚óè _ _ O
null _ _ B-Concept
is _ _ O
a _ _ O
special _ _ O
value _ _ O
you _ _ O
can _ _ O
put _ _ O
into _ _ O
a _ _ O
reference _ _ B-Concept
variable _ _ I-Concept
to _ _ O
indicate _ _ O
that _ _ O
it _ _ O
is _ _ O
uninitialized _ _ O
or _ _ O
‚Äú _ _ O
not _ _ O
pointing _ _ O
to _ _ O
anything _ _ O
. _ _ O
‚Äù _ _ O
‚óè _ _ O
trying _ _ O
to _ _ O
perform _ _ O
any _ _ O
operation _ _ O
besides _ _ O
assignment _ _ O
on _ _ O
null _ _ B-Concept
will _ _ O
lead _ _ O
to _ _ O
a _ _ O
runtime _ _ O
error _ _ O
( _ _ O
a _ _ O
crash _ _ O
) _ _ O
. _ _ O
‚óè _ _ O
unfortunately _ _ O
, _ _ O
most _ _ O
of _ _ O
the _ _ O
time _ _ O
, _ _ O
you _ _ O
do _ _ O
not _ _ O
want _ _ O
references _ _ O
to _ _ O
be _ _ O
null _ _ O
. _ _ O
o _ _ O
so _ _ O
by _ _ O
putting _ _ O
null _ _ O
in _ _ O
a _ _ O
language _ _ O
, _ _ O
and _ _ O
not _ _ O
requiring _ _ O
checks _ _ O
before _ _ O
using _ _ O
a _ _ O
reference _ _ O
, _ _ O
you _ _ O
are _ _ O
adding _ _ O
a _ _ O
huge _ _ O
number _ _ O
of _ _ O
potential _ _ O
crashes _ _ O
into _ _ O
virtually _ _ O
every _ _ O
program _ _ O
. _ _ O
‚óè _ _ O
also _ _ O
it _ _ O
‚Äôs _ _ O
just _ _ O
weird _ _ O
when _ _ O
it _ _ O
comes _ _ O
to _ _ O
typechecking _ _ O
. _ _ O
o _ _ O
it _ _ O
‚Äôs _ _ O
the _ _ O
only _ _ O
value _ _ O
that _ _ O
can _ _ O
be _ _ O
put _ _ O
into _ _ O
multiple _ _ O
different _ _ O
types _ _ O
. _ _ O
o _ _ O
String _ _ O
s _ _ O
= _ _ O
null _ _ O
; _ _ O
Object _ _ O
o _ _ O
= _ _ O
null _ _ O
; _ _ O
int _ _ O
[ _ _ O
] _ _ O
a _ _ O
= _ _ O
null _ _ O
; _ _ O
‚óè _ _ O
so _ _ O
null _ _ O
does _ _ O
not _ _ O
have _ _ O
a _ _ O
type _ _ O
of _ _ O
its _ _ O
own _ _ O
! _ _ O
type _ _ O
theory _ _ O
calls _ _ O
it _ _ O
a _ _ O
bottom _ _ O
type _ _ O
, _ _ O
because _ _ O
it _ _ O
is _ _ O
at _ _ O
the _ _ O
bottom _ _ O
of _ _ O
the _ _ O
type _ _ O
hierarchy _ _ O
and _ _ O
acts _ _ O
as _ _ O
a _ _ O
subtype _ _ O
of _ _ O
all _ _ O
other _ _ O
types _ _ O
. _ _ O
11 _ _ O

Struct _ _ B-Concept
Runtime _ _ I-Concept
Representation _ _ I-Concept
12 _ _ O

Data _ _ B-Concept
layout _ _ I-Concept
‚óè _ _ O
how _ _ O
are _ _ O
structs _ _ B-Concept
( _ _ O
and _ _ O
classes _ _ B-Concept
? _ _ O
) _ _ O
going _ _ O
to _ _ O
be _ _ O
represented _ _ O
in _ _ O
memory _ _ O
? _ _ O
o _ _ O
arrays _ _ B-Concept
work _ _ O
by _ _ O
putting _ _ O
the _ _ O
values _ _ O
next _ _ O
to _ _ O
each _ _ O
other _ _ O
. _ _ O
o _ _ O
okay _ _ O
, _ _ O
let _ _ O
's _ _ O
do _ _ O
that _ _ O
. _ _ O
struct _ _ B-Concept
Point3D _ _ O
{ _ _ O
x _ _ O
: _ _ O
int _ _ O
, _ _ O
y _ _ O
: _ _ O
int _ _ O
, _ _ O
z _ _ O
: _ _ O
int _ _ O
} _ _ O
assuming _ _ O
int _ _ O
is _ _ O
32 _ _ O
bits _ _ O
( _ _ O
4 _ _ O
Bytes _ _ O
) _ _ O
‚Ä¶ _ _ O
0 _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
5 _ _ O
6 _ _ O
7 _ _ O
8 _ _ O
9 _ _ O
10 _ _ O
11 _ _ O
these _ _ O
numbers _ _ O
are _ _ O
the _ _ O
offsets _ _ B-Concept
from _ _ O
the _ _ O
beginning _ _ O
of _ _ O
the _ _ O
struct _ _ B-Concept
. _ _ O
( _ _ O
assuming _ _ O
we _ _ O
're _ _ O
using _ _ O
a _ _ O
byte-addressable _ _ O
machine _ _ O
) _ _ O
they _ _ O
say _ _ O
how _ _ O
far _ _ O
" _ _ O
into _ _ O
the _ _ O
struct _ _ B-Concept
" _ _ O
each _ _ O
field _ _ O
is _ _ O
. _ _ O
13 _ _ O

Not _ _ O
so _ _ O
fast _ _ O
, _ _ O
Mister _ _ O
Gordon _ _ O
! _ _ O
‚óè _ _ O
since _ _ O
bool _ _ O
takes _ _ O
up _ _ O
1 _ _ O
byte _ _ O
, _ _ O
what _ _ O
if _ _ O
we _ _ O
had _ _ O
a _ _ O
struct _ _ O
like _ _ O
this _ _ O
: _ _ O
struct _ _ B-Concept
Hmm _ _ O
{ _ _ O
b _ _ O
: _ _ O
bool _ _ O
, _ _ O
i _ _ O
: _ _ O
int _ _ O
} _ _ O
b _ _ O
i _ _ O
0 _ _ O
1 _ _ O
this _ _ O
is _ _ O
a _ _ O
totally _ _ O
valid _ _ O
way _ _ O
of _ _ O
doing _ _ O
it _ _ O
. _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
unfortunately _ _ O
, _ _ O
lots _ _ O
of _ _ O
CPU _ _ O
architectures _ _ O
hate _ _ O
this _ _ O
. _ _ O
CPUs _ _ O
like _ _ O
values _ _ O
to _ _ O
be _ _ O
aligned _ _ B-Concept
. _ _ O
that _ _ O
means _ _ O
: _ _ O
the _ _ O
memory _ _ O
address _ _ O
in _ _ O
an _ _ O
n-byte _ _ O
load _ _ O
/ _ _ O
store _ _ O
must _ _ O
be _ _ O
a _ _ O
multiple _ _ O
of _ _ O
n. _ _ O
x86 _ _ O
CPUs _ _ O
will _ _ O
access _ _ O
unaligned _ _ B-Concept
values _ _ O
very _ _ O
slowly _ _ O
. _ _ O
MIPS _ _ O
CPUs _ _ O
will _ _ O
crash _ _ O
. _ _ O
( _ _ O
unless _ _ O
you _ _ O
use _ _ O
the _ _ O
much _ _ O
slower _ _ O
unaligned _ _ O
loads _ _ O
/ _ _ O
stores _ _ O
) _ _ O
so _ _ O
, _ _ O
we _ _ O
need _ _ O
to _ _ O
insert _ _ O
padding _ _ B-Concept
( _ _ O
extra _ _ O
unused _ _ O
bytes _ _ O
) _ _ O
into _ _ O
our _ _ O
structs _ _ B-Concept
to _ _ O
ensure _ _ O
each _ _ O
field _ _ O
is _ _ O
properly _ _ O
aligned _ _ B-Concept
. _ _ O
14 _ _ O

Struct _ _ B-Concept
padding _ _ I-Concept
‚óè _ _ O
we _ _ O
place _ _ O
each _ _ O
field _ _ O
at _ _ O
an _ _ O
offset _ _ B-Concept
that _ _ O
is _ _ O
a _ _ O
multiple _ _ O
of _ _ O
its _ _ O
alignment _ _ B-Concept
. _ _ O
‚óè _ _ O
then _ _ O
, _ _ O
the _ _ O
struct _ _ O
's _ _ O
size _ _ O
as _ _ O
a _ _ O
whole _ _ O
is _ _ O
rounded _ _ O
up _ _ O
to _ _ O
the _ _ O
largest _ _ O
alignment _ _ B-Concept
of _ _ O
any _ _ O
field _ _ O
. _ _ O
( _ _ O
this _ _ O
is _ _ O
important _ _ O
for _ _ O
arrays _ _ B-Concept
of _ _ O
structs _ _ B-Concept
. _ _ O
) _ _ O
‚óè _ _ O
so _ _ O
for _ _ O
this _ _ O
: _ _ O
struct _ _ B-Concept
Hmm _ _ O
{ _ _ O
b _ _ O
: _ _ O
bool _ _ O
, _ _ O
i _ _ O
: _ _ O
int _ _ O
} _ _ O
b _ _ O
0 _ _ O
i _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
5 _ _ O
6 _ _ O
7 _ _ O
and _ _ O
if _ _ O
we _ _ O
swapped _ _ O
b _ _ O
and _ _ O
i _ _ O
: _ _ O
i _ _ O
0 _ _ O
b _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
5 _ _ O
6 _ _ O
7 _ _ O
either _ _ O
way _ _ O
, _ _ O
the _ _ O
struct _ _ O
is _ _ O
8 _ _ O
bytes _ _ O
, _ _ O
and _ _ O
it _ _ O
must _ _ O
be _ _ O
4-byte _ _ O
aligned _ _ O
because _ _ O
of _ _ O
the _ _ O
int _ _ O
. _ _ O
15 _ _ O

Wait _ _ O
, _ _ O
why _ _ O
does _ _ O
the _ _ O
whole _ _ O
struct _ _ B-Concept
need _ _ O
to _ _ O
be _ _ O
padded _ _ B-Concept
? _ _ O
‚óè _ _ O
strictly _ _ O
speaking _ _ O
, _ _ O
for _ _ O
our _ _ O
language _ _ O
where _ _ O
structs _ _ B-Concept
are _ _ O
reference _ _ B-Concept
types _ _ I-Concept
, _ _ O
the _ _ O
structs _ _ B-Concept
do _ _ O
n't _ _ O
need _ _ O
padding _ _ B-Concept
at _ _ O
the _ _ O
end _ _ O
. _ _ O
‚óè _ _ O
but _ _ O
in _ _ O
languages _ _ O
where _ _ O
they _ _ O
're _ _ O
value _ _ B-Concept
types _ _ I-Concept
, _ _ O
it _ _ O
's _ _ O
crucial _ _ O
for _ _ O
maintaining _ _ O
alignment _ _ B-Concept
in _ _ O
arrays _ _ B-Concept
of _ _ O
structs _ _ B-Concept
. _ _ O
consider _ _ O
these _ _ O
arrays _ _ B-Concept
of _ _ O
two _ _ O
structs _ _ B-Concept
: _ _ O
i _ _ O
0 _ _ O
b _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
i _ _ O
0 _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
i _ _ O
4 _ _ O
5 _ _ O
b _ _ O
i _ _ O
4 _ _ O
5 _ _ O
6 _ _ O
7 _ _ O
8 _ _ O
b _ _ O
9 _ _ O
10 _ _ O
11 _ _ O
12 _ _ O
13 _ _ O
14 _ _ O
15 _ _ O
b _ _ O
6 _ _ O
7 _ _ O
8 _ _ O
9 _ _ O
without _ _ O
the _ _ O
end-padding _ _ B-Concept
, _ _ I-Concept
this _ _ O
int _ _ O
field _ _ O
of _ _ O
the _ _ O
second _ _ O
item _ _ O
is _ _ O
now _ _ O
misaligned _ _ B-Concept
. _ _ O
the _ _ O
memory _ _ B-Concept
allocator _ _ I-Concept
will _ _ O
have _ _ O
to _ _ O
allocate _ _ O
things _ _ O
at _ _ O
aligned _ _ B-Concept
memory _ _ O
addresses _ _ O
as _ _ O
well _ _ O
, _ _ O
for _ _ O
this _ _ O
to _ _ O
work _ _ O
. _ _ O
16 _ _ O

Anyway _ _ O
‚Ä¶ _ _ O
allocation _ _ B-Concept
‚óè _ _ O
now _ _ O
we _ _ O
know _ _ O
the _ _ O
size _ _ B-Concept
and _ _ O
alignment _ _ B-Concept
of _ _ O
each _ _ O
struct _ _ B-Concept
. _ _ O
‚óè _ _ O
we _ _ O
'll _ _ O
need _ _ O
a _ _ O
runtime _ _ B-Concept
library _ _ I-Concept
function _ _ O
to _ _ O
dynamically _ _ B-Concept
allocate _ _ I-Concept
structs _ _ B-Concept
. _ _ O
o _ _ O
let _ _ O
's _ _ O
call _ _ O
it _ _ O
rt$new _ _ O
( _ _ O
size _ _ O
: _ _ O
int _ _ O
) _ _ O
. _ _ O
it _ _ O
'll _ _ O
return _ _ O
an _ _ O
address _ _ O
. _ _ O
o _ _ O
to _ _ O
keep _ _ O
it _ _ O
simple _ _ O
, _ _ O
it _ _ O
'll _ _ O
always _ _ O
align _ _ B-Concept
things _ _ O
to _ _ O
4 _ _ O
bytes _ _ O
. _ _ O
struct _ _ B-Concept
Thing _ _ O
{ _ _ O
/ _ _ O
/ _ _ O
size _ _ O
: _ _ O
12 _ _ O
name _ _ O
: _ _ O
string _ _ O
, _ _ O
in_use _ _ O
: _ _ O
bool _ _ O
, _ _ O
flag _ _ O
: _ _ O
bool _ _ O
, _ _ O
count _ _ O
: _ _ O
int _ _ O
, _ _ O
} _ _ O
let _ _ O
t _ _ O
= _ _ O
new _ _ O
Thing _ _ O
( _ _ O
) _ _ O
; _ _ O
allocations _ _ B-Concept
get _ _ O
generated _ _ O
as _ _ O
calls _ _ O
to _ _ O
this _ _ O
function _ _ O
. _ _ O
addi _ _ O
sp _ _ O
, _ _ O
sp _ _ O
, _ _ O
-4 _ _ O
li _ _ O
s0 _ _ O
, _ _ O
12 _ _ O
sw _ _ O
s0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
sp _ _ O
) _ _ O
# _ _ O
size _ _ O
jal _ _ O
rt$new _ _ O
sw _ _ O
v0 _ _ O
, _ _ O
-24 _ _ O
( _ _ O
fp _ _ O
) _ _ O
# _ _ O
t _ _ O
17 _ _ O

Accessing _ _ B-Concept
fields _ _ I-Concept
‚óè _ _ O
we _ _ O
use _ _ O
the _ _ O
fields _ _ B-Concept
' _ _ O
offsets _ _ B-Concept
and _ _ O
types _ _ O
to _ _ O
generate _ _ B-Concept
code _ _ I-Concept
for _ _ O
field _ _ B-Concept
access _ _ I-Concept
. _ _ O
struct _ _ B-Concept
Thing _ _ O
{ _ _ O
name _ _ O
: _ _ O
string _ _ O
, _ _ O
/ _ _ O
/ _ _ O
offs _ _ O
: _ _ O
0 _ _ O
in_use _ _ O
: _ _ O
bool _ _ O
, _ _ O
/ _ _ O
/ _ _ O
offs _ _ O
: _ _ O
4 _ _ O
flag _ _ O
: _ _ O
bool _ _ O
, _ _ O
/ _ _ O
/ _ _ O
offs _ _ O
: _ _ O
5 _ _ O
count _ _ O
: _ _ O
int _ _ O
, _ _ O
/ _ _ O
/ _ _ O
offs _ _ O
: _ _ O
8 _ _ O
} _ _ O
to _ _ O
access _ _ B-Concept
a _ _ I-Concept
field _ _ I-Concept
, _ _ O
we _ _ O
add _ _ O
its _ _ O
offset _ _ B-Concept
to _ _ O
the _ _ O
struct _ _ B-Concept
instance _ _ O
's _ _ O
address _ _ O
, _ _ O
then _ _ O
use _ _ O
the _ _ O
right _ _ O
" _ _ O
flavor _ _ O
" _ _ O
of _ _ O
load _ _ O
/ _ _ O
store _ _ O
. _ _ O
let _ _ O
t _ _ O
= _ _ O
new _ _ O
Thing _ _ O
( _ _ O
) _ _ O
; _ _ O
t.in_use _ _ O
= _ _ O
true _ _ O
; _ _ O
t.count _ _ O
= _ _ O
20 _ _ O
; _ _ O
lw _ _ O
s0 _ _ O
, _ _ O
-24 _ _ O
( _ _ O
fp _ _ O
) _ _ O
# _ _ O
t _ _ O
li _ _ O
s1 _ _ O
, _ _ O
1 _ _ O
# _ _ O
true _ _ O
sb _ _ O
s1 _ _ O
, _ _ O
4 _ _ O
( _ _ O
s0 _ _ O
) _ _ O
# _ _ O
t.in_use _ _ O
= _ _ O
true _ _ O
lw _ _ O
s0 _ _ O
, _ _ O
-24 _ _ O
( _ _ O
fp _ _ O
) _ _ O
# _ _ O
t _ _ O
li _ _ O
s1 _ _ O
, _ _ O
20 _ _ O
sw _ _ O
s1 _ _ O
, _ _ O
8 _ _ O
( _ _ O
s0 _ _ O
) _ _ O
# _ _ O
t.count _ _ O
= _ _ O
20 _ _ O
18 _ _ O

OOP _ _ B-Concept
19 _ _ O

What _ _ O
is _ _ O
OOP _ _ B-Concept
( _ _ O
object-oriented _ _ B-Concept
programming _ _ I-Concept
) _ _ O
? _ _ O
‚óè _ _ O
we _ _ O
might _ _ O
gesture _ _ O
vaguely _ _ O
in _ _ O
Java _ _ O
's _ _ O
direction _ _ O
and _ _ O
say _ _ O
" _ _ O
it _ _ O
's _ _ O
like _ _ O
that _ _ O
" _ _ O
o _ _ O
but _ _ O
" _ _ O
Java-flavored _ _ O
OOP _ _ B-Concept
" _ _ O
is _ _ O
n't _ _ O
the _ _ O
only _ _ O
kind _ _ O
‚Ä¶ _ _ O
‚óè _ _ O
C _ _ O
has _ _ O
structs _ _ B-Concept
, _ _ I-Concept
but _ _ O
it _ _ O
is _ _ O
n't _ _ O
" _ _ O
OOP _ _ B-Concept
. _ _ O
" _ _ O
C++ _ _ O
has _ _ O
" _ _ O
classes _ _ O
" _ _ O
, _ _ O
and _ _ O
it _ _ O
is _ _ O
" _ _ O
OOP _ _ B-Concept
. _ _ O
" _ _ O
‚óè _ _ O
the _ _ O
core _ _ O
idea _ _ O
of _ _ O
OOP _ _ B-Concept
is _ _ O
packaging _ _ O
data _ _ B-Concept
alongside _ _ O
operations _ _ B-Concept
on _ _ I-Concept
that _ _ I-Concept
data _ _ I-Concept
into _ _ O
a _ _ O
single _ _ O
, _ _ O
indivisible _ _ O
entity _ _ O
. _ _ O
o _ _ O
so _ _ O
: _ _ O
the _ _ O
main _ _ O
thing _ _ O
that _ _ O
distinguishes _ _ O
C++ _ _ O
from _ _ O
C _ _ O
‚Ä¶ _ _ O
is _ _ O
methods _ _ B-Concept
. _ _ O
‚óè _ _ O
a _ _ O
method _ _ B-Concept
call _ _ I-Concept
is _ _ O
a _ _ O
special _ _ O
kind _ _ O
of _ _ O
function _ _ O
call _ _ O
: _ _ O
obj.method _ _ B-Concept
( _ _ O
) _ _ O
; _ _ O
o _ _ O
method _ _ B-Concept
calls _ _ I-Concept
can _ _ O
be _ _ O
more _ _ O
complex _ _ O
than _ _ O
" _ _ O
regular _ _ O
" _ _ O
function _ _ O
calls _ _ O
. _ _ O
‚óè _ _ O
other _ _ O
OOP _ _ B-Concept
concepts _ _ O
, _ _ O
which _ _ O
are _ _ O
not _ _ O
required _ _ O
but _ _ O
are _ _ O
common _ _ O
, _ _ O
include _ _ O
inheritance _ _ B-Concept
, _ _ O
subtyping _ _ B-Concept
, _ _ O
interfaces _ _ B-Concept
, _ _ O
privacy _ _ B-Concept
, _ _ O
constructors _ _ B-Concept
, _ _ O
and _ _ O
runtime _ _ B-Concept
type _ _ I-Concept
identification _ _ I-Concept
. _ _ O
20 _ _ O

Methods _ _ B-Concept
‚óè _ _ O
methods _ _ B-Concept
are _ _ O
special _ _ O
functions _ _ O
which _ _ O
are _ _ O
associated _ _ O
with _ _ O
an _ _ O
object _ _ B-Concept
. _ _ O
‚óè _ _ O
they _ _ O
take _ _ O
the _ _ O
object _ _ B-Concept
they _ _ O
are _ _ O
called _ _ O
on _ _ O
as _ _ O
an _ _ O
argument _ _ O
. _ _ O
struct _ _ B-Concept
Point _ _ O
{ _ _ O
this _ _ O
is _ _ O
passed _ _ O
implicitly _ _ O
, _ _ O
x _ _ O
: _ _ O
int _ _ O
, _ _ O
but _ _ O
it _ _ O
's _ _ O
still _ _ O
an _ _ O
argument _ _ O
. _ _ O
y _ _ O
: _ _ O
int _ _ O
fn _ _ O
to_string _ _ O
( _ _ O
) _ _ O
: _ _ O
string _ _ O
{ _ _ O
return _ _ O
to_string _ _ O
( _ _ O
this.x _ _ O
) _ _ O
+ _ _ O
" _ _ O
, _ _ O
" _ _ O
+ _ _ O
to_string _ _ O
( _ _ O
this.y _ _ O
) _ _ O
; _ _ O
} _ _ O
} _ _ O
let _ _ O
p _ _ O
= _ _ O
new _ _ O
Point _ _ O
( _ _ O
3 _ _ O
, _ _ O
8) _ _ O
; _ _ O
println_s _ _ O
( _ _ O
p.to_string _ _ O
( _ _ O
) _ _ O
) _ _ O
; _ _ O
here _ _ O
, _ _ O
the _ _ O
method _ _ B-Concept
call _ _ I-Concept
is _ _ O
syntactic _ _ B-Concept
sugar _ _ I-Concept
for _ _ O
something _ _ O
like _ _ O
: _ _ O
Point.to_string _ _ O
( _ _ O
p _ _ O
) _ _ O
this _ _ O
is _ _ O
static _ _ B-Concept
dispatch _ _ I-Concept
, _ _ O
because _ _ O
we _ _ O
can _ _ O
determine _ _ O
which _ _ O
method _ _ B-Concept
to _ _ O
call _ _ O
at _ _ O
compile-time _ _ B-Concept
. _ _ O
21 _ _ O

Constructors _ _ B-Concept
‚óè _ _ O
a _ _ O
constructor _ _ B-Concept
is _ _ O
just _ _ O
a _ _ O
method _ _ B-Concept
that _ _ O
is _ _ O
called _ _ O
on _ _ O
an _ _ O
instance _ _ B-Concept
of _ _ O
an _ _ O
object _ _ B-Concept
immediately _ _ O
after _ _ O
allocating _ _ B-Concept
it _ _ O
, _ _ O
to _ _ O
let _ _ O
you _ _ O
initialize _ _ O
its _ _ O
fields _ _ B-Concept
. _ _ O
class _ _ O
C _ _ O
{ _ _ O
String _ _ O
s _ _ O
; _ _ O
C _ _ O
( _ _ O
) _ _ O
{ _ _ O
/ _ _ O
/ _ _ O
s _ _ O
= _ _ O
= _ _ O
null _ _ O
s _ _ O
= _ _ O
" _ _ O
hi _ _ O
" _ _ O
; _ _ O
} _ _ O
} _ _ O
C _ _ O
c _ _ O
= _ _ O
new _ _ O
C _ _ O
( _ _ O
) _ _ O
; _ _ O
in _ _ O
this _ _ O
Java _ _ O
code _ _ O
, _ _ O
new _ _ O
C _ _ O
( _ _ O
) _ _ O
does _ _ O
the _ _ O
following _ _ O
: _ _ O
1 _ _ O
. _ _ O
allocates _ _ B-Concept
an _ _ O
instance _ _ B-Concept
of _ _ O
C _ _ O
2 _ _ O
. _ _ O
initializes _ _ O
all _ _ O
its _ _ O
fields _ _ B-Concept
to _ _ O
default _ _ O
values _ _ O
* _ _ O
3 _ _ O
. _ _ O
calls _ _ O
the _ _ O
constructor _ _ B-Concept
on _ _ O
that _ _ O
instance _ _ B-Concept
but _ _ O
Java _ _ O
does _ _ O
n‚Äôt _ _ O
really _ _ O
enforce _ _ O
that _ _ O
you _ _ O
do _ _ O
anything _ _ O
useful _ _ O
in _ _ O
the _ _ O
constructor _ _ B-Concept
, _ _ O
and _ _ O
before _ _ O
it _ _ O
completes _ _ O
, _ _ O
the _ _ O
object _ _ B-Concept
may _ _ O
be _ _ O
in _ _ O
an _ _ O
inconsistent _ _ O
state _ _ O
( _ _ O
i.e. _ _ O
calling _ _ O
methods _ _ B-Concept
on _ _ O
this _ _ O
may _ _ O
behave _ _ O
erratically _ _ O
or _ _ O
crash _ _ O
) _ _ O
. _ _ O
22 _ _ O

Data _ _ B-Concept
inheritance _ _ I-Concept
‚óè _ _ O
first _ _ O
, _ _ O
let _ _ O
's _ _ O
look _ _ O
at _ _ O
a _ _ O
simpler _ _ O
kind _ _ O
of _ _ O
inheritance _ _ B-Concept
, _ _ O
which _ _ O
just _ _ O
inherits _ _ B-Concept
data _ _ O
fields _ _ B-Concept
without _ _ O
inheriting _ _ B-Concept
methods _ _ B-Concept
, _ _ O
and _ _ O
does _ _ O
not _ _ O
imply _ _ O
subtyping _ _ B-Concept
. _ _ O
struct _ _ B-Concept
RGB _ _ O
{ _ _ O
r _ _ O
: _ _ O
int _ _ O
, _ _ O
g _ _ O
: _ _ O
int _ _ O
, _ _ O
b _ _ O
: _ _ O
int _ _ O
} _ _ O
the _ _ O
base _ _ O
class _ _ O
's _ _ O
fields _ _ O
are _ _ O
struct _ _ B-Concept
RGBA _ _ O
: _ _ O
RGB _ _ O
{ _ _ O
a _ _ O
: _ _ O
int _ _ O
} _ _ O
copied _ _ B-Concept
into _ _ O
the _ _ O
derived _ _ O
let _ _ O
color _ _ O
= _ _ O
new _ _ O
RGBA _ _ O
( _ _ O
255 _ _ O
, _ _ O
127 _ _ O
, _ _ O
0 _ _ O
, _ _ O
95 _ _ O
) _ _ O
; _ _ O
class _ _ O
's _ _ O
definition _ _ O
. _ _ O
we _ _ O
represent _ _ O
this _ _ O
in _ _ O
memory _ _ O
by _ _ O
prefixing _ _ B-Concept
: _ _ O
the _ _ O
beginning _ _ O
of _ _ O
an _ _ O
RGBA _ _ O
is _ _ O
an _ _ O
RGB _ _ O
. _ _ O
RGB _ _ O
RGBA _ _ O
r _ _ O
g _ _ O
b _ _ O
0 _ _ O
4 _ _ O
8 _ _ O
r _ _ O
g _ _ O
b _ _ O
a _ _ O
0 _ _ O
4 _ _ O
8 _ _ O
12 _ _ O
reusing _ _ O
only _ _ O
the _ _ O
data _ _ O
is _ _ O
limited _ _ O
in _ _ O
usefulness _ _ O
. _ _ O
reusing _ _ O
methods _ _ B-Concept
is _ _ O
much _ _ O
more _ _ O
useful _ _ O
. _ _ O
23 _ _ O

Method _ _ B-Concept
inheritance _ _ I-Concept
‚óè _ _ O
method _ _ B-Concept
inheritance _ _ I-Concept
takes _ _ O
advantage _ _ O
of _ _ O
the _ _ O
prefixed _ _ B-Concept
representation _ _ O
. _ _ O
o _ _ O
base _ _ B-Concept
class _ _ I-Concept
methods _ _ B-Concept
can _ _ O
be _ _ O
called _ _ O
on _ _ O
derived _ _ B-Concept
class _ _ I-Concept
instances _ _ B-Concept
, _ _ O
because _ _ O
the _ _ O
base _ _ B-Concept
class _ _ I-Concept
fields _ _ B-Concept
are _ _ O
at _ _ O
the _ _ O
same _ _ O
offsets _ _ B-Concept
. _ _ O
struct _ _ B-Concept
Animal _ _ O
{ _ _ O
species _ _ O
: _ _ O
string _ _ O
fn _ _ O
to_string _ _ O
( _ _ O
) _ _ O
: _ _ O
string _ _ O
{ _ _ O
return _ _ O
" _ _ O
Animal _ _ O
( _ _ O
" _ _ O
+ _ _ O
this.species _ _ O
+ _ _ O
" _ _ O
) _ _ O
" _ _ O
; _ _ O
} _ _ O
} _ _ O
struct _ _ B-Concept
Cat _ _ O
: _ _ O
Animal _ _ O
{ _ _ O
whiskers _ _ O
: _ _ O
int _ _ O
} _ _ O
let _ _ O
c _ _ O
= _ _ O
new _ _ O
Cat _ _ O
( _ _ O
"felis _ _ O
cattus _ _ O
" _ _ O
, _ _ O
15 _ _ O
) _ _ O
; _ _ O
println_s _ _ O
( _ _ O
c.to_string _ _ O
( _ _ O
) _ _ O
) _ _ O
; _ _ O
this _ _ O
is _ _ O
still _ _ O
static _ _ B-Concept
dispatch _ _ I-Concept
: _ _ O
the _ _ O
method _ _ B-Concept
call _ _ O
is _ _ O
sugar _ _ O
for _ _ O
Animal.to_string _ _ O
( _ _ O
c _ _ O
) _ _ O
. _ _ O
we _ _ O
can _ _ O
now _ _ O
say _ _ O
that _ _ O
Cat _ _ O
is _ _ O
a _ _ O
subtype _ _ B-Concept
of _ _ O
Animal _ _ O
. _ _ O
24 _ _ O

Where _ _ O
it _ _ O
starts _ _ O
getting _ _ O
crazy _ _ O
‚óè _ _ O
what _ _ O
if _ _ O
we _ _ O
want _ _ O
to _ _ O
specialize _ _ O
to_string _ _ O
( _ _ O
) _ _ O
in _ _ O
the _ _ O
Cat _ _ O
struct _ _ B-Concept
? _ _ O
struct _ _ B-Concept
Animal _ _ O
{ _ _ O
species _ _ O
: _ _ O
string _ _ O
fn _ _ O
to_string _ _ O
( _ _ O
) _ _ O
: _ _ O
string _ _ O
{ _ _ O
return _ _ O
" _ _ O
Animal _ _ O
( _ _ O
" _ _ O
+ _ _ O
this.species _ _ O
+ _ _ O
" _ _ O
) _ _ O
" _ _ O
; _ _ O
} _ _ O
the _ _ O
compiler _ _ B-Concept
might _ _ O
be _ _ O
able _ _ O
to _ _ O
} _ _ O
statically _ _ O
determine _ _ O
in _ _ O
this _ _ O
case _ _ O
that _ _ O
struct _ _ B-Concept
Cat _ _ O
: _ _ O
Animal _ _ O
{ _ _ O
it _ _ O
should _ _ O
call _ _ O
Cat.toString _ _ O
( _ _ O
c _ _ O
) _ _ O
. _ _ O
whiskers _ _ O
: _ _ O
int _ _ O
fn _ _ O
to_string _ _ O
( _ _ O
) _ _ O
: _ _ O
string _ _ O
{ _ _ O
return _ _ O
" _ _ O
meow _ _ O
meow _ _ O
meow _ _ O
! _ _ O
" _ _ O
; _ _ O
but _ _ O
it _ _ O
ca _ _ O
n't _ _ O
determine _ _ O
that _ _ O
in _ _ O
} _ _ O
the _ _ O
general _ _ O
case _ _ O
. _ _ O
} _ _ O
let _ _ O
c _ _ O
= _ _ O
new _ _ O
Cat _ _ O
( _ _ O
"felis _ _ O
cattus _ _ O
" _ _ O
, _ _ O
15 _ _ O
) _ _ O
; _ _ O
println_s _ _ O
( _ _ O
c.to_string _ _ O
( _ _ O
) _ _ O
) _ _ O
; _ _ O
25 _ _ O

The _ _ O
problem _ _ O
‚óè _ _ O
since _ _ O
a _ _ O
subtype _ _ B-Concept
can _ _ O
be _ _ O
used _ _ O
anywhere _ _ O
a _ _ O
base _ _ B-Concept
type _ _ I-Concept
is _ _ O
expected _ _ O
‚Ä¶ _ _ O
o _ _ O
a _ _ O
base _ _ B-Concept
type _ _ I-Concept
variable _ _ O
can _ _ O
contain _ _ O
different _ _ O
types _ _ B-Concept
of _ _ O
values _ _ O
. _ _ O
‚óè _ _ O
and _ _ O
since _ _ O
subtypes _ _ O
can _ _ O
have _ _ O
different _ _ O
implementations _ _ O
of _ _ O
the _ _ O
same _ _ O
methods _ _ O
as _ _ O
the _ _ O
supertype _ _ O
‚Ä¶ _ _ O
o _ _ O
you _ _ O
ca _ _ O
n't _ _ O
know _ _ O
what _ _ O
subtype _ _ O
implementation _ _ O
to _ _ O
call _ _ O
until _ _ O
runtime _ _ O
! _ _ O
fn _ _ O
print _ _ O
( _ _ O
a _ _ O
: _ _ O
Animal _ _ O
) _ _ O
{ _ _ O
/ _ _ O
/ _ _ O
how _ _ O
does _ _ O
this _ _ O
call _ _ O
to _ _ O
/ _ _ O
/ _ _ O
to_string _ _ O
know _ _ O
which _ _ O
/ _ _ O
/ _ _ O
implementation _ _ O
to _ _ O
use _ _ O
? _ _ O
println_s _ _ O
( _ _ O
a.to_string _ _ O
( _ _ O
) _ _ O
) _ _ O
; _ _ O
} _ _ O
print _ _ O
( _ _ O
new _ _ O
Cat _ _ O
( _ _ O
) _ _ O
) _ _ O
; _ _ O
print _ _ O
( _ _ O
new _ _ O
Dog _ _ O
( _ _ O
) _ _ O
) _ _ O
; _ _ O
print _ _ O
( _ _ O
new _ _ O
Horse _ _ O
( _ _ O
) _ _ O
) _ _ O
; _ _ O
the _ _ O
problem _ _ O
( _ _ O
as _ _ O
it _ _ O
often _ _ O
is _ _ O
) _ _ O
is _ _ O
that _ _ O
we _ _ O
lose _ _ O
type _ _ O
information _ _ O
in _ _ O
the _ _ O
translation _ _ O
from _ _ O
the _ _ O
source _ _ O
language _ _ O
to _ _ O
the _ _ O
target _ _ O
language _ _ O
. _ _ O
so _ _ O
, _ _ O
let _ _ O
's _ _ O
‚Ä¶ _ _ O
not _ _ O
do _ _ O
that _ _ O
. _ _ O
let _ _ O
's _ _ O
keep _ _ O
some _ _ O
of _ _ O
that _ _ O
type _ _ O
info _ _ O
. _ _ O
26 _ _ O

Virtual _ _ B-Concept
Methods _ _ I-Concept
and _ _ O
Dynamic _ _ B-Concept
Dispatch _ _ I-Concept
27 _ _ O

RTTI _ _ B-Concept
( _ _ O
Run-time _ _ B-Concept
Type _ _ I-Concept
Identification _ _ I-Concept
) _ _ O
‚óè _ _ O
the _ _ O
solution _ _ O
is _ _ O
to _ _ O
make _ _ O
each _ _ O
class _ _ B-Concept
instance _ _ I-Concept
carry _ _ O
an _ _ O
ID _ _ O
card _ _ O
. _ _ O
o _ _ O
this _ _ O
is _ _ O
implemented _ _ O
as _ _ O
a _ _ O
" _ _ O
secret _ _ O
" _ _ O
field _ _ O
in _ _ O
every _ _ O
class _ _ B-Concept
instance _ _ I-Concept
. _ _ O
c _ _ O
= _ _ O
new _ _ O
Cat _ _ O
( _ _ O
‚Ä¶ _ _ O
) _ _ O
; _ _ O
type _ _ O
: _ _ O
Cat _ _ O
species _ _ O
: _ _ O
" _ _ O
felis _ _ O
cattus _ _ O
" _ _ O
whiskers _ _ O
: _ _ O
15 _ _ O
d _ _ O
= _ _ O
new _ _ O
Dog _ _ O
( _ _ O
‚Ä¶ _ _ O
) _ _ O
; _ _ O
type _ _ O
: _ _ O
Dog _ _ O
species _ _ O
: _ _ O
" _ _ O
canis _ _ O
lupus _ _ O
" _ _ O
drooly _ _ O
: _ _ O
true _ _ O
fn _ _ O
print _ _ O
( _ _ O
a _ _ O
: _ _ O
Animal _ _ O
) _ _ O
{ _ _ O
println_s _ _ O
( _ _ O
a.to_string _ _ O
( _ _ O
) _ _ O
) _ _ O
; _ _ O
} _ _ O
this _ _ O
method _ _ O
call _ _ O
could _ _ O
be _ _ O
implemented _ _ O
something _ _ O
like _ _ O
: _ _ O
if _ _ O
a.type _ _ O
= _ _ O
= _ _ O
Cat _ _ O
{ _ _ O
Cat.to_string _ _ O
( _ _ O
a _ _ O
) _ _ O
} _ _ O
else _ _ O
if _ _ O
a.type _ _ O
= _ _ O
= _ _ O
Dog _ _ O
{ _ _ O
Dog.to_string _ _ O
( _ _ O
a _ _ O
) _ _ O
} _ _ O
but _ _ O
that _ _ O
would _ _ O
be _ _ O
horribly _ _ O
inefficient _ _ O
. _ _ O
28 _ _ O

Virtual _ _ B-Concept
method _ _ I-Concept
tables _ _ I-Concept
( _ _ O
vtables _ _ B-Concept
) _ _ O
‚óè _ _ O
to _ _ O
implement _ _ O
this _ _ O
efficiently _ _ O
, _ _ O
and _ _ O
to _ _ O
allow _ _ O
an _ _ O
unlimited _ _ O
number _ _ O
of _ _ O
subtypes _ _ B-Concept
, _ _ O
the _ _ O
" _ _ O
ID _ _ O
card _ _ O
" _ _ O
is _ _ O
a _ _ O
pointer _ _ O
to _ _ O
an _ _ O
array _ _ B-Concept
of _ _ O
function _ _ O
pointers _ _ O
. _ _ O
c _ _ O
= _ _ O
new _ _ O
Cat _ _ O
( _ _ O
‚Ä¶ _ _ O
) _ _ O
; _ _ O
Cat _ _ O
vtable _ _ B-Concept
0 _ _ O
vtbl _ _ O
0 _ _ O
breathe _ _ O
Animal.breathe _ _ O
( _ _ O
) _ _ O
4 _ _ O
species _ _ O
4 _ _ O
to_string _ _ O
Cat.to_string _ _ O
( _ _ O
) _ _ O
8 _ _ O
whiskers _ _ O
8 _ _ O
play_string _ _ O
Cat.play_string _ _ O
( _ _ O
) _ _ O
d _ _ O
= _ _ O
new _ _ O
Dog _ _ O
( _ _ O
‚Ä¶ _ _ O
) _ _ O
; _ _ O
Dog _ _ O
vtable _ _ B-Concept
0 _ _ O
vtbl _ _ O
0 _ _ O
breathe _ _ O
4 _ _ O
species _ _ O
4 _ _ O
to_string _ _ O
Dog.to_string _ _ O
( _ _ O
) _ _ O
8 _ _ O
drooly _ _ O
8 _ _ O
play_fetch _ _ O
Dog.play_fetch _ _ O
( _ _ O
) _ _ O
29 _ _ O

Virtual _ _ B-Concept
method _ _ I-Concept
calls _ _ I-Concept
‚óè _ _ O
to _ _ O
call _ _ O
a _ _ O
virtual _ _ B-Concept
method _ _ I-Concept
, _ _ O
we _ _ O
index _ _ O
the _ _ O
table _ _ O
to _ _ O
get _ _ O
the _ _ O
address _ _ O
‚Ä¶ _ _ O
o _ _ O
and _ _ O
do _ _ O
an _ _ O
indirect _ _ B-Concept
function _ _ I-Concept
call _ _ I-Concept
to _ _ O
that _ _ O
address _ _ O
. _ _ O
this _ _ O
method _ _ B-Concept
call _ _ I-Concept
becomes _ _ O
: _ _ O
fn _ _ O
print _ _ O
( _ _ O
a _ _ O
: _ _ O
Animal _ _ O
) _ _ O
{ _ _ O
a.vtbl _ _ O
[ _ _ O
1 _ _ O
] _ _ O
( _ _ O
a _ _ O
) _ _ O
println_s _ _ O
( _ _ O
a.to_string _ _ O
( _ _ O
) _ _ O
) _ _ O
; _ _ O
} _ _ O
or _ _ O
in _ _ O
assembly _ _ O
: _ _ O
the _ _ O
compiler _ _ B-Concept
knows _ _ O
the _ _ O
method _ _ B-Concept
indexes _ _ O
because _ _ O
the _ _ O
vtables _ _ B-Concept
for _ _ O
each _ _ O
class _ _ B-Concept
use _ _ O
prefixing _ _ B-Concept
: _ _ O
subtypes _ _ B-Concept
' _ _ O
vtables _ _ B-Concept
are _ _ O
prefixed _ _ B-Concept
with _ _ O
their _ _ O
supertype _ _ B-Concept
's _ _ I-Concept
vtable _ _ B-Concept
. _ _ O
addi _ _ O
sp _ _ O
, _ _ O
sp _ _ O
, _ _ O
-4 _ _ O
lw _ _ O
s0 _ _ O
, _ _ O
-16 _ _ O
( _ _ O
fp _ _ O
) _ _ O
# _ _ O
s0 _ _ O
= _ _ O
a _ _ O
sw _ _ O
s0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
sp _ _ O
) _ _ O
# _ _ O
pass _ _ O
' _ _ O
this _ _ O
' _ _ O
lw _ _ O
s0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
s0 _ _ O
) _ _ O
# _ _ O
s0 _ _ O
= _ _ O
a.vtbl _ _ O
lw _ _ O
s0 _ _ O
, _ _ O
4 _ _ O
( _ _ O
s0 _ _ O
) _ _ O
# _ _ O
s0 _ _ O
= _ _ O
a.vtbl _ _ O
[ _ _ O
1 _ _ O
] _ _ O
jalr _ _ B-Concept
s0 _ _ O
# _ _ O
call _ _ O
to_string _ _ O
jalr _ _ B-Concept
works _ _ O
like _ _ O
jal _ _ O
, _ _ O
but _ _ O
uses _ _ O
a _ _ O
register _ _ O
as _ _ O
the _ _ O
address _ _ O
of _ _ O
the _ _ O
function _ _ O
to _ _ O
call _ _ O
. _ _ O
30 _ _ O

Things _ _ O
to _ _ O
ponder _ _ O
on _ _ O
‚óè _ _ O
what _ _ O
are _ _ O
interfaces _ _ B-Concept
, _ _ O
then _ _ O
? _ _ O
o _ _ O
a _ _ O
" _ _ O
slice _ _ O
" _ _ O
of _ _ O
a _ _ O
vtable _ _ B-Concept
, _ _ O
sort _ _ O
of _ _ O
! _ _ O
o _ _ O
when _ _ O
a _ _ O
class _ _ B-Concept
implements _ _ O
an _ _ O
interface _ _ B-Concept
, _ _ O
those _ _ O
methods _ _ O
are _ _ O
present _ _ O
in _ _ O
its _ _ O
vtable _ _ B-Concept
at _ _ O
runtime _ _ B-Concept
. _ _ O
‚óè _ _ O
what _ _ O
about _ _ O
public _ _ B-Concept
/ _ _ O
protected _ _ B-Concept
/ _ _ O
private _ _ B-Concept
? _ _ O
final _ _ B-Concept
? _ _ O
override _ _ B-Concept
? _ _ O
o _ _ O
these _ _ O
are _ _ O
all _ _ O
semantic _ _ B-Concept
; _ _ O
they _ _ O
have _ _ O
no _ _ O
effect _ _ O
on _ _ O
the _ _ O
implementation _ _ O
. _ _ O
‚óè _ _ O
what _ _ O
about _ _ O
static _ _ O
variables _ _ O
/ _ _ O
methods _ _ O
? _ _ O
o _ _ O
they _ _ O
're _ _ O
globals _ _ O
whose _ _ O
names _ _ O
happen _ _ O
to _ _ O
be _ _ O
scoped _ _ O
inside _ _ O
a _ _ O
class _ _ B-Concept
. _ _ O
‚óè _ _ O
what _ _ O
about _ _ O
null _ _ B-Concept
? _ _ O
o _ _ O
we _ _ O
could _ _ O
have _ _ O
nullable _ _ O
reference _ _ B-Concept
types _ _ I-Concept
, _ _ O
like _ _ O
a _ _ O
restricted _ _ O
form _ _ O
of _ _ O
Rust _ _ O
's _ _ O
Option _ _ O
< _ _ O
T _ _ O
> _ _ O
that _ _ O
only _ _ O
works _ _ O
for _ _ O
references _ _ O
. _ _ O
‚óè _ _ O
what _ _ O
about _ _ O
inheriting _ _ B-Concept
from _ _ O
multiple _ _ O
classes _ _ O
? _ _ O
o _ _ O
do _ _ O
n't _ _ O
even _ _ O
go _ _ O
there _ _ O
. _ _ O
noooooope _ _ O
nope _ _ O
nope _ _ O
31 _ _ O



