self_training_1|cs0447|lec04
-DOCSTART- -X- -X- O

# _ _ O
4 _ _ O
Memory _ _ O
and _ _ O
Addresses _ _ O
Original _ _ O
slides _ _ O
by _ _ O
: _ _ O
Jarrett _ _ O
Billingsley _ _ O
Modified _ _ O
with _ _ O
bits _ _ O
from _ _ O
: _ _ O
Bruce _ _ O
Childers _ _ O
, _ _ O
David _ _ O
Wilkinson _ _ O
CS _ _ O
0447 _ _ O
Introduction _ _ O
to _ _ O
Computer _ _ O
Programming _ _ O
Luís _ _ O
Oliveira _ _ O
Fall _ _ O
2020 _ _ O

Class _ _ O
announcements _ _ O
● _ _ O
Add _ _ O
/ _ _ O
Drop _ _ O
period _ _ O
ends _ _ O
? _ _ O
? _ _ O
! _ _ O
● _ _ O
Everyone _ _ O
joined _ _ O
slack _ _ O
? _ _ O
Links _ _ O
will _ _ O
/ _ _ O
have _ _ O
? _ _ O
Expired _ _ O
● _ _ O
Repeat _ _ O
after _ _ O
me _ _ O
: _ _ O
o _ _ O
Store _ _ O
copies _ _ O
from _ _ O
the _ _ O
CPU _ _ O
to _ _ O
memory _ _ O
o _ _ O
Load _ _ O
copies _ _ O
from _ _ O
memory _ _ O
to _ _ O
CPU _ _ O
2 _ _ O

Variables _ _ O
, _ _ O
Loads _ _ O
, _ _ O
Stores _ _ O
3 _ _ O

Memory _ _ O
addresses _ _ O
● _ _ O
Everything _ _ O
in _ _ O
memory _ _ O
has _ _ O
an _ _ O
address _ _ O
o _ _ O
the _ _ O
position _ _ O
in _ _ O
memory _ _ O
where _ _ O
it _ _ O
begins _ _ O
▪ _ _ O
where _ _ O
its _ _ O
first _ _ O
byte _ _ O
is _ _ O
o _ _ O
this _ _ O
applies _ _ O
to _ _ O
variables _ _ O
, _ _ O
functions _ _ O
, _ _ O
objects _ _ O
, _ _ O
arrays _ _ O
etc _ _ O
. _ _ O
● _ _ O
A _ _ O
super _ _ O
important _ _ O
concept _ _ O
: _ _ O
every _ _ O
piece _ _ O
of _ _ O
data _ _ O
really _ _ O
has _ _ O
two _ _ O
parts _ _ O
: _ _ O
an _ _ O
address _ _ O
and _ _ O
a _ _ O
value _ _ O
● _ _ O
If _ _ O
you _ _ O
want _ _ O
to _ _ O
put _ _ O
a _ _ O
variable _ _ O
in _ _ O
memory _ _ O
… _ _ O
o _ _ O
first _ _ O
you _ _ O
need _ _ O
to _ _ O
figure _ _ O
out _ _ O
what _ _ O
address _ _ O
to _ _ O
put _ _ O
it _ _ O
in _ _ O
o _ _ O
this _ _ O
extremely _ _ O
tedious _ _ O
task _ _ O
is _ _ O
handled _ _ O
by _ _ O
assemblers _ _ O
▪ _ _ O
whew _ _ O
4 _ _ O

Putting _ _ O
a _ _ O
variable _ _ O
in _ _ O
memory _ _ O
● _ _ O
we _ _ O
can _ _ O
declare _ _ O
a _ _ O
global _ _ O
variable _ _ O
like _ _ O
this _ _ O
: _ _ O
.data _ _ O
x _ _ O
: _ _ O
.word _ _ O
4 _ _ O
name _ _ O
type _ _ O
initial _ _ O
value _ _ O
● _ _ O
the _ _ O
Java _ _ O
/ _ _ O
C _ _ O
equivalent _ _ O
would _ _ O
be _ _ O
static _ _ O
int _ _ O
x _ _ O
= _ _ O
4 _ _ O
; _ _ O
● _ _ O
.data _ _ O
says _ _ O
" _ _ O
I _ _ O
'm _ _ O
gon _ _ O
na _ _ O
declare _ _ O
variables _ _ O
" _ _ O
o _ _ O
you _ _ O
can _ _ O
declare _ _ O
as _ _ O
many _ _ O
as _ _ O
you _ _ O
want _ _ O
! _ _ O
o _ _ O
to _ _ O
go _ _ O
back _ _ O
to _ _ O
writing _ _ O
code _ _ O
, _ _ O
use _ _ O
.text _ _ O
● _ _ O
if _ _ O
we _ _ O
assemble _ _ O
this _ _ O
little _ _ O
program _ _ O
and _ _ O
make _ _ O
sure _ _ O
Tools _ _ O
> _ _ O
Show _ _ O
Labels _ _ O
Window _ _ O
is _ _ O
checked _ _ O
, _ _ O
what _ _ O
do _ _ O
you _ _ O
see _ _ O
? _ _ O
o _ _ O
the _ _ O
assembler _ _ O
gave _ _ O
the _ _ O
variable _ _ O
that _ _ O
address _ _ O
o _ _ O
it _ _ O
'll _ _ O
do _ _ O
that _ _ O
for _ _ O
every _ _ O
variable _ _ O
5 _ _ O

Load-store _ _ O
architectures _ _ O
● _ _ O
In _ _ O
some _ _ O
architectures _ _ O
, _ _ O
many _ _ O
instructions _ _ O
can _ _ O
access _ _ O
memory _ _ O
o _ _ O
x86 _ _ O
- _ _ O
64 _ _ O
: _ _ O
add _ _ O
[ _ _ O
rsp-8 _ _ O
] _ _ O
, _ _ O
rcx _ _ O
▪ _ _ O
adds _ _ O
the _ _ O
contents _ _ O
of _ _ O
rcx _ _ O
to _ _ O
the _ _ O
value _ _ O
at _ _ O
address _ _ O
rsp-8 _ _ O
● _ _ O
In _ _ O
a _ _ O
load-store _ _ O
architecture _ _ O
, _ _ O
all _ _ O
memory _ _ O
accesses _ _ O
are _ _ O
done _ _ O
with _ _ O
two _ _ O
kinds _ _ O
of _ _ O
instructions _ _ O
: _ _ O
loads _ _ O
and _ _ O
stores _ _ O
( _ _ O
like _ _ O
in _ _ O
MIPS _ _ O
) _ _ O
loads _ _ O
copy _ _ O
data _ _ O
from _ _ O
memory _ _ O
into _ _ O
CPU _ _ O
registers _ _ O
lw _ _ O
Registers _ _ O
Memory _ _ O
sw _ _ O
stores _ _ O
copy _ _ O
data _ _ O
from _ _ O
CPU _ _ O
registers _ _ O
into _ _ O
memory _ _ O
6 _ _ O

Operating _ _ O
on _ _ O
variables _ _ O
in _ _ O
memory _ _ O
( _ _ O
animated _ _ O
) _ _ O
● _ _ O
we _ _ O
want _ _ O
to _ _ O
increment _ _ O
a _ _ O
variable _ _ O
that _ _ O
is _ _ O
in _ _ O
memory _ _ O
o _ _ O
where _ _ O
do _ _ O
values _ _ O
have _ _ O
to _ _ O
be _ _ O
for _ _ O
the _ _ O
CPU _ _ O
to _ _ O
operate _ _ O
on _ _ O
them _ _ O
? _ _ O
o _ _ O
what _ _ O
do _ _ O
we _ _ O
want _ _ O
the _ _ O
overall _ _ O
outcome _ _ O
to _ _ O
be _ _ O
? _ _ O
● _ _ O
so _ _ O
, _ _ O
what _ _ O
three _ _ O
steps _ _ O
are _ _ O
needed _ _ O
to _ _ O
increment _ _ O
that _ _ O
variable _ _ O
? _ _ O
1 _ _ O
. _ _ O
load _ _ O
the _ _ O
value _ _ O
from _ _ O
memory _ _ O
into _ _ O
a _ _ O
register _ _ O
2 _ _ O
. _ _ O
add _ _ O
1 _ _ O
to _ _ O
the _ _ O
value _ _ O
in _ _ O
the _ _ O
register _ _ O
3 _ _ O
. _ _ O
store _ _ O
the _ _ O
value _ _ O
back _ _ O
into _ _ O
memory _ _ O
● _ _ O
every _ _ O
variable _ _ O
access _ _ O
works _ _ O
like _ _ O
this _ _ O
! _ _ O
! _ _ O
! _ _ O
o _ _ O
HLLs _ _ O
just _ _ O
hide _ _ O
this _ _ O
from _ _ O
you _ _ O
5 _ _ O
4 _ _ O
5 _ _ O
4 _ _ O
x _ _ O
7 _ _ O

Accessing _ _ O
memory _ _ O
in _ _ O
MIPS _ _ O
8 _ _ O

MIPS _ _ O
ISA _ _ O
: _ _ O
load _ _ O
and _ _ O
store _ _ O
instructions _ _ O
for _ _ O
words _ _ O
● _ _ O
you _ _ O
can _ _ O
load _ _ O
and _ _ O
store _ _ O
entire _ _ O
32-bit _ _ O
words _ _ O
with _ _ O
lw _ _ O
and _ _ O
sw _ _ O
● _ _ O
the _ _ O
instructions _ _ O
look _ _ O
like _ _ O
this _ _ O
( _ _ O
variable _ _ O
names _ _ O
not _ _ O
important _ _ O
) _ _ O
: _ _ O
lw _ _ O
t1 _ _ O
, _ _ O
x _ _ O
# _ _ O
loads _ _ O
from _ _ O
variable _ _ O
x _ _ O
into _ _ O
t1 _ _ O
sw _ _ O
t1 _ _ O
, _ _ O
x _ _ O
# _ _ O
stores _ _ O
from _ _ O
t1 _ _ O
into _ _ O
variable _ _ O
x _ _ O
● _ _ O
Ermm _ _ O
… _ _ O
In _ _ O
MIPS _ _ O
, _ _ O
stores _ _ O
are _ _ O
written _ _ O
with _ _ O
the _ _ O
destination _ _ O
on _ _ O
the _ _ O
right _ _ O
. _ _ O
! _ _ O
? _ _ O
o _ _ O
well _ _ O
, _ _ O
you _ _ O
can _ _ O
remember _ _ O
it _ _ O
with _ _ O
this _ _ O
diagram _ _ O
… _ _ O
o _ _ O
the _ _ O
memory _ _ O
is _ _ O
" _ _ O
on _ _ O
the _ _ O
right _ _ O
" _ _ O
for _ _ O
both _ _ O
lw _ _ O
loads _ _ O
and _ _ O
stores _ _ O
Registers _ _ O
Memory _ _ O
sw _ _ O
9 _ _ O

MIPS _ _ O
ISA _ _ O
: _ _ O
load _ _ O
and _ _ O
store _ _ O
instructions _ _ O
for _ _ O
words _ _ O
● _ _ O
You _ _ O
can _ _ O
also _ _ O
load _ _ O
the _ _ O
32-bit _ _ O
address _ _ O
of _ _ O
a _ _ O
variable _ _ O
with _ _ O
la _ _ O
la _ _ O
t1 _ _ O
, _ _ O
x _ _ O
# _ _ O
loads _ _ O
the _ _ O
ADDRESS _ _ O
of _ _ O
x _ _ O
into _ _ O
t1 _ _ O
t1 _ _ O
 _ _ O
will _ _ O
now _ _ O
contain _ _ O
4 _ _ O
: _ _ O
The _ _ O
address _ _ O
of _ _ O
variable _ _ O
x _ _ O
● _ _ O
And _ _ O
then _ _ O
use _ _ O
that _ _ O
address _ _ O
to _ _ O
access _ _ O
memory _ _ O
, _ _ O
e.g. _ _ O
: _ _ O
la _ _ O
t2 _ _ O
, _ _ O
0 _ _ O
( _ _ O
t1 _ _ O
) _ _ O
# _ _ O
the _ _ O
contents _ _ O
of _ _ O
x _ _ O
into _ _ O
t2 _ _ O
x _ _ O
Addr _ _ O
Val _ _ O
0 _ _ O
04 _ _ O
1 _ _ O
00 _ _ O
2 _ _ O
00 _ _ O
3 _ _ O
00 _ _ O
4 _ _ O
DE _ _ O
5 _ _ O
C0 _ _ O
6 _ _ O
EF _ _ O
7 _ _ O
BE _ _ O
8 _ _ O
6C _ _ O
9 _ _ O
34 _ _ O
A _ _ O
00 _ _ O
B _ _ O
01 _ _ O
10 _ _ O

Read _ _ O
, _ _ O
modify _ _ O
, _ _ O
write _ _ O
● _ _ O
you _ _ O
now _ _ O
know _ _ O
enough _ _ O
to _ _ O
increment _ _ O
x _ _ O
! _ _ O
● _ _ O
But _ _ O
first _ _ O
, _ _ O
lets _ _ O
look _ _ O
at _ _ O
some _ _ O
assembly _ _ O
● _ _ O
first _ _ O
we _ _ O
load _ _ O
x _ _ O
into _ _ O
a _ _ O
register _ _ O
● _ _ O
then _ _ O
… _ _ O
● _ _ O
and _ _ O
then _ _ O
… _ _ O
lw _ _ O
t0 _ _ O
, _ _ O
x _ _ O
add _ _ O
t0 _ _ O
, _ _ O
t0 _ _ O
, _ _ O
1 _ _ O
sw _ _ O
t0 _ _ O
, _ _ O
x _ _ O
● _ _ O
let _ _ O
's _ _ O
see _ _ O
what _ _ O
values _ _ O
are _ _ O
in _ _ O
t0 _ _ O
and _ _ O
memory _ _ O
after _ _ O
this _ _ O
program _ _ O
runs _ _ O
11 _ _ O

It _ _ O
really _ _ O
is _ _ O
that _ _ O
simple _ _ O
● _ _ O
variables _ _ O
in _ _ O
asm _ _ O
are _ _ O
n't _ _ O
THAT _ _ O
scary _ _ O
● _ _ O
please _ _ O
do _ _ O
n't _ _ O
be _ _ O
afraid _ _ O
of _ _ O
them _ _ O
● _ _ O
you _ _ O
just _ _ O
got _ _ O
ta _ _ O
remember _ _ O
to _ _ O
store _ _ O
if _ _ O
you _ _ O
wanna _ _ O
change _ _ O
em _ _ O
12 _ _ O

Questions _ _ O
? _ _ O
• _ _ O
Just _ _ O
in _ _ O
case _ _ O
I _ _ O
prepared _ _ O
some _ _ O
for _ _ O
you _ _ O
: _ _ O
o _ _ O
Does _ _ O
load _ _ O
word _ _ O
( _ _ O
lw _ _ O
) _ _ O
put _ _ O
or _ _ O
get _ _ O
data _ _ O
from _ _ O
memory _ _ O
? _ _ O
o _ _ O
I _ _ O
already _ _ O
know _ _ O
the _ _ O
word _ _ O
is _ _ O
the _ _ O
most _ _ O
“ _ _ O
comfortable _ _ O
” _ _ O
size _ _ O
for _ _ O
the _ _ O
CPU _ _ O
, _ _ O
but _ _ O
are _ _ O
they _ _ O
the _ _ O
only _ _ O
size _ _ O
it _ _ O
can _ _ O
work _ _ O
with _ _ O
? _ _ O
13 _ _ O

Smaller _ _ O
values _ _ O
14 _ _ O

Smaller _ _ O
numeric _ _ O
● _ _ O
MIPS _ _ O
also _ _ O
understands _ _ O
smaller _ _ O
and _ _ O
tiny _ _ O
datatypes _ _ O
.data _ _ O
x _ _ O
: _ _ O
.word _ _ O
4 _ _ O
y _ _ O
: _ _ O
.half _ _ O
4 _ _ O
z _ _ O
: _ _ O
.byte _ _ O
4 _ _ O
= _ _ O
> _ _ O
= _ _ O
> _ _ O
= _ _ O
> _ _ O
0x00000004 _ _ O
0x0004 _ _ O
0x04 _ _ O
15 _ _ O

MIPS _ _ O
ISA _ _ O
: _ _ O
loading _ _ O
and _ _ O
storing _ _ O
8 _ _ O
/ _ _ O
16-bit _ _ O
values _ _ O
● _ _ O
to _ _ O
load _ _ O
/ _ _ O
store _ _ O
bytes _ _ O
, _ _ O
we _ _ O
use _ _ O
lb _ _ O
/ _ _ O
sb _ _ O
● _ _ O
to _ _ O
load _ _ O
/ _ _ O
store _ _ O
16-bit _ _ O
( _ _ O
half-word _ _ O
) _ _ O
values _ _ O
, _ _ O
we _ _ O
use _ _ O
lh _ _ O
/ _ _ O
sh _ _ O
● _ _ O
these _ _ O
look _ _ O
and _ _ O
work _ _ O
just _ _ O
like _ _ O
lw _ _ O
/ _ _ O
sw _ _ O
, _ _ O
like _ _ O
: _ _ O
lb _ _ O
t0 _ _ O
, _ _ O
tiny _ _ O
# _ _ O
loads _ _ O
a _ _ O
byte _ _ O
into _ _ O
t0 _ _ O
sb _ _ O
t0 _ _ O
, _ _ O
tiny _ _ O
# _ _ O
stores _ _ O
a _ _ O
byte _ _ O
into _ _ O
tiny _ _ O
o _ _ O
… _ _ O
or _ _ O
DO _ _ O
THEY _ _ O
? _ _ O
! _ _ O
? _ _ O
! _ _ O
? _ _ O
! _ _ O
? _ _ O
● _ _ O
how _ _ O
big _ _ O
are _ _ O
registers _ _ O
? _ _ O
o _ _ O
what _ _ O
should _ _ O
go _ _ O
in _ _ O
those _ _ O
extra _ _ O
16 _ _ O
/ _ _ O
24 _ _ O
bits _ _ O
then _ _ O
? _ _ O
▪ _ _ O
? _ _ O
? _ _ O
? _ _ O
16 _ _ O

can _ _ O
I _ _ O
get _ _ O
an _ _ O
extension _ _ O
? _ _ O
… _ _ O
no _ _ O
● _ _ O
sometimes _ _ O
you _ _ O
need _ _ O
to _ _ O
widen _ _ O
a _ _ O
number _ _ O
with _ _ O
fewer _ _ O
bits _ _ O
to _ _ O
more _ _ O
● _ _ O
zero _ _ O
extension _ _ O
is _ _ O
easy _ _ O
: _ _ O
put _ _ O
0s _ _ O
at _ _ O
the _ _ O
beginning _ _ O
. _ _ O
10012 _ _ O
➔ _ _ O
to _ _ O
8 _ _ O
bits _ _ O
➔ _ _ O
0000 _ _ O
10012 _ _ O
● _ _ O
but _ _ O
there _ _ O
are _ _ O
also _ _ O
signed _ _ O
numbers _ _ O
which _ _ O
we _ _ O
did _ _ O
n't _ _ O
talk _ _ O
about _ _ O
yet _ _ O
o _ _ O
the _ _ O
top _ _ O
bit _ _ O
( _ _ O
MSB _ _ O
) _ _ O
of _ _ O
signed _ _ O
numbers _ _ O
is _ _ O
the _ _ O
sign _ _ O
( _ _ O
+ _ _ O
/- _ _ O
) _ _ O
● _ _ O
sign _ _ O
extension _ _ O
puts _ _ O
copies _ _ O
of _ _ O
the _ _ O
sign _ _ O
bit _ _ O
at _ _ O
the _ _ O
beginning _ _ O
10012 _ _ O
➔ _ _ O
to _ _ O
8 _ _ O
bits _ _ O
➔ _ _ O
1111 _ _ O
10012 _ _ O
00102 _ _ O
➔ _ _ O
to _ _ O
8 _ _ O
bits _ _ O
➔ _ _ O
0000 _ _ O
00102 _ _ O
o _ _ O
like _ _ O
spreading _ _ O
peanut _ _ O
butter _ _ O
▪ _ _ O
we _ _ O
'll _ _ O
learn _ _ O
about _ _ O
why _ _ O
this _ _ O
is _ _ O
important _ _ O
later _ _ O
in _ _ O
the _ _ O
course _ _ O
17 _ _ O

EXPAND _ _ O
VALUE _ _ O
● _ _ O
if _ _ O
you _ _ O
load _ _ O
a _ _ O
byte _ _ O
… _ _ O
31 _ _ O
0 _ _ O
00000000 _ _ O
00000000 _ _ O
00000000 _ _ O
00000000 _ _ O
10010000 _ _ O
If _ _ O
the _ _ O
byte _ _ O
is _ _ O
signed _ _ O
… _ _ O
what _ _ O
should _ _ O
it _ _ O
become _ _ O
? _ _ O
31 _ _ O
0 _ _ O
11111111 _ _ O
11111111 _ _ O
11111111 _ _ O
10010000 _ _ O
If _ _ O
the _ _ O
byte _ _ O
is _ _ O
unsigned _ _ O
… _ _ O
what _ _ O
should _ _ O
it _ _ O
become _ _ O
? _ _ O
31 _ _ O
0 _ _ O
00000000 _ _ O
00000000 _ _ O
00000000 _ _ O
10010000 _ _ O
lb _ _ O
does _ _ O
sign _ _ O
extension _ _ O
. _ _ O
lbu _ _ O
does _ _ O
zero _ _ O
extension _ _ O
. _ _ O
18 _ _ O

How _ _ O
does _ _ O
the _ _ O
CPU _ _ O
know _ _ O
whether _ _ O
it _ _ O
's _ _ O
signed _ _ O
or _ _ O
unsigned _ _ O
➔ _ _ O
Everything _ _ O
’s _ _ O
a _ _ O
number _ _ O
➔ _ _ O
Everything _ _ O
's _ _ O
in _ _ O
binary _ _ O
( _ _ O
and _ _ O
hex _ _ O
is _ _ O
convenient _ _ O
shorthand _ _ O
) _ _ O
➔ _ _ O
Numbers _ _ O
may _ _ O
not _ _ O
be _ _ O
numbers _ _ O
➔ _ _ O
So _ _ O
, _ _ O
how _ _ O
does _ _ O
the _ _ O
computer _ _ O
know _ _ O
a _ _ O
number _ _ O
is _ _ O
a _ _ O
number _ _ O
? _ _ O
o _ _ O
How _ _ O
does _ _ O
it _ _ O
know _ _ O
that _ _ O
a _ _ O
number _ _ O
is _ _ O
signed _ _ O
? _ _ O
o _ _ O
How _ _ O
does _ _ O
it _ _ O
know _ _ O
how _ _ O
to _ _ O
add _ _ O
two _ _ O
numbers _ _ O
? _ _ O
o _ _ O
How _ _ O
does _ _ O
it _ _ O
know _ _ O
how _ _ O
to _ _ O
manipulate _ _ O
strings _ _ O
? _ _ O
o _ _ O
How _ _ O
does _ _ O
it _ _ O
know _ _ O
if _ _ O
one _ _ O
pattern _ _ O
of _ _ O
bits _ _ O
is _ _ O
a _ _ O
string _ _ O
or _ _ O
a _ _ O
number _ _ O
or _ _ O
a _ _ O
video _ _ O
or _ _ O
a _ _ O
program _ _ O
or _ _ O
a _ _ O
file _ _ O
or _ _ O
an _ _ O
icon _ _ O
or _ _ O
19 _ _ O

IT _ _ O
DOESN _ _ O
' _ _ O
T _ _ O
20 _ _ O

How _ _ O
does _ _ O
the _ _ O
CPU _ _ O
know _ _ O
whether _ _ O
it _ _ O
's _ _ O
signed _ _ O
or _ _ O
unsigned _ _ O
• _ _ O
Do _ _ O
YOU _ _ O
think _ _ O
the _ _ O
CPU _ _ O
knows _ _ O
this _ _ O
? _ _ O
o _ _ O
no _ _ O
▪ _ _ O
it _ _ O
does _ _ O
n't _ _ O
– _ _ O
you _ _ O
have _ _ O
to _ _ O
use _ _ O
the _ _ O
right _ _ O
instruction _ _ O
. _ _ O
• _ _ O
It _ _ O
’s _ _ O
particularly _ _ O
easy _ _ O
to _ _ O
mess _ _ O
this _ _ O
up _ _ O
o _ _ O
lbu _ _ O
is _ _ O
usually _ _ O
what _ _ O
you _ _ O
want _ _ O
for _ _ O
byte _ _ O
variables _ _ O
but _ _ O
lb _ _ O
is _ _ O
one _ _ O
character _ _ O
shorter _ _ O
and _ _ O
just _ _ O
looks _ _ O
so _ _ O
nice _ _ O
and _ _ O
consistent _ _ O
… _ _ O
o _ _ O
But _ _ O
do _ _ O
n’t _ _ O
! _ _ O
21 _ _ O

Truncation _ _ O
● _ _ O
If _ _ O
we _ _ O
go _ _ O
the _ _ O
other _ _ O
way _ _ O
, _ _ O
the _ _ O
upper _ _ O
part _ _ O
of _ _ O
the _ _ O
value _ _ O
is _ _ O
cut _ _ O
off _ _ O
. _ _ O
sh _ _ O
31 _ _ O
0 _ _ O
11111111 _ _ O
00000100 _ _ O
10100010 _ _ O
00001110 _ _ O
11111111 _ _ O
00000100 _ _ O
● _ _ O
The _ _ O
sign _ _ O
issue _ _ O
does _ _ O
n't _ _ O
exist _ _ O
when _ _ O
storing _ _ O
, _ _ O
cause _ _ O
we _ _ O
're _ _ O
going _ _ O
from _ _ O
a _ _ O
larger _ _ O
number _ _ O
of _ _ O
bits _ _ O
to _ _ O
a _ _ O
smaller _ _ O
number _ _ O
o _ _ O
therefore _ _ O
, _ _ O
there _ _ O
are _ _ O
no _ _ O
sbu _ _ O
/ _ _ O
shu _ _ O
instructions _ _ O
22 _ _ O

Memory _ _ O
23 _ _ O

What _ _ O
is _ _ O
the _ _ O
memory _ _ O
? _ _ O
• _ _ O
The _ _ O
system _ _ O
memory _ _ O
is _ _ O
a _ _ O
piece _ _ O
of _ _ O
temporary _ _ O
storage _ _ O
hardware _ _ O
o _ _ O
it _ _ O
's _ _ O
smaller _ _ O
and _ _ O
faster _ _ O
( _ _ O
more _ _ O
expensive _ _ O
! _ _ O
) _ _ O
than _ _ O
the _ _ O
persistent _ _ O
storage _ _ O
. _ _ O
▪ _ _ O
maybe _ _ O
in _ _ O
the _ _ O
future _ _ O
it _ _ O
wo _ _ O
n't _ _ O
be _ _ O
temporary _ _ O
▪ _ _ O
the _ _ O
line _ _ O
between _ _ O
system _ _ O
memory _ _ O
and _ _ O
persistent _ _ O
storage _ _ O
will _ _ O
fade _ _ O
away _ _ O
… _ _ O
• _ _ O
It _ _ O
's _ _ O
where _ _ O
the _ _ O
programs _ _ O
and _ _ O
data _ _ O
that _ _ O
the _ _ O
computer _ _ O
is _ _ O
currently _ _ O
executing _ _ O
and _ _ O
using _ _ O
reside _ _ O
o _ _ O
all _ _ O
the _ _ O
variables _ _ O
, _ _ O
all _ _ O
the _ _ O
functions _ _ O
, _ _ O
all _ _ O
the _ _ O
open _ _ O
files _ _ O
etc _ _ O
. _ _ O
o _ _ O
the _ _ O
CPU _ _ O
can _ _ O
only _ _ O
run _ _ O
programs _ _ O
from _ _ O
system _ _ O
memory _ _ O
! _ _ O
24 _ _ O

Bytes _ _ O
, _ _ O
bytes _ _ O
, _ _ O
bytes _ _ O
● _ _ O
The _ _ O
memory _ _ O
is _ _ O
a _ _ O
big _ _ O
one-dimensional _ _ O
array _ _ O
of _ _ O
bytes _ _ O
● _ _ O
What _ _ O
do _ _ O
these _ _ O
bytes _ _ O
mean _ _ O
? _ _ O
o _ _ O
¯\_ _ _ O
( _ _ O
ツ _ _ O
) _ _ O
_ _ _ O
/ _ _ O
¯ _ _ O
● _ _ O
Every _ _ O
byte _ _ O
value _ _ O
has _ _ O
an _ _ O
address _ _ O
o _ _ O
This _ _ O
is _ _ O
its _ _ O
" _ _ O
array _ _ O
index _ _ O
" _ _ O
o _ _ O
Addresses _ _ O
start _ _ O
at _ _ O
0 _ _ O
, _ _ O
like _ _ O
arrays _ _ O
in _ _ O
C _ _ O
/ _ _ O
Java _ _ O
▪ _ _ O
Gee _ _ O
wonder _ _ O
where _ _ O
they _ _ O
got _ _ O
the _ _ O
idea _ _ O
▪ _ _ O
Addresses _ _ O
are _ _ O
the _ _ O
offset _ _ O
from _ _ O
the _ _ O
beginning _ _ O
! _ _ O
● _ _ O
When _ _ O
each _ _ O
byte _ _ O
has _ _ O
its _ _ O
own _ _ O
address _ _ O
, _ _ O
we _ _ O
call _ _ O
it _ _ O
a _ _ O
byteaddressable _ _ O
machine _ _ O
o _ _ O
not _ _ O
many _ _ O
non-byte-addressable _ _ O
machines _ _ O
these _ _ O
days _ _ O
Addr _ _ O
Val _ _ O
0 _ _ O
00 _ _ O
1 _ _ O
30 _ _ O
2 _ _ O
04 _ _ O
3 _ _ O
00 _ _ O
4 _ _ O
DE _ _ O
5 _ _ O
C0 _ _ O
6 _ _ O
EF _ _ O
7 _ _ O
BE _ _ O
8 _ _ O
6C _ _ O
9 _ _ O
34 _ _ O
A _ _ O
00 _ _ O
B _ _ O
01 _ _ O
C _ _ O
02 _ _ O
25 _ _ O

How _ _ O
much _ _ O
memory _ _ O
? _ _ O
● _ _ O
Each _ _ O
address _ _ O
refers _ _ O
to _ _ O
one _ _ O
byte _ _ O
. _ _ O
if _ _ O
your _ _ O
addresses _ _ O
are _ _ O
n _ _ O
bits _ _ O
long _ _ O
… _ _ O
how _ _ O
many _ _ O
bytes _ _ O
can _ _ O
your _ _ O
memory _ _ O
have _ _ O
? _ _ O
o _ _ O
2n _ _ O
B _ _ O
● _ _ O
machines _ _ O
with _ _ O
32-bit _ _ O
addresses _ _ O
can _ _ O
access _ _ O
232 _ _ O
B _ _ O
= _ _ O
4GiB _ _ O
of _ _ O
memory _ _ O
o _ _ O
with _ _ O
64-bit _ _ O
addresses _ _ O
… _ _ O
16EiB _ _ O
● _ _ O
Remember _ _ O
: _ _ O
o _ _ O
kibi _ _ O
, _ _ O
Mebi _ _ O
, _ _ O
Gibi _ _ O
, _ _ O
Tebi _ _ O
, _ _ O
Pebi _ _ O
, _ _ O
Exbi _ _ O
are _ _ O
powers _ _ O
of _ _ O
2 _ _ O
▪ _ _ O
kiB _ _ O
= _ _ O
210 _ _ O
, _ _ O
MiB _ _ O
= _ _ O
220 _ _ O
, _ _ O
GiB _ _ O
= _ _ O
230 _ _ O
etc _ _ O
. _ _ O
o _ _ O
kilo _ _ O
, _ _ O
mega _ _ O
, _ _ O
giga _ _ O
, _ _ O
tera _ _ O
, _ _ O
peta _ _ O
, _ _ O
exa _ _ O
are _ _ O
ostensibly _ _ O
powers _ _ O
of _ _ O
10 _ _ O
▪ _ _ O
kB _ _ O
= _ _ O
103 _ _ O
, _ _ O
MB _ _ O
= _ _ O
106 _ _ O
, _ _ O
GB _ _ O
= _ _ O
109 _ _ O
etc _ _ O
. _ _ O
26 _ _ O

Words _ _ O
, _ _ O
words _ _ O
, _ _ O
words _ _ O
● _ _ O
For _ _ O
most _ _ O
things _ _ O
, _ _ O
we _ _ O
want _ _ O
to _ _ O
use _ _ O
words _ _ O
o _ _ O
The _ _ O
" _ _ O
comfortable _ _ O
" _ _ O
integer _ _ O
size _ _ O
for _ _ O
the _ _ O
CPU _ _ O
o _ _ O
On _ _ O
this _ _ O
version _ _ O
of _ _ O
MIPS _ _ O
, _ _ O
it _ _ O
's _ _ O
32b _ _ O
( _ _ O
4B _ _ O
) _ _ O
● _ _ O
But _ _ O
our _ _ O
memory _ _ O
only _ _ O
holds _ _ O
bytes _ _ O
… _ _ O
● _ _ O
Combine _ _ O
multiple _ _ O
bytes _ _ O
into _ _ O
larger _ _ O
values _ _ O
o _ _ O
The _ _ O
CPU _ _ O
can _ _ O
handle _ _ O
this _ _ O
for _ _ O
us _ _ O
o _ _ O
But _ _ O
importantly _ _ O
, _ _ O
the _ _ O
data _ _ O
is _ _ O
still _ _ O
just _ _ O
bytes _ _ O
● _ _ O
When _ _ O
we _ _ O
talk _ _ O
about _ _ O
values _ _ O
bigger _ _ O
than _ _ O
a _ _ O
byte _ _ O
… _ _ O
o _ _ O
The _ _ O
address _ _ O
is _ _ O
the _ _ O
address _ _ O
of _ _ O
their _ _ O
first _ _ O
byte _ _ O
▪ _ _ O
The _ _ O
byte _ _ O
at _ _ O
the _ _ O
smallest _ _ O
address _ _ O
o _ _ O
So _ _ O
what _ _ O
are _ _ O
the _ _ O
addresses _ _ O
of _ _ O
the _ _ O
three _ _ O
words _ _ O
here _ _ O
? _ _ O
Addr _ _ O
Val _ _ O
0 _ _ O
00 _ _ O
1 _ _ O
30 _ _ O
2 _ _ O
04 _ _ O
3 _ _ O
00 _ _ O
4 _ _ O
DE _ _ O
5 _ _ O
C0 _ _ O
6 _ _ O
EF _ _ O
7 _ _ O
BE _ _ O
8 _ _ O
6C _ _ O
9 _ _ O
34 _ _ O
A _ _ O
00 _ _ O
B _ _ O
01 _ _ O
C _ _ O
02 _ _ O
27 _ _ O

Endianness _ _ O
28 _ _ O

A _ _ O
matter _ _ O
of _ _ O
perspective _ _ O
● _ _ O
let _ _ O
's _ _ O
say _ _ O
there _ _ O
's _ _ O
a _ _ O
word _ _ O
at _ _ O
address _ _ O
4 _ _ O
… _ _ O
made _ _ O
of _ _ O
4 _ _ O
bytes _ _ O
● _ _ O
wh…what _ _ O
word _ _ O
do _ _ O
those _ _ O
4 _ _ O
bytes _ _ O
represent _ _ O
? _ _ O
… _ _ O
is _ _ O
it _ _ O
0xDEC0EFBE _ _ O
? _ _ O
Addr _ _ O
Val _ _ O
... _ _ O
... _ _ O
7 _ _ O
DE _ _ O
6 _ _ O
C0 _ _ O
5 _ _ O
EF _ _ O
4 _ _ O
BE _ _ O
... _ _ O
... _ _ O
… _ _ O
is _ _ O
it _ _ O
0xBEEFC0DE _ _ O
? _ _ O
29 _ _ O

Endianness _ _ O
● _ _ O
when _ _ O
interpreting _ _ O
a _ _ O
sequence _ _ O
of _ _ O
bytes _ _ O
as _ _ O
larger _ _ O
values _ _ O
, _ _ O
endianness _ _ O
is _ _ O
the _ _ O
rule _ _ O
used _ _ O
to _ _ O
decide _ _ O
what _ _ O
order _ _ O
to _ _ O
put _ _ O
the _ _ O
bytes _ _ O
in _ _ O
little-endian _ _ O
means _ _ O
0 _ _ O
the _ _ O
“ _ _ O
LITTLE _ _ O
address _ _ O
“ _ _ O
DE _ _ O
contains _ _ O
the _ _ O
END-byte _ _ O
0xBEEFC0DE _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
big-endian _ _ O
means _ _ O
the _ _ O
“ _ _ O
BIG _ _ O
address _ _ O
" _ _ O
C0 _ _ O
EF _ _ O
BE _ _ O
contains _ _ O
the _ _ O
END-byte _ _ O
0xDEC0EFBE _ _ O
nothing _ _ O
to _ _ O
do _ _ O
with _ _ O
value _ _ O
of _ _ O
bytes _ _ O
, _ _ O
only _ _ O
order _ _ O
30 _ _ O

Which _ _ O
is _ _ O
better _ _ O
: _ _ O
little _ _ O
or _ _ O
big _ _ O
? _ _ O
● _ _ O
it _ _ O
does _ _ O
n't _ _ O
matter _ _ O
. _ _ O
* _ _ O
as _ _ O
long _ _ O
as _ _ O
you _ _ O
're _ _ O
consistent _ _ O
, _ _ O
it _ _ O
's _ _ O
fine _ _ O
● _ _ O
for _ _ O
political _ _ O
reasons _ _ O
, _ _ O
most _ _ O
computers _ _ O
today _ _ O
are _ _ O
little-endian _ _ O
● _ _ O
but _ _ O
endianness _ _ O
pops _ _ O
up _ _ O
whenever _ _ O
you _ _ O
have _ _ O
sequences _ _ O
of _ _ O
bytes _ _ O
: _ _ O
o _ _ O
like _ _ O
in _ _ O
files _ _ O
o _ _ O
or _ _ O
networks _ _ O
o _ _ O
or _ _ O
hardware _ _ O
buses _ _ O
o _ _ O
or _ _ O
… _ _ O
memory _ _ O
! _ _ O
● _ _ O
which _ _ O
one _ _ O
is _ _ O
MIPS _ _ O
? _ _ O
o _ _ O
it _ _ O
's _ _ O
bi-endian _ _ O
, _ _ O
meaning _ _ O
it _ _ O
can _ _ O
be _ _ O
configured _ _ O
to _ _ O
work _ _ O
either _ _ O
way _ _ O
o _ _ O
but _ _ O
MARS _ _ O
uses _ _ O
the _ _ O
endianness _ _ O
of _ _ O
the _ _ O
computer _ _ O
it _ _ O
's _ _ O
running _ _ O
on _ _ O
▪ _ _ O
so _ _ O
little-endian _ _ O
for _ _ O
virtually _ _ O
everyone _ _ O
– _ _ O
cause _ _ O
x86 _ _ O
– _ _ O
Apple _ _ O
sillycone _ _ O
will _ _ O
use _ _ O
a _ _ O
bi-endien _ _ O
architecture _ _ O
: _ _ O
ARM _ _ O
architecture _ _ O
( _ _ O
x86 _ _ O
) _ _ O
* _ _ O
big _ _ O
endian _ _ O
is _ _ O
better _ _ O
31 _ _ O

What _ _ O
DOESN _ _ O
' _ _ O
T _ _ O
endianness _ _ O
affect _ _ O
? _ _ O
× _ _ O
the _ _ O
arrangement _ _ O
of _ _ O
the _ _ O
bits _ _ O
within _ _ O
a _ _ O
byte _ _ O
o _ _ O
it _ _ O
just _ _ O
changes _ _ O
meaning _ _ O
of _ _ O
order _ _ O
of _ _ O
the _ _ O
bytes _ _ O
▪ _ _ O
note _ _ O
the _ _ O
bytes _ _ O
are _ _ O
still _ _ O
DE _ _ O
, _ _ O
C0 _ _ O
etc _ _ O
. _ _ O
× _ _ O
1-byte _ _ O
values _ _ O
, _ _ O
arrays _ _ O
of _ _ O
bytes _ _ O
, _ _ O
ASCII _ _ O
strings _ _ O
… _ _ O
o _ _ O
single _ _ O
bytes _ _ O
do _ _ O
n’t _ _ O
care _ _ O
about _ _ O
endianness _ _ O
at _ _ O
all _ _ O
× _ _ O
the _ _ O
ordering _ _ O
of _ _ O
bytes _ _ O
inside _ _ O
the _ _ O
CPU _ _ O
o _ _ O
there _ _ O
's _ _ O
no _ _ O
need _ _ O
for _ _ O
e.g. _ _ O
" _ _ O
big-endian _ _ O
" _ _ O
arithmetic _ _ O
o _ _ O
the _ _ O
CPU _ _ O
works _ _ O
with _ _ O
whole _ _ O
words _ _ O
● _ _ O
endianness _ _ O
only _ _ O
affects _ _ O
moving _ _ O
/ _ _ O
splitting _ _ O
data _ _ O
: _ _ O
o _ _ O
larger _ _ O
than _ _ O
single _ _ O
bytes _ _ O
o _ _ O
between _ _ O
the _ _ O
CPU _ _ O
and _ _ O
memory _ _ O
o _ _ O
or _ _ O
between _ _ O
multiple _ _ O
computers _ _ O
0xBEEFC0DE _ _ O
0xED0CFEEB _ _ O
0xDEC0EFBE _ _ O
l _ _ O
l _ _ O
e _ _ O
H _ _ O
o _ _ O
H _ _ O
e _ _ O
l _ _ O
l _ _ O
o _ _ O
32 _ _ O

Summary _ _ O
33 _ _ O



