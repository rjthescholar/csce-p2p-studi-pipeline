['train_set', 'labeled']|cs1541|lec2.2_pipelining
-DOCSTART- -X- -X- O

Processor _ _ B-Concept
Pipelining _ _ I-Concept
CS _ _ O
1541 _ _ O
Wonsun _ _ O
Ahn _ _ O

Pipelining _ _ B-Concept
Basics _ _ O
2 _ _ O

Improving _ _ O
Washer _ _ O
/ _ _ O
Dryer _ _ O
/ _ _ O
Closet _ _ O
Utilization _ _ O
● _ _ O
If _ _ O
you _ _ O
work _ _ O
on _ _ O
loads _ _ O
of _ _ O
laundry _ _ O
one _ _ O
by _ _ O
one _ _ O
, _ _ O
you _ _ O
only _ _ O
get _ _ O
~33 _ _ O
% _ _ O
utilization _ _ O
● _ _ O
If _ _ O
you _ _ O
form _ _ O
an _ _ O
“ _ _ O
assembly _ _ O
line _ _ O
” _ _ O
, _ _ O
you _ _ O
achieve _ _ O
~100 _ _ O
% _ _ O
utilization _ _ O
! _ _ O
3 _ _ O

Multi-cycle _ _ O
instruction _ _ O
execution _ _ O
● _ _ O
Let _ _ O
's _ _ O
watch _ _ O
how _ _ O
an _ _ O
instruction _ _ O
flows _ _ O
through _ _ O
the _ _ O
datapath _ _ O
. _ _ O
add _ _ O
Memory _ _ B-Concept
Clock _ _ O
! _ _ O
ID _ _ B-Concept
Set _ _ O
all _ _ O
control _ _ O
signals _ _ O
... _ _ O
Ins _ _ B-Concept
. _ _ I-Concept
Decoder _ _ I-Concept
IF _ _ B-Concept
Clock _ _ B-Concept
! _ _ O
Register _ _ B-Concept
File _ _ I-Concept
EX _ _ B-Concept
Clock _ _ B-Concept
! _ _ O
MEM _ _ B-Concept
Add _ _ O
... _ _ O
ALU _ _ B-Concept
Memory _ _ B-Concept
Clock _ _ B-Concept
! _ _ O
Data _ _ O
flows _ _ O
back _ _ O
to _ _ O
registers _ _ O
... _ _ O
WB _ _ B-Concept
4 _ _ O

Pipelined _ _ B-Concept
instruction _ _ O
execution _ _ O
● _ _ O
Pipelining _ _ B-Concept
allows _ _ O
one _ _ O
instruction _ _ O
to _ _ O
be _ _ O
fetched _ _ O
each _ _ O
cycle _ _ O
! _ _ O
add _ _ O
sub _ _ O
sw _ _ O
Memory _ _ B-Concept
ID _ _ B-Concept
Ins _ _ B-Concept
. _ _ I-Concept
Decoder _ _ I-Concept
IF _ _ B-Concept
Register _ _ B-Concept
File _ _ I-Concept
EX _ _ B-Concept
ALU _ _ B-Concept
MEM _ _ B-Concept
Memory _ _ B-Concept
WB _ _ O
5 _ _ O

Pipelining _ _ B-Concept
Timeline _ _ O
● _ _ O
This _ _ O
type _ _ O
of _ _ O
parallelism _ _ B-Concept
is _ _ O
called _ _ O
pipelined _ _ B-Concept
parallelism _ _ I-Concept
. _ _ O
Cycle _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
5 _ _ O
add _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t2 _ _ O
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
add _ _ O
t3 _ _ O
, _ _ O
t4 _ _ O
, _ _ O
t5 _ _ O
add _ _ O
s0 _ _ O
, _ _ O
s1 _ _ O
, _ _ O
s2 _ _ O
add _ _ O
s3 _ _ O
, _ _ O
s4 _ _ O
, _ _ O
s5 _ _ O
6 _ _ O
7 _ _ O
8 _ _ O
WB _ _ B-Concept
6 _ _ O

A _ _ O
Pipelined _ _ B-Concept
Implementation _ _ O
is _ _ O
even _ _ O
Faster _ _ O
! _ _ O
● _ _ O
Again _ _ O
each _ _ O
instruction _ _ O
takes _ _ O
different _ _ O
number _ _ O
of _ _ O
cycles _ _ B-Concept
to _ _ O
complete _ _ O
o _ _ O
lw _ _ O
takes _ _ O
5 _ _ O
cycles _ _ B-Concept
: _ _ O
IF _ _ B-Concept
/ _ _ O
ID _ _ B-Concept
/ _ _ O
EX _ _ B-Concept
/ _ _ O
MEM _ _ B-Concept
/ _ _ O
WB _ _ B-Concept
o _ _ O
add _ _ O
takes _ _ O
4 _ _ O
cycles _ _ B-Concept
: _ _ O
IF _ _ B-Concept
/ _ _ O
ID _ _ B-Concept
/ _ _ O
EX _ _ B-Concept
/ _ _ O
WB _ _ B-Concept
● _ _ O
If _ _ O
each _ _ O
stage _ _ O
takes _ _ O
1 _ _ O
ns _ _ O
each _ _ O
: _ _ O
o _ _ O
lw _ _ O
takes _ _ O
5 _ _ O
ns _ _ O
and _ _ O
add _ _ O
takes _ _ O
4 _ _ O
ns _ _ O
Q _ _ O
) _ _ O
The _ _ O
average _ _ O
instruction _ _ O
execution _ _ O
time _ _ O
( _ _ O
given _ _ O
100 _ _ O
instructions _ _ O
) _ _ O
? _ _ O
A _ _ O
) _ _ O
( _ _ O
99 _ _ O
ns _ _ O
+ _ _ O
5 _ _ O
ns _ _ O
) _ _ O
/ _ _ O
100 _ _ O
= _ _ O
1.04 _ _ O
ns _ _ O
o _ _ O
Assuming _ _ O
last _ _ O
instruction _ _ O
is _ _ O
a _ _ O
lw _ _ O
( _ _ O
a _ _ O
5-cycle _ _ O
instruction _ _ O
) _ _ O
o _ _ O
A _ _ O
~5X _ _ O
speed _ _ O
up _ _ O
from _ _ O
single _ _ O
cycle _ _ O
! _ _ O
7 _ _ O

Pipelined _ _ B-Concept
vs. _ _ O
Multi-cycle _ _ B-Concept
vs. _ _ O
Single-cycle _ _ B-Concept
● _ _ O
What _ _ O
happened _ _ O
to _ _ O
the _ _ O
three _ _ O
components _ _ O
of _ _ O
performance _ _ B-Concept
? _ _ O
instructions _ _ O
X _ _ O
program _ _ O
cycles _ _ O
instruction _ _ O
Architecture _ _ O
Instructions _ _ O
CPI _ _ B-Concept
Cycle _ _ B-Concept
Time _ _ I-Concept
( _ _ O
1 _ _ O
/ _ _ O
F _ _ O
) _ _ O
Single-cycle _ _ B-Concept
Same _ _ O
1 _ _ O
5 _ _ O
ns _ _ O
Multi-cycle _ _ B-Concept
Same _ _ O
4~5 _ _ O
1 _ _ O
ns _ _ O
Pipelined _ _ B-Concept
Same _ _ O
1 _ _ O
1 _ _ O
ns _ _ O
X _ _ O
seconds _ _ O
cycle _ _ O
● _ _ O
Compared _ _ O
to _ _ O
single-cycle _ _ B-Concept
, _ _ O
pipelining _ _ B-Concept
improves _ _ O
clock _ _ B-Concept
cycle _ _ I-Concept
time _ _ I-Concept
o _ _ O
Or _ _ O
in _ _ O
other _ _ O
words _ _ O
CPU _ _ O
clock _ _ B-Concept
frequency _ _ I-Concept
o _ _ O
The _ _ O
deeper _ _ O
the _ _ O
pipeline _ _ B-Concept
, _ _ O
the _ _ O
higher _ _ O
the _ _ O
frequency _ _ B-Concept
will _ _ O
be _ _ O
* _ _ O
Caveat _ _ O
: _ _ O
latch _ _ O
delay _ _ O
and _ _ O
unbalanced _ _ O
stages _ _ O
can _ _ O
increase _ _ O
cycle _ _ O
time _ _ O
8 _ _ O

How _ _ O
about _ _ O
the _ _ O
control _ _ B-Concept
signals _ _ I-Concept
? _ _ O
Memory _ _ B-Concept
Register _ _ B-Concept
File _ _ I-Concept
ALU _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
/ _ _ O
WB _ _ B-Concept
ID _ _ B-Concept
Ins _ _ B-Concept
. _ _ I-Concept
Decoder _ _ I-Concept
IF _ _ B-Concept
EX _ _ B-Concept
/ _ _ O
MEM _ _ B-Concept
/ _ _ O
WB _ _ B-Concept
● _ _ O
A _ _ O
new _ _ O
instruction _ _ O
is _ _ O
decoded _ _ B-Concept
at _ _ O
every _ _ O
cycle _ _ B-Concept
! _ _ O
● _ _ O
Control _ _ B-Concept
signals _ _ I-Concept
must _ _ O
be _ _ O
passed _ _ O
along _ _ O
with _ _ O
the _ _ O
data _ _ O
at _ _ O
each _ _ O
stage _ _ O
Memory _ _ B-Concept
WB _ _ B-Concept
9 _ _ O

Pipeline _ _ B-Concept
Hazards _ _ I-Concept
10 _ _ O

Pipeline _ _ B-Concept
Hazards _ _ I-Concept
● _ _ O
For _ _ O
pipelined _ _ B-Concept
CPUs _ _ O
, _ _ O
we _ _ O
said _ _ O
CPI _ _ O
is _ _ O
practically _ _ O
1 _ _ O
o _ _ O
But _ _ O
that _ _ O
depends _ _ O
entirely _ _ O
on _ _ O
having _ _ O
the _ _ O
pipeline _ _ B-Concept
filled _ _ O
o _ _ O
In _ _ O
real _ _ O
life _ _ O
, _ _ O
there _ _ O
are _ _ O
hazards _ _ B-Concept
that _ _ O
prevent _ _ O
100 _ _ O
% _ _ O
utilization _ _ O
● _ _ O
Pipeline _ _ B-Concept
Hazard _ _ I-Concept
o _ _ O
When _ _ O
the _ _ O
next _ _ O
instruction _ _ O
can _ _ O
not _ _ O
execute _ _ O
in _ _ O
the _ _ O
following _ _ O
cycle _ _ B-Concept
o _ _ O
Hazards _ _ B-Concept
introduce _ _ O
bubbles _ _ B-Concept
( _ _ O
delays _ _ B-Concept
) _ _ O
into _ _ O
the _ _ O
pipeline _ _ B-Concept
timeline _ _ O
● _ _ O
Architects _ _ O
have _ _ O
some _ _ O
tricks _ _ O
up _ _ O
their _ _ O
sleeves _ _ O
to _ _ O
avoid _ _ O
hazards _ _ B-Concept
● _ _ O
But _ _ O
first _ _ O
let _ _ O
’s _ _ O
briefly _ _ O
talk _ _ O
about _ _ O
the _ _ O
three _ _ O
types _ _ O
of _ _ O
hazards _ _ B-Concept
: _ _ O
Structural _ _ B-Concept
hazard _ _ I-Concept
, _ _ O
Data _ _ B-Concept
hazard _ _ I-Concept
, _ _ O
Control _ _ B-Concept
Hazard _ _ I-Concept
11 _ _ O

Structural _ _ B-Concept
Hazards _ _ I-Concept
● _ _ O
Two _ _ O
instructions _ _ O
need _ _ O
to _ _ O
use _ _ O
the _ _ O
same _ _ O
hardware _ _ O
at _ _ O
the _ _ O
same _ _ O
time _ _ O
. _ _ O
Cycle _ _ B-Concept
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
5 _ _ O
lw _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$0 _ _ O
) _ _ O
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
lw _ _ O
t1 _ _ O
, _ _ O
4 _ _ O
( _ _ O
$0 _ _ O
) _ _ O
lw _ _ O
t2 _ _ O
, _ _ O
8 _ _ O
( _ _ O
$0 _ _ O
) _ _ O
lw _ _ O
t3 _ _ O
, _ _ O
12 _ _ O
( _ _ O
$0 _ _ O
) _ _ O
6 _ _ O
7 _ _ O
8 _ _ O
WB _ _ B-Concept
12 _ _ O

Data _ _ B-Concept
Hazards _ _ I-Concept
● _ _ O
An _ _ O
instruction _ _ O
depends _ _ O
on _ _ O
the _ _ O
output _ _ O
of _ _ O
a _ _ O
previous _ _ O
one _ _ O
. _ _ O
Cycle _ _ B-Concept
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
5 _ _ O
add _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t2 _ _ O
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
sub _ _ O
s0 _ _ O
, _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
6 _ _ O
7 _ _ O
8 _ _ O
WB _ _ B-Concept
● _ _ O
sub _ _ O
must _ _ O
wait _ _ O
until _ _ O
add _ _ O
's _ _ O
WB _ _ B-Concept
phase _ _ O
is _ _ O
over _ _ O
before _ _ O
doing _ _ O
its _ _ O
ID _ _ B-Concept
phase _ _ O
add _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t2 _ _ O
sub _ _ O
s0 _ _ O
, _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
IF _ _ B-Concept
bubble _ _ B-Concept
bubble _ _ B-Concept
bubble _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
13 _ _ O

Control _ _ B-Concept
Hazards _ _ I-Concept
● _ _ O
You _ _ O
do _ _ O
n't _ _ O
know _ _ O
the _ _ O
outcome _ _ O
of _ _ O
a _ _ O
conditional _ _ O
branch _ _ O
. _ _ O
Cycle _ _ B-Concept
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
5 _ _ O
beq _ _ O
t0 _ _ O
, _ _ O
$0 _ _ O
, _ _ O
end _ _ O
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
add _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t2 _ _ O
6 _ _ O
7 _ _ O
8 _ _ O
WB _ _ B-Concept
● _ _ O
add _ _ O
must _ _ O
wait _ _ O
until _ _ O
beq _ _ O
’s _ _ O
EX _ _ B-Concept
phase _ _ O
is _ _ O
over _ _ O
before _ _ O
its _ _ O
IF _ _ B-Concept
phase _ _ O
beq _ _ O
t0 _ _ O
, _ _ O
$0 _ _ O
, _ _ O
end _ _ O
add _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t2 _ _ O
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
bubble _ _ B-Concept
bubble _ _ B-Concept
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
WB _ _ B-Concept
14 _ _ O

Dealing _ _ O
with _ _ O
Hazards _ _ B-Concept
● _ _ O
Pipeline _ _ B-Concept
must _ _ O
be _ _ O
controlled _ _ O
so _ _ O
that _ _ O
hazards _ _ B-Concept
do _ _ O
n’t _ _ O
cause _ _ O
malfunction _ _ O
● _ _ O
Who _ _ O
is _ _ O
in _ _ O
charge _ _ O
of _ _ O
that _ _ O
? _ _ O
You _ _ O
have _ _ O
a _ _ O
choice _ _ O
. _ _ O
1 _ _ O
. _ _ O
Compiler _ _ B-Concept
can _ _ O
avoid _ _ O
hazards _ _ B-Concept
by _ _ O
inserting _ _ O
nops _ _ B-Concept
§ _ _ O
Insert _ _ O
a _ _ O
nop _ _ B-Concept
where _ _ O
compiler _ _ O
thinks _ _ O
a _ _ O
hazard _ _ B-Concept
would _ _ O
happen _ _ O
2 _ _ O
. _ _ O
CPU _ _ O
can _ _ O
internally _ _ O
avoid _ _ O
hazards _ _ B-Concept
using _ _ O
a _ _ O
hazard _ _ B-Concept
detection _ _ I-Concept
unit _ _ I-Concept
§ _ _ O
If _ _ O
structural _ _ B-Concept
/ _ _ O
data _ _ B-Concept
hazard _ _ I-Concept
, _ _ O
pipeline _ _ B-Concept
stalled _ _ B-Concept
until _ _ O
resolved _ _ O
§ _ _ O
If _ _ O
control _ _ B-Concept
hazard _ _ I-Concept
, _ _ O
pipeline _ _ B-Concept
flushed _ _ B-Concept
of _ _ O
wrong _ _ O
path _ _ O
instructions _ _ O
15 _ _ O

Compiler _ _ O
avoiding _ _ O
a _ _ O
data _ _ B-Concept
hazard _ _ I-Concept
● _ _ O
The _ _ O
nops _ _ B-Concept
flow _ _ O
through _ _ O
the _ _ O
pipeline _ _ B-Concept
not _ _ O
doing _ _ O
any _ _ O
work _ _ O
Cycle _ _ B-Concept
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
5 _ _ O
add _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t2 _ _ O
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
bubble _ _ B-Concept
bubble _ _ B-Concept
bubble _ _ B-Concept
bubble _ _ B-Concept
bubble _ _ B-Concept
bubble _ _ B-Concept
bubble _ _ B-Concept
bubble _ _ B-Concept
bubble _ _ B-Concept
bubble _ _ B-Concept
bubble _ _ B-Concept
bubble _ _ B-Concept
bubble _ _ B-Concept
bubble _ _ B-Concept
bubble _ _ B-Concept
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
nop _ _ B-Concept
nop _ _ B-Concept
nop _ _ B-Concept
sub _ _ O
s0 _ _ O
, _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
6 _ _ O
7 _ _ O
8 _ _ O
16 _ _ O

Compiler _ _ O
avoiding _ _ O
a _ _ O
control _ _ B-Concept
hazard _ _ I-Concept
● _ _ O
The _ _ O
nops _ _ B-Concept
give _ _ O
time _ _ O
for _ _ O
condition _ _ O
to _ _ O
resolve _ _ O
before _ _ O
instruction _ _ B-Concept
fetch _ _ I-Concept
Cycle _ _ B-Concept
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
5 _ _ O
beq _ _ O
t0 _ _ O
, _ _ O
$0 _ _ O
, _ _ O
end _ _ O
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
bubble _ _ B-Concept
bubble _ _ B-Concept
bubble _ _ B-Concept
bubble _ _ B-Concept
bubble _ _ B-Concept
bubble _ _ B-Concept
bubble _ _ B-Concept
bubble _ _ B-Concept
bubble _ _ B-Concept
bubble _ _ B-Concept
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
nop _ _ B-Concept
nop _ _ B-Concept
add _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t2 _ _ O
6 _ _ O
7 _ _ O
8 _ _ O
WB _ _ B-Concept
17 _ _ O

Hazard _ _ B-Concept
Detection _ _ I-Concept
Unit _ _ I-Concept
Creates _ _ O
bubbles _ _ B-Concept
by _ _ O
zeroing _ _ O
all _ _ O
control _ _ B-Concept
signals _ _ I-Concept
, _ _ O
thereby _ _ O
creating _ _ O
a _ _ O
nop _ _ B-Concept
instruction _ _ O
Freezes _ _ O
IF _ _ B-Concept
and _ _ O
ID _ _ B-Concept
until _ _ O
hazard _ _ B-Concept
is _ _ O
resolved _ _ O
18 _ _ O

Hazard _ _ B-Concept
Detection _ _ I-Concept
Unit _ _ I-Concept
avoiding _ _ O
a _ _ O
data _ _ B-Concept
hazard _ _ I-Concept
● _ _ O
Suppose _ _ O
we _ _ O
have _ _ O
an _ _ O
add _ _ O
that _ _ O
depends _ _ O
on _ _ O
an _ _ O
lw _ _ O
. _ _ O
sub _ _ O
add _ _ O
lw _ _ O
ID _ _ B-Concept
Ins _ _ B-Concept
. _ _ I-Concept
Decoder _ _ I-Concept
IF _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
WAIT _ _ O
! _ _ O
Memory _ _ B-Concept
Register _ _ B-Concept
File _ _ I-Concept
ALU _ _ B-Concept
Memory _ _ B-Concept
WB _ _ B-Concept
19 _ _ O

Structural _ _ B-Concept
/ _ _ I-Concept
Data _ _ I-Concept
Hazards _ _ I-Concept
cause _ _ O
stalls _ _ B-Concept
● _ _ O
If _ _ O
HDU _ _ B-Concept
detects _ _ O
a _ _ O
structural _ _ B-Concept
or _ _ I-Concept
data _ _ I-Concept
hazard _ _ I-Concept
, _ _ O
it _ _ O
does _ _ O
the _ _ O
following _ _ O
: _ _ O
o _ _ O
It _ _ O
stops _ _ O
fetching _ _ B-Concept
instructions _ _ O
( _ _ O
does _ _ O
n't _ _ O
update _ _ O
the _ _ O
PC _ _ B-Concept
) _ _ O
. _ _ O
o _ _ O
It _ _ O
stops _ _ O
clocking _ _ B-Concept
the _ _ O
pipeline _ _ B-Concept
registers _ _ O
for _ _ O
the _ _ O
stalled _ _ B-Concept
stages _ _ O
. _ _ O
o _ _ O
The _ _ O
stages _ _ O
after _ _ O
the _ _ O
stalled _ _ B-Concept
instructions _ _ O
are _ _ O
filled _ _ O
with _ _ O
nops _ _ B-Concept
. _ _ O
§ _ _ O
Change _ _ O
control _ _ B-Concept
signals _ _ I-Concept
to _ _ O
0 _ _ O
using _ _ O
the _ _ O
mux _ _ O
! _ _ O
o _ _ O
In _ _ O
this _ _ O
way _ _ O
, _ _ O
all _ _ O
following _ _ O
instructions _ _ O
will _ _ O
be _ _ O
stalled _ _ B-Concept
● _ _ O
When _ _ O
structural _ _ B-Concept
or _ _ I-Concept
data _ _ I-Concept
hazard _ _ I-Concept
is _ _ O
resolved _ _ O
o _ _ O
HDU _ _ B-Concept
resumes _ _ O
instruction _ _ O
fetching _ _ B-Concept
and _ _ O
clocking _ _ B-Concept
of _ _ O
stalled _ _ B-Concept
stages _ _ O
● _ _ O
But _ _ O
what _ _ O
about _ _ O
control _ _ B-Concept
hazards _ _ I-Concept
? _ _ O
o _ _ O
Instructions _ _ O
in _ _ O
wrong _ _ O
path _ _ O
are _ _ O
already _ _ O
in _ _ O
pipeline _ _ B-Concept
! _ _ O
o _ _ O
Need _ _ O
to _ _ O
flush _ _ B-Concept
these _ _ O
instructions _ _ O
20 _ _ O

Control _ _ B-Concept
Hazard _ _ I-Concept
Example _ _ O
● _ _ O
Supposed _ _ O
we _ _ O
had _ _ O
this _ _ O
for _ _ O
loop _ _ O
followed _ _ O
by _ _ O
printf _ _ O
( _ _ O
“done _ _ O
” _ _ O
) _ _ O
: _ _ O
for _ _ O
( _ _ O
s0 _ _ O
= _ _ O
0 _ _ O
.. _ _ O
10 _ _ O
) _ _ O
print _ _ O
( _ _ O
s0 _ _ O
) _ _ O
; _ _ O
printf _ _ O
( _ _ O
"done _ _ O
" _ _ O
) _ _ O
; _ _ O
By _ _ O
the _ _ O
time _ _ O
s0 _ _ O
, _ _ O
10 _ _ O
are _ _ O
compared _ _ O
at _ _ O
blt _ _ O
EX _ _ B-Concept
stage _ _ O
, _ _ O
the _ _ O
CPU _ _ O
would _ _ O
have _ _ O
already _ _ O
fetched _ _ B-Concept
la _ _ O
and _ _ O
jal _ _ O
! _ _ O
li _ _ O
s0 _ _ O
, _ _ O
0 _ _ O
top _ _ O
: _ _ O
move _ _ O
a0 _ _ O
, _ _ O
s0 _ _ O
jal _ _ O
print _ _ O
addi _ _ O
s0 _ _ O
, _ _ O
s0 _ _ O
, _ _ O
1 _ _ O
blt _ _ O
s0 _ _ O
, _ _ O
10 _ _ O
, _ _ O
top _ _ O
la _ _ O
jal _ _ O
a0 _ _ O
, _ _ O
done_msg _ _ O
printf _ _ O
21 _ _ O

What _ _ O
's _ _ O
a _ _ O
flush _ _ B-Concept
? _ _ O
● _ _ O
A _ _ O
pipeline _ _ B-Concept
flush _ _ I-Concept
removes _ _ O
all _ _ O
wrong _ _ O
path _ _ O
instructions _ _ O
from _ _ O
pipeline _ _ B-Concept
Time _ _ O
0 _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
blt _ _ O
s0 _ _ O
, _ _ O
10 _ _ O
, _ _ O
top _ _ O
IF _ _ B-Concept
ID _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
IF _ _ B-Concept
ID _ _ B-Concept
P _ _ O
OW _ _ O
IF _ _ B-Concept
BO _ _ O
la _ _ O
a0 _ _ O
, _ _ O
done_msg _ _ O
jal _ _ O
printf _ _ O
s0 _ _ O
< _ _ O
10 _ _ O
... _ _ O
OOPS _ _ O
! _ _ O
move _ _ O
a0 _ _ O
, _ _ O
s0 _ _ O
5 _ _ O
6 _ _ O
7 _ _ O
EX _ _ B-Concept
MEM _ _ B-Concept
WB _ _ B-Concept
OM _ _ O
IF _ _ B-Concept
ID _ _ B-Concept
22 _ _ O

Hazard _ _ B-Concept
Detection _ _ I-Concept
Unit _ _ I-Concept
avoiding _ _ O
a _ _ O
control _ _ B-Concept
hazard _ _ I-Concept
● _ _ O
Let _ _ O
's _ _ O
watch _ _ O
the _ _ O
previous _ _ O
example _ _ O
. _ _ O
move _ _ O
blt _ _ O
jal _ _ O
la _ _ O
Memory _ _ B-Concept
ID _ _ B-Concept
nop _ _ B-Concept
Ins _ _ B-Concept
. _ _ I-Concept
Decoder _ _ I-Concept
IF _ _ B-Concept
EX _ _ B-Concept
MEM _ _ B-Concept
nop _ _ B-Concept
Register _ _ B-Concept
File _ _ I-Concept
ALU _ _ B-Concept
Memory _ _ B-Concept
WB _ _ B-Concept
23 _ _ O

Control _ _ O
Hazards _ _ O
cause _ _ O
flushes _ _ B-Concept
● _ _ O
If _ _ O
a _ _ O
control _ _ B-Concept
hazard _ _ I-Concept
is _ _ O
detected _ _ O
due _ _ O
to _ _ O
a _ _ O
branch _ _ O
instruction _ _ O
: _ _ O
o _ _ O
Any _ _ O
" _ _ O
newer _ _ O
" _ _ O
instructions _ _ O
( _ _ O
those _ _ O
already _ _ O
in _ _ O
the _ _ O
pipeline _ _ B-Concept
) _ _ O
→ _ _ O
transformed _ _ O
into _ _ O
nops _ _ B-Concept
. _ _ O
o _ _ O
Any _ _ O
" _ _ O
older _ _ O
" _ _ O
instructions _ _ O
( _ _ O
those _ _ O
that _ _ O
came _ _ O
BEFORE _ _ O
the _ _ O
branch _ _ O
) _ _ O
→ _ _ O
left _ _ O
alone _ _ O
to _ _ O
finish _ _ O
executing _ _ O
as _ _ O
normal _ _ O
. _ _ O
24 _ _ O

Performance _ _ O
penalty _ _ O
of _ _ O
pipeline _ _ O
stalls _ _ O
● _ _ O
Remember _ _ O
the _ _ O
three _ _ O
components _ _ O
of _ _ O
performance _ _ O
: _ _ O
instructions _ _ O
X _ _ O
program _ _ O
cycles _ _ B-Concept
instruction _ _ O
X _ _ O
seconds _ _ O
cycle _ _ O
Architecture _ _ O
Instructions _ _ O
CPI _ _ B-Concept
Cycle _ _ O
Time _ _ O
( _ _ O
1 _ _ O
/ _ _ O
F _ _ O
) _ _ O
Single-cycle _ _ B-Concept
Same _ _ O
1 _ _ O
5 _ _ O
ns _ _ O
Ideal _ _ B-Concept
5-stage _ _ I-Concept
pipeline _ _ I-Concept
Same _ _ O
1 _ _ O
1 _ _ O
ns _ _ O
Pipeline _ _ B-Concept
w _ _ O
/ _ _ O
stalls _ _ B-Concept
Same _ _ O
2 _ _ O
1 _ _ O
ns _ _ O
● _ _ O
Pipelining _ _ B-Concept
increases _ _ O
clock _ _ B-Concept
frequency _ _ I-Concept
proportionate _ _ O
to _ _ O
depth _ _ O
● _ _ O
But _ _ O
stalls _ _ B-Concept
increase _ _ O
CPI _ _ B-Concept
( _ _ O
cycles _ _ B-Concept
per _ _ I-Concept
instruction _ _ I-Concept
) _ _ O
o _ _ O
If _ _ O
stalls _ _ B-Concept
prevent _ _ O
new _ _ O
instructions _ _ O
from _ _ O
being _ _ O
fetched _ _ B-Concept
half _ _ O
the _ _ O
time _ _ O
, _ _ O
the _ _ O
CPU _ _ O
will _ _ O
have _ _ O
a _ _ O
CPI _ _ B-Concept
of _ _ O
2 _ _ O
→ _ _ O
Only _ _ O
2.5X _ _ O
speed _ _ O
up _ _ O
( _ _ O
instead _ _ O
of _ _ O
5X _ _ O
) _ _ O
● _ _ O
We _ _ O
’d _ _ O
like _ _ O
to _ _ O
avoid _ _ O
this _ _ O
penalty _ _ O
if _ _ O
possible _ _ O
! _ _ O
25 _ _ O

Compiler _ _ O
nops _ _ B-Concept
vs. _ _ O
CPU _ _ O
Hazard _ _ B-Concept
Detection _ _ I-Concept
Unit _ _ I-Concept
● _ _ O
Limitations _ _ O
of _ _ O
compiler _ _ O
nops _ _ B-Concept
o _ _ O
Compiler _ _ O
must _ _ O
make _ _ O
assumptions _ _ O
about _ _ O
processor _ _ O
design _ _ O
§ _ _ O
That _ _ O
means _ _ O
processor _ _ O
design _ _ O
must _ _ O
become _ _ O
part _ _ O
of _ _ O
ISA _ _ O
§ _ _ O
What _ _ O
if _ _ O
that _ _ O
design _ _ O
is _ _ O
no _ _ O
longer _ _ O
ideal _ _ O
in _ _ O
future _ _ O
generations _ _ O
? _ _ O
o _ _ O
Length _ _ O
of _ _ O
MEM _ _ B-Concept
stage _ _ O
is _ _ O
very _ _ O
hard _ _ O
to _ _ O
predict _ _ O
by _ _ O
the _ _ O
compiler _ _ O
§ _ _ O
Until _ _ O
now _ _ O
we _ _ O
assumed _ _ O
MEM _ _ B-Concept
takes _ _ O
a _ _ O
uniform _ _ O
one _ _ O
cycle _ _ B-Concept
§ _ _ O
But _ _ O
remember _ _ O
what _ _ O
we _ _ O
said _ _ O
about _ _ O
the _ _ O
Memory _ _ B-Concept
Wall _ _ I-Concept
? _ _ O
§ _ _ O
MEM _ _ B-Concept
is _ _ O
n’t _ _ O
uniform _ _ O
really _ _ O
and _ _ O
sometimes _ _ O
hundreds _ _ O
of _ _ O
cycles _ _ B-Concept
● _ _ O
But _ _ O
compiler _ _ O
nops _ _ B-Concept
is _ _ O
very _ _ O
energy-efficient _ _ O
o _ _ O
Hazard _ _ B-Concept
Detection _ _ I-Concept
Unit _ _ I-Concept
can _ _ O
be _ _ O
power _ _ O
hungry _ _ O
§ _ _ O
A _ _ O
lot _ _ O
of _ _ O
long _ _ O
wires _ _ O
controlling _ _ O
remote _ _ O
parts _ _ O
of _ _ O
the _ _ O
CPU _ _ O
§ _ _ O
Adds _ _ O
to _ _ O
the _ _ O
Power _ _ B-Concept
Wall _ _ I-Concept
problem _ _ O
o _ _ O
Compiler _ _ O
scheduling _ _ O
via _ _ O
nops _ _ B-Concept
removes _ _ O
need _ _ O
for _ _ O
HDU _ _ B-Concept
26 _ _ O


