unlabeled|cs0007|lec06
-DOCSTART- -X- -X- O

CS _ _ O
0007 _ _ O
: _ _ O
Introduction _ _ O
to _ _ O
Java _ _ O
Lecture _ _ O
6 _ _ O
Nathan _ _ O
Ong _ _ O
University _ _ O
of _ _ O
Pittsburgh _ _ O
September _ _ O
20 _ _ O
, _ _ O
2016 _ _ O

Even _ _ O
more _ _ O
API _ _ O
for _ _ O
your _ _ O
first _ _ O
Object _ _ O
SCANNERS _ _ O

Scanner _ _ O

What _ _ O
is _ _ O
a _ _ O
Scanner _ _ O
? _ _ O
• _ _ O
Retrieves _ _ O
input _ _ O
• _ _ O
Can _ _ O
take _ _ O
input _ _ O
from _ _ O
a _ _ O
file _ _ O
, _ _ O
an _ _ O
input _ _ O
stream _ _ O
( _ _ O
console _ _ O
, _ _ O
network _ _ O
, _ _ O
etc _ _ O
. _ _ O
) _ _ O
, _ _ O
or _ _ O
from _ _ O
a _ _ O
String _ _ O
• _ _ O
Can _ _ O
read _ _ O
all _ _ O
primitives _ _ O
( _ _ O
except _ _ O
chars _ _ O
) _ _ O
, _ _ O
and _ _ O
can _ _ O
read _ _ O
Strings _ _ O
• _ _ O
An _ _ O
object _ _ O

Declaring _ _ O
Objects _ _ O
Type _ _ O
name _ _ O
= _ _ O
expression _ _ O
; _ _ O

Scanner _ _ O
name _ _ O
= _ _ O
new _ _ O
Scanner _ _ O
( _ _ O
) _ _ O
; _ _ O
We _ _ O
will _ _ O
fill _ _ O
this _ _ O
in _ _ O
with _ _ O
something _ _ O
, _ _ O
but _ _ O
what _ _ O
exactly _ _ O
goes _ _ O
here _ _ O
? _ _ O

Declaring _ _ O
Objects _ _ O
• _ _ O
Any _ _ O
declaration _ _ O
of _ _ O
objects _ _ O
requires _ _ O
the _ _ O
keyword _ _ O
“ _ _ O
new _ _ O
” _ _ O
• _ _ O
The _ _ O
method _ _ O
that _ _ O
follows _ _ O
the _ _ O
keyword _ _ O
are _ _ O
called _ _ O
constructors _ _ O
• _ _ O
Where _ _ O
can _ _ O
I _ _ O
look _ _ O
for _ _ O
them _ _ O
? _ _ O

A _ _ O
Special _ _ O
InputStream _ _ O
System.in _ _ O
• _ _ O
The _ _ O
standard _ _ O
way _ _ O
to _ _ O
retrieve _ _ O
input _ _ O
( _ _ O
via _ _ O
the _ _ O
console _ _ O
) _ _ O
• _ _ O
A _ _ O
“ _ _ O
special _ _ O
” _ _ O
variable _ _ O
. _ _ O
• _ _ O
Is _ _ O
this _ _ O
static _ _ O
or _ _ O
non-static _ _ O
? _ _ O

Scanner _ _ O
consoleInput _ _ O
= _ _ O
new _ _ O
Scanner _ _ O
( _ _ O
System.in _ _ O
) _ _ O
; _ _ O

What _ _ O
can _ _ O
I _ _ O
do _ _ O
with _ _ O
it _ _ O
? _ _ O
• _ _ O
I _ _ O
have _ _ O
a _ _ O
Scanner _ _ O
that _ _ O
can _ _ O
read _ _ O
input _ _ O
from _ _ O
the _ _ O
user _ _ O
via _ _ O
the _ _ O
console _ _ O
. _ _ O
• _ _ O
How _ _ O
do _ _ O
I _ _ O
actually _ _ O
use _ _ O
it _ _ O
? _ _ O

Using _ _ O
Scanner _ _ O
public _ _ O
class _ _ O
AddingMachine _ _ O
{ _ _ O
public _ _ O
static _ _ O
void _ _ O
main _ _ O
( _ _ O
String _ _ O
[ _ _ O
] _ _ O
args _ _ O
) _ _ O
{ _ _ O
Scanner _ _ O
scan _ _ O
= _ _ O
new _ _ O
Scanner _ _ O
( _ _ O
System.in _ _ O
) _ _ O
; _ _ O
System.out.println _ _ O
( _ _ O
"Please _ _ O
enter _ _ O
a _ _ O
number _ _ O
: _ _ O
" _ _ O
) _ _ O
; _ _ O
double _ _ O
firstNum _ _ O
= _ _ O
scan.nextDouble _ _ O
( _ _ O
) _ _ O
; _ _ O
System.out.println _ _ O
( _ _ O
"Please _ _ O
enter _ _ O
a _ _ O
second _ _ O
number _ _ O
: _ _ O
" _ _ O
) _ _ O
; _ _ O
double _ _ O
secondNum _ _ O
= _ _ O
scan.nextDouble _ _ O
( _ _ O
) _ _ O
; _ _ O
double _ _ O
sum _ _ O
= _ _ O
firstNum _ _ O
+ _ _ O
secondNum _ _ O
; _ _ O
System.out.println _ _ O
( _ _ O
"The _ _ O
sum _ _ O
of _ _ O
" _ _ O
+ _ _ O
firstNum _ _ O
+ _ _ O
" _ _ O
and _ _ O
" _ _ O
+ _ _ O
secondNum _ _ O
+ _ _ O
" _ _ O
equals _ _ O
" _ _ O
+ _ _ O
sum _ _ O
) _ _ O
; _ _ O
} _ _ O
/ _ _ O
/ _ _ O
end _ _ O
method _ _ O
main _ _ O
} _ _ O
/ _ _ O
/ _ _ O
End _ _ O
class _ _ O
AddingMachine _ _ O

Using _ _ O
Scanner _ _ O
public _ _ O
class _ _ O
AddingMachine _ _ O
{ _ _ O
public _ _ O
static _ _ O
void _ _ O
main _ _ O
( _ _ O
String _ _ O
[ _ _ O
] _ _ O
args _ _ O
) _ _ O
{ _ _ O
Scanner _ _ O
scan _ _ O
= _ _ O
new _ _ O
Scanner _ _ O
( _ _ O
System.in _ _ O
) _ _ O
; _ _ O
System.out.println _ _ O
( _ _ O
"Please _ _ O
enter _ _ O
a _ _ O
number _ _ O
: _ _ O
" _ _ O
) _ _ O
; _ _ O
double _ _ O
firstNum _ _ O
= _ _ O
scan.nextDouble _ _ O
( _ _ O
) _ _ O
; _ _ O
System.out.println _ _ O
( _ _ O
"Please _ _ O
enter _ _ O
a _ _ O
second _ _ O
number _ _ O
: _ _ O
" _ _ O
) _ _ O
; _ _ O
double _ _ O
secondNum _ _ O
= _ _ O
scan.nextDouble _ _ O
( _ _ O
) _ _ O
; _ _ O
double _ _ O
sum _ _ O
= _ _ O
firstNum _ _ O
+ _ _ O
secondNum _ _ O
; _ _ O
System.out.println _ _ O
( _ _ O
"The _ _ O
sum _ _ O
of _ _ O
" _ _ O
+ _ _ O
firstNum _ _ O
+ _ _ O
" _ _ O
and _ _ O
" _ _ O
+ _ _ O
secondNum _ _ O
+ _ _ O
" _ _ O
equals _ _ O
" _ _ O
+ _ _ O
sum _ _ O
) _ _ O
; _ _ O
} _ _ O
/ _ _ O
/ _ _ O
end _ _ O
method _ _ O
main _ _ O
} _ _ O
/ _ _ O
/ _ _ O
End _ _ O
class _ _ O
AddingMachine _ _ O

Using _ _ O
Scanner _ _ O
public _ _ O
class _ _ O
AddingMachine _ _ O
{ _ _ O
public _ _ O
static _ _ O
void _ _ O
main _ _ O
( _ _ O
String _ _ O
[ _ _ O
] _ _ O
args _ _ O
) _ _ O
{ _ _ O
Scanner _ _ O
scan _ _ O
= _ _ O
new _ _ O
Scanner _ _ O
( _ _ O
System.in _ _ O
) _ _ O
; _ _ O
System.out.println _ _ O
( _ _ O
"Please _ _ O
enter _ _ O
a _ _ O
number _ _ O
: _ _ O
" _ _ O
) _ _ O
; _ _ O
double _ _ O
firstNum _ _ O
= _ _ O
scan.nextDouble _ _ O
( _ _ O
) _ _ O
; _ _ O
System.out.println _ _ O
( _ _ O
"Please _ _ O
enter _ _ O
a _ _ O
second _ _ O
number _ _ O
: _ _ O
" _ _ O
) _ _ O
; _ _ O
double _ _ O
secondNum _ _ O
= _ _ O
scan.nextDouble _ _ O
( _ _ O
) _ _ O
; _ _ O
double _ _ O
sum _ _ O
= _ _ O
firstNum _ _ O
+ _ _ O
secondNum _ _ O
; _ _ O
System.out.println _ _ O
( _ _ O
"The _ _ O
sum _ _ O
of _ _ O
" _ _ O
+ _ _ O
firstNum _ _ O
+ _ _ O
" _ _ O
and _ _ O
" _ _ O
+ _ _ O
secondNum _ _ O
+ _ _ O
" _ _ O
equals _ _ O
" _ _ O
+ _ _ O
sum _ _ O
) _ _ O
; _ _ O
} _ _ O
/ _ _ O
/ _ _ O
end _ _ O
method _ _ O
main _ _ O
} _ _ O
/ _ _ O
/ _ _ O
End _ _ O
class _ _ O
AddingMachine _ _ O

Let _ _ O
’s _ _ O
Compile _ _ O
? _ _ O
? _ _ O
? _ _ O

Error _ _ O
? _ _ O
! _ _ O
? _ _ O
“ _ _ O
Can _ _ O
not _ _ O
find _ _ O
symbol _ _ O
” _ _ O
• _ _ O
This _ _ O
indicates _ _ O
that _ _ O
the _ _ O
name _ _ O
does _ _ O
not _ _ O
refer _ _ O
to _ _ O
anything _ _ O
• _ _ O
Based _ _ O
on _ _ O
the _ _ O
console _ _ O
output _ _ O
, _ _ O
“ _ _ O
Scanner _ _ O
” _ _ O
does _ _ O
not _ _ O
exist _ _ O
• _ _ O
Is _ _ O
there _ _ O
a _ _ O
way _ _ O
to _ _ O
figure _ _ O
out _ _ O
why _ _ O
? _ _ O

From _ _ O
the _ _ O
API _ _ O

Error _ _ O
? _ _ O
! _ _ O
? _ _ O
• _ _ O
Rather _ _ O
than _ _ O
being _ _ O
a _ _ O
part _ _ O
of _ _ O
“ _ _ O
java.lang _ _ O
, _ _ O
” _ _ O
which _ _ O
is _ _ O
already _ _ O
included _ _ O
by _ _ O
default _ _ O
, _ _ O
it _ _ O
is _ _ O
part _ _ O
of _ _ O
a _ _ O
different _ _ O
package _ _ O
• _ _ O
In _ _ O
order _ _ O
to _ _ O
include _ _ O
Scanner _ _ O
, _ _ O
we _ _ O
need _ _ O
to _ _ O
do _ _ O
an _ _ O
import _ _ O

import _ _ O
java.util.Scanner _ _ O
; _ _ O
public _ _ O
class _ _ O
AddingMachine _ _ O
{ _ _ O
public _ _ O
static _ _ O
void _ _ O
main _ _ O
( _ _ O
String _ _ O
[ _ _ O
] _ _ O
args _ _ O
) _ _ O
{ _ _ O
Scanner _ _ O
scan _ _ O
= _ _ O
new _ _ O
Scanner _ _ O
( _ _ O
System.in _ _ O
) _ _ O
; _ _ O
System.out.println _ _ O
( _ _ O
"Please _ _ O
enter _ _ O
a _ _ O
number _ _ O
: _ _ O
" _ _ O
) _ _ O
; _ _ O
double _ _ O
firstNum _ _ O
= _ _ O
scan.nextDouble _ _ O
( _ _ O
) _ _ O
; _ _ O
System.out.println _ _ O
( _ _ O
"Please _ _ O
enter _ _ O
a _ _ O
second _ _ O
number _ _ O
: _ _ O
" _ _ O
) _ _ O
; _ _ O
double _ _ O
secondNum _ _ O
= _ _ O
scan.nextDouble _ _ O
( _ _ O
) _ _ O
; _ _ O
double _ _ O
sum _ _ O
= _ _ O
firstNum _ _ O
+ _ _ O
secondNum _ _ O
; _ _ O
System.out.println _ _ O
( _ _ O
"The _ _ O
sum _ _ O
of _ _ O
" _ _ O
+ _ _ O
firstNum _ _ O
+ _ _ O
" _ _ O
and _ _ O
" _ _ O
+ _ _ O
secondNum _ _ O
+ _ _ O
" _ _ O
equals _ _ O
" _ _ O
+ _ _ O
sum _ _ O
) _ _ O
; _ _ O
} _ _ O
/ _ _ O
/ _ _ O
end _ _ O
method _ _ O
main _ _ O
} _ _ O
/ _ _ O
/ _ _ O
End _ _ O
class _ _ O
AddingMachine _ _ O

Do _ _ O
n’t _ _ O
Forget _ _ O
to _ _ O
Import _ _ O

FUNCTIONS _ _ O

Functions _ _ O
• _ _ O
A _ _ O
function _ _ O
is _ _ O
similar _ _ O
to _ _ O
its _ _ O
mathematical _ _ O
counterpart _ _ O
• _ _ O
f _ _ O
( _ _ O
x _ _ O
) _ _ O
= _ _ O
x2 _ _ O
, _ _ O
plug _ _ O
in _ _ O
3 _ _ O
, _ _ O
get _ _ O
9 _ _ O
• _ _ O
Contains _ _ O
several _ _ O
more _ _ O
parts _ _ O

Java _ _ O
Functions _ _ O
• _ _ O
Takes _ _ O
in _ _ O
zero _ _ O
or _ _ O
more _ _ O
parameters _ _ O
, _ _ O
processes _ _ O
them _ _ O
in _ _ O
the _ _ O
function _ _ O
body _ _ O
, _ _ O
and _ _ O
returns _ _ O
a _ _ O
result _ _ O
• _ _ O
Imagine _ _ O
going _ _ O
to _ _ O
BestBuyTM _ _ O
and _ _ O
telling _ _ O
them _ _ O
you _ _ O
want _ _ O
your _ _ O
computer _ _ O
fixed _ _ O
. _ _ O
You _ _ O
are _ _ O
telling _ _ O
them _ _ O
to _ _ O
run _ _ O
a _ _ O
fixing _ _ O
function _ _ O
, _ _ O
with _ _ O
your _ _ O
computer _ _ O
being _ _ O
a _ _ O
parameter _ _ O
. _ _ O
What _ _ O
you _ _ O
get _ _ O
back _ _ O
is _ _ O
your _ _ O
fixed _ _ O
computer _ _ O
. _ _ O

You _ _ O
Already _ _ O
Have _ _ O
the _ _ O
Power _ _ O
! _ _ O
• _ _ O
You _ _ O
already _ _ O
know _ _ O
how _ _ O
to _ _ O
call _ _ O
functions _ _ O
! _ _ O
Static _ _ O
: _ _ O
ClassName.functionName _ _ O
( _ _ O
< _ _ O
parameters _ _ O
> _ _ O
) _ _ O
; _ _ O
Non-static _ _ O
: _ _ O
objectName.functionName _ _ O
( _ _ O
< _ _ O
parameter _ _ O
s _ _ O
> _ _ O
) _ _ O
; _ _ O
• _ _ O
How _ _ O
do _ _ O
I _ _ O
make _ _ O
my _ _ O
own _ _ O
? _ _ O

Function _ _ O
Components _ _ O
1 _ _ O
. _ _ O
2 _ _ O
. _ _ O
3 _ _ O
. _ _ O
Function _ _ O
4 _ _ O
. _ _ O
Header _ _ O
5 _ _ O
. _ _ O
Function _ _ O
Body _ _ O
6 _ _ O
. _ _ O
Visibility _ _ O
type _ _ O
( _ _ O
public _ _ O
/ _ _ O
protected _ _ O
/ _ _ O
private _ _ O
) _ _ O
static _ _ O
( _ _ O
For _ _ O
now _ _ O
, _ _ O
required _ _ O
) _ _ O
Return _ _ O
Type _ _ O
functionName _ _ O
Parentheses _ _ O
“ _ _ O
( _ _ O
) _ _ O
” _ _ O
– _ _ O
a _ _ O
) _ _ O
b _ _ O
) _ _ O
c _ _ O
) _ _ O
Parameters _ _ O
Type1 _ _ O
parameterName1 _ _ O
Type2 _ _ O
parameterName2 _ _ O
… _ _ O
Curly _ _ O
Brackets _ _ O
/ _ _ O
Braces _ _ O
“ _ _ O
{ _ _ O
} _ _ O
” _ _ O
– _ _ O
return _ _ O
a _ _ O
value _ _ O



