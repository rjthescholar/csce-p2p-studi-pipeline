unlabeled|cs0007|lec11
-DOCSTART- -X- -X- O

CS _ _ O
0007 _ _ O
: _ _ O
Introduction _ _ O
to _ _ O
Java _ _ O
Lecture _ _ O
11 _ _ O
Nathan _ _ O
Ong _ _ O
University _ _ O
of _ _ O
Pittsburgh _ _ O
October _ _ O
13 _ _ O
, _ _ O
2016 _ _ O

Annoucements _ _ O
• _ _ O
October _ _ O
17 _ _ O
– _ _ O
Fall _ _ O
Break _ _ O
• _ _ O
October _ _ O
18 _ _ O
– _ _ O
Monday _ _ O
Schedule _ _ O
– _ _ O
Those _ _ O
who _ _ O
are _ _ O
signed _ _ O
up _ _ O
for _ _ O
Monday _ _ O
Lab _ _ O
must _ _ O
attend _ _ O
– _ _ O
Those _ _ O
who _ _ O
are _ _ O
signed _ _ O
up _ _ O
for _ _ O
Tuesday _ _ O
Lab _ _ O
are _ _ O
not _ _ O
required _ _ O
to _ _ O
attend _ _ O
, _ _ O
but _ _ O
must _ _ O
complete _ _ O
the _ _ O
lab _ _ O
– _ _ O
No _ _ O
lecture _ _ O

Annoucements _ _ O
• _ _ O
Project _ _ O
0 _ _ O
is _ _ O
updated _ _ O
, _ _ O
please _ _ O
download _ _ O
the _ _ O
new _ _ O
version _ _ O
• _ _ O
Rubric _ _ O
will _ _ O
be _ _ O
released _ _ O
very _ _ O
soon _ _ O
• _ _ O
This _ _ O
project _ _ O
must _ _ O
be _ _ O
done _ _ O
by _ _ O
yourself _ _ O

Annoucements _ _ O
• _ _ O
Project _ _ O
1 _ _ O
will _ _ O
be _ _ O
released _ _ O
while _ _ O
Project _ _ O
0 _ _ O
is _ _ O
going _ _ O
on _ _ O
just _ _ O
to _ _ O
get _ _ O
you _ _ O
to _ _ O
start _ _ O
thinking _ _ O
about _ _ O
it _ _ O
, _ _ O
but _ _ O
the _ _ O
due _ _ O
date _ _ O
will _ _ O
be _ _ O
far _ _ O
into _ _ O
the _ _ O
future _ _ O
• _ _ O
There _ _ O
will _ _ O
only _ _ O
be _ _ O
two _ _ O
projects _ _ O

ARRAYS _ _ O
, _ _ O
LOOPS _ _ O
, _ _ O
AND _ _ O
RECURSION _ _ O

A _ _ O
Sudden _ _ O
Need _ _ O
• _ _ O
I _ _ O
need _ _ O
a _ _ O
function _ _ O
that _ _ O
returns _ _ O
the _ _ O
first _ _ O
100 _ _ O
terms _ _ O
of _ _ O
the _ _ O
harmonic _ _ O
series _ _ O
. _ _ O
• _ _ O
Harmonic _ _ O
series _ _ O
: _ _ O
 _ _ O
1 _ _ O
1 _ _ O
1 _ _ O
 _ _ O
n _ _ O
1 _ _ O
 _ _ O
2 _ _ O
 _ _ O
3 _ _ O
 _ _ O
... _ _ O
n _ _ O
1 _ _ O

The _ _ O
Dumb _ _ O
Way _ _ O
public _ _ O
static _ _ O
void _ _ O
main _ _ O
( _ _ O
String _ _ O
[ _ _ O
] _ _ O
args _ _ O
) _ _ O
{ _ _ O
double _ _ O
term0 _ _ O
= _ _ O
1.0 _ _ O
; _ _ O
double _ _ O
term1 _ _ O
= _ _ O
1.0 _ _ O
/ _ _ O
2.0 _ _ O
; _ _ O
double _ _ O
term2 _ _ O
= _ _ O
1.0 _ _ O
/ _ _ O
3.0 _ _ O
; _ _ O
… _ _ O
} _ _ O

Arrays _ _ O
• _ _ O
Arrays _ _ O
are _ _ O
ordered _ _ O
lists _ _ O
of _ _ O
things _ _ O
depending _ _ O
on _ _ O
the _ _ O
type _ _ O
you _ _ O
specify _ _ O
• _ _ O
How _ _ O
do _ _ O
you _ _ O
make _ _ O
one _ _ O
? _ _ O

Type _ _ O
[ _ _ O
] _ _ O
name _ _ O
= _ _ O
new _ _ O
Type _ _ O
[ _ _ O
size _ _ O
] _ _ O
; _ _ O

int _ _ O
[ _ _ O
] _ _ O
empty _ _ O
= _ _ O
new _ _ O
int _ _ O
[ _ _ O
10 _ _ O
] _ _ O
; _ _ O

int _ _ O
[ _ _ O
] _ _ O
list _ _ O
= _ _ O
{ _ _ O
1 _ _ O
, _ _ O
2 _ _ O
, _ _ O
3 _ _ O
, _ _ O
4 _ _ O
} _ _ O
; _ _ O

Now _ _ O
What _ _ O
? _ _ O
• _ _ O
I _ _ O
want _ _ O
the _ _ O
first _ _ O
element _ _ O
• _ _ O
list _ _ O
[ _ _ O
0 _ _ O
] _ _ O
• _ _ O
I _ _ O
want _ _ O
the _ _ O
last _ _ O
element _ _ O
• _ _ O
list _ _ O
[ _ _ O
3 _ _ O
] _ _ O
• _ _ O
I _ _ O
want _ _ O
the _ _ O
length _ _ O
• _ _ O
list.length _ _ O
= _ _ O
= _ _ O
4 _ _ O
• _ _ O
All _ _ O
operations _ _ O
for _ _ O
int _ _ O
are _ _ O
allowed _ _ O
for _ _ O
an _ _ O
individual _ _ O
element _ _ O
• _ _ O
list _ _ O
[ _ _ O
0 _ _ O
] _ _ O
+ _ _ O
list _ _ O
[ _ _ O
2 _ _ O
] _ _ O
= _ _ O
= _ _ O
list _ _ O
[ _ _ O
3 _ _ O
] _ _ O

How _ _ O
do _ _ O
I _ _ O
get _ _ O
every _ _ O
element _ _ O
so _ _ O
I _ _ O
can _ _ O
print _ _ O
it _ _ O
? _ _ O
• _ _ O
Reference _ _ O
every _ _ O
element _ _ O
• _ _ O
Many _ _ O
if _ _ O
statements _ _ O
! _ _ O
! _ _ O
! _ _ O
! _ _ O
! _ _ O
! _ _ O
YAAAAAAAAYYYY _ _ O
• _ _ O
No _ _ O
please _ _ O
do _ _ O
n't _ _ O
• _ _ O
But _ _ O
what _ _ O
else _ _ O
can _ _ O
we _ _ O
do _ _ O
? _ _ O
• _ _ O
WILD _ _ O
KEYWORD _ _ O
APPEARS _ _ O

while _ _ O
( _ _ O
) _ _ O
{ _ _ O
… _ _ O
} _ _ O
• _ _ O
While _ _ O
a _ _ O
condition _ _ O
is _ _ O
true _ _ O
, _ _ O
run _ _ O
the _ _ O
block _ _ O
• _ _ O
While _ _ O
not _ _ O
at _ _ O
the _ _ O
end _ _ O
of _ _ O
the _ _ O
list _ _ O
, _ _ O
print _ _ O
out _ _ O
the _ _ O
next _ _ O
element _ _ O
while _ _ O
( _ _ O
not _ _ O
at _ _ O
end _ _ O
of _ _ O
list _ _ O
) _ _ O
{ _ _ O
System.out.println _ _ O
( _ _ O
next _ _ O
element _ _ O
) _ _ O
; _ _ O
} _ _ O
/ _ _ O
/ _ _ O
end _ _ O
loop _ _ O
while _ _ O
( _ _ O
not _ _ O
at _ _ O
end _ _ O
of _ _ O
list _ _ O
) _ _ O

not _ _ O
at _ _ O
end _ _ O
of _ _ O
list _ _ O
• _ _ O
How _ _ O
do _ _ O
we _ _ O
know _ _ O
we _ _ O
're _ _ O
at _ _ O
the _ _ O
end _ _ O
of _ _ O
the _ _ O
list _ _ O
? _ _ O
• _ _ O
list.length _ _ O
• _ _ O
How _ _ O
do _ _ O
we _ _ O
know _ _ O
which _ _ O
one _ _ O
we _ _ O
're _ _ O
at _ _ O
? _ _ O
– _ _ O
We _ _ O
need _ _ O
to _ _ O
keep _ _ O
track _ _ O
int _ _ O
currElement _ _ O
= _ _ O
0 _ _ O
; _ _ O
– _ _ O
starts _ _ O
at _ _ O
0 _ _ O
– _ _ O
not _ _ O
equal _ _ O
to _ _ O
the _ _ O
end _ _ O
! _ _ O
currElement _ _ O
! _ _ O
= _ _ O
list.length _ _ O

while _ _ O
( _ _ O
) _ _ O
{ _ _ O
… _ _ O
} _ _ O
• _ _ O
While _ _ O
not _ _ O
at _ _ O
the _ _ O
end _ _ O
of _ _ O
the _ _ O
list _ _ O
, _ _ O
print _ _ O
out _ _ O
the _ _ O
next _ _ O
element _ _ O
int _ _ O
currElement _ _ O
= _ _ O
0 _ _ O
; _ _ O
while _ _ O
( _ _ O
currElement _ _ O
! _ _ O
= _ _ O
list.length _ _ O
) _ _ O
{ _ _ O
System.out.println _ _ O
( _ _ O
< _ _ O
next _ _ O
element _ _ O
> _ _ O
) _ _ O
; _ _ O
} _ _ O
/ _ _ O
/ _ _ O
end _ _ O
loop _ _ O
while _ _ O
( _ _ O
currElement _ _ O
! _ _ O
=list.length _ _ O
) _ _ O

next _ _ O
element _ _ O
• _ _ O
Do _ _ O
we _ _ O
really _ _ O
want _ _ O
to _ _ O
print _ _ O
out _ _ O
the _ _ O
next _ _ O
element _ _ O
? _ _ O
• _ _ O
If _ _ O
we _ _ O
start _ _ O
at _ _ O
0 _ _ O
, _ _ O
and _ _ O
the _ _ O
list _ _ O
starts _ _ O
at _ _ O
0 _ _ O
, _ _ O
do _ _ O
we _ _ O
? _ _ O
• _ _ O
No _ _ O
, _ _ O
we _ _ O
want _ _ O
it _ _ O
to _ _ O
print _ _ O
out _ _ O
the _ _ O
current _ _ O
element _ _ O
and _ _ O
then _ _ O
move _ _ O
to _ _ O
the _ _ O
next _ _ O
one _ _ O
• _ _ O
How _ _ O
do _ _ O
we _ _ O
print _ _ O
out _ _ O
the _ _ O
current _ _ O
element _ _ O
? _ _ O
System.out.println _ _ O
( _ _ O
list _ _ O
[ _ _ O
currElement _ _ O
] _ _ O
) _ _ O
; _ _ O
• _ _ O
How _ _ O
do _ _ O
we _ _ O
move _ _ O
to _ _ O
the _ _ O
next _ _ O
one _ _ O
? _ _ O
currElement _ _ O
= _ _ O
currElement _ _ O
+ _ _ O
1 _ _ O
; _ _ O

while _ _ O
( _ _ O
) _ _ O
{ _ _ O
… _ _ O
} _ _ O
• _ _ O
While _ _ O
not _ _ O
at _ _ O
the _ _ O
end _ _ O
of _ _ O
the _ _ O
list _ _ O
, _ _ O
print _ _ O
out _ _ O
the _ _ O
next _ _ O
element _ _ O
int _ _ O
currElement _ _ O
= _ _ O
0 _ _ O
; _ _ O
while _ _ O
( _ _ O
currElement _ _ O
! _ _ O
= _ _ O
list.length _ _ O
) _ _ O
{ _ _ O
System.out.println _ _ O
( _ _ O
list _ _ O
[ _ _ O
currElement _ _ O
] _ _ O
) _ _ O
; _ _ O
currElement _ _ O
= _ _ O
currElement _ _ O
+ _ _ O
1 _ _ O
; _ _ O
} _ _ O
/ _ _ O
/ _ _ O
end _ _ O
loop _ _ O
while _ _ O
( _ _ O
currElement _ _ O
! _ _ O
=list.length _ _ O
) _ _ O

Time _ _ O
to _ _ O
Optimize _ _ O
• _ _ O
currElement _ _ O
= _ _ O
currElement _ _ O
+ _ _ O
1 _ _ O
; _ _ O
• _ _ O
This _ _ O
is _ _ O
really _ _ O
long _ _ O
. _ _ O
There _ _ O
must _ _ O
be _ _ O
a _ _ O
faster _ _ O
way _ _ O
• _ _ O
There _ _ O
is _ _ O
! _ _ O
Use _ _ O
+ _ _ O
= _ _ O

+ _ _ O
= _ _ O
• _ _ O
Adds _ _ O
the _ _ O
right _ _ O
side _ _ O
to _ _ O
whatever _ _ O
was _ _ O
on _ _ O
the _ _ O
left _ _ O
side _ _ O
currElement _ _ O
+ _ _ O
= _ _ O
1 _ _ O
; _ _ O
is _ _ O
equivalent _ _ O
to _ _ O
currElement _ _ O
= _ _ O
currElement _ _ O
+ _ _ O
1 _ _ O
; _ _ O
• _ _ O
As _ _ O
it _ _ O
happens _ _ O
, _ _ O
people _ _ O
generally _ _ O
add _ _ O
one _ _ O
to _ _ O
many _ _ O
things _ _ O
all _ _ O
the _ _ O
time _ _ O
, _ _ O
so _ _ O
there _ _ O
is _ _ O
a _ _ O
shortercut _ _ O

+ _ _ O
+ _ _ O
currElement++ _ _ O
; _ _ O
is _ _ O
equivalent _ _ O
to _ _ O
currElement _ _ O
= _ _ O
currElement _ _ O
+ _ _ O
1 _ _ O
; _ _ O
• _ _ O
It _ _ O
is _ _ O
also _ _ O
common _ _ O
to _ _ O
subtract _ _ O
one _ _ O
from _ _ O
many _ _ O
things _ _ O
all _ _ O
the _ _ O
time _ _ O
, _ _ O
so _ _ O
there _ _ O
is _ _ O
a _ _ O
similar _ _ O
shorter-cut _ _ O

-currElement _ _ O
– _ _ O
– _ _ O
; _ _ O
is _ _ O
equivalent _ _ O
to _ _ O
currElement _ _ O
= _ _ O
currElement _ _ O
– _ _ O
1 _ _ O
; _ _ O
• _ _ O
Planning _ _ O
to _ _ O
add _ _ O
or _ _ O
subtract _ _ O
more _ _ O
than _ _ O
one _ _ O
? _ _ O
Use _ _ O
+ _ _ O
= _ _ O
and _ _ O
– _ _ O
= _ _ O

Mathematical _ _ O
Combination _ _ O
Operators _ _ O
+ _ _ O
= _ _ O
, _ _ O
-= _ _ O
, _ _ O
* _ _ O
= _ _ O
, _ _ O
/= _ _ O
( _ _ O
any _ _ O
numeric _ _ O
primitive _ _ O
) _ _ O
% _ _ O
= _ _ O
( _ _ O
int _ _ O
only _ _ O
) _ _ O
• _ _ O
Literally _ _ O
combines _ _ O
the _ _ O
operation _ _ O
and _ _ O
the _ _ O
assignment _ _ O
. _ _ O
variable _ _ O
◊ _ _ O
= _ _ O
value _ _ O
 _ _ O
variable _ _ O
= _ _ O
variable _ _ O
◊ _ _ O
value _ _ O
; _ _ O
int _ _ O
x _ _ O
= _ _ O
5 _ _ O
; _ _ O
x _ _ O
% _ _ O
= _ _ O
3 _ _ O
; _ _ O
/ _ _ O
/ _ _ O
x _ _ O
= _ _ O
= _ _ O
? _ _ O

while _ _ O
( _ _ O
) _ _ O
{ _ _ O
… _ _ O
} _ _ O
int _ _ O
currElement _ _ O
= _ _ O
0 _ _ O
; _ _ O
while _ _ O
( _ _ O
currElement _ _ O
! _ _ O
= _ _ O
list.length _ _ O
) _ _ O
{ _ _ O
System.out.println _ _ O
( _ _ O
list _ _ O
[ _ _ O
currElement _ _ O
] _ _ O
) _ _ O
; _ _ O
currElement++ _ _ O
; _ _ O
} _ _ O
/ _ _ O
/ _ _ O
end _ _ O
loop _ _ O
while _ _ O
( _ _ O
currElement _ _ O
! _ _ O
= _ _ O
list.length _ _ O
) _ _ O

A _ _ O
Little _ _ O
Security _ _ O
• _ _ O
currElement _ _ O
! _ _ O
= _ _ O
list.length _ _ O
• _ _ O
What _ _ O
happens _ _ O
if _ _ O
you _ _ O
accidentally _ _ O
added _ _ O
by _ _ O
three _ _ O
instead _ _ O
of _ _ O
one _ _ O
? _ _ O
• _ _ O
What _ _ O
happens _ _ O
if _ _ O
you _ _ O
accidentally _ _ O
changed _ _ O
the _ _ O
value _ _ O
of _ _ O
currElement _ _ O
so _ _ O
it _ _ O
's _ _ O
past _ _ O
the _ _ O
list _ _ O
length _ _ O
? _ _ O
• _ _ O
Safer _ _ O
check _ _ O
: _ _ O
currElement _ _ O
< _ _ O
list.length _ _ O

while _ _ O
( _ _ O
) _ _ O
{ _ _ O
… _ _ O
} _ _ O
int _ _ O
currElement _ _ O
= _ _ O
0 _ _ O
; _ _ O
while _ _ O
( _ _ O
currElement _ _ O
< _ _ O
list.length _ _ O
) _ _ O
{ _ _ O
System.out.println _ _ O
( _ _ O
list _ _ O
[ _ _ O
currElement _ _ O
] _ _ O
) _ _ O
; _ _ O
currElement++ _ _ O
; _ _ O
} _ _ O
/ _ _ O
/ _ _ O
end _ _ O
loop _ _ O
while _ _ O
( _ _ O
currElement _ _ O
< _ _ O
list.length _ _ O
) _ _ O

So _ _ O
Many _ _ O
Things _ _ O
We _ _ O
Have _ _ O
to _ _ O
Remember…WHYYYYYYYYYY _ _ O
int _ _ O
counter _ _ O
= _ _ O
start _ _ O
; _ _ O
while _ _ O
( _ _ O
condition _ _ O
) _ _ O
{ _ _ O
/ _ _ O
/ _ _ O
Do _ _ O
stuff _ _ O
counter _ _ O
increment _ _ O
} _ _ O
/ _ _ O
/ _ _ O
end _ _ O
loop _ _ O
while _ _ O
( _ _ O
condition _ _ O
) _ _ O
• _ _ O
There _ _ O
must _ _ O
be _ _ O
a _ _ O
better _ _ O
way _ _ O
• _ _ O
WILD _ _ O
KEYWORD _ _ O
APPEARS _ _ O

for _ _ O
( _ _ O
; _ _ O
; _ _ O
) _ _ O
{ _ _ O
… _ _ O
} _ _ O
• _ _ O
The _ _ O
for _ _ O
loop _ _ O
allows _ _ O
us _ _ O
to _ _ O
put _ _ O
everything _ _ O
together _ _ O
for _ _ O
us _ _ O
! _ _ O
• _ _ O
for _ _ O
( _ _ O
counter _ _ O
= _ _ O
start _ _ O
; _ _ O
condition _ _ O
; _ _ O
counter _ _ O
increment _ _ O
) _ _ O
• _ _ O
Now _ _ O
we _ _ O
do _ _ O
n't _ _ O
have _ _ O
to _ _ O
worry _ _ O
about _ _ O
the _ _ O
placement _ _ O
of _ _ O
the _ _ O
counter _ _ O
and _ _ O
incrementing _ _ O
it _ _ O
! _ _ O

EQUIVALENCE _ _ O
int _ _ O
counter _ _ O
= _ _ O
start _ _ O
; _ _ O
while _ _ O
( _ _ O
condition _ _ O
) _ _ O
{ _ _ O
/ _ _ O
/ _ _ O
Do _ _ O
stuff _ _ O
counter _ _ O
increment _ _ O
} _ _ O
/ _ _ O
/ _ _ O
end _ _ O
loop _ _ O
/ _ _ O
/ _ _ O
while _ _ O
( _ _ O
condition _ _ O
) _ _ O
for _ _ O
( _ _ O
int _ _ O
counter _ _ O
= _ _ O
start _ _ O
; _ _ O
condition _ _ O
; _ _ O
counter _ _ O
increment _ _ O
) _ _ O
{ _ _ O
/ _ _ O
/ _ _ O
Do _ _ O
stuff _ _ O
} _ _ O
/ _ _ O
/ _ _ O
end _ _ O
loop _ _ O
for _ _ O
( _ _ O
condition _ _ O
) _ _ O

for _ _ O
( _ _ O
; _ _ O
; _ _ O
) _ _ O
{ _ _ O
… _ _ O
} _ _ O
for _ _ O
( _ _ O
int _ _ O
currElement _ _ O
= _ _ O
0 _ _ O
; _ _ O
currElement _ _ O
< _ _ O
list.length _ _ O
; _ _ O
currElement++ _ _ O
) _ _ O
{ _ _ O
System.out.println _ _ O
( _ _ O
list _ _ O
[ _ _ O
currElement _ _ O
] _ _ O
) _ _ O
; _ _ O
} _ _ O
/ _ _ O
/ _ _ O
end _ _ O
loop _ _ O
for _ _ O
( _ _ O
currElement _ _ O
< _ _ O
list.length _ _ O
) _ _ O



