unlabeled|cs0007|lec15
-DOCSTART- -X- -X- O

CS _ _ O
0007 _ _ O
: _ _ O
Introduction _ _ O
to _ _ O
Java _ _ O
Lecture _ _ O
15 _ _ O
Nathan _ _ O
Ong _ _ O
University _ _ O
of _ _ O
Pittsburgh _ _ O
November _ _ O
1 _ _ O
, _ _ O
2016 _ _ O

Main _ _ O
Portions _ _ O
of _ _ O
OOP _ _ O
• _ _ O
Building _ _ O
a _ _ O
class _ _ O
• _ _ O
Determining _ _ O
inter-class _ _ O
relationships _ _ O
– _ _ O
Subclasses _ _ O
– _ _ O
Superclasses _ _ O
– _ _ O
Ownership _ _ O

Building _ _ O
Classes _ _ O
There _ _ O
are _ _ O
several _ _ O
parts _ _ O
of _ _ O
a _ _ O
class _ _ O
, _ _ O
much _ _ O
like _ _ O
there _ _ O
are _ _ O
several _ _ O
parts _ _ O
of _ _ O
an _ _ O
object _ _ O
• _ _ O
Properties _ _ O
– _ _ O
Static _ _ O
: _ _ O
Class-level _ _ O
variables _ _ O
– _ _ O
Non-static _ _ O
: _ _ O
Instance _ _ O
variables _ _ O
• _ _ O
Methods _ _ O
( _ _ O
originally _ _ O
functions _ _ O
) _ _ O
– _ _ O
Static _ _ O
: _ _ O
Class _ _ O
methods _ _ O
– _ _ O
Non-static _ _ O
: _ _ O
Instance _ _ O
methods _ _ O
– _ _ O
Special _ _ O
: _ _ O
Constructor _ _ O

Properties _ _ O
• _ _ O
Inherent _ _ O
things _ _ O
( _ _ O
objects _ _ O
/ _ _ O
primitives _ _ O
) _ _ O
describing _ _ O
the _ _ O
class _ _ O
or _ _ O
instance _ _ O
• _ _ O
Placed _ _ O
within _ _ O
the _ _ O
class _ _ O
, _ _ O
but _ _ O
outside _ _ O
any _ _ O
method _ _ O
• _ _ O
Class-level _ _ O
variables _ _ O
– _ _ O
Static _ _ O
– _ _ O
Usually _ _ O
constants _ _ O
– _ _ O
Declared _ _ O
and _ _ O
assigned _ _ O
outside _ _ O
any _ _ O
object _ _ O
• _ _ O
Instance _ _ O
variables _ _ O
– _ _ O
Non-static _ _ O
– _ _ O
Declared _ _ O
by _ _ O
each _ _ O
object _ _ O
construction _ _ O
, _ _ O
which _ _ O
allows _ _ O
them _ _ O
to _ _ O
contain _ _ O
different _ _ O
values _ _ O

Class-level _ _ O
Variables _ _ O
• _ _ O
Constants _ _ O
( _ _ O
final _ _ O
keyword _ _ O
) _ _ O
– _ _ O
Usually _ _ O
refers _ _ O
to _ _ O
limits _ _ O
or _ _ O
specific _ _ O
values _ _ O
– _ _ O
Signified _ _ O
in _ _ O
ALL_CAPS_WITH_UNDERSCORES _ _ O
– _ _ O
Variable _ _ O
can _ _ O
not _ _ O
be _ _ O
changed _ _ O
– _ _ O
Usually _ _ O
visible _ _ O
to _ _ O
anyone _ _ O
( _ _ O
public _ _ O
keyword _ _ O
) _ _ O
public _ _ O
static _ _ O
final _ _ O
double _ _ O
PI _ _ O
= _ _ O
3.14 _ _ O
; _ _ O
int _ _ O
radius _ _ O
= _ _ O
5 _ _ O
; _ _ O
double _ _ O
area _ _ O
= _ _ O
Math.PI*radius*radius _ _ O
; _ _ O

Class-level _ _ O
Variables _ _ O
• _ _ O
Non-Constants _ _ O
– _ _ O
Usually _ _ O
performs _ _ O
bookkeeping _ _ O
( _ _ O
e.g. _ _ O
how _ _ O
many _ _ O
objects _ _ O
did _ _ O
you _ _ O
instantiate _ _ O
? _ _ O
) _ _ O
– _ _ O
Usually _ _ O
visible _ _ O
only _ _ O
to _ _ O
the _ _ O
class _ _ O
( _ _ O
private _ _ O
keyword _ _ O
) _ _ O
private _ _ O
static _ _ O
int _ _ O
nextID _ _ O
= _ _ O
0 _ _ O
; _ _ O

Instance _ _ O
Variables _ _ O
• _ _ O
Variables _ _ O
that _ _ O
are _ _ O
object _ _ O
instance _ _ O
dependent _ _ O
• _ _ O
All _ _ O
cars _ _ O
have _ _ O
a _ _ O
color _ _ O
, _ _ O
but _ _ O
not _ _ O
all _ _ O
cars _ _ O
are _ _ O
red _ _ O
• _ _ O
Possibly _ _ O
constant _ _ O
( _ _ O
final _ _ O
keyword _ _ O
) _ _ O
– _ _ O
Must _ _ O
be _ _ O
assigned _ _ O
at _ _ O
construction _ _ O
– _ _ O
Can _ _ O
not _ _ O
change _ _ O
value _ _ O
for _ _ O
the _ _ O
lifetime _ _ O
of _ _ O
the _ _ O
object _ _ O

Example _ _ O
public _ _ O
class _ _ O
Car _ _ O
{ _ _ O
private _ _ O
final _ _ O
int _ _ O
idNum _ _ O
; _ _ O
private _ _ O
Color _ _ O
color _ _ O
; _ _ O
private _ _ O
String _ _ O
licensePlate _ _ O
; _ _ O
… _ _ O
} _ _ O

How _ _ O
to _ _ O
Determine _ _ O
? _ _ O
• _ _ O
Depends _ _ O
on _ _ O
your _ _ O
needs _ _ O
and _ _ O
requirements _ _ O
of _ _ O
the _ _ O
scenario _ _ O
• _ _ O
A _ _ O
good _ _ O
rule _ _ O
of _ _ O
thumb _ _ O
: _ _ O
Restrict _ _ O
everything _ _ O
as _ _ O
much _ _ O
as _ _ O
possible _ _ O
. _ _ O
If _ _ O
a _ _ O
variable _ _ O
does _ _ O
not _ _ O
need _ _ O
to _ _ O
change _ _ O
, _ _ O
make _ _ O
it _ _ O
final _ _ O
to _ _ O
prevent _ _ O
possible _ _ O
accidents _ _ O
. _ _ O
If _ _ O
a _ _ O
variable _ _ O
does _ _ O
not _ _ O
need _ _ O
to _ _ O
be _ _ O
directly _ _ O
visible _ _ O
to _ _ O
everyone _ _ O
, _ _ O
make _ _ O
it _ _ O
private _ _ O
. _ _ O

Methods _ _ O
• _ _ O
Functions _ _ O
that _ _ O
alter _ _ O
the _ _ O
object _ _ O
or _ _ O
operate _ _ O
using _ _ O
the _ _ O
properties _ _ O
of _ _ O
the _ _ O
object _ _ O
• _ _ O
This _ _ O
allows _ _ O
further _ _ O
control _ _ O
over _ _ O
how _ _ O
the _ _ O
object _ _ O
should _ _ O
be _ _ O
used _ _ O
, _ _ O
essentially _ _ O
providing _ _ O
guidelines _ _ O
to _ _ O
programmers _ _ O
on _ _ O
correct _ _ O
usage _ _ O
• _ _ O
Three _ _ O
main _ _ O
types _ _ O
– _ _ O
Static _ _ O
: _ _ O
Class _ _ O
methods _ _ O
– _ _ O
Non-static _ _ O
: _ _ O
Instance _ _ O
methods _ _ O
– _ _ O
Special _ _ O
: _ _ O
Constructor _ _ O

Constructors _ _ O
• _ _ O
Essentially _ _ O
a _ _ O
method _ _ O
initializing _ _ O
the _ _ O
object _ _ O
• _ _ O
Calling _ _ O
this _ _ O
special _ _ O
method _ _ O
requires _ _ O
the _ _ O
keyword _ _ O
new _ _ O
• _ _ O
We _ _ O
have _ _ O
seen _ _ O
this _ _ O
before _ _ O
! _ _ O
! _ _ O
! _ _ O
• _ _ O
But _ _ O
how _ _ O
do _ _ O
I _ _ O
make _ _ O
one _ _ O
? _ _ O

Constructor _ _ O
1 _ _ O
. _ _ O
2 _ _ O
. _ _ O
3 _ _ O
. _ _ O
Function _ _ O
4 _ _ O
. _ _ O
Header _ _ O
5 _ _ O
. _ _ O
Function _ _ O
Body _ _ O
6 _ _ O
. _ _ O
Visibility _ _ O
type _ _ O
( _ _ O
public _ _ O
/ _ _ O
protected _ _ O
/ _ _ O
private _ _ O
) _ _ O
static _ _ O
( _ _ O
For _ _ O
now _ _ O
, _ _ O
required _ _ O
) _ _ O
Return _ _ O
Type _ _ O
functionName _ _ O
Same _ _ O
name _ _ O
as _ _ O
the _ _ O
class _ _ O
Parentheses _ _ O
“ _ _ O
( _ _ O
) _ _ O
” _ _ O
– _ _ O
a _ _ O
) _ _ O
b _ _ O
) _ _ O
c _ _ O
) _ _ O
Parameters _ _ O
Type1 _ _ O
parameterName1 _ _ O
Type2 _ _ O
parameterName2 _ _ O
… _ _ O
Curly _ _ O
Brackets _ _ O
/ _ _ O
Braces _ _ O
“ _ _ O
{ _ _ O
} _ _ O
” _ _ O
– _ _ O
return _ _ O
a _ _ O
value _ _ O

Car _ _ O
Example _ _ O
public _ _ O
class _ _ O
Car _ _ O
{ _ _ O
private _ _ O
final _ _ O
int _ _ O
idNum _ _ O
; _ _ O
private _ _ O
Color _ _ O
color _ _ O
; _ _ O
private _ _ O
String _ _ O
licensePlate _ _ O
; _ _ O
public _ _ O
Car _ _ O
( _ _ O
Color _ _ O
color _ _ O
) _ _ O
{ _ _ O
/ _ _ O
/ _ _ O
initialize _ _ O
instance _ _ O
variables _ _ O
} _ _ O
/ _ _ O
/ _ _ O
end _ _ O
constructor _ _ O
( _ _ O
Color _ _ O
) _ _ O
… _ _ O
} _ _ O
/ _ _ O
/ _ _ O
End _ _ O
class _ _ O
Car _ _ O

Instance _ _ O
Variable _ _ O
Manipulation _ _ O
• _ _ O
To _ _ O
reference _ _ O
non-static _ _ O
objectdependent _ _ O
variables _ _ O
, _ _ O
use _ _ O
the _ _ O
keyword _ _ O
this _ _ O
followed _ _ O
by _ _ O
the _ _ O
dot _ _ O
operator _ _ O
. _ _ O
• _ _ O
The _ _ O
keyword _ _ O
can _ _ O
distinguish _ _ O
these _ _ O
object-dependent _ _ O
variables _ _ O
and _ _ O
parameters _ _ O
. _ _ O
• _ _ O
It _ _ O
can _ _ O
be _ _ O
used _ _ O
regularly _ _ O
, _ _ O
with _ _ O
no _ _ O
need _ _ O
to _ _ O
declare _ _ O
them _ _ O
. _ _ O

Car _ _ O
Example _ _ O
public _ _ O
class _ _ O
Car _ _ O
{ _ _ O
private _ _ O
final _ _ O
int _ _ O
idNum _ _ O
; _ _ O
private _ _ O
Color _ _ O
color _ _ O
; _ _ O
private _ _ O
String _ _ O
licensePlate _ _ O
; _ _ O
public _ _ O
Car _ _ O
( _ _ O
Color _ _ O
color _ _ O
) _ _ O
{ _ _ O
this.color _ _ O
= _ _ O
color _ _ O
; _ _ O
… _ _ O
} _ _ O
/ _ _ O
/ _ _ O
end _ _ O
constructor _ _ O
( _ _ O
Color _ _ O
) _ _ O
… _ _ O
} _ _ O
/ _ _ O
/ _ _ O
End _ _ O
class _ _ O
Car _ _ O

Control _ _ O
Question _ _ O
• _ _ O
Should _ _ O
we _ _ O
allow _ _ O
the _ _ O
function _ _ O
caller _ _ O
( _ _ O
e.g. _ _ O
random _ _ O
user _ _ O
) _ _ O
to _ _ O
make _ _ O
the _ _ O
car _ _ O
’s _ _ O
ID _ _ O
number _ _ O
? _ _ O
Probably _ _ O
not _ _ O
. _ _ O
• _ _ O
We _ _ O
want _ _ O
the _ _ O
ID _ _ O
number _ _ O
to _ _ O
be _ _ O
unique _ _ O
. _ _ O
• _ _ O
Simple _ _ O
solution _ _ O
: _ _ O
just _ _ O
count _ _ O
up _ _ O
by _ _ O
one _ _ O
every _ _ O
time _ _ O
a _ _ O
new _ _ O
car _ _ O
is _ _ O
made _ _ O
. _ _ O
• _ _ O
We _ _ O
can _ _ O
do _ _ O
this _ _ O
via _ _ O
a _ _ O
class-level _ _ O
variable _ _ O
. _ _ O

Car _ _ O
Example _ _ O
public _ _ O
class _ _ O
Car _ _ O
{ _ _ O
private _ _ O
static _ _ O
int _ _ O
nextIDNum _ _ O
= _ _ O
0 _ _ O
; _ _ O
private _ _ O
final _ _ O
int _ _ O
idNum _ _ O
; _ _ O
private _ _ O
Color _ _ O
color _ _ O
; _ _ O
private _ _ O
String _ _ O
licensePlate _ _ O
; _ _ O
public _ _ O
Car _ _ O
( _ _ O
Color _ _ O
color _ _ O
) _ _ O
{ _ _ O
this.color _ _ O
= _ _ O
color _ _ O
; _ _ O
this.idNum _ _ O
= _ _ O
Car.nextIDNum _ _ O
; _ _ O
Car.nextIDNum++ _ _ O
; _ _ O
… _ _ O
} _ _ O
/ _ _ O
/ _ _ O
end _ _ O
constructor _ _ O
( _ _ O
Color _ _ O
) _ _ O
… _ _ O
} _ _ O
/ _ _ O
/ _ _ O
End _ _ O
class _ _ O
Car _ _ O

Car _ _ O
Example _ _ O
public _ _ O
Car _ _ O
( _ _ O
Color _ _ O
color _ _ O
) _ _ O
{ _ _ O
… _ _ O
this.idNum _ _ O
= _ _ O
Car.nextIDNum _ _ O
; _ _ O
Car.nextIDNum++ _ _ O
; _ _ O
… _ _ O
} _ _ O
/ _ _ O
/ _ _ O
end _ _ O
constructor _ _ O
( _ _ O
Color _ _ O
) _ _ O
Because _ _ O
nextIDNum _ _ O
is _ _ O
static _ _ O
, _ _ O
and _ _ O
was _ _ O
initialized _ _ O
to _ _ O
0 _ _ O
, _ _ O
the _ _ O
first _ _ O
car _ _ O
has _ _ O
an _ _ O
ID _ _ O
number _ _ O
of _ _ O
0 _ _ O
. _ _ O
Then _ _ O
the _ _ O
static _ _ O
value _ _ O
is _ _ O
increased _ _ O
by _ _ O
1 _ _ O
. _ _ O
The _ _ O
next _ _ O
time _ _ O
we _ _ O
construct _ _ O
a _ _ O
new _ _ O
car _ _ O
, _ _ O
its _ _ O
ID _ _ O
number _ _ O
will _ _ O
be _ _ O
1 _ _ O
. _ _ O

Method _ _ O
Overloading _ _ O
• _ _ O
Remember _ _ O
function _ _ O
overloading _ _ O
? _ _ O
• _ _ O
This _ _ O
can _ _ O
apply _ _ O
to _ _ O
constructors _ _ O
as _ _ O
well _ _ O
! _ _ O

Overloading _ _ O
Constructors _ _ O
public _ _ O
class _ _ O
Car _ _ O
{ _ _ O
… _ _ O
public _ _ O
Car _ _ O
( _ _ O
Color _ _ O
color _ _ O
) _ _ O
{ _ _ O
this.color _ _ O
= _ _ O
color _ _ O
; _ _ O
this.idNum _ _ O
= _ _ O
Car.nextIDNum _ _ O
; _ _ O
Car.nextIDNum++ _ _ O
; _ _ O
… _ _ O
} _ _ O
/ _ _ O
/ _ _ O
end _ _ O
constructor _ _ O
( _ _ O
Color _ _ O
) _ _ O
/ _ _ O
/ _ _ O
default _ _ O
color _ _ O
is _ _ O
Color.RED _ _ O
public _ _ O
Car _ _ O
( _ _ O
) _ _ O
{ _ _ O
this _ _ O
( _ _ O
Color.RED _ _ O
) _ _ O
; _ _ O
} _ _ O
/ _ _ O
/ _ _ O
end _ _ O
constructor _ _ O
( _ _ O
) _ _ O
… _ _ O
} _ _ O
/ _ _ O
/ _ _ O
End _ _ O
class _ _ O
Car _ _ O
Referencing _ _ O
other _ _ O
constructors _ _ O
can _ _ O
be _ _ O
done _ _ O
with _ _ O
the _ _ O

Overloading _ _ O
Constructors _ _ O
• _ _ O
If _ _ O
you _ _ O
will _ _ O
call _ _ O
another _ _ O
constructor _ _ O
, _ _ O
then _ _ O
that _ _ O
is _ _ O
the _ _ O
only _ _ O
line _ _ O
of _ _ O
code _ _ O
that _ _ O
can _ _ O
be _ _ O
present _ _ O
in _ _ O
the _ _ O
constructor _ _ O

Functional _ _ O
Functions _ _ O
• _ _ O
The _ _ O
most _ _ O
common _ _ O
functions _ _ O
are _ _ O
getters _ _ O
and _ _ O
setters _ _ O
– _ _ O
Getters _ _ O
retrieve _ _ O
the _ _ O
values _ _ O
of _ _ O
instance _ _ O
variables _ _ O
and _ _ O
return _ _ O
them _ _ O
– _ _ O
Setters _ _ O
alter _ _ O
the _ _ O
values _ _ O
of _ _ O
the _ _ O
instance _ _ O
variables _ _ O
• _ _ O
Why _ _ O
use _ _ O
these _ _ O
functions _ _ O
rather _ _ O
than _ _ O
setting _ _ O
the _ _ O
variable _ _ O
to _ _ O
be _ _ O
public _ _ O
? _ _ O
• _ _ O
Control _ _ O
! _ _ O

Car _ _ O
Example _ _ O
public _ _ O
class _ _ O
Car _ _ O
{ _ _ O
private _ _ O
static _ _ O
int _ _ O
nextIDNum _ _ O
= _ _ O
0 _ _ O
; _ _ O
private _ _ O
final _ _ O
int _ _ O
idNum _ _ O
; _ _ O
private _ _ O
Color _ _ O
color _ _ O
; _ _ O
private _ _ O
String _ _ O
licensePlate _ _ O
; _ _ O
public _ _ O
int _ _ O
getIDNum _ _ O
( _ _ O
) _ _ O
{ _ _ O
return _ _ O
this.idNum _ _ O
; _ _ O
} _ _ O
/ _ _ O
/ _ _ O
end _ _ O
function _ _ O
( _ _ O
) _ _ O
… _ _ O
} _ _ O
/ _ _ O
/ _ _ O
End _ _ O
class _ _ O
Car _ _ O

Car _ _ O
Example _ _ O
public _ _ O
class _ _ O
Car _ _ O
{ _ _ O
private _ _ O
static _ _ O
int _ _ O
nextIDNum _ _ O
= _ _ O
0 _ _ O
; _ _ O
private _ _ O
final _ _ O
int _ _ O
idNum _ _ O
; _ _ O
private _ _ O
Color _ _ O
color _ _ O
; _ _ O
private _ _ O
String _ _ O
licensePlate _ _ O
; _ _ O
public _ _ O
void _ _ O
setColor _ _ O
( _ _ O
Color _ _ O
color _ _ O
) _ _ O
{ _ _ O
this.color _ _ O
= _ _ O
color _ _ O
; _ _ O
} _ _ O
/ _ _ O
/ _ _ O
end _ _ O
function _ _ O
( _ _ O
Color _ _ O
) _ _ O
… _ _ O
} _ _ O
/ _ _ O
/ _ _ O
End _ _ O
class _ _ O
Car _ _ O

Why _ _ O
Bother _ _ O
? _ _ O
• _ _ O
Having _ _ O
these _ _ O
methods _ _ O
ensure _ _ O
you _ _ O
have _ _ O
full _ _ O
control _ _ O
over _ _ O
the _ _ O
instance _ _ O
variables _ _ O
• _ _ O
Should _ _ O
you _ _ O
decide _ _ O
to _ _ O
change _ _ O
how _ _ O
the _ _ O
variable _ _ O
is _ _ O
accessed _ _ O
or _ _ O
altered _ _ O
, _ _ O
you _ _ O
only _ _ O
need _ _ O
to _ _ O
change _ _ O
the _ _ O
method _ _ O
. _ _ O
• _ _ O
You _ _ O
only _ _ O
add _ _ O
them _ _ O
when _ _ O
you _ _ O
need _ _ O
them _ _ O
! _ _ O

Recap _ _ O
A _ _ O
class _ _ O
needs _ _ O
these _ _ O
components _ _ O
: _ _ O
• _ _ O
Class-level _ _ O
/ _ _ O
Instance _ _ O
Variables _ _ O
• _ _ O
Methods _ _ O
• _ _ O
Constructor _ _ O
( _ _ O
s _ _ O
) _ _ O



