unlabeled|cs0441|lec15
-DOCSTART- -X- -X- O

Discrete _ _ O
Structures _ _ O
for _ _ O
Computer _ _ O
Science _ _ O
William _ _ O
Garrison _ _ O
bill@cs.pitt.edu _ _ O
6311 _ _ O
Sennott _ _ O
Square _ _ O
Lecture _ _ O
# _ _ O
15 _ _ O
: _ _ O
Recursion _ _ O
and _ _ O
Structural _ _ O
Induction _ _ O
Based _ _ O
on _ _ O
materials _ _ O
developed _ _ O
by _ _ O
Dr. _ _ O
Adam _ _ O
Lee _ _ O

There _ _ O
are _ _ O
many _ _ O
uses _ _ O
of _ _ O
induction _ _ O
in _ _ O
computer _ _ O
science _ _ O
! _ _ O
Proof _ _ O
by _ _ O
induction _ _ O
is _ _ O
often _ _ O
used _ _ O
to _ _ O
reason _ _ O
about _ _ O
: _ _ O
l _ _ O
Algorithm _ _ O
properties _ _ O
( _ _ O
correctness _ _ O
, _ _ O
etc _ _ O
. _ _ O
) _ _ O
l _ _ O
Properties _ _ O
of _ _ O
data _ _ O
structures _ _ O
l _ _ O
Membership _ _ O
in _ _ O
certain _ _ O
sets _ _ O
l _ _ O
Determining _ _ O
whether _ _ O
certain _ _ O
expressions _ _ O
are _ _ O
well-formed _ _ O
l _ _ O
… _ _ O
To _ _ O
begin _ _ O
looking _ _ O
at _ _ O
how _ _ O
we _ _ O
can _ _ O
use _ _ O
induction _ _ O
to _ _ O
prove _ _ O
the _ _ O
above _ _ O
types _ _ O
of _ _ O
statements _ _ O
, _ _ O
we _ _ O
first _ _ O
need _ _ O
to _ _ O
learn _ _ O
about _ _ O
recursion _ _ O

Sometimes _ _ O
, _ _ O
it _ _ O
is _ _ O
difficult _ _ O
or _ _ O
messy _ _ O
to _ _ O
define _ _ O
some _ _ O
object _ _ O
explicitly _ _ O
Recursive _ _ O
objects _ _ O
are _ _ O
defined _ _ O
in _ _ O
terms _ _ O
of _ _ O
( _ _ O
other _ _ O
instances _ _ O
of _ _ O
) _ _ O
themselves _ _ O
We _ _ O
often _ _ O
see _ _ O
the _ _ O
recursive _ _ O
versions _ _ O
of _ _ O
the _ _ O
following _ _ O
types _ _ O
of _ _ O
objects _ _ O
: _ _ O
l _ _ O
Functions _ _ O
l _ _ O
Sequences _ _ O
l _ _ O
Sets _ _ O
l _ _ O
Data _ _ O
structures _ _ O
Let _ _ O
’s _ _ O
look _ _ O
at _ _ O
some _ _ O
examples _ _ O
… _ _ O

Recursive _ _ O
functions _ _ O
are _ _ O
useful _ _ O
When _ _ O
defining _ _ O
a _ _ O
recursive _ _ O
function _ _ O
whose _ _ O
domain _ _ O
is _ _ O
the _ _ O
set _ _ O
of _ _ O
natural _ _ O
numbers _ _ O
, _ _ O
we _ _ O
have _ _ O
two _ _ O
steps _ _ O
: _ _ O
1 _ _ O
. _ _ O
Basis _ _ O
step _ _ O
: _ _ O
Define _ _ O
the _ _ O
behavior _ _ O
of _ _ O
f _ _ O
( _ _ O
0 _ _ O
) _ _ O
2 _ _ O
. _ _ O
Recursive _ _ O
step _ _ O
: _ _ O
Compute _ _ O
f _ _ O
( _ _ O
n+1 _ _ O
) _ _ O
using _ _ O
f _ _ O
( _ _ O
0 _ _ O
) _ _ O
, _ _ O
… _ _ O
, _ _ O
f _ _ O
( _ _ O
n _ _ O
) _ _ O
Does _ _ O
n’t _ _ O
this _ _ O
look _ _ O
a _ _ O
little _ _ O
bit _ _ O
like _ _ O
strong _ _ O
induction _ _ O
? _ _ O
Example _ _ O
: _ _ O
Let _ _ O
f _ _ O
( _ _ O
0 _ _ O
) _ _ O
= _ _ O
3 _ _ O
, _ _ O
f _ _ O
( _ _ O
n+1 _ _ O
) _ _ O
= _ _ O
2f _ _ O
( _ _ O
n _ _ O
) _ _ O
+ _ _ O
3 _ _ O
l _ _ O
l _ _ O
l _ _ O
l _ _ O
l _ _ O
f _ _ O
( _ _ O
1 _ _ O
) _ _ O
= _ _ O
2f _ _ O
( _ _ O
0 _ _ O
) _ _ O
+ _ _ O
3 _ _ O
= _ _ O
2 _ _ O
( _ _ O
3 _ _ O
) _ _ O
+ _ _ O
3 _ _ O
= _ _ O
9 _ _ O
f _ _ O
( _ _ O
2 _ _ O
) _ _ O
= _ _ O
2f _ _ O
( _ _ O
1 _ _ O
) _ _ O
+ _ _ O
3 _ _ O
= _ _ O
2 _ _ O
( _ _ O
9 _ _ O
) _ _ O
+ _ _ O
3 _ _ O
= _ _ O
21 _ _ O
f _ _ O
( _ _ O
3 _ _ O
) _ _ O
= _ _ O
2f _ _ O
( _ _ O
2 _ _ O
) _ _ O
+ _ _ O
3 _ _ O
= _ _ O
2 _ _ O
( _ _ O
21 _ _ O
) _ _ O
+ _ _ O
3 _ _ O
= _ _ O
45 _ _ O
f _ _ O
( _ _ O
4 _ _ O
) _ _ O
= _ _ O
2f _ _ O
( _ _ O
3 _ _ O
) _ _ O
+ _ _ O
3 _ _ O
= _ _ O
2 _ _ O
( _ _ O
45 _ _ O
) _ _ O
+ _ _ O
3 _ _ O
= _ _ O
93 _ _ O
… _ _ O

Some _ _ O
functions _ _ O
can _ _ O
be _ _ O
defined _ _ O
more _ _ O
precisely _ _ O
using _ _ O
recursion _ _ O
Example _ _ O
: _ _ O
Define _ _ O
the _ _ O
factorial _ _ O
function _ _ O
F _ _ O
( _ _ O
n _ _ O
) _ _ O
recursively _ _ O
1 _ _ O
. _ _ O
Basis _ _ O
step _ _ O
: _ _ O
F _ _ O
( _ _ O
0 _ _ O
) _ _ O
= _ _ O
1 _ _ O
2 _ _ O
. _ _ O
Recursive _ _ O
step _ _ O
: _ _ O
F _ _ O
( _ _ O
n+1 _ _ O
) _ _ O
= _ _ O
( _ _ O
n+1 _ _ O
) _ _ O
× _ _ O
F _ _ O
( _ _ O
n _ _ O
) _ _ O
Note _ _ O
: _ _ O
F _ _ O
( _ _ O
4 _ _ O
) _ _ O
= _ _ O
4 _ _ O
× _ _ O
F _ _ O
( _ _ O
3 _ _ O
) _ _ O
The _ _ O
recursive _ _ O
definition _ _ O
= _ _ O
4 _ _ O
× _ _ O
3 _ _ O
× _ _ O
F _ _ O
( _ _ O
2 _ _ O
) _ _ O
avoids _ _ O
using _ _ O
the _ _ O
“ _ _ O
… _ _ O
” _ _ O
shorthand _ _ O
! _ _ O
= _ _ O
4 _ _ O
× _ _ O
3 _ _ O
× _ _ O
2 _ _ O
× _ _ O
F _ _ O
( _ _ O
1 _ _ O
) _ _ O
= _ _ O
4 _ _ O
× _ _ O
3 _ _ O
× _ _ O
2 _ _ O
× _ _ O
1 _ _ O
× _ _ O
F _ _ O
( _ _ O
0 _ _ O
) _ _ O
= _ _ O
4 _ _ O
× _ _ O
3 _ _ O
× _ _ O
2 _ _ O
× _ _ O
1 _ _ O
× _ _ O
1 _ _ O
= _ _ O
24 _ _ O
Compare _ _ O
the _ _ O
above _ _ O
definition _ _ O
our _ _ O
old _ _ O
definition _ _ O
: _ _ O
l _ _ O
F _ _ O
( _ _ O
n _ _ O
) _ _ O
= _ _ O
n _ _ O
× _ _ O
( _ _ O
n-1 _ _ O
) _ _ O
× _ _ O
… _ _ O
× _ _ O
2 _ _ O
× _ _ O
1 _ _ O

It _ _ O
should _ _ O
be _ _ O
no _ _ O
surprise _ _ O
that _ _ O
we _ _ O
can _ _ O
also _ _ O
define _ _ O
recursive _ _ O
sequences _ _ O
Example _ _ O
: _ _ O
The _ _ O
Fibonacci _ _ O
numbers _ _ O
, _ _ O
{ _ _ O
fn _ _ O
} _ _ O
, _ _ O
are _ _ O
defined _ _ O
as _ _ O
follows _ _ O
: _ _ O
l _ _ O
f0 _ _ O
= _ _ O
1 _ _ O
l _ _ O
f1 _ _ O
= _ _ O
1 _ _ O
l _ _ O
fn _ _ O
= _ _ O
fn-1 _ _ O
+ _ _ O
fn-2 _ _ O
This _ _ O
is _ _ O
like _ _ O
strong _ _ O
induction _ _ O
, _ _ O
since _ _ O
we _ _ O
need _ _ O
more _ _ O
than _ _ O
fn-1 _ _ O
to _ _ O
compute _ _ O
fn _ _ O
. _ _ O
Calculate _ _ O
: _ _ O
f2 _ _ O
, _ _ O
f3 _ _ O
, _ _ O
f4 _ _ O
, _ _ O
and _ _ O
f5 _ _ O
l _ _ O
f2 _ _ O
= _ _ O
f1 _ _ O
+ _ _ O
f0 _ _ O
= _ _ O
1 _ _ O
+ _ _ O
1 _ _ O
= _ _ O
2 _ _ O
l _ _ O
f3 _ _ O
= _ _ O
f2 _ _ O
+ _ _ O
f1 _ _ O
= _ _ O
2 _ _ O
+ _ _ O
1 _ _ O
= _ _ O
3 _ _ O
l _ _ O
f4 _ _ O
= _ _ O
f3 _ _ O
+ _ _ O
f2 _ _ O
= _ _ O
3 _ _ O
+ _ _ O
2 _ _ O
= _ _ O
5 _ _ O
l _ _ O
f5 _ _ O
= _ _ O
f4 _ _ O
+ _ _ O
f3 _ _ O
= _ _ O
5 _ _ O
+ _ _ O
3 _ _ O
= _ _ O
8 _ _ O
This _ _ O
gives _ _ O
us _ _ O
the _ _ O
sequence _ _ O
{ _ _ O
fn _ _ O
} _ _ O
= _ _ O
1 _ _ O
, _ _ O
1 _ _ O
, _ _ O
2 _ _ O
, _ _ O
3 _ _ O
, _ _ O
5 _ _ O
, _ _ O
8 _ _ O
, _ _ O
13 _ _ O
, _ _ O
21 _ _ O
, _ _ O
34 _ _ O
, _ _ O
… _ _ O

Recursion _ _ O
is _ _ O
used _ _ O
heavily _ _ O
in _ _ O
the _ _ O
study _ _ O
of _ _ O
strings _ _ O
Let _ _ O
: _ _ O
∑ _ _ O
be _ _ O
defined _ _ O
as _ _ O
an _ _ O
alphabet _ _ O
l _ _ O
Binary _ _ O
strings _ _ O
: _ _ O
∑ _ _ O
= _ _ O
{ _ _ O
0 _ _ O
, _ _ O
1 _ _ O
} _ _ O
l _ _ O
Lower _ _ O
case _ _ O
letters _ _ O
: _ _ O
∑ _ _ O
= _ _ O
{ _ _ O
a _ _ O
, _ _ O
b _ _ O
, _ _ O
c _ _ O
, _ _ O
… _ _ O
, _ _ O
z _ _ O
} _ _ O
We _ _ O
can _ _ O
define _ _ O
the _ _ O
set _ _ O
∑ _ _ O
* _ _ O
containing _ _ O
all _ _ O
strings _ _ O
over _ _ O
the _ _ O
λ _ _ O
is _ _ O
the _ _ O
empty _ _ O
string _ _ O
alphabet _ _ O
∑ _ _ O
as _ _ O
follows _ _ O
: _ _ O
containing _ _ O
no _ _ O
characters _ _ O
1 _ _ O
. _ _ O
Basis _ _ O
step _ _ O
: _ _ O
λ _ _ O
∈ _ _ O
∑ _ _ O
* _ _ O
2 _ _ O
. _ _ O
Recursive _ _ O
step _ _ O
: _ _ O
If _ _ O
w _ _ O
∈ _ _ O
∑ _ _ O
* _ _ O
and _ _ O
x _ _ O
∈ _ _ O
∑ _ _ O
, _ _ O
then _ _ O
wx _ _ O
∈ _ _ O
∑ _ _ O
* _ _ O
Example _ _ O
: _ _ O
If _ _ O
∑ _ _ O
= _ _ O
{ _ _ O
0 _ _ O
, _ _ O
1 _ _ O
} _ _ O
, _ _ O
then _ _ O
∑ _ _ O
* _ _ O
= _ _ O
{ _ _ O
λ _ _ O
, _ _ O
0 _ _ O
, _ _ O
1 _ _ O
, _ _ O
01 _ _ O
, _ _ O
11 _ _ O
, _ _ O
… _ _ O
} _ _ O

This _ _ O
recursive _ _ O
definition _ _ O
allows _ _ O
us _ _ O
to _ _ O
easily _ _ O
define _ _ O
important _ _ O
string _ _ O
operations _ _ O
Definition _ _ O
: _ _ O
The _ _ O
concatenation _ _ O
of _ _ O
two _ _ O
strings _ _ O
can _ _ O
be _ _ O
defined _ _ O
as _ _ O
follows _ _ O
: _ _ O
1 _ _ O
. _ _ O
Basis _ _ O
step _ _ O
: _ _ O
if _ _ O
w _ _ O
∈ _ _ O
∑ _ _ O
* _ _ O
, _ _ O
then _ _ O
w⋄λ _ _ O
= _ _ O
w _ _ O
2 _ _ O
. _ _ O
Recursive _ _ O
step _ _ O
: _ _ O
if _ _ O
w1 _ _ O
∈ _ _ O
∑ _ _ O
* _ _ O
, _ _ O
w2 _ _ O
∈ _ _ O
∑ _ _ O
* _ _ O
, _ _ O
and _ _ O
x _ _ O
∈ _ _ O
∑ _ _ O
, _ _ O
then _ _ O
w1⋄ _ _ O
( _ _ O
w2x _ _ O
) _ _ O
= _ _ O
( _ _ O
w1⋄w2 _ _ O
) _ _ O
x _ _ O
Example _ _ O
: _ _ O
Concatenate _ _ O
the _ _ O
strings _ _ O
“ _ _ O
Hello _ _ O
” _ _ O
and _ _ O
“ _ _ O
World _ _ O
” _ _ O
1 _ _ O
. _ _ O
Hello⋄World _ _ O
= _ _ O
( _ _ O
Hello⋄Worl _ _ O
) _ _ O
d _ _ O
2 _ _ O
. _ _ O
= _ _ O
( _ _ O
Hello⋄Wor _ _ O
) _ _ O
ld _ _ O
3 _ _ O
. _ _ O
= _ _ O
( _ _ O
Hello⋄Wo _ _ O
) _ _ O
rld _ _ O
4 _ _ O
. _ _ O
= _ _ O
( _ _ O
Hello⋄W _ _ O
) _ _ O
orld _ _ O
5 _ _ O
. _ _ O
= _ _ O
( _ _ O
Hello⋄λ _ _ O
) _ _ O
World _ _ O
6 _ _ O
. _ _ O
= _ _ O
HelloWorld _ _ O

This _ _ O
recursive _ _ O
definition _ _ O
allows _ _ O
us _ _ O
to _ _ O
easily _ _ O
define _ _ O
important _ _ O
string _ _ O
operations _ _ O
Definition _ _ O
: _ _ O
The _ _ O
length _ _ O
l _ _ O
( _ _ O
w _ _ O
) _ _ O
of _ _ O
a _ _ O
string _ _ O
can _ _ O
be _ _ O
defined _ _ O
as _ _ O
follows _ _ O
: _ _ O
1 _ _ O
. _ _ O
Basis _ _ O
step _ _ O
: _ _ O
l _ _ O
( _ _ O
λ _ _ O
) _ _ O
= _ _ O
0 _ _ O
2 _ _ O
. _ _ O
Recursive _ _ O
step _ _ O
: _ _ O
l _ _ O
( _ _ O
wx _ _ O
) _ _ O
= _ _ O
l _ _ O
( _ _ O
w _ _ O
) _ _ O
+ _ _ O
1 _ _ O
if _ _ O
w _ _ O
∈ _ _ O
∑ _ _ O
* _ _ O
and _ _ O
x _ _ O
∈ _ _ O
∑ _ _ O
Example _ _ O
: _ _ O
l _ _ O
( _ _ O
1001 _ _ O
) _ _ O
= _ _ O
l _ _ O
( _ _ O
100 _ _ O
) _ _ O
+ _ _ O
1 _ _ O
= _ _ O
l _ _ O
( _ _ O
10 _ _ O
) _ _ O
+ _ _ O
1 _ _ O
+ _ _ O
1 _ _ O
= _ _ O
l _ _ O
( _ _ O
1 _ _ O
) _ _ O
+ _ _ O
1 _ _ O
+ _ _ O
1 _ _ O
+ _ _ O
1 _ _ O
= _ _ O
l _ _ O
( _ _ O
λ _ _ O
) _ _ O
+ _ _ O
1 _ _ O
+ _ _ O
1 _ _ O
+ _ _ O
1 _ _ O
+ _ _ O
1 _ _ O
= _ _ O
0+1+1+1+1 _ _ O
= _ _ O
4 _ _ O

We _ _ O
can _ _ O
define _ _ O
sets _ _ O
of _ _ O
well-formed _ _ O
formulae _ _ O
recursively _ _ O
This _ _ O
is _ _ O
often _ _ O
used _ _ O
to _ _ O
specify _ _ O
the _ _ O
operations _ _ O
permissible _ _ O
in _ _ O
a _ _ O
given _ _ O
formal _ _ O
language _ _ O
( _ _ O
e.g. _ _ O
, _ _ O
a _ _ O
programming _ _ O
language _ _ O
) _ _ O
Example _ _ O
: _ _ O
Defining _ _ O
propositional _ _ O
logic _ _ O
1 _ _ O
. _ _ O
Basis _ _ O
step _ _ O
: _ _ O
⟙ _ _ O
, _ _ O
⟘ _ _ O
, _ _ O
and _ _ O
s _ _ O
are _ _ O
well-formed _ _ O
propositional _ _ O
logic _ _ O
statements _ _ O
( _ _ O
where _ _ O
s _ _ O
is _ _ O
a _ _ O
propositional _ _ O
variable _ _ O
) _ _ O
2 _ _ O
. _ _ O
Recursive _ _ O
step _ _ O
: _ _ O
If _ _ O
E _ _ O
and _ _ O
F _ _ O
are _ _ O
well-formed _ _ O
statements _ _ O
, _ _ O
so _ _ O
are _ _ O
➣ _ _ O
➣ _ _ O
➣ _ _ O
➣ _ _ O
➣ _ _ O
( _ _ O
¬E _ _ O
) _ _ O
( _ _ O
E _ _ O
∧ _ _ O
F _ _ O
) _ _ O
( _ _ O
E _ _ O
∨ _ _ O
F _ _ O
) _ _ O
( _ _ O
E _ _ O
→ _ _ O
F _ _ O
) _ _ O
( _ _ O
E _ _ O
↔ _ _ O
F _ _ O
) _ _ O

Example _ _ O
Question _ _ O
: _ _ O
Is _ _ O
( _ _ O
( _ _ O
p _ _ O
∧ _ _ O
q _ _ O
) _ _ O
→ _ _ O
( _ _ O
( _ _ O
( _ _ O
¬r _ _ O
) _ _ O
∨ _ _ O
q _ _ O
) _ _ O
∧ _ _ O
t _ _ O
) _ _ O
) _ _ O
well-formed _ _ O
? _ _ O
l _ _ O
l _ _ O
l _ _ O
l _ _ O
l _ _ O
Basis _ _ O
tells _ _ O
us _ _ O
that _ _ O
p _ _ O
, _ _ O
q _ _ O
, _ _ O
r _ _ O
, _ _ O
t _ _ O
are _ _ O
well-formed _ _ O
1st _ _ O
application _ _ O
: _ _ O
( _ _ O
p _ _ O
∧ _ _ O
q _ _ O
) _ _ O
, _ _ O
( _ _ O
¬r _ _ O
) _ _ O
are _ _ O
well-formed _ _ O
2nd _ _ O
application _ _ O
: _ _ O
( _ _ O
( _ _ O
¬r _ _ O
) _ _ O
∨ _ _ O
q _ _ O
) _ _ O
is _ _ O
well-formed _ _ O
3rd _ _ O
application _ _ O
: _ _ O
( _ _ O
( _ _ O
( _ _ O
¬r _ _ O
) _ _ O
∨ _ _ O
q _ _ O
) _ _ O
∧ _ _ O
t _ _ O
) _ _ O
4th _ _ O
application _ _ O
: _ _ O
( _ _ O
( _ _ O
p _ _ O
∧ _ _ O
q _ _ O
) _ _ O
→ _ _ O
( _ _ O
( _ _ O
( _ _ O
¬r _ _ O
) _ _ O
∨ _ _ O
q _ _ O
) _ _ O
∧ _ _ O
t _ _ O
) _ _ O
) _ _ O
is _ _ O
well-formed _ _ O
✔ _ _ O

In-class _ _ O
exercises _ _ O
Problem _ _ O
1 _ _ O
: _ _ O
Construct _ _ O
a _ _ O
recursive _ _ O
definition _ _ O
of _ _ O
the _ _ O
sequence _ _ O
𝑎 _ _ O
# _ _ O
where _ _ O
the _ _ O
𝑛$% _ _ O
term _ _ O
is _ _ O
a _ _ O
natural _ _ O
number _ _ O
computed _ _ O
by _ _ O
adding _ _ O
the _ _ O
𝑛 _ _ O
− _ _ O
1 _ _ O
$ _ _ O
% _ _ O
term _ _ O
to _ _ O
the _ _ O
square _ _ O
of _ _ O
the _ _ O
𝑛 _ _ O
− _ _ O
3 _ _ O
$ _ _ O
% _ _ O
term _ _ O
. _ _ O
Assume _ _ O
that _ _ O
the _ _ O
first _ _ O
three _ _ O
terms _ _ O
of _ _ O
this _ _ O
sequence _ _ O
are _ _ O
1 _ _ O
, _ _ O
1 _ _ O
, _ _ O
1 _ _ O
. _ _ O
Problem _ _ O
2 _ _ O
: _ _ O
Top _ _ O
Hat _ _ O

Like _ _ O
other _ _ O
forms _ _ O
of _ _ O
induction _ _ O
, _ _ O
structural _ _ O
induction _ _ O
requires _ _ O
that _ _ O
we _ _ O
consider _ _ O
two _ _ O
cases _ _ O
Basis _ _ O
step _ _ O
: _ _ O
Show _ _ O
that _ _ O
the _ _ O
result _ _ O
holds _ _ O
for _ _ O
the _ _ O
objects _ _ O
specified _ _ O
in _ _ O
the _ _ O
basis _ _ O
case _ _ O
of _ _ O
the _ _ O
recursive _ _ O
definition _ _ O
Recursive _ _ O
step _ _ O
: _ _ O
Show _ _ O
that _ _ O
if _ _ O
the _ _ O
result _ _ O
holds _ _ O
for _ _ O
the _ _ O
objects _ _ O
used _ _ O
to _ _ O
construct _ _ O
new _ _ O
elements _ _ O
using _ _ O
the _ _ O
recursive _ _ O
step _ _ O
of _ _ O
the _ _ O
definition _ _ O
, _ _ O
then _ _ O
it _ _ O
holds _ _ O
for _ _ O
the _ _ O
new _ _ O
object _ _ O
as _ _ O
well _ _ O
. _ _ O
To _ _ O
see _ _ O
how _ _ O
this _ _ O
works _ _ O
, _ _ O
let _ _ O
’s _ _ O
revisit _ _ O
string _ _ O
length _ _ O
… _ _ O

Recall _ _ O
from _ _ O
earlier _ _ O
… _ _ O
Definition _ _ O
: _ _ O
The _ _ O
length _ _ O
l _ _ O
( _ _ O
w _ _ O
) _ _ O
of _ _ O
a _ _ O
string _ _ O
can _ _ O
be _ _ O
defined _ _ O
as _ _ O
follows _ _ O
: _ _ O
1 _ _ O
. _ _ O
Basis _ _ O
step _ _ O
: _ _ O
l _ _ O
( _ _ O
λ _ _ O
) _ _ O
= _ _ O
0 _ _ O
2 _ _ O
. _ _ O
Recursive _ _ O
step _ _ O
: _ _ O
l _ _ O
( _ _ O
wx _ _ O
) _ _ O
= _ _ O
l _ _ O
( _ _ O
w _ _ O
) _ _ O
+ _ _ O
1 _ _ O
if _ _ O
w _ _ O
∈ _ _ O
∑ _ _ O
* _ _ O
and _ _ O
x _ _ O
∈ _ _ O
∑ _ _ O
Example _ _ O
: _ _ O
l _ _ O
( _ _ O
1001 _ _ O
) _ _ O
= _ _ O
l _ _ O
( _ _ O
100 _ _ O
) _ _ O
+ _ _ O
1 _ _ O
= _ _ O
l _ _ O
( _ _ O
10 _ _ O
) _ _ O
+ _ _ O
1 _ _ O
+ _ _ O
1 _ _ O
= _ _ O
l _ _ O
( _ _ O
1 _ _ O
) _ _ O
+ _ _ O
1 _ _ O
+ _ _ O
1 _ _ O
+ _ _ O
1 _ _ O
= _ _ O
l _ _ O
( _ _ O
λ _ _ O
) _ _ O
+ _ _ O
1 _ _ O
+ _ _ O
1 _ _ O
+ _ _ O
1 _ _ O
+ _ _ O
1 _ _ O
= _ _ O
0+1+1+1+1 _ _ O
= _ _ O
4 _ _ O

Prove _ _ O
that _ _ O
l _ _ O
( _ _ O
x⋄y _ _ O
) _ _ O
= _ _ O
l _ _ O
( _ _ O
x _ _ O
) _ _ O
+ _ _ O
l _ _ O
( _ _ O
y _ _ O
) _ _ O
for _ _ O
x _ _ O
, _ _ O
y _ _ O
∈ _ _ O
∑ _ _ O
* _ _ O
P _ _ O
( _ _ O
n _ _ O
) _ _ O
≡ _ _ O
l _ _ O
( _ _ O
x⋄y _ _ O
) _ _ O
= _ _ O
l _ _ O
( _ _ O
x _ _ O
) _ _ O
+ _ _ O
l _ _ O
( _ _ O
y _ _ O
) _ _ O
whenever _ _ O
x _ _ O
∈ _ _ O
∑ _ _ O
* _ _ O
and _ _ O
l _ _ O
( _ _ O
y _ _ O
) _ _ O
= _ _ O
n _ _ O
Base _ _ O
case _ _ O
: _ _ O
P _ _ O
( _ _ O
0 _ _ O
) _ _ O
: _ _ O
l _ _ O
( _ _ O
x⋄λ _ _ O
) _ _ O
= _ _ O
l _ _ O
( _ _ O
x _ _ O
) _ _ O
= _ _ O
l _ _ O
( _ _ O
x _ _ O
) _ _ O
+ _ _ O
0 _ _ O
= _ _ O
l _ _ O
( _ _ O
x _ _ O
) _ _ O
+ _ _ O
l _ _ O
( _ _ O
λ _ _ O
) _ _ O
✔ _ _ O
I.H. _ _ O
: _ _ O
Assume _ _ O
that _ _ O
P _ _ O
( _ _ O
k _ _ O
) _ _ O
holds _ _ O
for _ _ O
an _ _ O
arbitrary _ _ O
integer _ _ O
k _ _ O
Inductive _ _ O
step _ _ O
: _ _ O
We _ _ O
will _ _ O
now _ _ O
show _ _ O
that _ _ O
P _ _ O
( _ _ O
k _ _ O
) _ _ O
→ _ _ O
P _ _ O
( _ _ O
k+1 _ _ O
) _ _ O
n _ _ O
Consider _ _ O
the _ _ O
string _ _ O
x⋄ya _ _ O
, _ _ O
where _ _ O
x _ _ O
, _ _ O
y _ _ O
∈ _ _ O
∑ _ _ O
* _ _ O
, _ _ O
a _ _ O
∈ _ _ O
∑ _ _ O
and _ _ O
l _ _ O
( _ _ O
y _ _ O
) _ _ O
= _ _ O
k _ _ O
n _ _ O
l _ _ O
( _ _ O
x⋄ya _ _ O
) _ _ O
= _ _ O
l _ _ O
( _ _ O
x⋄y _ _ O
) _ _ O
+ _ _ O
1 _ _ O
by _ _ O
the _ _ O
recursive _ _ O
definition _ _ O
of _ _ O
l _ _ O
( _ _ O
) _ _ O
n _ _ O
= _ _ O
l _ _ O
( _ _ O
x _ _ O
) _ _ O
+ _ _ O
l _ _ O
( _ _ O
y _ _ O
) _ _ O
+ _ _ O
1 _ _ O
by _ _ O
the _ _ O
I.H. _ _ O
n _ _ O
Since _ _ O
l _ _ O
( _ _ O
ya _ _ O
) _ _ O
= _ _ O
l _ _ O
( _ _ O
y _ _ O
) _ _ O
+ _ _ O
1 _ _ O
by _ _ O
the _ _ O
recursive _ _ O
defintion _ _ O
of _ _ O
l _ _ O
( _ _ O
) _ _ O
, _ _ O
we _ _ O
have _ _ O
that _ _ O
l _ _ O
( _ _ O
x⋄ya _ _ O
) _ _ O
= _ _ O
l _ _ O
( _ _ O
x _ _ O
) _ _ O
+ _ _ O
l _ _ O
( _ _ O
ya _ _ O
) _ _ O
, _ _ O
where _ _ O
ya _ _ O
is _ _ O
a _ _ O
string _ _ O
of _ _ O
size _ _ O
k+1 _ _ O
Conclusion _ _ O
: _ _ O
Since _ _ O
we _ _ O
have _ _ O
proved _ _ O
the _ _ O
base _ _ O
case _ _ O
and _ _ O
the _ _ O
inductive _ _ O
case _ _ O
, _ _ O
the _ _ O
claim _ _ O
holds _ _ O
by _ _ O
structural _ _ O
induction _ _ O
❏ _ _ O

Many _ _ O
common _ _ O
data _ _ O
structures _ _ O
used _ _ O
in _ _ O
computer _ _ O
science _ _ O
have _ _ O
recursive _ _ O
definitions _ _ O
Example _ _ O
: _ _ O
Rooted _ _ O
Trees _ _ O
Base _ _ O
step _ _ O
: _ _ O
A _ _ O
single _ _ O
node _ _ O
is _ _ O
a _ _ O
rooted _ _ O
tree _ _ O
Recursive _ _ O
step _ _ O
: _ _ O
If _ _ O
T1 _ _ O
, _ _ O
T2 _ _ O
, _ _ O
… _ _ O
, _ _ O
Tn _ _ O
are _ _ O
disjoint _ _ O
rooted _ _ O
trees _ _ O
with _ _ O
roots _ _ O
r1 _ _ O
, _ _ O
r2 _ _ O
, _ _ O
… _ _ O
, _ _ O
rn _ _ O
then _ _ O
introducing _ _ O
a _ _ O
new _ _ O
root _ _ O
r _ _ O
connected _ _ O
to _ _ O
r1 _ _ O
, _ _ O
r2 _ _ O
, _ _ O
… _ _ O
, _ _ O
rn _ _ O
forms _ _ O
a _ _ O
new _ _ O
rooted _ _ O
tree _ _ O
. _ _ O

Example _ _ O
Rooted _ _ O
Trees _ _ O
Base _ _ O
case _ _ O
: _ _ O
One _ _ O
application _ _ O
: _ _ O
… _ _ O
Two _ _ O
applications _ _ O
: _ _ O
… _ _ O
… _ _ O

Many _ _ O
common _ _ O
data _ _ O
structures _ _ O
used _ _ O
in _ _ O
computer _ _ O
science _ _ O
have _ _ O
recursive _ _ O
definitions _ _ O
Example _ _ O
: _ _ O
Extended _ _ O
binary _ _ O
trees _ _ O
Base _ _ O
step _ _ O
: _ _ O
The _ _ O
empty _ _ O
set _ _ O
is _ _ O
an _ _ O
extended _ _ O
binary _ _ O
tree _ _ O
Recursive _ _ O
step _ _ O
: _ _ O
If _ _ O
T1 _ _ O
and _ _ O
T2 _ _ O
are _ _ O
disjoint _ _ O
extended _ _ O
binary _ _ O
trees _ _ O
with _ _ O
roots _ _ O
r1 _ _ O
and _ _ O
r2 _ _ O
, _ _ O
then _ _ O
introducing _ _ O
a _ _ O
new _ _ O
root _ _ O
r _ _ O
connected _ _ O
to _ _ O
r1 _ _ O
and _ _ O
r2 _ _ O
forms _ _ O
a _ _ O
new _ _ O
extended _ _ O
binary _ _ O
tree _ _ O
. _ _ O

Example _ _ O
Extended _ _ O
Binary _ _ O
Trees _ _ O
Base _ _ O
case _ _ O
: _ _ O
∅ _ _ O
Step _ _ O
1 _ _ O
: _ _ O
Step _ _ O
2 _ _ O
: _ _ O
Step _ _ O
3 _ _ O
: _ _ O
… _ _ O
… _ _ O

Many _ _ O
common _ _ O
data _ _ O
structures _ _ O
used _ _ O
in _ _ O
computer _ _ O
science _ _ O
have _ _ O
recursive _ _ O
definitions _ _ O
Example _ _ O
: _ _ O
Full _ _ O
binary _ _ O
trees _ _ O
Base _ _ O
step _ _ O
: _ _ O
A _ _ O
single _ _ O
root _ _ O
node _ _ O
r _ _ O
is _ _ O
a _ _ O
full _ _ O
binary _ _ O
tree _ _ O
Recursive _ _ O
step _ _ O
: _ _ O
If _ _ O
T1 _ _ O
and _ _ O
T2 _ _ O
are _ _ O
disjoint _ _ O
full _ _ O
binary _ _ O
trees _ _ O
with _ _ O
roots _ _ O
r1 _ _ O
and _ _ O
r2 _ _ O
, _ _ O
then _ _ O
introducing _ _ O
a _ _ O
new _ _ O
root _ _ O
r _ _ O
connected _ _ O
to _ _ O
r1 _ _ O
and _ _ O
r2 _ _ O
forms _ _ O
a _ _ O
new _ _ O
full _ _ O
binary _ _ O
tree _ _ O
. _ _ O

Example _ _ O
Full _ _ O
Binary _ _ O
Trees _ _ O
Base _ _ O
case _ _ O
: _ _ O
Step _ _ O
1 _ _ O
: _ _ O
Step _ _ O
2 _ _ O
: _ _ O
… _ _ O

Trees _ _ O
are _ _ O
used _ _ O
to _ _ O
parse _ _ O
expressions _ _ O
456 _ _ O
( _ _ O
( _ _ O
( _ _ O
3 _ _ O
+ _ _ O
6 _ _ O
) _ _ O
× _ _ O
7 _ _ O
) _ _ O
– _ _ O
( _ _ O
4 _ _ O
+ _ _ O
2 _ _ O
) _ _ O
) _ _ O
× _ _ O
8 _ _ O
× _ _ O
57 _ _ O
63 _ _ O
- _ _ O
8 _ _ O
× _ _ O
6 _ _ O
+ _ _ O
9 _ _ O
+ _ _ O
3 _ _ O
7 _ _ O
6 _ _ O
4 _ _ O
2 _ _ O

Trees _ _ O
are _ _ O
used _ _ O
to _ _ O
enable _ _ O
fast _ _ O
searches _ _ O
Consider _ _ O
the _ _ O
set _ _ O
S _ _ O
= _ _ O
{ _ _ O
56 _ _ O
, _ _ O
22 _ _ O
, _ _ O
34 _ _ O
, _ _ O
89 _ _ O
, _ _ O
99 _ _ O
, _ _ O
77 _ _ O
, _ _ O
16 _ _ O
} _ _ O
34 _ _ O
< _ _ O
56 _ _ O
22 _ _ O
34 _ _ O
> _ _ O
22 _ _ O
34 _ _ O
16 _ _ O
56 _ _ O
262 _ _ O
> _ _ O
56 _ _ O
89 _ _ O
77 _ _ O
262 _ _ O
> _ _ O
89 _ _ O
99 _ _ O
Question _ _ O
: _ _ O
Is _ _ O
34 _ _ O
∈ _ _ O
S _ _ O
? _ _ O
Question _ _ O
: _ _ O
Is _ _ O
262 _ _ O
∈ _ _ O
S _ _ O
? _ _ O
YES _ _ O
! _ _ O
NO _ _ O
! _ _ O

As _ _ O
with _ _ O
other _ _ O
recursively _ _ O
defined _ _ O
objects _ _ O
, _ _ O
we _ _ O
can _ _ O
define _ _ O
many _ _ O
properties _ _ O
of _ _ O
trees _ _ O
recursively _ _ O
Definition _ _ O
: _ _ O
Given _ _ O
a _ _ O
tree _ _ O
T _ _ O
, _ _ O
we _ _ O
can _ _ O
define _ _ O
the _ _ O
height _ _ O
of _ _ O
T _ _ O
recursively _ _ O
, _ _ O
as _ _ O
follows _ _ O
: _ _ O
1 _ _ O
. _ _ O
Basis _ _ O
step _ _ O
: _ _ O
If _ _ O
T _ _ O
consists _ _ O
only _ _ O
of _ _ O
the _ _ O
root _ _ O
node _ _ O
r _ _ O
, _ _ O
then _ _ O
h _ _ O
( _ _ O
T _ _ O
) _ _ O
= _ _ O
0 _ _ O
2 _ _ O
. _ _ O
Recursive _ _ O
step _ _ O
: _ _ O
If _ _ O
T _ _ O
consists _ _ O
of _ _ O
a _ _ O
root _ _ O
r _ _ O
that _ _ O
connects _ _ O
to _ _ O
subtrees _ _ O
T1 _ _ O
, _ _ O
… _ _ O
, _ _ O
Tn _ _ O
, _ _ O
then _ _ O
h _ _ O
( _ _ O
T _ _ O
) _ _ O
= _ _ O
1 _ _ O
+ _ _ O
max _ _ O
( _ _ O
h _ _ O
( _ _ O
T1 _ _ O
) _ _ O
, _ _ O
… _ _ O
, _ _ O
h _ _ O
( _ _ O
Tn _ _ O
) _ _ O
) _ _ O
Example _ _ O
: _ _ O
What _ _ O
is _ _ O
the _ _ O
height _ _ O
of _ _ O
this _ _ O
tree _ _ O
T _ _ O
? _ _ O
h _ _ O
( _ _ O
T _ _ O
) _ _ O
= _ _ O
1 _ _ O
+ _ _ O
max _ _ O
( _ _ O
h _ _ O
( _ _ O
L _ _ O
) _ _ O
, _ _ O
h _ _ O
( _ _ O
R _ _ O
) _ _ O
) _ _ O
= _ _ O
3 _ _ O
h _ _ O
( _ _ O
L _ _ O
) _ _ O
= _ _ O
1 _ _ O
+ _ _ O
h _ _ O
( _ _ O
L1 _ _ O
) _ _ O
= _ _ O
2 _ _ O
h _ _ O
( _ _ O
L1 _ _ O
) _ _ O
= _ _ O
1 _ _ O
+ _ _ O
max _ _ O
( _ _ O
h _ _ O
( _ _ O
L11 _ _ O
) _ _ O
, _ _ O
h _ _ O
( _ _ O
L12 _ _ O
) _ _ O
) _ _ O
= _ _ O
1 _ _ O
h _ _ O
( _ _ O
L11 _ _ O
) _ _ O
= _ _ O
0 _ _ O
h _ _ O
( _ _ O
R _ _ O
) _ _ O
= _ _ O
1 _ _ O
+ _ _ O
h _ _ O
( _ _ O
R1 _ _ O
) _ _ O
= _ _ O
1 _ _ O
h _ _ O
( _ _ O
R1 _ _ O
) _ _ O
= _ _ O
0 _ _ O
h _ _ O
( _ _ O
L12 _ _ O
) _ _ O
= _ _ O
0 _ _ O

If _ _ O
T _ _ O
is _ _ O
a _ _ O
full _ _ O
binary _ _ O
tree _ _ O
, _ _ O
then _ _ O
the _ _ O
number _ _ O
of _ _ O
nodes _ _ O
in _ _ O
T _ _ O
( _ _ O
denoted _ _ O
n _ _ O
( _ _ O
T _ _ O
) _ _ O
) _ _ O
is _ _ O
less _ _ O
than _ _ O
or _ _ O
equal _ _ O
to _ _ O
2h _ _ O
( _ _ O
T _ _ O
) _ _ O
+1 _ _ O
- _ _ O
1 _ _ O
Claim _ _ O
: _ _ O
n _ _ O
( _ _ O
T _ _ O
) _ _ O
≤ _ _ O
2h _ _ O
( _ _ O
T _ _ O
) _ _ O
+1 _ _ O
- _ _ O
1 _ _ O
Base _ _ O
case _ _ O
: _ _ O
T _ _ O
contains _ _ O
only _ _ O
a _ _ O
root _ _ O
node _ _ O
. _ _ O
In _ _ O
this _ _ O
case _ _ O
n _ _ O
( _ _ O
T _ _ O
) _ _ O
= _ _ O
1 _ _ O
and _ _ O
h _ _ O
( _ _ O
T _ _ O
) _ _ O
= _ _ O
0 _ _ O
. _ _ O
Note _ _ O
that _ _ O
20+1 _ _ O
- _ _ O
1 _ _ O
= _ _ O
1 _ _ O
, _ _ O
so _ _ O
the _ _ O
claim _ _ O
holds _ _ O
. _ _ O
I.H. _ _ O
: _ _ O
Assume _ _ O
that _ _ O
claim _ _ O
holds _ _ O
for _ _ O
a _ _ O
tree _ _ O
of _ _ O
height _ _ O
k _ _ O
Inductive _ _ O
step _ _ O
: _ _ O
Show _ _ O
that _ _ O
the _ _ O
claim _ _ O
holds _ _ O
for _ _ O
trees _ _ O
of _ _ O
height _ _ O
k+1 _ _ O
n _ _ O
Let _ _ O
T1 _ _ O
and _ _ O
T2 _ _ O
be _ _ O
disjoint _ _ O
full _ _ O
binary _ _ O
trees _ _ O
of _ _ O
height _ _ O
k _ _ O
n _ _ O
By _ _ O
the _ _ O
I.H. _ _ O
, _ _ O
n _ _ O
( _ _ O
T1 _ _ O
) _ _ O
≤ _ _ O
2h _ _ O
( _ _ O
T1 _ _ O
) _ _ O
+1 _ _ O
- _ _ O
1 _ _ O
and _ _ O
n _ _ O
( _ _ O
T2 _ _ O
) _ _ O
≤ _ _ O
2h _ _ O
( _ _ O
T2 _ _ O
) _ _ O
+1 _ _ O
- _ _ O
1 _ _ O
n _ _ O
Let _ _ O
r _ _ O
be _ _ O
a _ _ O
unique _ _ O
root _ _ O
element _ _ O
, _ _ O
and _ _ O
let _ _ O
T _ _ O
be _ _ O
the _ _ O
tree _ _ O
formed _ _ O
using _ _ O
r _ _ O
as _ _ O
a _ _ O
root _ _ O
, _ _ O
T1 _ _ O
as _ _ O
the _ _ O
left _ _ O
subtree _ _ O
of _ _ O
r _ _ O
, _ _ O
and _ _ O
T2 _ _ O
as _ _ O
the _ _ O
right _ _ O
subtree _ _ O
of _ _ O
r _ _ O
r _ _ O
T1 _ _ O
T2 _ _ O

If _ _ O
T _ _ O
is _ _ O
a _ _ O
full _ _ O
binary _ _ O
tree _ _ O
, _ _ O
then _ _ O
the _ _ O
number _ _ O
of _ _ O
nodes _ _ O
in _ _ O
T _ _ O
( _ _ O
denoted _ _ O
n _ _ O
( _ _ O
T _ _ O
) _ _ O
) _ _ O
is _ _ O
less _ _ O
than _ _ O
or _ _ O
equal _ _ O
to _ _ O
2h _ _ O
( _ _ O
T _ _ O
) _ _ O
+1 _ _ O
- _ _ O
1 _ _ O
r _ _ O
T1 _ _ O
T2 _ _ O
Inductive _ _ O
step _ _ O
( _ _ O
cont _ _ O
. _ _ O
) _ _ O
: _ _ O
We _ _ O
have _ _ O
that _ _ O
n _ _ O
n _ _ O
( _ _ O
T _ _ O
) _ _ O
= _ _ O
1 _ _ O
+ _ _ O
n _ _ O
( _ _ O
T1 _ _ O
) _ _ O
+ _ _ O
n _ _ O
( _ _ O
T2 _ _ O
) _ _ O
n _ _ O
≤ _ _ O
1 _ _ O
+ _ _ O
2h _ _ O
( _ _ O
T1 _ _ O
) _ _ O
+1 _ _ O
- _ _ O
1 _ _ O
+ _ _ O
2h _ _ O
( _ _ O
T2 _ _ O
) _ _ O
+1 _ _ O
- _ _ O
1 _ _ O
n _ _ O
≤ _ _ O
2h _ _ O
( _ _ O
T1 _ _ O
) _ _ O
+1 _ _ O
+ _ _ O
2h _ _ O
( _ _ O
T2 _ _ O
) _ _ O
+1 _ _ O
– _ _ O
1 _ _ O
n _ _ O
≤ _ _ O
2 _ _ O
×max _ _ O
( _ _ O
2h _ _ O
( _ _ O
T1 _ _ O
) _ _ O
+1 _ _ O
, _ _ O
2h _ _ O
( _ _ O
T2 _ _ O
) _ _ O
+1 _ _ O
) _ _ O
– _ _ O
1 _ _ O
n _ _ O
≤ _ _ O
2 _ _ O
×2max _ _ O
( _ _ O
h _ _ O
( _ _ O
T1 _ _ O
) _ _ O
, _ _ O
h _ _ O
( _ _ O
T2 _ _ O
) _ _ O
) _ _ O
+1 _ _ O
– _ _ O
1 _ _ O
n _ _ O
≤ _ _ O
2 _ _ O
×2h _ _ O
( _ _ O
T _ _ O
) _ _ O
– _ _ O
1 _ _ O
n _ _ O
≤ _ _ O
2h _ _ O
( _ _ O
T _ _ O
) _ _ O
+1 _ _ O
– _ _ O
1 _ _ O
by _ _ O
recursive _ _ O
formula _ _ O
of _ _ O
n _ _ O
( _ _ O
T _ _ O
) _ _ O
by _ _ O
I.H. _ _ O
sum _ _ O
of _ _ O
2 _ _ O
terms _ _ O
≤ _ _ O
twice _ _ O
larger _ _ O
term _ _ O
max _ _ O
( _ _ O
2x _ _ O
, _ _ O
2y _ _ O
) _ _ O
= _ _ O
2max _ _ O
( _ _ O
x _ _ O
, _ _ O
y _ _ O
) _ _ O
by _ _ O
recursive _ _ O
def’n _ _ O
of _ _ O
h _ _ O
( _ _ O
T _ _ O
) _ _ O
Conclusion _ _ O
: _ _ O
Since _ _ O
we _ _ O
have _ _ O
proved _ _ O
the _ _ O
base _ _ O
case _ _ O
and _ _ O
the _ _ O
inductive _ _ O
case _ _ O
, _ _ O
the _ _ O
claim _ _ O
holds _ _ O
by _ _ O
structural _ _ O
induction _ _ O
❏ _ _ O

In-class _ _ O
exercises _ _ O
Problem _ _ O
3 _ _ O
: _ _ O
Use _ _ O
structural _ _ O
induction _ _ O
to _ _ O
prove _ _ O
that _ _ O
checking _ _ O
whether _ _ O
some _ _ O
number _ _ O
is _ _ O
contained _ _ O
in _ _ O
a _ _ O
binary _ _ O
search _ _ O
tree _ _ O
T _ _ O
involves _ _ O
at _ _ O
most _ _ O
h _ _ O
( _ _ O
T _ _ O
) _ _ O
+1 _ _ O
comparison _ _ O
operations _ _ O
. _ _ O

Final _ _ O
Thoughts _ _ O
n _ _ O
Structural _ _ O
induction _ _ O
can _ _ O
be _ _ O
used _ _ O
to _ _ O
prove _ _ O
properties _ _ O
of _ _ O
recursive _ _ O
l _ _ O
Functions _ _ O
l _ _ O
Sequences _ _ O
l _ _ O
Sets _ _ O
l _ _ O
Data _ _ O
structures _ _ O
n _ _ O
Next _ _ O
time _ _ O
, _ _ O
we _ _ O
start _ _ O
learning _ _ O
about _ _ O
counting _ _ O
and _ _ O
combinatorics _ _ O
( _ _ O
Section _ _ O
6.1 _ _ O
) _ _ O



