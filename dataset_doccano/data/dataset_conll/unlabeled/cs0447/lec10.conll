unlabeled|cs0447|lec10
-DOCSTART- -X- -X- O

# _ _ O
10 _ _ O
The _ _ O
Register _ _ O
File _ _ O
and _ _ O
Building _ _ O
an _ _ O
ALU _ _ O
CS _ _ O
0447 _ _ O
Introduction _ _ O
to _ _ O
Computer _ _ O
Programming _ _ O
Luís _ _ O
Oliveira _ _ O
Original _ _ O
slides _ _ O
by _ _ O
: _ _ O
Jarrett _ _ O
Billingsley _ _ O
Modified _ _ O
with _ _ O
bits _ _ O
from _ _ O
: _ _ O
Bruce _ _ O
Childers _ _ O
, _ _ O
David _ _ O
Wilkinson _ _ O
1 _ _ O
Fall _ _ O
2020 _ _ O

The _ _ O
Register _ _ O
File _ _ O
Abstracting _ _ O
out _ _ O
the _ _ O
flip-flops _ _ O
. _ _ O
2 _ _ O

Remember _ _ O
this _ _ O
? _ _ O
Program _ _ O
instruction _ _ O
Control _ _ O
3 _ _ O
5 _ _ O
8 _ _ O
Registers _ _ O
+ _ _ O
A _ _ O
B _ _ O
C _ _ O
Memory _ _ O
Unresolved _ _ O
questions _ _ O
: _ _ O
● _ _ O
What _ _ O
's _ _ O
the _ _ O
control _ _ O
? _ _ O
● _ _ O
What _ _ O
's _ _ O
the _ _ O
datapath _ _ O
? _ _ O
● _ _ O
How _ _ O
does _ _ O
it _ _ O
know _ _ O
what _ _ O
instruction _ _ O
to _ _ O
get _ _ O
next _ _ O
? _ _ O
● _ _ O
How _ _ O
does _ _ O
it _ _ O
know _ _ O
what _ _ O
registers _ _ O
to _ _ O
access _ _ O
? _ _ O
● _ _ O
How _ _ O
does _ _ O
it _ _ O
know _ _ O
to _ _ O
add _ _ O
, _ _ O
subtract _ _ O
, _ _ O
etc _ _ O
. _ _ O
? _ _ O
Datapath _ _ O
Processor _ _ O
3 _ _ O

Zooming _ _ O
in _ _ O
if _ _ O
( _ _ O
add _ _ O
) _ _ O
do _ _ O
this _ _ O
else _ _ O
if _ _ O
... _ _ O
fp _ _ O
s4 _ _ O
at _ _ O
sp _ _ O
eax _ _ O
? _ _ O
Control _ _ O
t0 _ _ O
Registers _ _ O
registers _ _ O
hold _ _ O
the _ _ O
values _ _ O
being _ _ O
computed _ _ O
control _ _ O
signals _ _ O
! _ _ O
values _ _ O
move _ _ O
between _ _ O
them _ _ O
... _ _ O
oh _ _ O
yeah _ _ O
, _ _ O
memory _ _ O
too _ _ O
the _ _ O
control _ _ O
tells _ _ O
everything _ _ O
else _ _ O
what _ _ O
to _ _ O
do _ _ O
, _ _ O
and _ _ O
when _ _ O
+ _ _ O
-÷ _ _ O
× _ _ O
⊕∫ _ _ O
☃ _ _ O
& _ _ O
● _ _ O
There _ _ O
are _ _ O
a _ _ O
few _ _ O
major _ _ O
parts _ _ O
of _ _ O
any _ _ O
CPU _ _ O
: _ _ O
Datapath _ _ O
the _ _ O
datapath _ _ O
computes _ _ O
new _ _ O
values _ _ O
4 _ _ O

A _ _ O
bit _ _ O
less _ _ O
abstract _ _ O
Control _ _ O
● _ _ O
The _ _ O
registers _ _ O
are _ _ O
grouped _ _ O
together _ _ O
into _ _ O
the _ _ O
register _ _ O
file _ _ O
● _ _ O
The _ _ O
ALU _ _ O
( _ _ O
arithmetic _ _ O
and _ _ O
logic _ _ O
unit _ _ O
) _ _ O
is _ _ O
the _ _ O
main _ _ O
part _ _ O
of _ _ O
the _ _ O
datapath _ _ O
● _ _ O
The _ _ O
control _ _ O
is _ _ O
doing _ _ O
its _ _ O
thing _ _ O
, _ _ O
somehow _ _ O
… _ _ O
? _ _ O
( _ _ O
we _ _ O
’ll _ _ O
see _ _ O
) _ _ O
Register _ _ O
File _ _ O
ALU _ _ O
we _ _ O
can _ _ O
get _ _ O
the _ _ O
values _ _ O
of _ _ O
two _ _ O
registers _ _ O
at _ _ O
once _ _ O
5 _ _ O

It _ _ O
does _ _ O
n't _ _ O
have _ _ O
to _ _ O
be _ _ O
this _ _ O
way _ _ O
CISC _ _ O
CPUs _ _ O
usually _ _ O
have _ _ O
small _ _ O
sets _ _ O
of _ _ O
registers _ _ O
, _ _ O
and _ _ O
many _ _ O
have _ _ O
special _ _ O
purposes _ _ O
or _ _ O
behaviors _ _ O
8086 _ _ O
z80 _ _ O
6502 _ _ O
PDP8 _ _ O
ax _ _ O
bx _ _ O
cx _ _ O
dx _ _ O
si _ _ O
di _ _ O
sp _ _ O
bp _ _ O
a _ _ O
f _ _ O
b _ _ O
c _ _ O
d _ _ O
e _ _ O
h _ _ O
l _ _ O
ix _ _ O
iy _ _ O
sp _ _ O
A _ _ O
X _ _ O
Y _ _ O
AC _ _ O
16 _ _ O
bits _ _ O
12 _ _ O
bits _ _ O
RISC _ _ O
CPUs _ _ O
usually _ _ O
have _ _ O
32 _ _ O
* _ _ O
mostlyinterchangeable _ _ O
registers _ _ O
: _ _ O
MIPS _ _ O
, _ _ O
RISC _ _ O
, _ _ O
SPARC _ _ O
, _ _ O
ARMv8 _ _ O
, _ _ O
RISC-V _ _ O
… _ _ O
r0 _ _ O
r1 _ _ O
r2 _ _ O
r3 _ _ O
r4 _ _ O
r5 _ _ O
r6 _ _ O
r7 _ _ O
r8 _ _ O
r9 _ _ O
r10 _ _ O
r11 _ _ O
r12 _ _ O
r13 _ _ O
r14 _ _ O
r15 _ _ O
32 _ _ O
/ _ _ O
64 _ _ O
r16 _ _ O
r17 _ _ O
r18 _ _ O
r19 _ _ O
r20 _ _ O
r21 _ _ O
r22 _ _ O
r23 _ _ O
bits _ _ O
r24 _ _ O
r25 _ _ O
r26 _ _ O
r27 _ _ O
r28 _ _ O
r29 _ _ O
r30 _ _ O
r31 _ _ O
8 _ _ O
bits _ _ O
why _ _ O
is _ _ O
this _ _ O
? _ _ O
well _ _ O
, _ _ O
what _ _ O
do _ _ O
you _ _ O
remember _ _ O
about _ _ O
the _ _ O
differences _ _ O
between _ _ O
RISC _ _ O
and _ _ O
CISC _ _ O
? _ _ O
* _ _ O
or _ _ O
32 _ _ O
at _ _ O
a _ _ O
time _ _ O
6 _ _ O

Tug-of-war _ _ O
● _ _ O
Register _ _ O
file _ _ O
design _ _ O
is _ _ O
constrained _ _ O
by _ _ O
many _ _ O
competing _ _ O
factors _ _ O
compilers _ _ O
love _ _ O
lots _ _ O
of _ _ O
ISA _ _ O
says _ _ O
instructions _ _ O
identical _ _ O
registers _ _ O
! _ _ O
… _ _ O
but _ _ O
there _ _ O
are _ _ O
diminishing _ _ O
returns _ _ O
. _ _ O
have _ _ O
2 _ _ O
operands _ _ O
and _ _ O
1 _ _ O
destination _ _ O
fast _ _ O
L1 _ _ O
cache _ _ O
? _ _ O
not _ _ O
as _ _ O
… _ _ O
except _ _ O
for _ _ O
this _ _ O
one _ _ O
many _ _ O
regs _ _ O
needed _ _ O
D _ _ O
Q _ _ O
instruction _ _ O
that _ _ O
has _ _ O
D _ _ O
QQ _ _ O
D _ _ O
2 _ _ O
destinations _ _ O
. _ _ O
multi-issue _ _ O
CPU _ _ O
: _ _ O
need _ _ O
to _ _ O
humans _ _ O
like _ _ O
intuitive _ _ O
assembly _ _ O
language _ _ O
! _ _ O
with _ _ O
lots _ _ O
of _ _ O
registers _ _ O
, _ _ O
function _ _ O
calls _ _ O
are _ _ O
faster _ _ O
! _ _ O
… _ _ O
but _ _ O
context _ _ O
switches _ _ O
are _ _ O
slower _ _ O
. _ _ O
read _ _ O
4 _ _ O
regs _ _ O
and _ _ O
write _ _ O
2 _ _ O
more _ _ O
registers _ _ O
means _ _ O
more _ _ O
silicon _ _ O
… _ _ O
7 _ _ O

A _ _ O
word _ _ O
of _ _ O
advice _ _ O
● _ _ O
You _ _ O
will _ _ O
see _ _ O
many _ _ O
imperfect _ _ O
designs _ _ O
in _ _ O
your _ _ O
life _ _ O
● _ _ O
But _ _ O
in _ _ O
problem-solving _ _ O
, _ _ O
perfection _ _ O
is _ _ O
n't _ _ O
always _ _ O
the _ _ O
goal _ _ O
o _ _ O
everyone _ _ O
has _ _ O
to _ _ O
work _ _ O
within _ _ O
the _ _ O
constraints _ _ O
they _ _ O
're _ _ O
given _ _ O
● _ _ O
and _ _ O
if _ _ O
everyone _ _ O
does _ _ O
something _ _ O
the _ _ O
same _ _ O
way _ _ O
… _ _ O
o _ _ O
there _ _ O
are _ _ O
probably _ _ O
problems _ _ O
/ _ _ O
constraints _ _ O
you _ _ O
do _ _ O
n't _ _ O
know _ _ O
about _ _ O
o _ _ O
do _ _ O
n't _ _ O
waste _ _ O
your _ _ O
time _ _ O
reinventing _ _ O
the _ _ O
wheel _ _ O
. _ _ O
▪ _ _ O
find _ _ O
out _ _ O
why _ _ O
it _ _ O
's _ _ O
done _ _ O
that _ _ O
way _ _ O
first _ _ O
. _ _ O
● _ _ O
When _ _ O
it _ _ O
comes _ _ O
to _ _ O
register _ _ O
files _ _ O
, _ _ O
32 _ _ O
registers _ _ O
is _ _ O
just _ _ O
a _ _ O
nice _ _ O
number _ _ O
o _ _ O
not _ _ O
too _ _ O
many _ _ O
, _ _ O
not _ _ O
too _ _ O
few _ _ O
, _ _ O
a _ _ O
nice _ _ O
middle-ground _ _ O
● _ _ O
also _ _ O
do _ _ O
n't _ _ O
be _ _ O
a _ _ O
judgmental _ _ O
ass _ _ O
about _ _ O
someone _ _ O
else _ _ O
's _ _ O
design _ _ O
because _ _ O
one _ _ O
, _ _ O
it _ _ O
's _ _ O
shitty _ _ O
, _ _ O
and _ _ O
two _ _ O
, _ _ O
they _ _ O
know _ _ O
more _ _ O
about _ _ O
why _ _ O
it _ _ O
was _ _ O
designed _ _ O
that _ _ O
way _ _ O
, _ _ O
so _ _ O
you _ _ O
're _ _ O
just _ _ O
being _ _ O
presumptuous _ _ O
8 _ _ O

Soooo _ _ O
registers _ _ O
… _ _ O
How _ _ O
do _ _ O
we _ _ O
create _ _ O
a _ _ O
register _ _ O
? _ _ O
● _ _ O
If _ _ O
we _ _ O
create _ _ O
a _ _ O
32-bit _ _ O
register _ _ O
out _ _ O
of _ _ O
D _ _ O
Flip-Flops _ _ O
: _ _ O
D _ _ O
Q _ _ O
D _ _ O
Q _ _ O
D _ _ O
Q _ _ O
D _ _ O
Q _ _ O
D _ _ O
Flip-Flop _ _ O
D _ _ O
Flip-Flop _ _ O
D _ _ O
Flip-Flop _ _ O
D _ _ O
Flip-Flop _ _ O
3rd _ _ O
bit _ _ O
2nd _ _ O
bit _ _ O
1st _ _ O
bit _ _ O
0th _ _ O
bit _ _ O
We _ _ O
abstract _ _ O
away _ _ O
to _ _ O
this _ _ O
: _ _ O
32 _ _ O
D _ _ O
Q _ _ O
32 _ _ O
Register _ _ O
Thankfully _ _ O
, _ _ O
so _ _ O
does _ _ O
Logisim _ _ O
! _ _ O
9 _ _ O

Combined _ _ O
into _ _ O
… _ _ O
● _ _ O
Then _ _ O
, _ _ O
we _ _ O
can _ _ O
combine _ _ O
many _ _ O
of _ _ O
those _ _ O
together _ _ O
: _ _ O
Register _ _ O
File _ _ O
32 _ _ O
D _ _ O
Q _ _ O
32 _ _ O
Register _ _ O
32 _ _ O
D _ _ O
Q _ _ O
32 _ _ O
Register _ _ O
… _ _ O
32 _ _ O
D _ _ O
Q _ _ O
32 _ _ O
Register _ _ O
10 _ _ O

The _ _ O
MIPS _ _ O
register _ _ O
file _ _ O
● _ _ O
In _ _ O
the _ _ O
instruction _ _ O
add _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t2 _ _ O
, _ _ O
how _ _ O
many _ _ O
registers _ _ O
are _ _ O
read _ _ O
? _ _ O
o _ _ O
how _ _ O
many _ _ O
are _ _ O
written _ _ O
? _ _ O
o _ _ O
how _ _ O
many _ _ O
different _ _ O
registers _ _ O
are _ _ O
accessed _ _ O
? _ _ O
there _ _ O
's _ _ O
one _ _ O
input _ _ O
or _ _ O
write _ _ O
port _ _ O
it _ _ O
needs _ _ O
a _ _ O
clock _ _ O
signal _ _ O
. _ _ O
what _ _ O
other _ _ O
control _ _ O
signals _ _ O
does _ _ O
it _ _ O
need _ _ O
? _ _ O
Register _ _ O
File _ _ O
WE _ _ O
how _ _ O
about _ _ O
a _ _ O
write _ _ O
enable _ _ O
? _ _ O
rd _ _ O
rs _ _ O
rt _ _ O
there _ _ O
are _ _ O
two _ _ O
output _ _ O
or _ _ O
read _ _ O
ports _ _ O
each _ _ O
port _ _ O
can _ _ O
read _ _ O
a _ _ O
different _ _ O
register _ _ O
and _ _ O
inputs _ _ O
to _ _ O
select _ _ O
the _ _ O
registers _ _ O
? _ _ O
11 _ _ O

Reading _ _ O
from _ _ O
one _ _ O
register _ _ O
● _ _ O
You _ _ O
have _ _ O
two _ _ O
registers _ _ O
, _ _ O
and _ _ O
you _ _ O
want _ _ O
to _ _ O
choose _ _ O
one _ _ O
to _ _ O
read _ _ O
what _ _ O
kind _ _ O
of _ _ O
component _ _ O
chooses _ _ O
? _ _ O
D _ _ O
A _ _ O
WE83 _ _ O
Q _ _ O
29 _ _ O
83 _ _ O
B _ _ O
D _ _ O
reading _ _ O
from _ _ O
a _ _ O
register _ _ O
is _ _ O
technically _ _ O
combinational _ _ O
Q _ _ O
29 _ _ O
WE _ _ O
0 _ _ O
1 _ _ O
a _ _ O
read _ _ O
port _ _ O
is _ _ O
made _ _ O
of _ _ O
a _ _ O
select _ _ O
signal _ _ O
, _ _ O
a _ _ O
MUX _ _ O
, _ _ O
and _ _ O
a _ _ O
data _ _ O
output _ _ O
12 _ _ O

Writing _ _ O
● _ _ O
For _ _ O
the _ _ O
write _ _ O
port _ _ O
, _ _ O
we _ _ O
only _ _ O
want _ _ O
to _ _ O
write _ _ O
to _ _ O
one _ _ O
register _ _ O
at _ _ O
a _ _ O
time _ _ O
● _ _ O
We _ _ O
'll _ _ O
have _ _ O
a _ _ O
select _ _ O
signal _ _ O
again _ _ O
… _ _ O
when _ _ O
should _ _ O
we _ _ O
write _ _ O
to _ _ O
A _ _ O
? _ _ O
select _ _ O
= _ _ O
0 _ _ O
Do _ _ O
we _ _ O
ALWAYS _ _ O
write _ _ O
to _ _ O
a _ _ O
register _ _ O
? _ _ O
WE _ _ O
= _ _ O
1 _ _ O
How _ _ O
about _ _ O
in _ _ O
beq _ _ O
A _ _ O
, _ _ O
3 _ _ O
, _ _ O
top _ _ O
? _ _ O
D _ _ O
Q _ _ O
83 _ _ O
WE _ _ O
when _ _ O
should _ _ O
we _ _ O
write _ _ O
to _ _ O
B _ _ O
? _ _ O
D _ _ O
select _ _ O
= _ _ O
1 _ _ O
WE _ _ O
= _ _ O
1 _ _ O
Q _ _ O
29 _ _ O
WE _ _ O
A _ _ O
B _ _ O
13 _ _ O

Close _ _ O
the _ _ O
door _ _ O
● _ _ O
when _ _ O
a _ _ O
register _ _ O
's _ _ O
write _ _ O
enable _ _ O
is _ _ O
0 _ _ O
, _ _ O
what _ _ O
happens _ _ O
to _ _ O
the _ _ O
data _ _ O
? _ _ O
● _ _ O
so _ _ O
we _ _ O
can _ _ O
hook _ _ O
up _ _ O
the _ _ O
data _ _ O
input _ _ O
to _ _ O
all _ _ O
registers _ _ O
at _ _ O
once _ _ O
. _ _ O
Data _ _ O
D _ _ O
Q _ _ O
83 _ _ O
WE _ _ O
A _ _ O
only _ _ O
the _ _ O
register _ _ O
with _ _ O
WE=1 _ _ O
will _ _ O
store _ _ O
the _ _ O
data _ _ O
D _ _ O
Q _ _ O
29 _ _ O
WE _ _ O
B _ _ O
14 _ _ O

Chekhov _ _ O
's _ _ O
Gun _ _ O
● _ _ O
there _ _ O
's _ _ O
a _ _ O
component _ _ O
we _ _ O
have _ _ O
n't _ _ O
seen _ _ O
in _ _ O
a _ _ O
while _ _ O
which _ _ O
only _ _ O
sends _ _ O
an _ _ O
input _ _ O
value _ _ O
to _ _ O
one _ _ O
of _ _ O
its _ _ O
outputs _ _ O
( _ _ O
demux _ _ O
) _ _ O
D _ _ O
WE _ _ O
0 _ _ O
WE _ _ O
1 _ _ O
0 _ _ O
Q _ _ O
83 _ _ O
WE _ _ O
D _ _ O
WE _ _ O
0 _ _ O
a _ _ O
write _ _ O
port _ _ O
is _ _ O
made _ _ O
of _ _ O
a _ _ O
select _ _ O
signal _ _ O
, _ _ O
a _ _ O
data _ _ O
input _ _ O
, _ _ O
a _ _ O
write _ _ O
enable _ _ O
, _ _ O
and _ _ O
some _ _ O
kinda _ _ O
logic _ _ O
to _ _ O
send _ _ O
the _ _ O
write _ _ O
enable _ _ O
to _ _ O
one _ _ O
register _ _ O
Q _ _ O
29 _ _ O
WE _ _ O
A _ _ O
B _ _ O
15 _ _ O

The _ _ O
Register _ _ O
File _ _ O
● _ _ O
And _ _ O
then _ _ O
, _ _ O
we _ _ O
can _ _ O
abstract _ _ O
our _ _ O
subcircuit _ _ O
to _ _ O
the _ _ O
following _ _ O
: _ _ O
o _ _ O
This _ _ O
presumes _ _ O
we _ _ O
have _ _ O
32 _ _ O
registers _ _ O
which _ _ O
are _ _ O
32-bits _ _ O
in _ _ O
size _ _ O
o _ _ O
( _ _ O
like _ _ O
MIPS _ _ O
! _ _ O
) _ _ O
WriteEnable _ _ O
WriteData _ _ O
Register1 _ _ O
Register2 _ _ O
32 _ _ O
32 _ _ O
5 _ _ O
5 _ _ O
Register _ _ O
File _ _ O
32 _ _ O
ReadData1 _ _ O
ReadData2 _ _ O
5 _ _ O
16 _ _ O

Diving _ _ O
in _ _ O
Control _ _ O
● _ _ O
We _ _ O
have _ _ O
a _ _ O
complete _ _ O
register _ _ O
file _ _ O
! _ _ O
● _ _ O
Now _ _ O
… _ _ O
let _ _ O
’s _ _ O
look _ _ O
more _ _ O
closely _ _ O
at _ _ O
building _ _ O
an _ _ O
ALU _ _ O
. _ _ O
Register _ _ O
File _ _ O
ALU _ _ O
17 _ _ O

Building _ _ O
Out _ _ O
a _ _ O
Basic _ _ O
ALU _ _ O
Doing _ _ O
the _ _ O
stuff _ _ O
. _ _ O
18 _ _ O

Starting _ _ O
small _ _ O
, _ _ O
the _ _ O
one-bit _ _ O
adder _ _ O
● _ _ O
Who _ _ O
remembers _ _ O
how _ _ O
to _ _ O
use _ _ O
an _ _ O
adder _ _ O
to _ _ O
subtract _ _ O
? _ _ O
Carry _ _ O
in _ _ O
A _ _ O
B _ _ O
+ _ _ O
Result _ _ O
Carry _ _ O
out _ _ O
19 _ _ O

Starting _ _ O
small _ _ O
, _ _ O
the _ _ O
one-bit _ _ O
adder _ _ O
● _ _ O
Here _ _ O
is _ _ O
a _ _ O
simple _ _ O
ALU _ _ O
. _ _ O
It _ _ O
can _ _ O
Add _ _ O
A _ _ O
and _ _ O
B _ _ O
together _ _ O
. _ _ O
o _ _ O
There _ _ O
are _ _ O
a _ _ O
few _ _ O
control _ _ O
signals _ _ O
leading _ _ O
into _ _ O
it _ _ O
and _ _ O
several _ _ O
outputs _ _ O
. _ _ O
o _ _ O
Consider _ _ O
how _ _ O
this _ _ O
ALU _ _ O
subcircuit _ _ O
, _ _ O
as _ _ O
it _ _ O
is _ _ O
, _ _ O
can _ _ O
perform _ _ O
“ _ _ O
A _ _ O
– _ _ O
B _ _ O
” _ _ O
A _ _ O
Binvert _ _ O
Carry _ _ O
in _ _ O
B _ _ O
0 _ _ O
1 _ _ O
+ _ _ O
Result _ _ O
Carry _ _ O
out _ _ O
This _ _ O
is _ _ O
a _ _ O
MUX _ _ O
20 _ _ O

A _ _ O
basic _ _ O
1-bit _ _ O
ALU _ _ O
– _ _ O
Addition _ _ O
Binvert _ _ O
Carry _ _ O
in _ _ O
0 _ _ O
0 _ _ O
Put _ _ O
it _ _ O
in _ _ O
a _ _ O
box _ _ O
A _ _ O
Result _ _ O
B _ _ O
0 _ _ O
1 _ _ O
+ _ _ O
Carry _ _ O
out _ _ O
21 _ _ O

A _ _ O
basic _ _ O
1-bit _ _ O
ALU _ _ O
– _ _ O
Subtraction _ _ O
2s _ _ O
Complement _ _ O
1- _ _ O
Invert _ _ O
Binvert _ _ O
Carry _ _ O
in _ _ O
1 _ _ O
1 _ _ O
2-Add _ _ O
one _ _ O
A _ _ O
Result _ _ O
B _ _ O
0 _ _ O
1 _ _ O
+ _ _ O
Carry _ _ O
out _ _ O
22 _ _ O

A _ _ O
basic _ _ O
1-bit _ _ O
ALU _ _ O
– _ _ O
Expanding _ _ O
the _ _ O
adder _ _ O
ALU _ _ O
– _ _ O
Arithmetic _ _ O
and _ _ O
Logic _ _ O
Unit _ _ O
● _ _ O
This _ _ O
ALU _ _ O
can _ _ O
perform _ _ O
the _ _ O
arithmetic _ _ O
operations _ _ O
add _ _ O
, _ _ O
and _ _ O
subtract _ _ O
. _ _ O
● _ _ O
And _ _ O
the _ _ O
logic _ _ O
operations _ _ O
AND _ _ O
, _ _ O
OR _ _ O
, _ _ O
and _ _ O
NOT _ _ O
● _ _ O
Operation _ _ O
is _ _ O
selected _ _ O
by _ _ O
the _ _ O
signal _ _ O
Operation _ _ O
: _ _ O
( _ _ O
2-bits _ _ O
) _ _ O
00 _ _ O
– _ _ O
AND _ _ O
; _ _ O
01 _ _ O
– _ _ O
OR _ _ O
; _ _ O
10 _ _ O
– _ _ O
ADD _ _ O
; _ _ O
11 _ _ O
– _ _ O
SLT _ _ O
Binvert _ _ O
Carry _ _ O
in _ _ O
Operation _ _ O
2 _ _ O
A _ _ O
0 _ _ O
1 _ _ O
B _ _ O
0 _ _ O
1 _ _ O
+ _ _ O
Less _ _ O
Result _ _ O
2 _ _ O
3 _ _ O
Carry _ _ O
out _ _ O
23 _ _ O

A _ _ O
basic _ _ O
1-bit _ _ O
ALU _ _ O
– _ _ O
Addition _ _ O
Binvert _ _ O
Carry _ _ O
in _ _ O
Operation _ _ O
0 _ _ O
0 _ _ O
2 _ _ O
10 _ _ O
A _ _ O
The _ _ O
other _ _ O
outputs _ _ O
are _ _ O
being _ _ O
calculated _ _ O
. _ _ O
0 _ _ O
1 _ _ O
B _ _ O
0 _ _ O
1 _ _ O
+ _ _ O
Less _ _ O
2 _ _ O
Result _ _ O
But _ _ O
not _ _ O
propagated _ _ O
3 _ _ O
Carry _ _ O
out _ _ O
24 _ _ O

A _ _ O
basic _ _ O
1-bit _ _ O
ALU _ _ O
– _ _ O
Subtraction _ _ O
Binvert _ _ O
Carry _ _ O
in _ _ O
Operation _ _ O
1 _ _ O
1 _ _ O
2 _ _ O
10 _ _ O
A _ _ O
0 _ _ O
1 _ _ O
B _ _ O
0 _ _ O
1 _ _ O
+ _ _ O
Less _ _ O
Result _ _ O
2 _ _ O
3 _ _ O
Carry _ _ O
out _ _ O
25 _ _ O

A _ _ O
basic _ _ O
1-bit _ _ O
ALU _ _ O
– _ _ O
AND _ _ O
Binvert _ _ O
Carry _ _ O
in _ _ O
Operation _ _ O
0 _ _ O
X _ _ O
2 _ _ O
00 _ _ O
A _ _ O
0 _ _ O
1 _ _ O
B _ _ O
0 _ _ O
1 _ _ O
+ _ _ O
Less _ _ O
Result _ _ O
2 _ _ O
3 _ _ O
Carry _ _ O
out _ _ O
26 _ _ O

A _ _ O
basic _ _ O
1-bit _ _ O
ALU _ _ O
– _ _ O
OR _ _ O
Binvert _ _ O
Carry _ _ O
in _ _ O
Operation _ _ O
0 _ _ O
X _ _ O
2 _ _ O
01 _ _ O
A _ _ O
0 _ _ O
1 _ _ O
B _ _ O
0 _ _ O
1 _ _ O
+ _ _ O
Less _ _ O
Result _ _ O
2 _ _ O
3 _ _ O
Carry _ _ O
out _ _ O
27 _ _ O

A _ _ O
basic _ _ O
1-bit _ _ O
ALU _ _ O
– _ _ O
NAND _ _ O
and _ _ O
NOR _ _ O
? _ _ O
Remember _ _ O
Boolean _ _ O
algebra _ _ O
? _ _ O
𝐴 _ _ O
+ _ _ O
𝐵 _ _ O
= _ _ O
𝐴. _ _ O
𝐵 _ _ O
𝐴𝐵 _ _ O
= _ _ O
𝐴 _ _ O
+ _ _ O
𝐵 _ _ O
𝐴 _ _ O
𝐵 _ _ O
𝐴 _ _ O
+ _ _ O
𝐵 _ _ O
𝐴 _ _ O
𝐵 _ _ O
𝐴. _ _ O
𝐵 _ _ O
0 _ _ O
0 _ _ O
1 _ _ O
1 _ _ O
1 _ _ O
1 _ _ O
0 _ _ O
1 _ _ O
0 _ _ O
1 _ _ O
0 _ _ O
0 _ _ O
1 _ _ O
0 _ _ O
0 _ _ O
0 _ _ O
1 _ _ O
0 _ _ O
1 _ _ O
1 _ _ O
0 _ _ O
0 _ _ O
0 _ _ O
0 _ _ O
𝐴 _ _ O
𝐵 _ _ O
𝐴𝐵 _ _ O
𝐴 _ _ O
𝐵 _ _ O
𝐴 _ _ O
+ _ _ O
𝐵 _ _ O
0 _ _ O
0 _ _ O
1 _ _ O
1 _ _ O
1 _ _ O
1 _ _ O
0 _ _ O
1 _ _ O
1 _ _ O
1 _ _ O
0 _ _ O
1 _ _ O
1 _ _ O
0 _ _ O
1 _ _ O
0 _ _ O
1 _ _ O
1 _ _ O
1 _ _ O
1 _ _ O
0 _ _ O
0 _ _ O
0 _ _ O
0 _ _ O
28 _ _ O

A _ _ O
basic _ _ O
1-bit _ _ O
ALU _ _ O
– _ _ O
NAND _ _ O
We _ _ O
need _ _ O
to _ _ O
add _ _ O
another _ _ O
inverter _ _ O
and _ _ O
mutex _ _ O
Ainvert _ _ O
Binvert _ _ O
1 _ _ O
A _ _ O
Carry _ _ O
in _ _ O
Operation _ _ O
1 _ _ O
X _ _ O
0 _ _ O
2 _ _ O
01 _ _ O
0 _ _ O
1 _ _ O
1 _ _ O
B _ _ O
0 _ _ O
1 _ _ O
+ _ _ O
Less _ _ O
Result _ _ O
2 _ _ O
3 _ _ O
Carry _ _ O
out _ _ O
29 _ _ O

A _ _ O
basic _ _ O
1-bit _ _ O
ALU _ _ O
– _ _ O
NOR _ _ O
Ainvert _ _ O
Binvert _ _ O
1 _ _ O
A _ _ O
Carry _ _ O
in _ _ O
Operation _ _ O
1 _ _ O
X _ _ O
0 _ _ O
2 _ _ O
00 _ _ O
0 _ _ O
1 _ _ O
1 _ _ O
B _ _ O
0 _ _ O
1 _ _ O
+ _ _ O
Less _ _ O
Result _ _ O
2 _ _ O
3 _ _ O
Carry _ _ O
out _ _ O
30 _ _ O

A _ _ O
basic _ _ O
1-bit _ _ O
ALU _ _ O
, _ _ O
with _ _ O
overflow _ _ O
detection _ _ O
● _ _ O
This _ _ O
ALU _ _ O
can _ _ O
detect _ _ O
overflow _ _ O
Ainvert _ _ O
● _ _ O
Also _ _ O
allows _ _ O
to _ _ O
perform _ _ O
the _ _ O
SLT _ _ O
operation _ _ O
! _ _ O
● _ _ O
Remember _ _ O
the _ _ O
slt _ _ O
instruction _ _ O
? _ _ O
blt _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
label _ _ O
o _ _ O
It _ _ O
’s _ _ O
equivalent _ _ O
to _ _ O
slt _ _ O
at _ _ O
, _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
bnq _ _ O
at _ _ O
, _ _ O
zero _ _ O
, _ _ O
label _ _ O
A _ _ O
Binvert _ _ O
0 _ _ O
Operation _ _ O
2 _ _ O
0 _ _ O
1 _ _ O
1 _ _ O
B _ _ O
● _ _ O
SLT _ _ O
– _ _ O
Set _ _ O
if _ _ O
Less _ _ O
Then _ _ O
o _ _ O
“ _ _ O
Set _ _ O
” _ _ O
= _ _ O
1 _ _ O
if _ _ O
a _ _ O
< _ _ O
b _ _ O
Carry _ _ O
in _ _ O
0 _ _ O
1 _ _ O
+ _ _ O
Less _ _ O
2 _ _ O
3 _ _ O
o _ _ O
“ _ _ O
Set _ _ O
” _ _ O
= _ _ O
0 _ _ O
if _ _ O
a _ _ O
> _ _ O
=b _ _ O
Result _ _ O
Set _ _ O
Overflow _ _ O
Carry _ _ O
out _ _ O
31 _ _ O

A _ _ O
basic _ _ O
1-bit _ _ O
ALU _ _ O
, _ _ O
with _ _ O
overflow _ _ O
detection _ _ O
● _ _ O
This _ _ O
ALU _ _ O
can _ _ O
detect _ _ O
overflow _ _ O
Ainvert _ _ O
● _ _ O
Also _ _ O
allows _ _ O
to _ _ O
perform _ _ O
the _ _ O
SLT _ _ O
operation _ _ O
! _ _ O
● _ _ O
Remember _ _ O
the _ _ O
slt _ _ O
instruction _ _ O
? _ _ O
blt _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
label _ _ O
o _ _ O
It _ _ O
’s _ _ O
equivalent _ _ O
to _ _ O
slt _ _ O
at _ _ O
, _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
bnq _ _ O
at _ _ O
, _ _ O
zero _ _ O
, _ _ O
label _ _ O
A _ _ O
Binvert _ _ O
Operation _ _ O
2 _ _ O
0 _ _ O
0 _ _ O
1 _ _ O
1 _ _ O
B _ _ O
● _ _ O
SLT _ _ O
– _ _ O
Set _ _ O
if _ _ O
Less _ _ O
Then _ _ O
o _ _ O
“ _ _ O
Set _ _ O
” _ _ O
= _ _ O
1 _ _ O
if _ _ O
a _ _ O
< _ _ O
b _ _ O
Carry _ _ O
in _ _ O
0 _ _ O
1 _ _ O
+ _ _ O
Result _ _ O
2 _ _ O
Less _ _ O
3 _ _ O
o _ _ O
“ _ _ O
Set _ _ O
” _ _ O
= _ _ O
0 _ _ O
if _ _ O
a _ _ O
> _ _ O
=b _ _ O
Set _ _ O
● _ _ O
What _ _ O
is _ _ O
the _ _ O
propagation _ _ O
delay _ _ O
? _ _ O
Overflow _ _ O
Carry _ _ O
out _ _ O
Assume _ _ O
: _ _ O
Not _ _ O
: _ _ O
2ns _ _ O
, _ _ O
Mux _ _ O
: _ _ O
6ns _ _ O
, _ _ O
Adder _ _ O
: _ _ O
10ns _ _ O
, _ _ O
AND _ _ O
/ _ _ O
OR _ _ O
/ _ _ O
XOR _ _ O
: _ _ O
4ns _ _ O
( _ _ O
26ns _ _ O
) _ _ O
32 _ _ O

Building _ _ O
it _ _ O
up _ _ O
! _ _ O
● _ _ O
Combine _ _ O
multiple _ _ O
1-bit _ _ O
ALUs _ _ O
● _ _ O
We _ _ O
can _ _ O
combine _ _ O
the _ _ O
Binvert _ _ O
and _ _ O
Carry _ _ O
in _ _ O
signals _ _ O
o _ _ O
They _ _ O
are _ _ O
used _ _ O
simultaneously _ _ O
for _ _ O
subtractions _ _ O
o _ _ O
Otherwise _ _ O
, _ _ O
we _ _ O
do _ _ O
n’t _ _ O
care _ _ O
about _ _ O
the _ _ O
Carry _ _ O
in _ _ O
Ainvert _ _ O
Bnegate _ _ O
1 _ _ O
0 _ _ O
Carry _ _ O
in _ _ O
can _ _ O
be _ _ O
connected _ _ O
to _ _ O
Binvert _ _ O
A0 _ _ O
B0 _ _ O
Carry _ _ O
in _ _ O
Less _ _ O
Carry _ _ O
out _ _ O
A1 _ _ O
B1 _ _ O
Carry _ _ O
in _ _ O
0 _ _ O
ALU _ _ O
0 _ _ O
ALU _ _ O
1 _ _ O
Less _ _ O
Carry _ _ O
out _ _ O
A2 _ _ O
B2 _ _ O
Carry _ _ O
in _ _ O
0 _ _ O
ALU _ _ O
2 _ _ O
Less _ _ O
Carry _ _ O
out _ _ O
A31 _ _ O
B31 _ _ O
Carry _ _ O
in _ _ O
0 _ _ O
Less _ _ O
ALU _ _ O
31 _ _ O
Carry _ _ O
out _ _ O
2 _ _ O
Operation _ _ O
10 _ _ O
Result0 _ _ O
1 _ _ O
Result1 _ _ O
0 _ _ O
Result2 _ _ O
0 _ _ O
Result31 _ _ O
Set _ _ O
0 _ _ O
Overflow _ _ O
1 _ _ O
33 _ _ O

Implementing _ _ O
SLT _ _ O
● _ _ O
SLT _ _ O
uses _ _ O
subtraction _ _ O
slt _ _ O
at _ _ O
, _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
t0 _ _ O
< _ _ O
t1 _ _ O
: _ _ O
t0-t1 _ _ O
< _ _ O
0 _ _ O
o _ _ O
Set _ _ O
is _ _ O
1 _ _ O
● _ _ O
Note _ _ O
how _ _ O
Set _ _ O
is _ _ O
connected _ _ O
to _ _ O
ALU0 _ _ O
’s _ _ O
Less _ _ O
input _ _ O
Ainvert _ _ O
Bnegate _ _ O
1 _ _ O
0 _ _ O
A0 _ _ O
B0 _ _ O
Carry _ _ O
in _ _ O
Less _ _ O
Carry _ _ O
out _ _ O
A1 _ _ O
B1 _ _ O
Carry _ _ O
in _ _ O
0 _ _ O
● _ _ O
Could _ _ O
we _ _ O
use _ _ O
Result31 _ _ O
instead _ _ O
? _ _ O
o _ _ O
No _ _ O
, _ _ O
note _ _ O
how _ _ O
the _ _ O
output _ _ O
is _ _ O
0 _ _ O
, _ _ O
not _ _ O
1 _ _ O
2 _ _ O
ALU _ _ O
0 _ _ O
ALU _ _ O
1 _ _ O
Less _ _ O
Carry _ _ O
out _ _ O
A2 _ _ O
B2 _ _ O
Carry _ _ O
in _ _ O
0 _ _ O
ALU _ _ O
2 _ _ O
Less _ _ O
Carry _ _ O
out _ _ O
A31 _ _ O
B31 _ _ O
Carry _ _ O
in _ _ O
0 _ _ O
Less _ _ O
ALU _ _ O
31 _ _ O
Carry _ _ O
out _ _ O
Operation _ _ O
11 _ _ O
Result0 _ _ O
1 _ _ O
Result1 _ _ O
0 _ _ O
Result2 _ _ O
0 _ _ O
Result31 _ _ O
Set _ _ O
0 _ _ O
Overflow _ _ O
1 _ _ O
34 _ _ O

A _ _ O
32-bit _ _ O
ALU _ _ O
Ainvert _ _ O
Bnegate _ _ O
4 _ _ O
ALU _ _ O
operation _ _ O
A _ _ O
32 _ _ O
32 _ _ O
ALU _ _ O
B _ _ O
32 _ _ O
2 _ _ O
A0 _ _ O
B0 _ _ O
Carry _ _ O
in _ _ O
Less _ _ O
Carry _ _ O
out _ _ O
Operation _ _ O
Result0 _ _ O
ALU _ _ O
0 _ _ O
Zero _ _ O
detection _ _ O
is _ _ O
so _ _ O
common _ _ O
that _ _ O
is _ _ O
usually _ _ O
supported _ _ O
by _ _ O
ALUs _ _ O
E.g. _ _ O
beq _ _ O
, _ _ O
bne _ _ O
A1 _ _ O
B1 _ _ O
Carry _ _ O
in _ _ O
Result _ _ O
Zero _ _ O
0 _ _ O
Less _ _ O
Carry _ _ O
out _ _ O
Overflow _ _ O
A2 _ _ O
B2 _ _ O
Carry _ _ O
in _ _ O
0 _ _ O
Less _ _ O
A31 _ _ O
B31 _ _ O
0 _ _ O
Less _ _ O
Result1 _ _ O
ALU _ _ O
1 _ _ O
Zero _ _ O
Result2 _ _ O
ALU _ _ O
2 _ _ O
Carry _ _ O
out _ _ O
Carry _ _ O
in _ _ O
ALU _ _ O
31 _ _ O
Carry _ _ O
out _ _ O
Result31 _ _ O
Set _ _ O
Overflow _ _ O
As _ _ O
we _ _ O
saw _ _ O
when _ _ O
we _ _ O
talked _ _ O
about _ _ O
overflow _ _ O
. _ _ O
It _ _ O
can _ _ O
be _ _ O
detected _ _ O
in _ _ O
the _ _ O
MSB _ _ O
35 _ _ O

A _ _ O
basic _ _ O
32-bit _ _ O
ALU _ _ O
? _ _ O
● _ _ O
ALUs _ _ O
are _ _ O
many _ _ O
times _ _ O
in _ _ O
the _ _ O
real _ _ O
world _ _ O
built _ _ O
as _ _ O
multiple _ _ O
1-bit _ _ O
ALUs _ _ O
. _ _ O
o _ _ O
Called _ _ O
bit-slicing _ _ O
● _ _ O
However _ _ O
, _ _ O
we _ _ O
can _ _ O
happily _ _ O
live _ _ O
in _ _ O
our _ _ O
ideal _ _ O
world _ _ O
for _ _ O
a _ _ O
bit _ _ O
longer _ _ O
! _ _ O
● _ _ O
We _ _ O
can _ _ O
build _ _ O
it _ _ O
much _ _ O
like _ _ O
the _ _ O
1-bit _ _ O
model _ _ O
, _ _ O
but _ _ O
just _ _ O
tell _ _ O
Logisim _ _ O
to _ _ O
make _ _ O
the _ _ O
components _ _ O
’ _ _ O
“ _ _ O
Data _ _ O
Size _ _ O
” _ _ O
32-bits _ _ O
. _ _ O
o _ _ O
i.e. _ _ O
, _ _ O
for _ _ O
your _ _ O
project _ _ O
. _ _ O
● _ _ O
Whew _ _ O
! _ _ O
Ainvert _ _ O
Bnegate _ _ O
1 _ _ O
A _ _ O
Operation _ _ O
1 _ _ O
2 _ _ O
00 _ _ O
0 _ _ O
0 _ _ O
1 _ _ O
1 _ _ O
B _ _ O
+ _ _ O
0 _ _ O
1 _ _ O
Result _ _ O
2 _ _ O
< _ _ O
3 _ _ O
Carry _ _ O
out _ _ O
Overflow _ _ O
36 _ _ O

Zooming _ _ O
Out _ _ O
Again _ _ O
● _ _ O
Now _ _ O
, _ _ O
how _ _ O
to _ _ O
we _ _ O
wire _ _ O
up _ _ O
the _ _ O
Register _ _ O
File _ _ O
with _ _ O
the _ _ O
ALU _ _ O
? _ _ O
? _ _ O
o _ _ O
How _ _ O
do _ _ O
we _ _ O
know _ _ O
which _ _ O
registers _ _ O
to _ _ O
use _ _ O
? _ _ O
o _ _ O
How _ _ O
do _ _ O
we _ _ O
pull _ _ O
in _ _ O
instructions _ _ O
? _ _ O
● _ _ O
Tune _ _ O
in _ _ O
next _ _ O
time _ _ O
for _ _ O
… _ _ O
o _ _ O
Control _ _ O
and _ _ O
Datapath _ _ O
4 _ _ O
ALU _ _ O
operation _ _ O
A _ _ O
WriteEnable _ _ O
WriteData _ _ O
Register1 _ _ O
Register2 _ _ O
WriteRegister _ _ O
32 _ _ O
32 _ _ O
5 _ _ O
5 _ _ O
Register _ _ O
File _ _ O
32 _ _ O
32 _ _ O
32 _ _ O
ALU _ _ O
ReadData1 _ _ O
B _ _ O
32 _ _ O
Result _ _ O
Zero _ _ O
Overflow _ _ O
ReadData2 _ _ O
5 _ _ O
37 _ _ O



