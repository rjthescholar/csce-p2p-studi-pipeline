unlabeled|cs0447|lec16
-DOCSTART- -X- -X- O

# _ _ O
16 _ _ O
CS _ _ O
0447 _ _ O
Introduction _ _ O
to _ _ O
Computer _ _ O
Programming _ _ O
Pipelining _ _ O
Luís _ _ O
Oliveira _ _ O
Fall _ _ O
2020 _ _ O

Announcements _ _ O
● _ _ O
OMETS _ _ O
! _ _ O
! _ _ O
! _ _ O
! _ _ O
! _ _ O
! _ _ O
! _ _ O
! _ _ O
11 _ _ O
! _ _ O
! _ _ O
! _ _ O
! _ _ O
! _ _ O
! _ _ O
! _ _ O
! _ _ O
! _ _ O
1 _ _ O
! _ _ O
! _ _ O
! _ _ O
1eleven _ _ O
! _ _ O
! _ _ O
! _ _ O
! _ _ O
2 _ _ O

How _ _ O
can _ _ O
we _ _ O
make _ _ O
the _ _ O
CPU _ _ O
more _ _ O
efficient _ _ O
? _ _ O
… _ _ O
P _ _ O
3 _ _ O

Doing _ _ O
the _ _ O
laundry _ _ O
Luis _ _ O
( _ _ O
me _ _ O
) _ _ O
, _ _ O
Artur _ _ O
, _ _ O
Stephen _ _ O
, _ _ O
and _ _ O
Ray _ _ O
have _ _ O
one _ _ O
load _ _ O
of _ _ O
clothes _ _ O
to _ _ O
o _ _ O
Wash _ _ O
Washer _ _ O
takes _ _ O
60 _ _ O
minutes _ _ O
o _ _ O
Dry _ _ O
o _ _ O
Fold _ _ O
Dryer _ _ O
takes _ _ O
60 _ _ O
minutes _ _ O
Folding _ _ O
takes _ _ O
60 _ _ O
minutes _ _ O
Where _ _ O
we _ _ O
live _ _ O
, _ _ O
we _ _ O
can _ _ O
only _ _ O
do _ _ O
laundry _ _ O
Saturday _ _ O
from _ _ O
9 _ _ O
: _ _ O
00 _ _ O
to _ _ O
18 _ _ O
: _ _ O
00 _ _ O
! _ _ O
4 _ _ O

Sequential _ _ O
laundry _ _ O
● _ _ O
We _ _ O
have _ _ O
four _ _ O
loads _ _ O
of _ _ O
laundry _ _ O
to _ _ O
do _ _ O
( _ _ O
Luis _ _ O
, _ _ O
Artur _ _ O
, _ _ O
Stephen _ _ O
, _ _ O
and _ _ O
Ray _ _ O
) _ _ O
First _ _ O
, _ _ O
I _ _ O
wash _ _ O
9 _ _ O
: _ _ O
00 _ _ O
10 _ _ O
: _ _ O
00 _ _ O
11 _ _ O
: _ _ O
00 _ _ O
12 _ _ O
: _ _ O
00 _ _ O
13 _ _ O
: _ _ O
00 _ _ O
14 _ _ O
: _ _ O
00 _ _ O
15 _ _ O
: _ _ O
00 _ _ O
16 _ _ O
: _ _ O
00 _ _ O
17 _ _ O
: _ _ O
00 _ _ O
Then _ _ O
, _ _ O
I _ _ O
dry _ _ O
Finally _ _ O
, _ _ O
I _ _ O
fold _ _ O
It _ _ O
took _ _ O
me _ _ O
3 _ _ O
: _ _ O
00 _ _ O
, _ _ O
we _ _ O
still _ _ O
have _ _ O
three _ _ O
loads _ _ O
remaining _ _ O
! _ _ O
Yikes _ _ O
! _ _ O
It _ _ O
’s _ _ O
15 _ _ O
: _ _ O
00 _ _ O
, _ _ O
we _ _ O
still _ _ O
have _ _ O
two _ _ O
loads _ _ O
to _ _ O
go _ _ O
It _ _ O
’s _ _ O
18 _ _ O
: _ _ O
00 _ _ O
, _ _ O
and _ _ O
Ray _ _ O
can _ _ O
not _ _ O
do _ _ O
his _ _ O
laundry _ _ O
! _ _ O
5 _ _ O

How _ _ O
can _ _ O
we _ _ O
solve _ _ O
this _ _ O
? _ _ O
● _ _ O
Buy _ _ O
more _ _ O
machines _ _ O
! _ _ O
! _ _ O
! _ _ O
● _ _ O
Or _ _ O
… _ _ O
6 _ _ O

Pipelined _ _ O
laundry _ _ O
● _ _ O
We _ _ O
have _ _ O
four _ _ O
loads _ _ O
of _ _ O
laundry _ _ O
to _ _ O
do _ _ O
( _ _ O
Luis _ _ O
, _ _ O
Artur _ _ O
, _ _ O
Stephen _ _ O
, _ _ O
and _ _ O
Ray _ _ O
) _ _ O
9 _ _ O
: _ _ O
00 _ _ O
10 _ _ O
: _ _ O
00 _ _ O
11 _ _ O
: _ _ O
00 _ _ O
12 _ _ O
: _ _ O
00 _ _ O
13 _ _ O
: _ _ O
00 _ _ O
14 _ _ O
: _ _ O
00 _ _ O
15 _ _ O
: _ _ O
00 _ _ O
16 _ _ O
: _ _ O
00 _ _ O
17 _ _ O
: _ _ O
00 _ _ O
But _ _ O
did _ _ O
the _ _ O
time _ _ O
it _ _ O
takes _ _ O
to _ _ O
wash _ _ O
the _ _ O
clothes _ _ O
change _ _ O
? _ _ O
The _ _ O
washer _ _ O
is _ _ O
now _ _ O
free _ _ O
! _ _ O
! _ _ O
We _ _ O
can _ _ O
start _ _ O
the _ _ O
next _ _ O
load _ _ O
! _ _ O
Everyone _ _ O
can _ _ O
do _ _ O
their _ _ O
laundry _ _ O
Rinse _ _ O
and _ _ O
repeat _ _ O
7 _ _ O

Upgrading _ _ O
the _ _ O
multi-cycle _ _ O
CPU _ _ O
Let _ _ O
’s _ _ O
apply _ _ O
the _ _ O
same _ _ O
concept _ _ O
to _ _ O
a _ _ O
multi-cycle _ _ O
CPU _ _ O
! _ _ O
Keep _ _ O
the _ _ O
same _ _ O
clock _ _ O
● _ _ O
Reuse _ _ O
resources _ _ O
with _ _ O
… _ _ O
Time _ _ O
0 _ _ O
1 _ _ O
add _ _ O
t2 _ _ O
, _ _ O
t2 _ _ O
, _ _ O
t3 _ _ O
Mem _ _ O
Reg _ _ O
lw _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
t1 _ _ O
) _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
5 _ _ O
Mem _ _ O
Reg _ _ O
6 _ _ O
7 _ _ O
Reg _ _ O
Mem _ _ O
Reg _ _ O
8 _ _ O

Lighting _ _ O
up _ _ O
the _ _ O
silicon _ _ O
( _ _ O
animated _ _ O
) _ _ O
Executing _ _ O
instructions _ _ O
in _ _ O
a _ _ O
pipeline _ _ O
F _ _ O
D _ _ O
X _ _ O
M _ _ O
Memory _ _ O
Control _ _ O
sub _ _ O
add _ _ O
sw _ _ O
Register _ _ O
File _ _ O
Memory _ _ O
again _ _ O
W _ _ O
Uses _ _ O
memory _ _ O
Uses _ _ O
decoder _ _ O
/ _ _ O
registers _ _ O
Uses _ _ O
ALU _ _ O
Uses _ _ O
memory _ _ O
9 _ _ O

Pipeline _ _ O
vs _ _ O
Multi-cycle _ _ O
Pipelining _ _ O
does _ _ O
n’t _ _ O
help _ _ O
latency _ _ O
of _ _ O
a _ _ O
single _ _ O
instruction _ _ O
! _ _ O
It _ _ O
helps _ _ O
throughput _ _ O
of _ _ O
the _ _ O
entire _ _ O
workload _ _ O
! _ _ O
Different _ _ O
tasks _ _ O
operating _ _ O
different _ _ O
resources _ _ O
can _ _ O
execute _ _ O
simultaneously _ _ O
More _ _ O
stages _ _ O
, _ _ O
more _ _ O
potential _ _ O
speedup _ _ O
( _ _ O
too _ _ O
many _ _ O
stages _ _ O
is _ _ O
not _ _ O
good _ _ O
! _ _ O
) _ _ O
Time _ _ O
0 _ _ O
1 _ _ O
add _ _ O
t2 _ _ O
, _ _ O
t2 _ _ O
, _ _ O
t3 _ _ O
Mem _ _ O
Reg _ _ O
lw _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
t1 _ _ O
) _ _ O
Mem _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
5 _ _ O
Mem _ _ O
Reg _ _ O
6 _ _ O
7 _ _ O
Reg _ _ O
Reg _ _ O
10 _ _ O

So _ _ O
how _ _ O
did _ _ O
we _ _ O
improve _ _ O
performance _ _ O
? _ _ O
● _ _ O
Did _ _ O
we _ _ O
make _ _ O
any _ _ O
individual _ _ O
instruction _ _ O
faster _ _ O
? _ _ O
o _ _ O
No _ _ O
, _ _ O
the _ _ O
add _ _ O
still _ _ O
took _ _ O
4 _ _ O
cycles _ _ O
… _ _ O
the _ _ O
lw _ _ O
took _ _ O
5 _ _ O
cycles _ _ O
● _ _ O
But _ _ O
the _ _ O
whole _ _ O
thing _ _ O
finished _ _ O
faster _ _ O
. _ _ O
right _ _ O
? _ _ O
Yes _ _ O
, _ _ O
by _ _ O
overlapping _ _ O
the _ _ O
instructions _ _ O
, _ _ O
we _ _ O
increased _ _ O
the _ _ O
throughput _ _ O
. _ _ O
In _ _ O
any _ _ O
given _ _ O
clock _ _ O
cycle _ _ O
, _ _ O
we _ _ O
're _ _ O
now _ _ O
doing _ _ O
more _ _ O
work _ _ O
. _ _ O
With _ _ O
this _ _ O
we _ _ O
can _ _ O
get _ _ O
the _ _ O
CPI _ _ O
down _ _ O
closer _ _ O
to _ _ O
1 _ _ O
. _ _ O
11 _ _ O

The _ _ O
average _ _ O
CPI _ _ O
● _ _ O
It _ _ O
’s _ _ O
the _ _ O
average _ _ O
number _ _ O
of _ _ O
Cycles _ _ O
Per _ _ O
Instruction _ _ O
o _ _ O
For _ _ O
any _ _ O
program _ _ O
, _ _ O
we _ _ O
count _ _ O
the _ _ O
# _ _ O
of _ _ O
cycles _ _ O
▪ _ _ O
and _ _ O
divide _ _ O
by _ _ O
the _ _ O
# _ _ O
of _ _ O
instructions _ _ O
Time _ _ O
0 _ _ O
1 _ _ O
add _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t2 _ _ O
Mem _ _ O
Reg _ _ O
add _ _ O
t3 _ _ O
, _ _ O
t4 _ _ O
, _ _ O
t5 _ _ O
Mem _ _ O
2 _ _ O
3 _ _ O
Reg _ _ O
5 _ _ O
6 _ _ O
7 _ _ O
CPI _ _ O
= _ _ O
7 _ _ O
÷ _ _ O
4 _ _ O
= _ _ O
1.75 _ _ O
Reg _ _ O
Reg _ _ O
Mem _ _ O
Reg _ _ O
What _ _ O
happens _ _ O
when _ _ O
we _ _ O
have _ _ O
an _ _ O
add _ _ O
s3 _ _ O
, _ _ O
s4 _ _ O
, _ _ O
s5 _ _ O
infinite _ _ O
number _ _ O
of _ _ O
instructions _ _ O
? _ _ O
Mem _ _ O
add _ _ O
s0 _ _ O
, _ _ O
s1 _ _ O
, _ _ O
s2 _ _ O
4 _ _ O
Reg _ _ O
Reg _ _ O
Reg _ _ O
12 _ _ O

Pipeline _ _ O
( _ _ O
real-world _ _ O
) _ _ O
issues _ _ O
13 _ _ O

Instructions _ _ O
are _ _ O
co-dependent _ _ O
 _ _ O
● _ _ O
Sometimes _ _ O
, _ _ O
the _ _ O
next _ _ O
instruction _ _ O
can _ _ O
not _ _ O
execute _ _ O
in _ _ O
the _ _ O
next _ _ O
cycle _ _ O
o _ _ O
We _ _ O
call _ _ O
those _ _ O
pipeline _ _ O
hazards _ _ O
. _ _ O
● _ _ O
Hazards _ _ O
happen _ _ O
when _ _ O
for _ _ O
any _ _ O
reason _ _ O
an _ _ O
instruction _ _ O
is _ _ O
unable _ _ O
to _ _ O
advance _ _ O
( _ _ O
execute _ _ O
) _ _ O
in _ _ O
the _ _ O
pipeline _ _ O
● _ _ O
We _ _ O
’ll _ _ O
look _ _ O
at _ _ O
three _ _ O
types _ _ O
of _ _ O
hazards _ _ O
o _ _ O
Structural _ _ O
hazards _ _ O
o _ _ O
Data _ _ O
hazards _ _ O
o _ _ O
Control _ _ O
hazards _ _ O
14 _ _ O

Structural _ _ O
hazards _ _ O
Attempting _ _ O
to _ _ O
use _ _ O
the _ _ O
same _ _ O
resource _ _ O
two _ _ O
different _ _ O
ways _ _ O
simultaneously _ _ O
. _ _ O
E.g. _ _ O
: _ _ O
● _ _ O
You _ _ O
get _ _ O
home _ _ O
soaking _ _ O
wet _ _ O
and _ _ O
need _ _ O
to _ _ O
dry _ _ O
your _ _ O
clothes _ _ O
while _ _ O
someone _ _ O
is _ _ O
using _ _ O
the _ _ O
dryer _ _ O
In _ _ O
a _ _ O
CPU _ _ O
with _ _ O
a _ _ O
single _ _ O
memory _ _ O
: _ _ O
● _ _ O
Can _ _ O
we _ _ O
fetch _ _ O
a _ _ O
new _ _ O
instruction _ _ O
while _ _ O
reading _ _ O
a _ _ O
word _ _ O
from _ _ O
memory _ _ O
? _ _ O
o _ _ O
NOPe _ _ O
: _ _ O
structural _ _ O
hazard _ _ O
15 _ _ O

Structural _ _ O
hazards _ _ O
● _ _ O
Two _ _ O
instructions _ _ O
using _ _ O
the _ _ O
same _ _ O
hardware _ _ O
at _ _ O
the _ _ O
same _ _ O
time _ _ O
Time _ _ O
0 _ _ O
1 _ _ O
lw _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$0 _ _ O
) _ _ O
Mem _ _ O
Reg _ _ O
lw _ _ O
t1 _ _ O
, _ _ O
4 _ _ O
( _ _ O
$0 _ _ O
) _ _ O
lw _ _ O
t2 _ _ O
, _ _ O
8 _ _ O
( _ _ O
$0 _ _ O
) _ _ O
lw _ _ O
t3 _ _ O
, _ _ O
12 _ _ O
( _ _ O
$0 _ _ O
) _ _ O
Mem _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
Mem _ _ O
Reg _ _ O
Mem _ _ O
Reg _ _ O
Mem _ _ O
Reg _ _ O
6 _ _ O
7 _ _ O
Reg _ _ O
Mem _ _ O
Reg _ _ O
Mem _ _ O
5 _ _ O
Reg _ _ O
Mem _ _ O
Reg _ _ O
16 _ _ O

Structural _ _ O
hazards _ _ O
– _ _ O
What _ _ O
can _ _ O
I _ _ O
do _ _ O
? _ _ O
? _ _ O
? _ _ O
● _ _ O
Structural _ _ O
hazards _ _ O
arise _ _ O
from _ _ O
lack _ _ O
of _ _ O
resources _ _ O
● _ _ O
So _ _ O
… _ _ O
We _ _ O
can _ _ O
eliminate _ _ O
the _ _ O
hazard _ _ O
by _ _ O
adding _ _ O
more _ _ O
resources _ _ O
! _ _ O
o _ _ O
Add _ _ O
a _ _ O
second _ _ O
memory _ _ O
? _ _ O
▪ _ _ O
The _ _ O
Harvard _ _ O
architecture _ _ O
! _ _ O
● _ _ O
Another _ _ O
solution _ _ O
: _ _ O
o _ _ O
Stall _ _ O
the _ _ O
instruction _ _ O
until _ _ O
the _ _ O
resource _ _ O
is _ _ O
available _ _ O
Time _ _ O
lw _ _ O
t3 _ _ O
, _ _ O
12 _ _ O
( _ _ O
$0 _ _ O
) _ _ O
0 _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
5 _ _ O
6 _ _ O
7 _ _ O
NOP _ _ O
NOP _ _ O
NOP _ _ O
NOP _ _ O
NOP _ _ O
Mem _ _ O
Reg _ _ O
Mem _ _ O
Reg _ _ O
17 _ _ O

Structural _ _ O
hazards _ _ O
– _ _ O
What _ _ O
can _ _ O
I _ _ O
do _ _ O
? _ _ O
? _ _ O
? _ _ O
● _ _ O
You _ _ O
may _ _ O
need _ _ O
more _ _ O
than _ _ O
one _ _ O
stall _ _ O
! _ _ O
Time _ _ O
0 _ _ O
1 _ _ O
lw _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$0 _ _ O
) _ _ O
Mem _ _ O
Reg _ _ O
lw _ _ O
t1 _ _ O
, _ _ O
4 _ _ O
( _ _ O
$0 _ _ O
) _ _ O
lw _ _ O
t2 _ _ O
, _ _ O
8 _ _ O
( _ _ O
$0 _ _ O
) _ _ O
lw _ _ O
t3 _ _ O
, _ _ O
12 _ _ O
( _ _ O
$0 _ _ O
) _ _ O
Mem _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
Mem _ _ O
Reg _ _ O
Mem _ _ O
Reg _ _ O
Mem _ _ O
Reg _ _ O
5 _ _ O
6 _ _ O
7 _ _ O
Reg _ _ O
Mem _ _ O
Reg _ _ O
NOP _ _ O
NOP _ _ O
NOP _ _ O
NOP _ _ O
NOP _ _ O
NOP _ _ O
NOP _ _ O
NOP _ _ O
NOP _ _ O
NOP _ _ O
NOP _ _ O
NOP _ _ O
NOP _ _ O
NOP _ _ O
NOP _ _ O
NOP _ _ O
NOP _ _ O
NOP _ _ O
Mem _ _ O
Reg _ _ O
Mem _ _ O
Reg _ _ O
18 _ _ O

Data _ _ O
hazards _ _ O
Attempting _ _ O
to _ _ O
use _ _ O
an _ _ O
item _ _ O
before _ _ O
it _ _ O
is _ _ O
ready _ _ O
. _ _ O
E.g. _ _ O
: _ _ O
● _ _ O
Only _ _ O
one _ _ O
sock _ _ O
of _ _ O
a _ _ O
pair _ _ O
is _ _ O
found _ _ O
during _ _ O
folding _ _ O
● _ _ O
It _ _ O
’s _ _ O
in _ _ O
the _ _ O
dryer _ _ O
! _ _ O
Folding _ _ O
has _ _ O
to _ _ O
wait _ _ O
! _ _ O
In _ _ O
a _ _ O
CPU _ _ O
: _ _ O
● _ _ O
Instruction _ _ O
depends _ _ O
on _ _ O
result _ _ O
of _ _ O
prior _ _ O
instruction _ _ O
still _ _ O
in _ _ O
the _ _ O
pipeline _ _ O
add _ _ O
s0 _ _ O
, _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
sub _ _ O
t2 _ _ O
, _ _ O
t2 _ _ O
, _ _ O
s0 _ _ O
s0 _ _ O
must _ _ O
be _ _ O
produced _ _ O
before _ _ O
it _ _ O
can _ _ O
be _ _ O
used _ _ O
19 _ _ O

Data _ _ O
hazards _ _ O
– _ _ O
What _ _ O
can _ _ O
I _ _ O
do _ _ O
? _ _ O
? _ _ O
? _ _ O
● _ _ O
Are _ _ O
these _ _ O
common _ _ O
? _ _ O
o _ _ O
Yup _ _ O
! _ _ O
You _ _ O
bet _ _ O
! _ _ O
i=i+1 _ _ O
array _ _ O
[ _ _ O
i _ _ O
] _ _ O
● _ _ O
Solution _ _ O
1 _ _ O
: _ _ O
Stall _ _ O
until _ _ O
value _ _ O
is _ _ O
written _ _ O
back _ _ O
to _ _ O
the _ _ O
register _ _ O
file _ _ O
o _ _ O
Penalty _ _ O
is _ _ O
high _ _ O
with _ _ O
this _ _ O
solution _ _ O
. _ _ O
Time _ _ O
0 _ _ O
1 _ _ O
add _ _ O
s0 _ _ O
, _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
Mem _ _ O
Reg _ _ O
sub _ _ O
t2 _ _ O
, _ _ O
t2 _ _ O
, _ _ O
s0 _ _ O
NOP _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
5 _ _ O
6 _ _ O
7 _ _ O
Reg _ _ O
NOP _ _ O
Mem _ _ O
Reg _ _ O
Reg _ _ O
20 _ _ O

Data _ _ O
hazards _ _ O
– _ _ O
What _ _ O
can _ _ O
I _ _ O
do _ _ O
? _ _ O
? _ _ O
? _ _ O
● _ _ O
Solution _ _ O
2 _ _ O
: _ _ O
What _ _ O
if _ _ O
we _ _ O
improve _ _ O
the _ _ O
register _ _ O
file _ _ O
? _ _ O
Write _ _ O
to _ _ O
the _ _ O
register _ _ O
on _ _ O
the _ _ O
falling _ _ O
edge _ _ O
Time _ _ O
0 _ _ O
1 _ _ O
add _ _ O
s0 _ _ O
, _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
Mem _ _ O
Reg _ _ O
sub _ _ O
t2 _ _ O
, _ _ O
t2 _ _ O
, _ _ O
s0 _ _ O
NOP _ _ O
2 _ _ O
Read _ _ O
register _ _ O
during _ _ O
the _ _ O
second _ _ O
half _ _ O
Register _ _ O
File _ _ O
3 _ _ O
4 _ _ O
5 _ _ O
6 _ _ O
7 _ _ O
W _ _ O
Reg _ _ O
Mem _ _ O
RegR _ _ O
Reg _ _ O
21 _ _ O

Data _ _ O
hazards _ _ O
– _ _ O
What _ _ O
can _ _ O
I _ _ O
do _ _ O
? _ _ O
? _ _ O
? _ _ O
● _ _ O
Solution _ _ O
3 _ _ O
: _ _ O
Can _ _ O
we _ _ O
forward _ _ O
the _ _ O
ALU _ _ O
output _ _ O
? _ _ O
o _ _ O
Add _ _ O
path _ _ O
from _ _ O
ALU _ _ O
output _ _ O
to _ _ O
one _ _ O
of _ _ O
its _ _ O
inputs _ _ O
Forwarding _ _ O
: _ _ O
Passing _ _ O
the _ _ O
result _ _ O
from _ _ O
a _ _ O
later _ _ O
stage _ _ O
to _ _ O
an _ _ O
earlier _ _ O
one _ _ O
Time _ _ O
0 _ _ O
1 _ _ O
add _ _ O
s0 _ _ O
, _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
Mem _ _ O
Reg _ _ O
sub _ _ O
t2 _ _ O
, _ _ O
t2 _ _ O
, _ _ O
s0 _ _ O
Mem _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
Reg _ _ O
Reg _ _ O
Reg _ _ O
5 _ _ O
6 _ _ O
7 _ _ O
The _ _ O
value _ _ O
needed _ _ O
by _ _ O
the _ _ O
sub _ _ O
is _ _ O
n’t _ _ O
read _ _ O
from _ _ O
the _ _ O
reg _ _ O
file _ _ O
- _ _ O
it _ _ O
comes _ _ O
directly _ _ O
from _ _ O
the _ _ O
result _ _ O
output _ _ O
from _ _ O
doing _ _ O
the _ _ O
add _ _ O
operation _ _ O
22 _ _ O

Control _ _ O
hazards _ _ O
Attempting _ _ O
to _ _ O
make _ _ O
a _ _ O
decision _ _ O
before _ _ O
condition _ _ O
is _ _ O
evaluated _ _ O
● _ _ O
If _ _ O
the _ _ O
dirty _ _ O
clothes _ _ O
are _ _ O
not _ _ O
clean _ _ O
after _ _ O
washing _ _ O
! _ _ O
● _ _ O
Then _ _ O
I _ _ O
must _ _ O
wash _ _ O
them _ _ O
again _ _ O
In _ _ O
a _ _ O
CPU _ _ O
: _ _ O
● _ _ O
Branches _ _ O
blt _ _ O
s0 _ _ O
, _ _ O
s1 _ _ O
, _ _ O
DONE _ _ O
add _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t2 _ _ O
or _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t2 _ _ O
DONE _ _ O
: _ _ O
sub _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t2 _ _ O
Which _ _ O
path _ _ O
will _ _ O
the _ _ O
program _ _ O
take _ _ O
? _ _ O
Which _ _ O
instruction _ _ O
do _ _ O
we _ _ O
fetch _ _ O
next _ _ O
? _ _ O
23 _ _ O

Control _ _ O
hazards _ _ O
Attempting _ _ O
to _ _ O
make _ _ O
a _ _ O
decision _ _ O
before _ _ O
condition _ _ O
is _ _ O
evaluated _ _ O
● _ _ O
If _ _ O
the _ _ O
dirty _ _ O
clothes _ _ O
are _ _ O
not _ _ O
clean _ _ O
after _ _ O
washing _ _ O
! _ _ O
● _ _ O
Then _ _ O
I _ _ O
must _ _ O
wash _ _ O
them _ _ O
again _ _ O
In _ _ O
a _ _ O
CPU _ _ O
: _ _ O
● _ _ O
Branches _ _ O
if _ _ O
s0 _ _ O
< _ _ O
s1 _ _ O
goto _ _ O
DONE _ _ O
add _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t2 _ _ O
or _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t2 _ _ O
DONE _ _ O
: _ _ O
sub _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t2 _ _ O
Which _ _ O
path _ _ O
will _ _ O
the _ _ O
program _ _ O
take _ _ O
? _ _ O
Which _ _ O
instruction _ _ O
do _ _ O
we _ _ O
fetch _ _ O
next _ _ O
? _ _ O
24 _ _ O

Control _ _ O
hazards _ _ O
– _ _ O
What _ _ O
can _ _ O
I _ _ O
do _ _ O
? _ _ O
? _ _ O
? _ _ O
● _ _ O
We _ _ O
can _ _ O
stall _ _ O
… _ _ O
until _ _ O
the _ _ O
outcome _ _ O
is _ _ O
known _ _ O
! _ _ O
Time _ _ O
0 _ _ O
1 _ _ O
blt _ _ O
s0 _ _ O
, _ _ O
s1 _ _ O
, _ _ O
DONE _ _ O
Mem _ _ O
Reg _ _ O
sub _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t2 _ _ O
NOP _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
NOP _ _ O
Mem _ _ O
Reg _ _ O
5 _ _ O
6 _ _ O
7 _ _ O
Reg _ _ O
● _ _ O
This _ _ O
is _ _ O
a _ _ O
bit _ _ O
wasteful _ _ O
! _ _ O
We _ _ O
really _ _ O
do _ _ O
n’t _ _ O
like _ _ O
stalls _ _ O
! _ _ O
☺ _ _ O
● _ _ O
We _ _ O
want _ _ O
the _ _ O
pipeline _ _ O
always _ _ O
full _ _ O
and _ _ O
doing _ _ O
useful _ _ O
work _ _ O
! _ _ O
25 _ _ O

Control _ _ O
hazards _ _ O
– _ _ O
What _ _ O
can _ _ O
I _ _ O
do _ _ O
? _ _ O
? _ _ O
? _ _ O
● _ _ O
Sooo _ _ O
… _ _ O
we _ _ O
can _ _ O
predict _ _ O
that _ _ O
the _ _ O
branch _ _ O
is _ _ O
never _ _ O
taken _ _ O
! _ _ O
( _ _ O
naïve _ _ O
) _ _ O
Time _ _ O
0 _ _ O
1 _ _ O
blt _ _ O
s0 _ _ O
, _ _ O
s1 _ _ O
, _ _ O
DONE _ _ O
Mem _ _ O
Reg _ _ O
add _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t2 _ _ O
Mem _ _ O
2 _ _ O
Reg _ _ O
3 _ _ O
4 _ _ O
5 _ _ O
6 _ _ O
7 _ _ O
Reg _ _ O
● _ _ O
We _ _ O
attempt _ _ O
to _ _ O
execute _ _ O
the _ _ O
next _ _ O
sequential _ _ O
instruction _ _ O
! _ _ O
● _ _ O
It _ _ O
is _ _ O
a _ _ O
gamble _ _ O
! _ _ O
that _ _ O
the _ _ O
branch _ _ O
will _ _ O
never _ _ O
be _ _ O
taken _ _ O
. _ _ O
● _ _ O
But _ _ O
if _ _ O
we _ _ O
are _ _ O
right _ _ O
, _ _ O
there _ _ O
is _ _ O
no _ _ O
stall _ _ O
! _ _ O
! _ _ O
! _ _ O
☺ _ _ O
26 _ _ O

Control _ _ O
hazards _ _ O
– _ _ O
What _ _ O
if _ _ O
we _ _ O
are _ _ O
wrong _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
! _ _ O
! _ _ O
! _ _ O
● _ _ O
Ok _ _ O
, _ _ O
what _ _ O
if _ _ O
we _ _ O
are _ _ O
wrong _ _ O
? _ _ O
? _ _ O
? _ _ O
! _ _ O
! _ _ O
Time _ _ O
0 _ _ O
1 _ _ O
blt _ _ O
s0 _ _ O
, _ _ O
s1 _ _ O
, _ _ O
DONE _ _ O
Mem _ _ O
Reg _ _ O
add _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t2 _ _ O
or _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t2 _ _ O
sub _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t2 _ _ O
Mem _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
Reg _ _ O
NOP _ _ O
NOP _ _ O
Mem _ _ O
NOP _ _ O
NOP _ _ O
Mem _ _ O
Reg _ _ O
5 _ _ O
6 _ _ O
7 _ _ O
NOP _ _ O
Reg _ _ O
● _ _ O
Just _ _ O
abort _ _ O
( _ _ O
stall _ _ O
the _ _ O
remaining _ _ O
steps _ _ O
) _ _ O
to _ _ O
fix _ _ O
it _ _ O
! _ _ O
Nothing _ _ O
was _ _ O
actually _ _ O
changed _ _ O
! _ _ O
● _ _ O
Read _ _ O
the _ _ O
correct _ _ O
instruction _ _ O
! _ _ O
27 _ _ O

Fun _ _ O
facts _ _ O
! _ _ O
● _ _ O
How _ _ O
often _ _ O
do _ _ O
you _ _ O
think _ _ O
a _ _ O
( _ _ O
less-naïve _ _ O
) _ _ O
branch _ _ O
predictor _ _ O
is _ _ O
correct _ _ O
? _ _ O
Using _ _ O
128 _ _ O
Bytes _ _ O
all _ _ O
these _ _ O
predictors _ _ O
have _ _ O
an _ _ O
accuracy _ _ O
of _ _ O
> _ _ O
90 _ _ O
% _ _ O
! _ _ O
! _ _ O
! _ _ O
McFarling _ _ O
, _ _ O
Scott _ _ O
. _ _ O
Combining _ _ O
branch _ _ O
predictors _ _ O
. _ _ O
Vol _ _ O
. _ _ O
49 _ _ O
. _ _ O
Technical _ _ O
Report _ _ O
TN-36 _ _ O
, _ _ O
Digital _ _ O
Western _ _ O
Research _ _ O
Laboratory _ _ O
, _ _ O
1993 _ _ O
. _ _ O
28 _ _ O

What _ _ O
to _ _ O
know _ _ O
more _ _ O
? _ _ O
● _ _ O
CS _ _ O
1541 _ _ O
– _ _ O
Introduction _ _ O
to _ _ O
Computer _ _ O
Architecture _ _ O
o _ _ O
Learn _ _ O
more _ _ O
about _ _ O
hazards _ _ O
. _ _ O
o _ _ O
Learn _ _ O
more _ _ O
about _ _ O
branch _ _ O
predictors _ _ O
. _ _ O
o _ _ O
Learn _ _ O
about _ _ O
memory _ _ O
hierarchies _ _ O
. _ _ O
o _ _ O
And _ _ O
more _ _ O
… _ _ O
29 _ _ O

Performance _ _ O
and _ _ O
The _ _ O
Law _ _ O
of _ _ O
Diminishing _ _ O
Returns _ _ O
30 _ _ O

Do _ _ O
n't _ _ O
waste _ _ O
your _ _ O
time _ _ O
... _ _ O
● _ _ O
suppose _ _ O
you _ _ O
're _ _ O
trying _ _ O
to _ _ O
get _ _ O
better _ _ O
at _ _ O
time _ _ O
management _ _ O
● _ _ O
you _ _ O
got _ _ O
an _ _ O
app _ _ O
that _ _ O
lets _ _ O
you _ _ O
time _ _ O
how _ _ O
long _ _ O
you _ _ O
do _ _ O
stuff _ _ O
if _ _ O
you _ _ O
wanted _ _ O
to _ _ O
get _ _ O
more _ _ O
free _ _ O
time _ _ O
by _ _ O
halving _ _ O
the _ _ O
amount _ _ O
of _ _ O
time _ _ O
it _ _ O
takes _ _ O
to _ _ O
do _ _ O
one _ _ O
task _ _ O
, _ _ O
which _ _ O
task _ _ O
would _ _ O
you _ _ O
choose _ _ O
? _ _ O
Commuting _ _ O
Hygiene _ _ O
Watching _ _ O
Youtube _ _ O
Meals _ _ O
Working _ _ O
31 _ _ O

If _ _ O
you _ _ O
cut _ _ O
Youtube _ _ O
by _ _ O
half _ _ O
... _ _ O
● _ _ O
look _ _ O
at _ _ O
all _ _ O
the _ _ O
extra _ _ O
free _ _ O
time _ _ O
you _ _ O
have _ _ O
! _ _ O
Hygiene _ _ O
Commuting _ _ O
Free _ _ O
time _ _ O
! _ _ O
Meals _ _ O
Watching _ _ O
Youtube _ _ O
Working _ _ O
32 _ _ O

If _ _ O
you _ _ O
cut _ _ O
commuting _ _ O
by _ _ O
half _ _ O
... _ _ O
● _ _ O
look _ _ O
at _ _ O
... _ _ O
all _ _ O
the _ _ O
extra _ _ O
free _ _ O
time _ _ O
... _ _ O
you _ _ O
have _ _ O
. _ _ O
Free _ _ O
time _ _ O
! _ _ O
Hygiene _ _ O
Commuting _ _ O
Watching _ _ O
Youtube _ _ O
Meals _ _ O
Working _ _ O
33 _ _ O

The _ _ O
tale _ _ O
of _ _ O
two _ _ O
multipliers _ _ O
● _ _ O
The _ _ O
tale _ _ O
starts _ _ O
with _ _ O
a _ _ O
simple _ _ O
program _ _ O
li _ _ O
$ _ _ O
1 _ _ O
, _ _ O
100 _ _ O
lw _ _ O
lw _ _ O
mult _ _ O
mflo _ _ O
sw _ _ O
addi _ _ O
bne _ _ O
$ _ _ O
2 _ _ O
, _ _ O
A _ _ O
[ _ _ O
i _ _ O
] _ _ O
$ _ _ O
3 _ _ O
, _ _ O
B _ _ O
[ _ _ O
i _ _ O
] _ _ O
$ _ _ O
3 _ _ O
, _ _ O
$ _ _ O
2 _ _ O
$ _ _ O
4 _ _ O
$ _ _ O
4 _ _ O
, _ _ O
C _ _ O
[ _ _ O
i _ _ O
] _ _ O
$ _ _ O
1 _ _ O
, _ _ O
$ _ _ O
1 _ _ O
, _ _ O
-1 _ _ O
$ _ _ O
1 _ _ O
, _ _ O
$ _ _ O
0 _ _ O
, _ _ O
L0 _ _ O
L0 _ _ O
: _ _ O
; _ _ O
pseudo-code _ _ O
to _ _ O
load _ _ O
A _ _ O
[ _ _ O
i _ _ O
] _ _ O
; _ _ O
pseudo-code _ _ O
to _ _ O
load _ _ O
B _ _ O
[ _ _ O
i _ _ O
] _ _ O
; _ _ O
pseudo-code _ _ O
to _ _ O
store _ _ O
C _ _ O
[ _ _ O
i _ _ O
] _ _ O
● _ _ O
How _ _ O
many _ _ O
times _ _ O
does _ _ O
the _ _ O
loop _ _ O
execute _ _ O
? _ _ O
Runs _ _ O
100 _ _ O
times _ _ O
34 _ _ O

The _ _ O
tale _ _ O
of _ _ O
two _ _ O
multipliers _ _ O
● _ _ O
You _ _ O
measure _ _ O
how _ _ O
long _ _ O
it _ _ O
takes _ _ O
to _ _ O
execute _ _ O
. _ _ O
o _ _ O
It _ _ O
took _ _ O
102010ns _ _ O
li _ _ O
$ _ _ O
1 _ _ O
, _ _ O
100 _ _ O
10ns _ _ O
L0 _ _ O
: _ _ O
lw _ _ O
lw _ _ O
mult _ _ O
mflo _ _ O
sw _ _ O
addi _ _ O
bne _ _ O
That _ _ O
’s _ _ O
too _ _ O
long _ _ O
! _ _ O
$ _ _ O
2 _ _ O
, _ _ O
A _ _ O
[ _ _ O
i _ _ O
] _ _ O
$ _ _ O
3 _ _ O
, _ _ O
B _ _ O
[ _ _ O
i _ _ O
] _ _ O
$ _ _ O
3 _ _ O
, _ _ O
$ _ _ O
2 _ _ O
$ _ _ O
4 _ _ O
$ _ _ O
4 _ _ O
, _ _ O
C _ _ O
[ _ _ O
i _ _ O
] _ _ O
$ _ _ O
1 _ _ O
, _ _ O
$ _ _ O
1 _ _ O
, _ _ O
-1 _ _ O
$ _ _ O
1 _ _ O
, _ _ O
$ _ _ O
0 _ _ O
, _ _ O
L0 _ _ O
10ns _ _ O
10ns _ _ O
960ns _ _ O
10ns _ _ O
10ns _ _ O
10ns _ _ O
10ns _ _ O
I _ _ O
need _ _ O
to _ _ O
improve _ _ O
this _ _ O
, _ _ O
what _ _ O
should _ _ O
I _ _ O
do _ _ O
? _ _ O
Let _ _ O
me _ _ O
check _ _ O
what _ _ O
is _ _ O
going _ _ O
on _ _ O
here _ _ O
! _ _ O
96000ns _ _ O
! _ _ O
! _ _ O
! _ _ O
𝑡𝑖𝑚𝑒 _ _ O
= _ _ O
1 _ _ O
× _ _ O
10𝑛𝑠 _ _ O
+ _ _ O
6 _ _ O
× _ _ O
100 _ _ O
× _ _ O
10𝑛𝑠 _ _ O
+ _ _ O
1 _ _ O
× _ _ O
100 _ _ O
× _ _ O
960𝑛𝑠 _ _ O
= _ _ O
102010𝑛𝑠 _ _ O
35 _ _ O

The _ _ O
tale _ _ O
of _ _ O
two _ _ O
multipliers _ _ O
● _ _ O
It _ _ O
seems _ _ O
this _ _ O
CPU _ _ O
implements _ _ O
a _ _ O
slow _ _ O
multiplier _ _ O
o _ _ O
It _ _ O
needs _ _ O
to _ _ O
execute _ _ O
3 _ _ O
distinct _ _ O
steps _ _ O
: _ _ O
( _ _ O
1 _ _ O
) _ _ O
add _ _ O
, _ _ O
( _ _ O
2 _ _ O
) _ _ O
shift _ _ O
left _ _ O
, _ _ O
and _ _ O
( _ _ O
3 _ _ O
) _ _ O
shift _ _ O
right _ _ O
o _ _ O
Multiplication _ _ O
takes _ _ O
32-bit _ _ O
numbers _ _ O
▪ _ _ O
The _ _ O
ALU _ _ O
and _ _ O
the _ _ O
adder _ _ O
are _ _ O
64-bits _ _ O
! _ _ O
o _ _ O
The _ _ O
64-bit _ _ O
addition _ _ O
takes _ _ O
10ns _ _ O
o _ _ O
Shifts _ _ O
also _ _ O
take _ _ O
10ns _ _ O
o _ _ O
The _ _ O
multiplication _ _ O
takes _ _ O
96 _ _ O
steps _ _ O
→ _ _ O
3 _ _ O
× _ _ O
32bits _ _ O
What _ _ O
if _ _ O
I _ _ O
used _ _ O
another _ _ O
multiplier _ _ O
design _ _ O
? _ _ O
▪ _ _ O
total _ _ O
= _ _ O
96 _ _ O
steps _ _ O
× _ _ O
10𝑛𝑠 _ _ O
= _ _ O
960𝑛𝑠 _ _ O
36 _ _ O

The _ _ O
tale _ _ O
of _ _ O
two _ _ O
multipliers _ _ O
● _ _ O
I _ _ O
know _ _ O
, _ _ O
let _ _ O
’s _ _ O
use _ _ O
a _ _ O
Fast _ _ O
multiplier _ _ O
design _ _ O
I _ _ O
have _ _ O
1 _ _ O
. _ _ O
It _ _ O
combines _ _ O
some _ _ O
registers _ _ O
2 _ _ O
. _ _ O
And _ _ O
we _ _ O
can _ _ O
make _ _ O
it _ _ O
do _ _ O
the _ _ O
3 _ _ O
steps _ _ O
simultaneously _ _ O
3 _ _ O
. _ _ O
And _ _ O
the _ _ O
ALU _ _ O
only _ _ O
needs _ _ O
to _ _ O
be _ _ O
32-bits _ _ O
! _ _ O
o _ _ O
Assuming _ _ O
a _ _ O
linear _ _ O
relationship _ _ O
between _ _ O
bits _ _ O
and _ _ O
adder _ _ O
speed _ _ O
: _ _ O
▪ _ _ O
The _ _ O
32-bit _ _ O
addition _ _ O
takes _ _ O
5ns _ _ O
o _ _ O
The _ _ O
multiplication _ _ O
takes _ _ O
32 _ _ O
steps _ _ O
→ _ _ O
1 _ _ O
( _ _ O
𝑐𝑜𝑚𝑏𝑖𝑛𝑒𝑑 _ _ O
) _ _ O
× _ _ O
32bits _ _ O
▪ _ _ O
total _ _ O
= _ _ O
32 _ _ O
steps _ _ O
× _ _ O
5𝑛𝑠 _ _ O
= _ _ O
160𝑛𝑠 _ _ O
Cool _ _ O
! _ _ O
That _ _ O
’s _ _ O
a _ _ O
lot _ _ O
faster _ _ O
! _ _ O
! _ _ O
37 _ _ O

The _ _ O
tale _ _ O
of _ _ O
two _ _ O
multipliers _ _ O
● _ _ O
Let _ _ O
’s _ _ O
calculate _ _ O
how _ _ O
much _ _ O
faster _ _ O
it _ _ O
is _ _ O
: _ _ O
o _ _ O
Let _ _ O
’s _ _ O
calculate _ _ O
the _ _ O
speedup _ _ O
ratio _ _ O
: _ _ O
▪ _ _ O
The _ _ O
factor _ _ O
by _ _ O
which _ _ O
the _ _ O
new _ _ O
version _ _ O
is _ _ O
faster _ _ O
than _ _ O
the _ _ O
old _ _ O
one _ _ O
slow _ _ O
multiplier _ _ O
time _ _ O
960𝑛𝑠 _ _ O
speedup _ _ O
= _ _ O
= _ _ O
= _ _ O
6× _ _ O
𝑓𝑎𝑠𝑡 _ _ O
𝑚𝑢𝑙𝑡𝑖𝑝𝑙𝑖𝑒𝑟 _ _ O
𝑡𝑖𝑚𝑒 _ _ O
160𝑛𝑠 _ _ O
But _ _ O
will _ _ O
the _ _ O
program _ _ O
improve _ _ O
that _ _ O
much _ _ O
? _ _ O
38 _ _ O

The _ _ O
tale _ _ O
of _ _ O
two _ _ O
multipliers _ _ O
𝑡𝑖𝑚𝑒 _ _ O
= _ _ O
1 _ _ O
× _ _ O
10𝑛𝑠 _ _ O
+ _ _ O
6 _ _ O
× _ _ O
100 _ _ O
× _ _ O
10𝑛𝑠 _ _ O
+ _ _ O
1 _ _ O
× _ _ O
100 _ _ O
× _ _ O
160𝑛𝑠 _ _ O
= _ _ O
22010𝑛𝑠 _ _ O
slow _ _ O
program _ _ O
102010𝑛𝑠 _ _ O
𝐬𝐩𝐞𝐞𝐝𝐮𝐩 _ _ O
= _ _ O
= _ _ O
𝑓𝑎𝑠𝑡 _ _ O
𝑝𝑟𝑜𝑔𝑟𝑎𝑚 _ _ O
22010𝑛𝑠 _ _ O
= _ _ O
𝟒. _ _ O
𝟔𝟑 _ _ O
× _ _ O
It _ _ O
still _ _ O
an _ _ O
improvement _ _ O
! _ _ O
But _ _ O
not _ _ O
6x _ _ O
. _ _ O
Why _ _ O
? _ _ O
● _ _ O
The _ _ O
multiplier _ _ O
is _ _ O
only _ _ O
used _ _ O
once _ _ O
! _ _ O
39 _ _ O

The _ _ O
tale _ _ O
of _ _ O
two _ _ O
multipliers _ _ O
● _ _ O
What _ _ O
happens _ _ O
if _ _ O
we _ _ O
decrease _ _ O
the _ _ O
proportion _ _ O
of _ _ O
execution _ _ O
time _ _ O
? _ _ O
Suppose _ _ O
101 _ _ O
instructions _ _ O
: _ _ O
100 _ _ O
non-multiply _ _ O
, _ _ O
1 _ _ O
multiply _ _ O
𝑡𝑖𝑚𝑒 _ _ O
𝑠𝑙𝑜𝑤 _ _ O
= _ _ O
100 _ _ O
× _ _ O
10𝑛𝑠 _ _ O
+ _ _ O
960𝑛𝑠 _ _ O
= _ _ O
1960𝑛𝑠 _ _ O
𝑡𝑖𝑚𝑒 _ _ O
𝑓𝑎𝑠𝑡 _ _ O
= _ _ O
100 _ _ O
× _ _ O
10𝑛𝑠 _ _ O
+ _ _ O
160𝑛𝑠 _ _ O
= _ _ O
1160𝑛𝑠 _ _ O
1960𝑛𝑠 _ _ O
𝑠𝑝𝑒𝑒𝑑𝑢𝑝 _ _ O
= _ _ O
= _ _ O
1.7 _ _ O
× _ _ O
1160𝑛𝑠 _ _ O
Suppose _ _ O
1001 _ _ O
instructions _ _ O
: _ _ O
1000 _ _ O
non-multiply _ _ O
, _ _ O
1 _ _ O
multiply _ _ O
𝑡𝑖𝑚𝑒 _ _ O
𝑠𝑙𝑜𝑤 _ _ O
= _ _ O
1000 _ _ O
× _ _ O
10𝑛𝑠 _ _ O
+ _ _ O
960𝑛𝑠 _ _ O
= _ _ O
10960𝑛𝑠 _ _ O
𝑡𝑖𝑚𝑒 _ _ O
𝑓𝑎𝑠𝑡 _ _ O
= _ _ O
1000 _ _ O
× _ _ O
10𝑛𝑠 _ _ O
+ _ _ O
160𝑛𝑠 _ _ O
= _ _ O
10160𝑛𝑠 _ _ O
10960𝑛𝑠 _ _ O
𝑠𝑝𝑒𝑒𝑑𝑢𝑝 _ _ O
= _ _ O
= _ _ O
1.08 _ _ O
× _ _ O
10160𝑛𝑠 _ _ O
40 _ _ O

Decreasing _ _ O
gains _ _ O
● _ _ O
6 _ _ O
×→ _ _ O
4.63 _ _ O
×→ _ _ O
1.7 _ _ O
×→ _ _ O
1.08 _ _ O
× _ _ O
● _ _ O
What _ _ O
happened _ _ O
? _ _ O
o _ _ O
Proportion _ _ O
of _ _ O
time _ _ O
spent _ _ O
multiplying _ _ O
was _ _ O
not _ _ O
enough _ _ O
to _ _ O
have _ _ O
gains _ _ O
● _ _ O
Optimization _ _ O
is _ _ O
a _ _ O
balancing _ _ O
act _ _ O
. _ _ O
o _ _ O
As _ _ O
you _ _ O
solve _ _ O
a _ _ O
bottleneck _ _ O
, _ _ O
a _ _ O
new _ _ O
one _ _ O
will _ _ O
appear _ _ O
. _ _ O
o _ _ O
Improve _ _ O
things _ _ O
to _ _ O
a _ _ O
point _ _ O
, _ _ O
then _ _ O
there _ _ O
are _ _ O
diminishing _ _ O
returns _ _ O
! _ _ O
5s _ _ O
4s _ _ O
3s _ _ O
2s _ _ O
4s _ _ O
3s _ _ O
2s _ _ O
3s _ _ O
3s _ _ O
41 _ _ O

What _ _ O
about _ _ O
pipelining _ _ O
? _ _ O
● _ _ O
How _ _ O
much _ _ O
faster _ _ O
( _ _ O
and _ _ O
why _ _ O
) _ _ O
is _ _ O
a _ _ O
pipelined _ _ O
implementation _ _ O
of _ _ O
MIPS _ _ O
? _ _ O
● _ _ O
As _ _ O
we _ _ O
saw _ _ O
last _ _ O
class _ _ O
, _ _ O
we _ _ O
compute _ _ O
the _ _ O
speedup _ _ O
for _ _ O
this _ _ O
: _ _ O
slow _ _ O
time _ _ O
speedup _ _ O
= _ _ O
𝑓𝑎𝑠𝑡 _ _ O
𝑡𝑖𝑚𝑒 _ _ O
● _ _ O
And _ _ O
how _ _ O
do _ _ O
we _ _ O
compute _ _ O
“ _ _ O
time _ _ O
” _ _ O
? _ _ O
CPU _ _ O
time _ _ O
= _ _ O
𝑛 _ _ O
× _ _ O
𝐶𝑃𝐼 _ _ O
× _ _ O
𝑡 _ _ O
seconds _ _ O
42 _ _ O

Average _ _ O
Instruction _ _ O
CPI _ _ O
● _ _ O
What _ _ O
is _ _ O
an _ _ O
“ _ _ O
average _ _ O
instruction _ _ O
” _ _ O
CPI _ _ O
? _ _ O
o _ _ O
Remember _ _ O
how _ _ O
we _ _ O
calculated _ _ O
the _ _ O
average _ _ O
CPI _ _ O
of _ _ O
a _ _ O
program _ _ O
? _ _ O
● _ _ O
Given _ _ O
a _ _ O
program _ _ O
, _ _ O
how _ _ O
many _ _ O
cycles _ _ O
does _ _ O
an _ _ O
instruction _ _ O
typically _ _ O
take _ _ O
? _ _ O
o _ _ O
It _ _ O
depends _ _ O
on _ _ O
the _ _ O
program _ _ O
! _ _ O
o _ _ O
How _ _ O
many _ _ O
instructions _ _ O
, _ _ O
and _ _ O
what _ _ O
types _ _ O
? _ _ O
▪ _ _ O
E.g. _ _ O
: _ _ O
all _ _ O
adds _ _ O
vs. _ _ O
all _ _ O
loads _ _ O
for _ _ O
multi-cycle _ _ O
implementation _ _ O
● _ _ O
The _ _ O
average _ _ O
instruction _ _ O
CPI _ _ O
is _ _ O
the _ _ O
average _ _ O
cycle _ _ O
count _ _ O
per _ _ O
instruction _ _ O
43 _ _ O

Instruction _ _ O
Mix _ _ O
● _ _ O
Instruction _ _ O
mix _ _ O
: _ _ O
Is _ _ O
the _ _ O
% _ _ O
total _ _ O
instruction _ _ O
count _ _ O
( _ _ O
n _ _ O
) _ _ O
corresponding _ _ O
to _ _ O
each _ _ O
instruction _ _ O
class _ _ O
● _ _ O
Program _ _ O
A _ _ O
: _ _ O
100 _ _ O
adds _ _ O
, _ _ O
100 _ _ O
subtracts _ _ O
, _ _ O
50 _ _ O
loads _ _ O
, _ _ O
25 _ _ O
stores _ _ O
, _ _ O
50 _ _ O
branches _ _ O
, _ _ O
and _ _ O
10 _ _ O
jumps _ _ O
. _ _ O
Total _ _ O
335 _ _ O
instructions _ _ O
. _ _ O
● _ _ O
What _ _ O
is _ _ O
the _ _ O
mix _ _ O
? _ _ O
Arithmetic _ _ O
( _ _ O
100+100 _ _ O
) _ _ O
/ _ _ O
335 _ _ O
= _ _ O
0.597 _ _ O
= _ _ O
59.7 _ _ O
% _ _ O
Load _ _ O
50 _ _ O
/ _ _ O
335 _ _ O
= _ _ O
0.149 _ _ O
= _ _ O
14.9 _ _ O
% _ _ O
Store _ _ O
25 _ _ O
/ _ _ O
335 _ _ O
= _ _ O
0.075 _ _ O
= _ _ O
7.5 _ _ O
% _ _ O
Branch _ _ O
50 _ _ O
/ _ _ O
335 _ _ O
= _ _ O
0.149 _ _ O
= _ _ O
14.9 _ _ O
% _ _ O
Jump _ _ O
10 _ _ O
/ _ _ O
335 _ _ O
= _ _ O
0.03 _ _ O
= _ _ O
3.0 _ _ O
% _ _ O
44 _ _ O

CPI _ _ O
– _ _ O
Multi-cycle _ _ O
● _ _ O
Given _ _ O
this _ _ O
mix _ _ O
, _ _ O
what _ _ O
is _ _ O
the _ _ O
Average _ _ O
Cycles _ _ O
Per _ _ O
Instruction _ _ O
( _ _ O
CPI _ _ O
) _ _ O
? _ _ O
o _ _ O
E.g. _ _ O
, _ _ O
with _ _ O
a _ _ O
multi-cycle _ _ O
CPU _ _ O
. _ _ O
● _ _ O
We _ _ O
compute _ _ O
the _ _ O
weighted _ _ O
average _ _ O
CPI= _ _ O
Σ𝑎𝑙𝑙 _ _ O
𝑐𝑙𝑎𝑠𝑠𝑒𝑠 _ _ O
𝑓𝑟𝑒𝑞 _ _ O
× _ _ O
𝑐𝑦𝑐𝑙𝑒𝑠 _ _ O
Class _ _ O
Frequency _ _ O
Cycles _ _ O
Contribution _ _ O
Arithmetic _ _ O
59.7 _ _ O
% _ _ O
4 _ _ O
2.388 _ _ O
Load _ _ O
14.9 _ _ O
% _ _ O
5 _ _ O
0.745 _ _ O
Store _ _ O
7.5 _ _ O
% _ _ O
4 _ _ O
0.3 _ _ O
Branch _ _ O
14.9 _ _ O
% _ _ O
3 _ _ O
0.447 _ _ O
Jump _ _ O
3.0 _ _ O
% _ _ O
3 _ _ O
0.09 _ _ O
Total _ _ O
3.97 _ _ O
CPI _ _ O
45 _ _ O

CPU _ _ O
time _ _ O
● _ _ O
And _ _ O
now _ _ O
we _ _ O
can _ _ O
calculate _ _ O
the _ _ O
CPU _ _ O
time _ _ O
o _ _ O
Assuming _ _ O
a _ _ O
cycle _ _ O
length _ _ O
of _ _ O
2ns _ _ O
CPU _ _ O
time _ _ O
= _ _ O
335 _ _ O
× _ _ O
3.97 _ _ O
× _ _ O
2𝑛𝑠 _ _ O
= _ _ O
2660𝑛𝑠 _ _ O
Class _ _ O
Frequency _ _ O
Cycles _ _ O
Contribution _ _ O
Arithmetic _ _ O
59.7 _ _ O
% _ _ O
4 _ _ O
2.388 _ _ O
Load _ _ O
14.9 _ _ O
% _ _ O
5 _ _ O
0.745 _ _ O
Store _ _ O
7.5 _ _ O
% _ _ O
4 _ _ O
0.3 _ _ O
Branch _ _ O
14.9 _ _ O
% _ _ O
3 _ _ O
0.447 _ _ O
Jump _ _ O
3.0 _ _ O
% _ _ O
3 _ _ O
0.09 _ _ O
Total _ _ O
3.97 _ _ O
CPI _ _ O
46 _ _ O

What _ _ O
about _ _ O
in _ _ O
the _ _ O
pipeline _ _ O
implementation _ _ O
? _ _ O
● _ _ O
In _ _ O
the _ _ O
best _ _ O
case _ _ O
, _ _ O
what _ _ O
is _ _ O
the _ _ O
CPI _ _ O
? _ _ O
o _ _ O
How _ _ O
many _ _ O
instructions _ _ O
are _ _ O
we _ _ O
starting _ _ O
every _ _ O
clock _ _ O
cycle _ _ O
? _ _ O
● _ _ O
What _ _ O
about _ _ O
the _ _ O
typical _ _ O
case _ _ O
, _ _ O
what _ _ O
is _ _ O
the _ _ O
CPI _ _ O
? _ _ O
o _ _ O
We _ _ O
have _ _ O
to _ _ O
consider _ _ O
hazards _ _ O
. _ _ O
o _ _ O
Say _ _ O
, _ _ O
20 _ _ O
% _ _ O
of _ _ O
branches _ _ O
are _ _ O
predicted _ _ O
correctly _ _ O
. _ _ O
o _ _ O
60 _ _ O
% _ _ O
of _ _ O
loads _ _ O
do _ _ O
not _ _ O
conflict _ _ O
with _ _ O
other _ _ O
memory _ _ O
accesses _ _ O
. _ _ O
● _ _ O
Assume _ _ O
the _ _ O
same _ _ O
program _ _ O
and _ _ O
clock _ _ O
cycle _ _ O
. _ _ O
47 _ _ O

Instruction _ _ O
Mix _ _ O
– _ _ O
Pipeline _ _ O
● _ _ O
Instruction _ _ O
mix _ _ O
: _ _ O
Treat _ _ O
the _ _ O
delayed _ _ O
load _ _ O
and _ _ O
branch _ _ O
instructions _ _ O
as _ _ O
a _ _ O
separate _ _ O
class _ _ O
Class _ _ O
Arithmetic _ _ O
Frequency _ _ O
Cycles _ _ O
59.7 _ _ O
% _ _ O
1 _ _ O
0.6*14.9%=8.94 _ _ O
% _ _ O
1 _ _ O
Load _ _ O
– _ _ O
delay _ _ O
5.96 _ _ O
% _ _ O
2 _ _ O
Store _ _ O
7.5 _ _ O
% _ _ O
1 _ _ O
0.2*14.9%=2.98 _ _ O
% _ _ O
1 _ _ O
11.92 _ _ O
% _ _ O
3 _ _ O
3.0 _ _ O
% _ _ O
1 _ _ O
Load _ _ O
– _ _ O
no _ _ O
delay _ _ O
Branch _ _ O
predicted _ _ O
Branch _ _ O
not _ _ O
predicted _ _ O
Jump _ _ O
48 _ _ O

CPI _ _ O
– _ _ O
Pipeline _ _ O
● _ _ O
We _ _ O
compute _ _ O
the _ _ O
weighted _ _ O
average _ _ O
CPI= _ _ O
Σ𝑎𝑙𝑙 _ _ O
𝑐𝑙𝑎𝑠𝑠𝑒𝑠 _ _ O
𝑓𝑟𝑒𝑞 _ _ O
× _ _ O
𝑐𝑦𝑐𝑙𝑒𝑠 _ _ O
Class _ _ O
Cycles _ _ O
Contribution _ _ O
59.7 _ _ O
% _ _ O
1 _ _ O
0.597 _ _ O
0.6*14.9%=8.94 _ _ O
% _ _ O
1 _ _ O
0.0894 _ _ O
Load _ _ O
– _ _ O
delay _ _ O
5.96 _ _ O
% _ _ O
2 _ _ O
0.1192 _ _ O
Store _ _ O
7.5 _ _ O
% _ _ O
1 _ _ O
.075 _ _ O
0.2*14.9%=2.98 _ _ O
% _ _ O
1 _ _ O
.0298 _ _ O
11.92 _ _ O
% _ _ O
3 _ _ O
0.3576 _ _ O
3.0 _ _ O
% _ _ O
1 _ _ O
0.03 _ _ O
Arithmetic _ _ O
Load _ _ O
– _ _ O
no _ _ O
delay _ _ O
Branch _ _ O
predicted _ _ O
Branch _ _ O
not _ _ O
predicted _ _ O
Jump _ _ O
Frequency _ _ O
Total _ _ O
1.30 _ _ O
CPI _ _ O
49 _ _ O

The _ _ O
speedup _ _ O
● _ _ O
Compute _ _ O
CPU _ _ O
execution _ _ O
time _ _ O
of _ _ O
pipelined _ _ O
implementation _ _ O
o _ _ O
Every _ _ O
value _ _ O
except _ _ O
CPI _ _ O
is _ _ O
the _ _ O
same _ _ O
as _ _ O
in _ _ O
the _ _ O
multi-cycle _ _ O
▪ _ _ O
n _ _ O
– _ _ O
is _ _ O
a _ _ O
property _ _ O
of _ _ O
the _ _ O
program _ _ O
Pipeline _ _ O
CPU _ _ O
time _ _ O
= _ _ O
335 _ _ O
× _ _ O
1.30 _ _ O
× _ _ O
2𝑛𝑠 _ _ O
= _ _ O
871𝑛𝑠 _ _ O
2660𝑛𝑠 _ _ O
speedup _ _ O
= _ _ O
= _ _ O
3.05 _ _ O
× _ _ O
871𝑛𝑠 _ _ O
50 _ _ O



