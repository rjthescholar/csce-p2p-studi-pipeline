unlabeled|cs0449|final_review
-DOCSTART- -X- -X- O

Intro _ _ O
to _ _ O
Systems _ _ O
Software _ _ O
CS _ _ O
449 _ _ O
Final _ _ O
Review _ _ O
Bryant _ _ O
and _ _ O
O’Hallaron _ _ O
, _ _ O
Computer _ _ O
Systems _ _ O
: _ _ O
A _ _ O
Programmer _ _ O
’s _ _ O
Perspective _ _ O
, _ _ O
Third _ _ O
Edition _ _ O
1 _ _ O

Topics _ _ O
• _ _ O
Buffer _ _ O
overflow _ _ O
• _ _ O
Linking _ _ O
( _ _ O
high _ _ O
level _ _ O
understanding _ _ O
) _ _ O
• _ _ O
Cache _ _ O
memories _ _ O
• _ _ O
Virtual _ _ O
Memory _ _ O
• _ _ O
Memory _ _ O
Allocation _ _ O
• _ _ O
Processes _ _ O
2 _ _ O

Just _ _ O
for _ _ O
fun _ _ O
# _ _ O
1 _ _ O
: _ _ O
What _ _ O
does _ _ O
this _ _ O
code _ _ O
print _ _ O
? _ _ O
# _ _ O
include _ _ O
< _ _ O
stdio.h _ _ O
> _ _ O
# _ _ O
include _ _ O
< _ _ O
stddef.h _ _ O
> _ _ O
int _ _ O
foo _ _ O
( _ _ O
int _ _ O
x _ _ O
, _ _ O
int _ _ O
y _ _ O
) _ _ O
{ _ _ O
struct _ _ O
s _ _ O
{ _ _ O
char _ _ O
a _ _ O
[ _ _ O
x _ _ O
] _ _ O
; _ _ O
char _ _ O
b _ _ O
[ _ _ O
y _ _ O
] _ _ O
; _ _ O
char _ _ O
c _ _ O
; _ _ O
} _ _ O
; _ _ O
return _ _ O
offsetof _ _ O
( _ _ O
struct _ _ O
s _ _ O
, _ _ O
c _ _ O
) _ _ O
; _ _ O
} _ _ O
int _ _ O
main _ _ O
( _ _ O
void _ _ O
) _ _ O
{ _ _ O
printf _ _ O
( _ _ O
"%d\n _ _ O
" _ _ O
, _ _ O
foo _ _ O
( _ _ O
2 _ _ O
, _ _ O
3 _ _ O
) _ _ O
) _ _ O
; _ _ O
} _ _ O
Only _ _ O
works _ _ O
with _ _ O
“ _ _ O
gcc _ _ O
” _ _ O
J _ _ O

Just _ _ O
for _ _ O
fun _ _ O
# _ _ O
2 _ _ O
: _ _ O
What _ _ O
does _ _ O
this _ _ O
code _ _ O
print _ _ O
? _ _ O
# _ _ O
include _ _ O
< _ _ O
stdio.h _ _ O
> _ _ O
# _ _ O
include _ _ O
< _ _ O
stddef.h _ _ O
> _ _ O
int _ _ O
bar _ _ O
( _ _ O
int _ _ O
x _ _ O
, _ _ O
int _ _ O
y _ _ O
) _ _ O
{ _ _ O
struct _ _ O
s _ _ O
{ _ _ O
char _ _ O
a _ _ O
[ _ _ O
x _ _ O
] _ _ O
[ _ _ O
y _ _ O
] _ _ O
; _ _ O
} _ _ O
; _ _ O
return _ _ O
sizeof _ _ O
( _ _ O
struct _ _ O
s _ _ O
) _ _ O
; _ _ O
} _ _ O
int _ _ O
main _ _ O
( _ _ O
void _ _ O
) _ _ O
{ _ _ O
printf _ _ O
( _ _ O
"%d\n _ _ O
" _ _ O
, _ _ O
bar _ _ O
( _ _ O
2 _ _ O
, _ _ O
3 _ _ O
) _ _ O
) _ _ O
; _ _ O
} _ _ O
Only _ _ O
works _ _ O
with _ _ O
“ _ _ O
gcc _ _ O
” _ _ O
J _ _ O

Buffer _ _ O
Overflow _ _ O

Stack _ _ O
Discipline _ _ O
• _ _ O
This _ _ O
kind _ _ O
of _ _ O
problem _ _ O
covers _ _ O
a _ _ O
wide _ _ O
range _ _ O
of _ _ O
topics _ _ O
, _ _ O
such _ _ O
as _ _ O
stack _ _ O
frames _ _ O
, _ _ O
string _ _ O
representations _ _ O
, _ _ O
ASCII _ _ O
code _ _ O
, _ _ O
and _ _ O
byte _ _ O
ordering _ _ O
• _ _ O
It _ _ O
demonstrates _ _ O
the _ _ O
dangers _ _ O
of _ _ O
out-of-bounds _ _ O
memory _ _ O
references _ _ O
and _ _ O
the _ _ O
basic _ _ O
ideas _ _ O
behind _ _ O
buffer _ _ O
overflow _ _ O

Reference _ _ O
• _ _ O
Read _ _ O
: _ _ O
CSAPP3e _ _ O
3.10.3 _ _ O
( _ _ O
“ _ _ O
Out-of-Bounds _ _ O
Memory _ _ O
References _ _ O
and _ _ O
Buffer _ _ O
Overflow _ _ O
” _ _ O
) _ _ O
• _ _ O
Exercise _ _ O
: _ _ O
CSAPP _ _ O
practice _ _ O
problem _ _ O
3.46 _ _ O

Practice _ _ O
problem _ _ O
3.46 _ _ O
• _ _ O
Below _ _ O
is _ _ O
a _ _ O
( _ _ O
low-quality _ _ O
) _ _ O
implementation _ _ O
of _ _ O
a _ _ O
function _ _ O
that _ _ O
reads _ _ O
a _ _ O
line _ _ O
from _ _ O
standard _ _ O
input _ _ O
, _ _ O
copies _ _ O
the _ _ O
string _ _ O
to _ _ O
newly _ _ O
allocated _ _ O
storage _ _ O
, _ _ O
and _ _ O
returns _ _ O
a _ _ O
pointer _ _ O
to _ _ O
the _ _ O
result _ _ O
/ _ _ O
* _ _ O
This _ _ O
is _ _ O
very _ _ O
low-quality _ _ O
code _ _ O
. _ _ O
It _ _ O
is _ _ O
intended _ _ O
to _ _ O
illustrate _ _ O
bad _ _ O
programming _ _ O
practices _ _ O
. _ _ O
See _ _ O
Practice _ _ O
Problem _ _ O
3.46 _ _ O
. _ _ O
* _ _ O
/ _ _ O
char _ _ O
* _ _ O
get_line _ _ O
( _ _ O
) _ _ O
{ _ _ O
char _ _ O
buf _ _ O
[ _ _ O
4 _ _ O
] _ _ O
; _ _ O
char _ _ O
* _ _ O
result _ _ O
; _ _ O
gets _ _ O
( _ _ O
buf _ _ O
) _ _ O
; _ _ O
result _ _ O
= _ _ O
malloc _ _ O
( _ _ O
strlen _ _ O
( _ _ O
buf _ _ O
) _ _ O
) _ _ O
; _ _ O
strcpy _ _ O
( _ _ O
result _ _ O
, _ _ O
buf _ _ O
) _ _ O
; _ _ O
return _ _ O
result _ _ O
; _ _ O
} _ _ O

Practice _ _ O
problem _ _ O
3.46 _ _ O
• _ _ O
Disassembly _ _ O
up _ _ O
through _ _ O
call _ _ O
to _ _ O
gets _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
5 _ _ O
char _ _ O
* _ _ O
get_line _ _ O
( _ _ O
) _ _ O
0000000000400720 _ _ O
< _ _ O
get_line _ _ O
> _ _ O
: _ _ O
400720 _ _ O
: _ _ O
53 _ _ O
push _ _ O
% _ _ O
rbx _ _ O
400721 _ _ O
: _ _ O
48 _ _ O
83 _ _ O
ec _ _ O
10 _ _ O
sub _ _ O
$ _ _ O
0x10 _ _ O
, _ _ O
%rsp _ _ O
See _ _ O
diagram _ _ O
stack _ _ O
at _ _ O
this _ _ O
point _ _ O
400725 _ _ O
: _ _ O
48 _ _ O
89 _ _ O
e7 _ _ O
mov _ _ O
% _ _ O
rsp _ _ O
, _ _ O
%rdi _ _ O
400728 _ _ O
: _ _ O
e8 _ _ O
73 _ _ O
ff _ _ O
ff _ _ O
ff _ _ O
callq _ _ O
4006a0 _ _ O
< _ _ O
gets _ _ O
> _ _ O
Modify _ _ O
diagram _ _ O
to _ _ O
show _ _ O
stack _ _ O
contents _ _ O
at _ _ O
this _ _ O
point _ _ O

Practice _ _ O
problem _ _ O
3.46 _ _ O
Consider _ _ O
the _ _ O
following _ _ O
scenario _ _ O
. _ _ O
Procedure _ _ O
get_line _ _ O
is _ _ O
called _ _ O
with _ _ O
the _ _ O
return _ _ O
address _ _ O
equal _ _ O
to _ _ O
0x400776 _ _ O
and _ _ O
register _ _ O
% _ _ O
rbx _ _ O
equal _ _ O
to _ _ O
0x0123456789ABCDEF _ _ O
. _ _ O
You _ _ O
type _ _ O
in _ _ O
the _ _ O
string _ _ O
: _ _ O
0123456789012345678901234 _ _ O
The _ _ O
program _ _ O
terminates _ _ O
with _ _ O
a _ _ O
segmentation _ _ O
fault _ _ O
. _ _ O
You _ _ O
run _ _ O
GDB _ _ O
and _ _ O
determine _ _ O
that _ _ O
the _ _ O
error _ _ O
occurs _ _ O
during _ _ O
the _ _ O
execution _ _ O
of _ _ O
the _ _ O
ret _ _ O
instruction _ _ O
of _ _ O
get_line _ _ O
. _ _ O

Practice _ _ O
problem _ _ O
3.46 _ _ O
• _ _ O
Question _ _ O
A _ _ O
: _ _ O
Fill _ _ O
in _ _ O
the _ _ O
diagram _ _ O
that _ _ O
follows _ _ O
, _ _ O
indicating _ _ O
as _ _ O
much _ _ O
as _ _ O
you _ _ O
can _ _ O
about _ _ O
the _ _ O
stack _ _ O
just _ _ O
after _ _ O
executing _ _ O
the _ _ O
instruction _ _ O
at _ _ O
line _ _ O
3 _ _ O
in _ _ O
the _ _ O
disassembly _ _ O
. _ _ O
Label _ _ O
the _ _ O
quantities _ _ O
stored _ _ O
on _ _ O
the _ _ O
stack _ _ O
( _ _ O
e.g. _ _ O
, _ _ O
" _ _ O
Return _ _ O
address _ _ O
" _ _ O
) _ _ O
on _ _ O
the _ _ O
right _ _ O
, _ _ O
and _ _ O
their _ _ O
hexadecimal _ _ O
values _ _ O
( _ _ O
if _ _ O
known _ _ O
) _ _ O
within _ _ O
the _ _ O
box _ _ O
. _ _ O
Each _ _ O
box _ _ O
represents _ _ O
8 _ _ O
bytes _ _ O
. _ _ O
Indicate _ _ O
the _ _ O
position _ _ O
of _ _ O
% _ _ O
rsp _ _ O
. _ _ O
Recall _ _ O
that _ _ O
the _ _ O
ASCII _ _ O
codes _ _ O
for _ _ O
characters _ _ O
0–9 _ _ O
are _ _ O
0x30–0x39 _ _ O
. _ _ O

Practice _ _ O
problem _ _ O
3.46 _ _ O
• _ _ O
Question _ _ O
A _ _ O
: _ _ O
Fill _ _ O
in _ _ O
the _ _ O
diagram _ _ O
that _ _ O
follows _ _ O
, _ _ O
indicating _ _ O
as _ _ O
much _ _ O
as _ _ O
you _ _ O
can _ _ O
about _ _ O
the _ _ O
stack _ _ O
just _ _ O
after _ _ O
executing _ _ O
the _ _ O
instruction _ _ O
at _ _ O
line _ _ O
3 _ _ O
in _ _ O
the _ _ O
disassembly _ _ O
. _ _ O
Label _ _ O
the _ _ O
quantities _ _ O
stored _ _ O
on _ _ O
the _ _ O
stack _ _ O
( _ _ O
e.g. _ _ O
, _ _ O
" _ _ O
Return _ _ O
address _ _ O
" _ _ O
) _ _ O
on _ _ O
the _ _ O
right _ _ O
, _ _ O
and _ _ O
their _ _ O
hexadecimal _ _ O
values _ _ O
( _ _ O
if _ _ O
known _ _ O
) _ _ O
within _ _ O
the _ _ O
box _ _ O
. _ _ O
Each _ _ O
box _ _ O
represents _ _ O
8 _ _ O
bytes _ _ O
. _ _ O
Indicate _ _ O
the _ _ O
position _ _ O
of _ _ O
% _ _ O
rsp _ _ O
. _ _ O
Recall _ _ O
that _ _ O
the _ _ O
ASCII _ _ O
codes _ _ O
for _ _ O
characters _ _ O
0–9 _ _ O
are _ _ O
0x30–0x39 _ _ O
. _ _ O
Stack _ _ O
after _ _ O
line _ _ O
3 _ _ O
: _ _ O

Practice _ _ O
problem _ _ O
3.46 _ _ O
• _ _ O
Question _ _ O
B _ _ O
: _ _ O
Modify _ _ O
your _ _ O
diagram _ _ O
to _ _ O
show _ _ O
the _ _ O
effect _ _ O
of _ _ O
the _ _ O
call _ _ O
to _ _ O
gets _ _ O
( _ _ O
line _ _ O
5 _ _ O
) _ _ O

Practice _ _ O
problem _ _ O
3.46 _ _ O
• _ _ O
Question _ _ O
B _ _ O
: _ _ O
Modify _ _ O
your _ _ O
diagram _ _ O
to _ _ O
show _ _ O
the _ _ O
effect _ _ O
of _ _ O
the _ _ O
call _ _ O
to _ _ O
gets _ _ O
( _ _ O
line _ _ O
5 _ _ O
) _ _ O
Stack _ _ O
after _ _ O
line _ _ O
5 _ _ O
: _ _ O

Practice _ _ O
problem _ _ O
3.46 _ _ O
• _ _ O
Question _ _ O
C _ _ O
: _ _ O
To _ _ O
what _ _ O
address _ _ O
does _ _ O
the _ _ O
program _ _ O
attempt _ _ O
to _ _ O
return _ _ O
? _ _ O
The _ _ O
program _ _ O
is _ _ O
attempting _ _ O
to _ _ O
return _ _ O
to _ _ O
address _ _ O
0x040034 _ _ O
. _ _ O
The _ _ O
low-order _ _ O
2 _ _ O
bytes _ _ O
were _ _ O
overwritten _ _ O
by _ _ O
the _ _ O
code _ _ O
for _ _ O
character _ _ O
‘ _ _ O
4 _ _ O
’ _ _ O
and _ _ O
the _ _ O
terminating _ _ O
null _ _ O
character _ _ O
. _ _ O

Practice _ _ O
problem _ _ O
3.46 _ _ O
• _ _ O
Question _ _ O
D _ _ O
: _ _ O
What _ _ O
register _ _ O
( _ _ O
s _ _ O
) _ _ O
have _ _ O
corrupted _ _ O
value _ _ O
( _ _ O
s _ _ O
) _ _ O
when _ _ O
get_line _ _ O
returns _ _ O
? _ _ O
The _ _ O
saved _ _ O
value _ _ O
of _ _ O
register _ _ O
% _ _ O
rbx _ _ O
was _ _ O
set _ _ O
to _ _ O
0x3332313039383736 _ _ O
. _ _ O
This _ _ O
value _ _ O
will _ _ O
be _ _ O
loaded _ _ O
into _ _ O
the _ _ O
register _ _ O
before _ _ O
get_line _ _ O
returns _ _ O
. _ _ O

Practice _ _ O
problem _ _ O
3.46 _ _ O
• _ _ O
Question _ _ O
E _ _ O
: _ _ O
Besides _ _ O
the _ _ O
potential _ _ O
for _ _ O
buffer _ _ O
overflow _ _ O
, _ _ O
what _ _ O
two _ _ O
other _ _ O
things _ _ O
are _ _ O
wrong _ _ O
with _ _ O
the _ _ O
code _ _ O
for _ _ O
function _ _ O
get_line _ _ O
? _ _ O
The _ _ O
call _ _ O
to _ _ O
malloc _ _ O
should _ _ O
have _ _ O
had _ _ O
strlen _ _ O
( _ _ O
buf _ _ O
) _ _ O
+1 _ _ O
as _ _ O
its _ _ O
argument _ _ O
, _ _ O
and _ _ O
the _ _ O
code _ _ O
should _ _ O
also _ _ O
check _ _ O
that _ _ O
the _ _ O
returned _ _ O
value _ _ O
is _ _ O
not _ _ O
equal _ _ O
to _ _ O
NULL _ _ O
. _ _ O

Cache _ _ O
Memories _ _ O
18 _ _ O

Practice _ _ O
Cache _ _ O
Problem _ _ O
• _ _ O
We _ _ O
have _ _ O
a _ _ O
64 _ _ O
KiB _ _ O
address _ _ O
space _ _ O
• _ _ O
The _ _ O
cache _ _ O
is _ _ O
a _ _ O
1 _ _ O
KiB _ _ O
, _ _ O
direct-mapped _ _ O
cache _ _ O
using _ _ O
256-byte _ _ O
blocks _ _ O
with _ _ O
write-back _ _ O
and _ _ O
write-allocate _ _ O
policies _ _ O
• _ _ O
write-allocate _ _ O
: _ _ O
memory _ _ O
is _ _ O
read _ _ O
after _ _ O
a _ _ O
cache-miss-on-write _ _ O
• _ _ O
write-back _ _ O
: _ _ O
dirty _ _ O
data _ _ O
is _ _ O
written _ _ O
back _ _ O
to _ _ O
memory _ _ O
on _ _ O
eviction _ _ O
a _ _ O
) _ _ O
Calculate _ _ O
the _ _ O
TIO _ _ O
address _ _ O
breakdown _ _ O
: _ _ O

Practice _ _ O
Cache _ _ O
Problem _ _ O
• _ _ O
We _ _ O
have _ _ O
a _ _ O
64 _ _ O
KiB _ _ O
address _ _ O
space _ _ O
• _ _ O
The _ _ O
cache _ _ O
is _ _ O
a _ _ O
1 _ _ O
KiB _ _ O
, _ _ O
direct-mapped _ _ O
cache _ _ O
using _ _ O
256-byte _ _ O
blocks _ _ O
with _ _ O
write-back _ _ O
and _ _ O
write-allocate _ _ O
policies _ _ O
• _ _ O
write-allocate _ _ O
: _ _ O
memory _ _ O
is _ _ O
read _ _ O
after _ _ O
a _ _ O
cache-miss-on-write _ _ O
• _ _ O
write-back _ _ O
: _ _ O
dirty _ _ O
data _ _ O
is _ _ O
written _ _ O
back _ _ O
to _ _ O
memory _ _ O
on _ _ O
eviction _ _ O
a _ _ O
) _ _ O
Calculate _ _ O
the _ _ O
TIO _ _ O
address _ _ O
breakdown _ _ O
: _ _ O

Practice _ _ O
Cache _ _ O
Problem _ _ O
b _ _ O
) _ _ O
During _ _ O
some _ _ O
part _ _ O
of _ _ O
a _ _ O
running _ _ O
program _ _ O
, _ _ O
the _ _ O
cache _ _ O
’s _ _ O
management _ _ O
bits _ _ O
are _ _ O
as _ _ O
shown _ _ O
below _ _ O
. _ _ O
Four _ _ O
options _ _ O
for _ _ O
the _ _ O
next _ _ O
two _ _ O
memory _ _ O
accesses _ _ O
are _ _ O
given _ _ O
( _ _ O
R _ _ O
= _ _ O
read _ _ O
, _ _ O
W _ _ O
= _ _ O
write _ _ O
) _ _ O
. _ _ O
Circle _ _ O
the _ _ O
option _ _ O
that _ _ O
results _ _ O
in _ _ O
data _ _ O
from _ _ O
the _ _ O
cache _ _ O
being _ _ O
written _ _ O
to _ _ O
memory _ _ O

Practice _ _ O
Cache _ _ O
Problem _ _ O
( _ _ O
1 _ _ O
) _ _ O
R _ _ O
0x4C00 _ _ O
, _ _ O
W _ _ O
0x5C00 _ _ O
( _ _ O
3 _ _ O
) _ _ O
W _ _ O
0x2300 _ _ O
, _ _ O
R _ _ O
0x0F00 _ _ O
( _ _ O
2 _ _ O
) _ _ O
W _ _ O
0x5500 _ _ O
, _ _ O
W _ _ O
0x7A00 _ _ O
( _ _ O
4 _ _ O
) _ _ O
R _ _ O
0x3000 _ _ O
, _ _ O
R _ _ O
0x3000 _ _ O

Practice _ _ O
Cache _ _ O
Problem _ _ O
( _ _ O
1 _ _ O
) _ _ O
R _ _ O
0x4C00 _ _ O
, _ _ O
W _ _ O
0x5C00 _ _ O
( _ _ O
3 _ _ O
) _ _ O
W _ _ O
0x2300 _ _ O
, _ _ O
R _ _ O
0x0F00 _ _ O
R _ _ O
0b0100 _ _ O
1100 _ _ O
… _ _ O
, _ _ O
W _ _ O
0b0101 _ _ O
1100 _ _ O
… _ _ O
W _ _ O
0b0010 _ _ O
0011 _ _ O
… _ _ O
, _ _ O
R _ _ O
0000 _ _ O
1111 _ _ O
… _ _ O
( _ _ O
2 _ _ O
) _ _ O
W _ _ O
0x5500 _ _ O
, _ _ O
W _ _ O
0x7A00 _ _ O
( _ _ O
4 _ _ O
) _ _ O
R _ _ O
0x3000 _ _ O
, _ _ O
R _ _ O
0x3000 _ _ O
W _ _ O
0b0101 _ _ O
0101 _ _ O
… _ _ O
, _ _ O
W _ _ O
0b0111 _ _ O
1010 _ _ O
… _ _ O
R _ _ O
0b0011 _ _ O
0000 _ _ O
… _ _ O
, _ _ O
R _ _ O
0011 _ _ O
0000 _ _ O
… _ _ O

Practice _ _ O
Cache _ _ O
Problem _ _ O
( _ _ O
1 _ _ O
) _ _ O
R _ _ O
0x4C00 _ _ O
, _ _ O
W _ _ O
0x5C00 _ _ O
( _ _ O
3 _ _ O
) _ _ O
W _ _ O
0x2300 _ _ O
, _ _ O
R _ _ O
0x0F00 _ _ O
R _ _ O
0b0100 _ _ O
1100 _ _ O
… _ _ O
, _ _ O
W _ _ O
0b0101 _ _ O
1100 _ _ O
… _ _ O
W _ _ O
0b0010 _ _ O
0011 _ _ O
… _ _ O
, _ _ O
R _ _ O
0000 _ _ O
1111 _ _ O
… _ _ O
The _ _ O
read _ _ O
evicts _ _ O
line _ _ O
0 _ _ O
, _ _ O
but _ _ O
the _ _ O
dirty _ _ O
bit _ _ O
was _ _ O
not _ _ O
set _ _ O
so _ _ O
nothing _ _ O
is _ _ O
written _ _ O
( _ _ O
also _ _ O
, _ _ O
line _ _ O
0 _ _ O
was _ _ O
initially _ _ O
invalid _ _ O
) _ _ O
. _ _ O
The _ _ O
write _ _ O
overwrites _ _ O
line _ _ O
0 _ _ O
again _ _ O
but _ _ O
since _ _ O
the _ _ O
cache _ _ O
is _ _ O
writeback _ _ O
nothing _ _ O
is _ _ O
written _ _ O
to _ _ O
memory _ _ O
. _ _ O
The _ _ O
write _ _ O
evicts _ _ O
line _ _ O
3 _ _ O
which _ _ O
was _ _ O
invalid _ _ O
and _ _ O
not _ _ O
dirty _ _ O
, _ _ O
so _ _ O
nothing _ _ O
is _ _ O
written _ _ O
to _ _ O
memory _ _ O
. _ _ O
The _ _ O
read _ _ O
, _ _ O
however _ _ O
, _ _ O
also _ _ O
maps _ _ O
to _ _ O
line _ _ O
3 _ _ O
so _ _ O
it _ _ O
must _ _ O
write _ _ O
the _ _ O
value _ _ O
changed _ _ O
in _ _ O
the _ _ O
write _ _ O
back _ _ O
to _ _ O
memory _ _ O
before _ _ O
it _ _ O
can _ _ O
update _ _ O
the _ _ O
cache _ _ O
. _ _ O
( _ _ O
2 _ _ O
) _ _ O
W _ _ O
0x5500 _ _ O
, _ _ O
W _ _ O
0x7A00 _ _ O
( _ _ O
4 _ _ O
) _ _ O
R _ _ O
0x3000 _ _ O
, _ _ O
R _ _ O
0x3000 _ _ O
W _ _ O
0b0101 _ _ O
0101 _ _ O
… _ _ O
, _ _ O
W _ _ O
0b0111 _ _ O
1010 _ _ O
… _ _ O
R _ _ O
0b0011 _ _ O
0000 _ _ O
… _ _ O
, _ _ O
R _ _ O
0011 _ _ O
0000 _ _ O
… _ _ O
The _ _ O
first _ _ O
write _ _ O
does _ _ O
n’t _ _ O
evict _ _ O
anything _ _ O
because _ _ O
the _ _ O
tags _ _ O
match _ _ O
. _ _ O
The _ _ O
second _ _ O
write _ _ O
evicts _ _ O
the _ _ O
old _ _ O
data _ _ O
, _ _ O
but _ _ O
the _ _ O
dirty _ _ O
bit _ _ O
was _ _ O
not _ _ O
set _ _ O
so _ _ O
the _ _ O
old _ _ O
data _ _ O
does _ _ O
n’t _ _ O
need _ _ O
to _ _ O
be _ _ O
written _ _ O
back _ _ O
to _ _ O
memory _ _ O
. _ _ O
Line _ _ O
0 _ _ O
is _ _ O
initially _ _ O
not _ _ O
dirty _ _ O
( _ _ O
and _ _ O
invalid _ _ O
) _ _ O
so _ _ O
nothing _ _ O
is _ _ O
written _ _ O
back _ _ O
to _ _ O
memory _ _ O
from _ _ O
either _ _ O
of _ _ O
these _ _ O
reads _ _ O
( _ _ O
which _ _ O
both _ _ O
read _ _ O
from _ _ O
the _ _ O
same _ _ O
line _ _ O
) _ _ O
. _ _ O

Implementing _ _ O
LRU _ _ O
( _ _ O
Least _ _ O
Recently _ _ O
Used _ _ O
) _ _ O
Block _ _ O
Tag _ _ O
A _ _ O
E _ _ O
B _ _ O
C _ _ O
D _ _ O
Block _ _ O
requests _ _ O
: _ _ O
Valid _ _ O
LRU _ _ O
3 _ _ O
0 _ _ O
2 _ _ O
ß _ _ O
least _ _ O
recent _ _ O
used _ _ O
1 _ _ O
0 _ _ O
2 _ _ O
1 _ _ O
3 _ _ O
2 _ _ O
3 _ _ O
E _ _ O
D _ _ O
How _ _ O
large _ _ O
( _ _ O
in _ _ O
bits _ _ O
) _ _ O
should _ _ O
the _ _ O
LRU _ _ O
counter _ _ O
be _ _ O
on _ _ O
an _ _ O
N-way _ _ O
set-associative _ _ O
cache _ _ O
? _ _ O
25 _ _ O

Virtual _ _ O
Memory _ _ O

End-to-End _ _ O
Address _ _ O
Translation _ _ O
• _ _ O
Consider _ _ O
the _ _ O
following _ _ O
memory _ _ O
system _ _ O
: _ _ O
– _ _ O
The _ _ O
memory _ _ O
is _ _ O
byte _ _ O
addressable _ _ O
– _ _ O
Virtual _ _ O
addresses _ _ O
are _ _ O
14 _ _ O
bits _ _ O
wide _ _ O
( _ _ O
n _ _ O
= _ _ O
14 _ _ O
) _ _ O
– _ _ O
Physical _ _ O
addresses _ _ O
are _ _ O
12 _ _ O
bits _ _ O
wide _ _ O
( _ _ O
m _ _ O
= _ _ O
12 _ _ O
) _ _ O
– _ _ O
The _ _ O
page _ _ O
size _ _ O
is _ _ O
64 _ _ O
Bytes _ _ O
( _ _ O
P _ _ O
= _ _ O
64 _ _ O
) _ _ O
– _ _ O
The _ _ O
L1 _ _ O
d-cache _ _ O
is _ _ O
physically _ _ O
addressed _ _ O
and _ _ O
direct _ _ O
mapped _ _ O
, _ _ O
with _ _ O
a _ _ O
4-Byte _ _ O
line _ _ O
size _ _ O
and _ _ O
16 _ _ O
total _ _ O
sets _ _ O

Virtual _ _ O
and _ _ O
physical _ _ O
addresses _ _ O
• _ _ O
14-bit _ _ O
virtual _ _ O
addresses _ _ O
( _ _ O
n _ _ O
= _ _ O
14 _ _ O
) _ _ O
• _ _ O
12-bit _ _ O
physical _ _ O
addresses _ _ O
( _ _ O
m _ _ O
= _ _ O
12 _ _ O
) _ _ O
• _ _ O
64-byte _ _ O
pages _ _ O
( _ _ O
P _ _ O
= _ _ O
64 _ _ O
) _ _ O

Snapshot _ _ O
of _ _ O
the _ _ O
page _ _ O
table _ _ O

Snapshot _ _ O
of _ _ O
the _ _ O
L1 _ _ O
d-cache _ _ O
4B-block _ _ O

Practice _ _ O
Problem _ _ O
9.4 _ _ O
( _ _ O
CSAPP _ _ O
: _ _ O
3e _ _ O
) _ _ O
• _ _ O
Show _ _ O
how _ _ O
the _ _ O
example _ _ O
memory _ _ O
system _ _ O
translates _ _ O
a _ _ O
virtual _ _ O
address _ _ O
into _ _ O
a _ _ O
physical _ _ O
address _ _ O
and _ _ O
accesses _ _ O
the _ _ O
cache _ _ O
• _ _ O
Given _ _ O
virtual _ _ O
address _ _ O
: _ _ O
0x03d7 _ _ O
What _ _ O
is _ _ O
the _ _ O
virtual _ _ O
address _ _ O
format _ _ O
? _ _ O
0 _ _ O
0 _ _ O
0 _ _ O
0 _ _ O
1 _ _ O
1 _ _ O
1 _ _ O
1 _ _ O
0 _ _ O
1 _ _ O
0 _ _ O
1 _ _ O
1 _ _ O
1 _ _ O

Address _ _ O
Translation _ _ O
0x0f _ _ O
N _ _ O
0x0d _ _ O
0x03d7 _ _ O
0 _ _ O
| _ _ O
0 _ _ O
| _ _ O
0 _ _ O
| _ _ O
0| _ _ O
1 _ _ O
| _ _ O
1 _ _ O
| _ _ O
1 _ _ O
| _ _ O
1 _ _ O
| _ _ O
0 _ _ O
| _ _ O
1 _ _ O
| _ _ O
0 _ _ O
| _ _ O
1 _ _ O
| _ _ O
1 _ _ O
| _ _ O
1 _ _ O
0x0f _ _ O
0x17 _ _ O
32 _ _ O

Physical _ _ O
Memory _ _ O
Access _ _ O
0x03 _ _ O
0x05 _ _ O
0x0d _ _ O
Y _ _ O
0x1d _ _ O
0x0d _ _ O
0x03d7 _ _ O
0x05 _ _ O
0x03 _ _ O
0 _ _ O
| _ _ O
0 _ _ O
| _ _ O
1 _ _ O
| _ _ O
1 _ _ O
| _ _ O
0 _ _ O
| _ _ O
1 _ _ O
| _ _ O
0 _ _ O
| _ _ O
1 _ _ O
| _ _ O
0 _ _ O
| _ _ O
1 _ _ O
| _ _ O
1 _ _ O
| _ _ O
1 _ _ O
0x0d _ _ O
0x17 _ _ O

Memory _ _ O
Allocation _ _ O

Dynamic _ _ O
storage _ _ O
allocation _ _ O
• _ _ O
Consider _ _ O
an _ _ O
allocator _ _ O
that _ _ O
uses _ _ O
an _ _ O
list _ _ O
. _ _ O
The _ _ O
layout _ _ O
of _ _ O
each _ _ O
allocated _ _ O
AND _ _ O
free _ _ O
memory _ _ O
block _ _ O
is _ _ O
as _ _ O
follows _ _ O
: _ _ O
• _ _ O
Each _ _ O
memory _ _ O
block _ _ O
, _ _ O
either _ _ O
allocated _ _ O
or _ _ O
free _ _ O
, _ _ O
has _ _ O
a _ _ O
size _ _ O
. _ _ O
• _ _ O
The _ _ O
size _ _ O
does _ _ O
n’t _ _ O
include _ _ O
the _ _ O
header _ _ O
. _ _ O
• _ _ O
The _ _ O
size _ _ O
is _ _ O
negative _ _ O
if _ _ O
the _ _ O
block _ _ O
is _ _ O
free _ _ O
, _ _ O
positive _ _ O
otherwise _ _ O
• _ _ O
It _ _ O
’s _ _ O
a _ _ O
32-bit _ _ O
machine _ _ O
, _ _ O
addresses _ _ O
and _ _ O
ints _ _ O
are _ _ O
both _ _ O
32-bits _ _ O
Header _ _ O
Data _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
| _ _ O
( _ _ O
int _ _ O
) _ _ O
Block _ _ O
size _ _ O
( _ _ O
Bytes _ _ O
) _ _ O
| _ _ O
| _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
| _ _ O
| _ _ O
( _ _ O
int _ _ O
) _ _ O
Previous _ _ O
address _ _ O
| _ _ O
|____________________________| _ _ O
| _ _ O
| _ _ O
| _ _ O
| _ _ O
| _ _ O
| _ _ O
| _ _ O
| _ _ O
| _ _ O
| _ _ O
| _ _ O
| _ _ O
|____________________________| _ _ O

• _ _ O
Given _ _ O
the _ _ O
contents _ _ O
of _ _ O
the _ _ O
heap _ _ O
shown _ _ O
on _ _ O
the _ _ O
left _ _ O
, _ _ O
show _ _ O
the _ _ O
new _ _ O
contents _ _ O
of _ _ O
the _ _ O
heap _ _ O
( _ _ O
in _ _ O
the _ _ O
right _ _ O
table _ _ O
) _ _ O
after _ _ O
a _ _ O
call _ _ O
to _ _ O
free _ _ O
( _ _ O
0x400b014 _ _ O
) _ _ O
is _ _ O
executed _ _ O
• _ _ O
Your _ _ O
answers _ _ O
should _ _ O
be _ _ O
given _ _ O
as _ _ O
hex _ _ O
values _ _ O
• _ _ O
Note _ _ O
that _ _ O
the _ _ O
address _ _ O
grows _ _ O
from _ _ O
bottom _ _ O
up _ _ O
• _ _ O
Assume _ _ O
that _ _ O
the _ _ O
allocator _ _ O
uses _ _ O
immediate _ _ O
coalescing _ _ O
, _ _ O
that _ _ O
is _ _ O
, _ _ O
adjacent _ _ O
free _ _ O
blocks _ _ O
are _ _ O
merged _ _ O
immediately _ _ O
each _ _ O
time _ _ O
a _ _ O
block _ _ O
is _ _ O
freed _ _ O
Before _ _ O
After _ _ O
0x0400b00c _ _ O
0x0400affc _ _ O
0x00000002 _ _ O
0x00000002 _ _ O
0x0400affc _ _ O
0x0400affc _ _ O
0x00000002 _ _ O
0xFFFFFFFFE _ _ O
0x0400aff8 _ _ O
0x0400aff8 _ _ O
0xFFFFFFFFE _ _ O
0xFFFFFFFFA _ _ O

Processes _ _ O

Processes _ _ O
• _ _ O
Consider _ _ O
this _ _ O
code _ _ O
using _ _ O
Linux _ _ O
’s _ _ O
fork _ _ O
: _ _ O
int _ _ O
x _ _ O
= _ _ O
7 _ _ O
; _ _ O
if _ _ O
( _ _ O
fork _ _ O
( _ _ O
) _ _ O
) _ _ O
{ _ _ O
x++ _ _ O
; _ _ O
printf _ _ O
( _ _ O
" _ _ O
% _ _ O
d _ _ O
" _ _ O
, _ _ O
x _ _ O
) _ _ O
; _ _ O
fork _ _ O
( _ _ O
) _ _ O
; _ _ O
x++ _ _ O
; _ _ O
printf _ _ O
( _ _ O
" _ _ O
% _ _ O
d _ _ O
" _ _ O
, _ _ O
x _ _ O
) _ _ O
; _ _ O
} _ _ O
else _ _ O
{ _ _ O
printf _ _ O
( _ _ O
" _ _ O
% _ _ O
d _ _ O
" _ _ O
, _ _ O
x _ _ O
) _ _ O
; _ _ O
} _ _ O
What _ _ O
are _ _ O
all _ _ O
the _ _ O
different _ _ O
possible _ _ O
outputs _ _ O
( _ _ O
i.e. _ _ O
order _ _ O
of _ _ O
things _ _ O
printed _ _ O
) _ _ O
for _ _ O
this _ _ O
code _ _ O
? _ _ O
( _ _ O
Hint _ _ O
: _ _ O
there _ _ O
are _ _ O
4 _ _ O
of _ _ O
them _ _ O
. _ _ O
) _ _ O
Tip _ _ O
: _ _ O
try _ _ O
drawing _ _ O
a _ _ O
process _ _ O
graph _ _ O
for _ _ O
this _ _ O
program _ _ O

Processes _ _ O
• _ _ O
Consider _ _ O
this _ _ O
code _ _ O
using _ _ O
Linux _ _ O
’s _ _ O
fork _ _ O
: _ _ O
int _ _ O
x _ _ O
= _ _ O
7 _ _ O
; _ _ O
if _ _ O
( _ _ O
fork _ _ O
( _ _ O
) _ _ O
) _ _ O
{ _ _ O
x++ _ _ O
; _ _ O
printf _ _ O
( _ _ O
" _ _ O
% _ _ O
d _ _ O
" _ _ O
, _ _ O
x _ _ O
) _ _ O
; _ _ O
fork _ _ O
( _ _ O
) _ _ O
; _ _ O
x++ _ _ O
; _ _ O
printf _ _ O
( _ _ O
" _ _ O
% _ _ O
d _ _ O
" _ _ O
, _ _ O
x _ _ O
) _ _ O
; _ _ O
} _ _ O
else _ _ O
{ _ _ O
printf _ _ O
( _ _ O
" _ _ O
% _ _ O
d _ _ O
" _ _ O
, _ _ O
x _ _ O
) _ _ O
; _ _ O
} _ _ O

Processes _ _ O
• _ _ O
Consider _ _ O
this _ _ O
code _ _ O
using _ _ O
Linux _ _ O
’s _ _ O
fork _ _ O
: _ _ O
int _ _ O
x _ _ O
= _ _ O
7 _ _ O
; _ _ O
if _ _ O
( _ _ O
fork _ _ O
( _ _ O
) _ _ O
) _ _ O
{ _ _ O
x++ _ _ O
; _ _ O
printf _ _ O
( _ _ O
" _ _ O
% _ _ O
d _ _ O
" _ _ O
, _ _ O
x _ _ O
) _ _ O
; _ _ O
fork _ _ O
( _ _ O
) _ _ O
; _ _ O
x++ _ _ O
; _ _ O
printf _ _ O
( _ _ O
" _ _ O
% _ _ O
d _ _ O
" _ _ O
, _ _ O
x _ _ O
) _ _ O
; _ _ O
} _ _ O
else _ _ O
{ _ _ O
printf _ _ O
( _ _ O
" _ _ O
% _ _ O
d _ _ O
" _ _ O
, _ _ O
x _ _ O
) _ _ O
; _ _ O
} _ _ O
Possible _ _ O
orderings _ _ O
: _ _ O
7 _ _ O
8 _ _ O
9 _ _ O
9 _ _ O
8 _ _ O
7 _ _ O
9 _ _ O
9 _ _ O
8 _ _ O
9 _ _ O
7 _ _ O
9 _ _ O
8 _ _ O
9 _ _ O
9 _ _ O
7 _ _ O

More _ _ O
stuff _ _ O

Dynamic _ _ O
storage _ _ O
allocation _ _ O
• _ _ O
Five _ _ O
helper _ _ O
routines _ _ O
are _ _ O
defined _ _ O
to _ _ O
facilitate _ _ O
the _ _ O
implementation _ _ O
of _ _ O
free _ _ O
( _ _ O
void _ _ O
* _ _ O
p _ _ O
) _ _ O
• _ _ O
The _ _ O
functionality _ _ O
of _ _ O
each _ _ O
routine _ _ O
is _ _ O
explained _ _ O
in _ _ O
the _ _ O
comment _ _ O
above _ _ O
the _ _ O
function _ _ O
definition _ _ O
• _ _ O
Fill _ _ O
in _ _ O
the _ _ O
body _ _ O
of _ _ O
the _ _ O
helper _ _ O
routines _ _ O
the _ _ O
code _ _ O
section _ _ O
label _ _ O
that _ _ O
implement _ _ O
the _ _ O
corresponding _ _ O
functionality _ _ O
correctly _ _ O
• _ _ O
Important _ _ O
notice _ _ O
: _ _ O
Block _ _ O
sizes _ _ O
are _ _ O
4 _ _ O
bytes _ _ O
in _ _ O
this _ _ O
problem _ _ O

Dynamic _ _ O
storage _ _ O
allocation _ _ O
• _ _ O
Code _ _ O
1 _ _ O
: _ _ O
/ _ _ O
* _ _ O
given _ _ O
a _ _ O
pointer _ _ O
p _ _ O
to _ _ O
an _ _ O
allocated _ _ O
block _ _ O
, _ _ O
i.e. _ _ O
, _ _ O
p _ _ O
is _ _ O
a _ _ O
pointer _ _ O
returned _ _ O
by _ _ O
some _ _ O
previous _ _ O
malloc _ _ O
( _ _ O
) _ _ O
/ _ _ O
realloc _ _ O
( _ _ O
) _ _ O
call _ _ O
; _ _ O
returns _ _ O
the _ _ O
pointer _ _ O
to _ _ O
the _ _ O
header _ _ O
of _ _ O
the _ _ O
block* _ _ O
/ _ _ O
void _ _ O
* _ _ O
header _ _ O
( _ _ O
void _ _ O
* _ _ O
p _ _ O
) _ _ O
{ _ _ O
void _ _ O
* _ _ O
ptr _ _ O
; _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
; _ _ O
return _ _ O
ptr _ _ O
; _ _ O
} _ _ O
A. _ _ O
ptr _ _ O
= _ _ O
p-2 _ _ O
B. _ _ O
ptr _ _ O
= _ _ O
( _ _ O
void _ _ O
* _ _ O
) _ _ O
( _ _ O
( _ _ O
int _ _ O
* _ _ O
) _ _ O
p-2 _ _ O
) _ _ O
C. _ _ O
ptr _ _ O
= _ _ O
( _ _ O
void _ _ O
* _ _ O
) _ _ O
( _ _ O
( _ _ O
int _ _ O
* _ _ O
) _ _ O
p+2 _ _ O
) _ _ O

Dynamic _ _ O
storage _ _ O
allocation _ _ O
• _ _ O
Code _ _ O
2 _ _ O
: _ _ O
/ _ _ O
* _ _ O
given _ _ O
a _ _ O
pointer _ _ O
to _ _ O
a _ _ O
valid _ _ O
block _ _ O
header _ _ O
or _ _ O
footer _ _ O
, _ _ O
returns _ _ O
the _ _ O
size _ _ O
of _ _ O
the _ _ O
block _ _ O
* _ _ O
/ _ _ O
int _ _ O
size _ _ O
( _ _ O
void _ _ O
* _ _ O
hp _ _ O
) _ _ O
{ _ _ O
int _ _ O
result _ _ O
; _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
; _ _ O
return _ _ O
result _ _ O
; _ _ O
} _ _ O
A. _ _ O
result _ _ O
= _ _ O
( _ _ O
* _ _ O
hp _ _ O
> _ _ O
0 _ _ O
) _ _ O
?*hp _ _ O
: _ _ O
-*hp _ _ O
; _ _ O
B. _ _ O
result _ _ O
= _ _ O
* _ _ O
( _ _ O
int _ _ O
* _ _ O
) _ _ O
hp _ _ O
; _ _ O
C. _ _ O
result _ _ O
= _ _ O
( _ _ O
* _ _ O
( _ _ O
int _ _ O
* _ _ O
) _ _ O
hp _ _ O
> _ _ O
0 _ _ O
) _ _ O
? _ _ O
( _ _ O
* _ _ O
( _ _ O
int _ _ O
* _ _ O
) _ _ O
hp _ _ O
) _ _ O
: _ _ O
( _ _ O
-* _ _ O
( _ _ O
int _ _ O
* _ _ O
) _ _ O
hp _ _ O
) _ _ O
; _ _ O

Dynamic _ _ O
storage _ _ O
allocation _ _ O
• _ _ O
Code _ _ O
3 _ _ O
: _ _ O
/ _ _ O
* _ _ O
given _ _ O
a _ _ O
pointer _ _ O
p _ _ O
to _ _ O
an _ _ O
allocated _ _ O
block _ _ O
, _ _ O
i.e. _ _ O
p _ _ O
is _ _ O
a _ _ O
pointer _ _ O
returned _ _ O
by _ _ O
some _ _ O
previous _ _ O
malloc _ _ O
( _ _ O
) _ _ O
/ _ _ O
realloc _ _ O
( _ _ O
) _ _ O
call _ _ O
; _ _ O
returns _ _ O
the _ _ O
pointer _ _ O
to _ _ O
the _ _ O
next _ _ O
of _ _ O
the _ _ O
block* _ _ O
/ _ _ O
void _ _ O
* _ _ O
next _ _ O
( _ _ O
void _ _ O
* _ _ O
p _ _ O
) _ _ O
{ _ _ O
void _ _ O
* _ _ O
ptr _ _ O
; _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
; _ _ O
return _ _ O
ptr _ _ O
; _ _ O
} _ _ O
A. _ _ O
ptr _ _ O
= _ _ O
p+size _ _ O
( _ _ O
header _ _ O
( _ _ O
p _ _ O
) _ _ O
) _ _ O
B. _ _ O
ptr _ _ O
= _ _ O
p+size _ _ O
( _ _ O
header _ _ O
( _ _ O
p _ _ O
) _ _ O
) _ _ O
-8 _ _ O
C. _ _ O
ptr _ _ O
= _ _ O
( _ _ O
int _ _ O
* _ _ O
) _ _ O
p+size _ _ O
( _ _ O
header _ _ O
( _ _ O
p _ _ O
) _ _ O
) _ _ O
-2 _ _ O

Dynamic _ _ O
storage _ _ O
allocation _ _ O
• _ _ O
Code _ _ O
4 _ _ O
: _ _ O
/ _ _ O
* _ _ O
given _ _ O
a _ _ O
pointer _ _ O
to _ _ O
a _ _ O
valid _ _ O
block _ _ O
header _ _ O
or _ _ O
footer _ _ O
, _ _ O
returns _ _ O
the _ _ O
usage _ _ O
of _ _ O
the _ _ O
current _ _ O
block _ _ O
, _ _ O
1 _ _ O
for _ _ O
allocated _ _ O
, _ _ O
0 _ _ O
for _ _ O
free _ _ O
* _ _ O
/ _ _ O
int _ _ O
allocated _ _ O
( _ _ O
void _ _ O
* _ _ O
hp _ _ O
) _ _ O
{ _ _ O
int _ _ O
result _ _ O
; _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
; _ _ O
return _ _ O
result _ _ O
; _ _ O
} _ _ O
A. _ _ O
result= _ _ O
( _ _ O
* _ _ O
( _ _ O
int _ _ O
* _ _ O
) _ _ O
hp _ _ O
) _ _ O
> _ _ O
0 _ _ O
B. _ _ O
result= _ _ O
( _ _ O
* _ _ O
( _ _ O
int _ _ O
* _ _ O
) _ _ O
hp _ _ O
) _ _ O
==0 _ _ O
C. _ _ O
result= _ _ O
( _ _ O
* _ _ O
( _ _ O
int _ _ O
* _ _ O
) _ _ O
hp _ _ O
) _ _ O
< _ _ O
0 _ _ O

Dynamic _ _ O
storage _ _ O
allocation _ _ O
• _ _ O
Code _ _ O
5 _ _ O
: _ _ O
/ _ _ O
* _ _ O
given _ _ O
a _ _ O
pointer _ _ O
to _ _ O
a _ _ O
valid _ _ O
block _ _ O
header _ _ O
, _ _ O
returns _ _ O
the _ _ O
pointer _ _ O
to _ _ O
the _ _ O
header _ _ O
of _ _ O
previous _ _ O
block _ _ O
in _ _ O
memory _ _ O
* _ _ O
/ _ _ O
void _ _ O
* _ _ O
prev _ _ O
( _ _ O
void _ _ O
* _ _ O
hp _ _ O
) _ _ O
{ _ _ O
void _ _ O
* _ _ O
ptr _ _ O
; _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
; _ _ O
return _ _ O
ptr _ _ O
; _ _ O
} _ _ O
A. _ _ O
ptr _ _ O
= _ _ O
hp _ _ O
– _ _ O
* _ _ O
( _ _ O
( _ _ O
int* _ _ O
) _ _ O
hp _ _ O
+ _ _ O
1 _ _ O
) _ _ O
B. _ _ O
ptr _ _ O
= _ _ O
( _ _ O
void* _ _ O
) _ _ O
* _ _ O
( _ _ O
( _ _ O
int* _ _ O
) _ _ O
hp _ _ O
+ _ _ O
1 _ _ O
) _ _ O
C. _ _ O
ptr _ _ O
= _ _ O
( _ _ O
void* _ _ O
) _ _ O
( _ _ O
( _ _ O
int* _ _ O
) _ _ O
hp _ _ O
+ _ _ O
1 _ _ O
) _ _ O

Cache _ _ O
Puzzle _ _ O
• _ _ O
Given _ _ O
the _ _ O
following _ _ O
sequence _ _ O
of _ _ O
access _ _ O
results _ _ O
( _ _ O
addresses _ _ O
are _ _ O
given _ _ O
in _ _ O
decimal _ _ O
) _ _ O
on _ _ O
a _ _ O
cold _ _ O
/ _ _ O
empty _ _ O
cache _ _ O
of _ _ O
size _ _ O
16 _ _ O
bytes _ _ O
, _ _ O
what _ _ O
can _ _ O
we _ _ O
deduce _ _ O
about _ _ O
its _ _ O
properties _ _ O
? _ _ O
Assume _ _ O
an _ _ O
LRU _ _ O
replacement _ _ O
policy _ _ O
( _ _ O
0 _ _ O
, _ _ O
Miss _ _ O
) _ _ O
, _ _ O
( _ _ O
8 _ _ O
, _ _ O
Miss _ _ O
) _ _ O
, _ _ O
( _ _ O
0 _ _ O
, _ _ O
Hit _ _ O
) _ _ O
, _ _ O
( _ _ O
16 _ _ O
, _ _ O
Miss _ _ O
) _ _ O
, _ _ O
( _ _ O
8 _ _ O
, _ _ O
Miss _ _ O
) _ _ O
What _ _ O
can _ _ O
we _ _ O
say _ _ O
about _ _ O
the _ _ O
block _ _ O
size _ _ O
? _ _ O

Cache _ _ O
Puzzle _ _ O
• _ _ O
Given _ _ O
the _ _ O
following _ _ O
sequence _ _ O
of _ _ O
access _ _ O
results _ _ O
( _ _ O
addresses _ _ O
are _ _ O
given _ _ O
in _ _ O
decimal _ _ O
) _ _ O
on _ _ O
a _ _ O
cold _ _ O
/ _ _ O
empty _ _ O
cache _ _ O
of _ _ O
size _ _ O
16 _ _ O
bytes _ _ O
, _ _ O
what _ _ O
can _ _ O
we _ _ O
deduce _ _ O
about _ _ O
its _ _ O
properties _ _ O
? _ _ O
Assume _ _ O
an _ _ O
LRU _ _ O
replacement _ _ O
policy _ _ O
( _ _ O
0 _ _ O
, _ _ O
Miss _ _ O
) _ _ O
, _ _ O
( _ _ O
8 _ _ O
, _ _ O
Miss _ _ O
) _ _ O
, _ _ O
( _ _ O
0 _ _ O
, _ _ O
Hit _ _ O
) _ _ O
, _ _ O
( _ _ O
16 _ _ O
, _ _ O
Miss _ _ O
) _ _ O
, _ _ O
( _ _ O
8 _ _ O
, _ _ O
Miss _ _ O
) _ _ O
What _ _ O
can _ _ O
we _ _ O
say _ _ O
about _ _ O
the _ _ O
block _ _ O
size _ _ O
? _ _ O
The _ _ O
block _ _ O
size _ _ O
must _ _ O
be _ _ O
≤ _ _ O
8 _ _ O
because _ _ O
access _ _ O
( _ _ O
2 _ _ O
) _ _ O
to _ _ O
address _ _ O
8 _ _ O
is _ _ O
a _ _ O
miss _ _ O
after _ _ O
access _ _ O
( _ _ O
1 _ _ O
) _ _ O
to _ _ O
address _ _ O
0 _ _ O
is _ _ O
a _ _ O
hit _ _ O
. _ _ O

Cache _ _ O
Puzzle _ _ O
( _ _ O
0 _ _ O
, _ _ O
Miss _ _ O
) _ _ O
, _ _ O
( _ _ O
8 _ _ O
, _ _ O
Miss _ _ O
) _ _ O
, _ _ O
( _ _ O
0 _ _ O
, _ _ O
Hit _ _ O
) _ _ O
, _ _ O
( _ _ O
16 _ _ O
, _ _ O
Miss _ _ O
) _ _ O
, _ _ O
( _ _ O
8 _ _ O
, _ _ O
Miss _ _ O
) _ _ O
Assuming _ _ O
that _ _ O
the _ _ O
block _ _ O
size _ _ O
is _ _ O
8 _ _ O
bytes _ _ O
, _ _ O
can _ _ O
this _ _ O
cache _ _ O
be _ _ O
… _ _ O
( _ _ O
Hint _ _ O
: _ _ O
draw _ _ O
the _ _ O
cache _ _ O
and _ _ O
simulate _ _ O
it _ _ O
) _ _ O
a. _ _ O
Direct-mapped _ _ O
? _ _ O
Does _ _ O
this _ _ O
cache _ _ O
work _ _ O
for _ _ O
the _ _ O
access _ _ O
results _ _ O
? _ _ O
Yes _ _ O
, _ _ O
Yes _ _ O
, _ _ O
Yes _ _ O
, _ _ O
Yes _ _ O
( _ _ O
evict _ _ O
0 _ _ O
) _ _ O
, _ _ O
No _ _ O
( _ _ O
8 _ _ O
would _ _ O
still _ _ O
be _ _ O
in _ _ O
cache _ _ O
) _ _ O

Cache _ _ O
Puzzle _ _ O
( _ _ O
0 _ _ O
, _ _ O
Miss _ _ O
) _ _ O
, _ _ O
( _ _ O
8 _ _ O
, _ _ O
Miss _ _ O
) _ _ O
, _ _ O
( _ _ O
0 _ _ O
, _ _ O
Hit _ _ O
) _ _ O
, _ _ O
( _ _ O
16 _ _ O
, _ _ O
Miss _ _ O
) _ _ O
, _ _ O
( _ _ O
8 _ _ O
, _ _ O
Miss _ _ O
) _ _ O
Assuming _ _ O
that _ _ O
the _ _ O
block _ _ O
size _ _ O
is _ _ O
8 _ _ O
bytes _ _ O
, _ _ O
can _ _ O
this _ _ O
cache _ _ O
be _ _ O
… _ _ O
( _ _ O
Hint _ _ O
: _ _ O
draw _ _ O
the _ _ O
cache _ _ O
and _ _ O
simulate _ _ O
it _ _ O
) _ _ O
b. _ _ O
2-way _ _ O
set _ _ O
associative _ _ O
? _ _ O
Does _ _ O
this _ _ O
cache _ _ O
work _ _ O
for _ _ O
the _ _ O
access _ _ O
results _ _ O
? _ _ O
Yes _ _ O
, _ _ O
Yes _ _ O
, _ _ O
Yes _ _ O
, _ _ O
Yes _ _ O
( _ _ O
evict _ _ O
8 _ _ O
b _ _ O
/ _ _ O
c _ _ O
it _ _ O
’s _ _ O
the _ _ O
least _ _ O
recently _ _ O
used _ _ O
) _ _ O
, _ _ O
Yes _ _ O
( _ _ O
8 _ _ O
is _ _ O
no _ _ O
longer _ _ O
in _ _ O
cache _ _ O
) _ _ O

Cache _ _ O
Puzzle _ _ O
( _ _ O
0 _ _ O
, _ _ O
Miss _ _ O
) _ _ O
, _ _ O
( _ _ O
8 _ _ O
, _ _ O
Miss _ _ O
) _ _ O
, _ _ O
( _ _ O
0 _ _ O
, _ _ O
Hit _ _ O
) _ _ O
, _ _ O
( _ _ O
16 _ _ O
, _ _ O
Miss _ _ O
) _ _ O
, _ _ O
( _ _ O
8 _ _ O
, _ _ O
Miss _ _ O
) _ _ O
Assuming _ _ O
that _ _ O
the _ _ O
block _ _ O
size _ _ O
is _ _ O
8 _ _ O
bytes _ _ O
, _ _ O
can _ _ O
this _ _ O
cache _ _ O
be _ _ O
… _ _ O
( _ _ O
Hint _ _ O
: _ _ O
draw _ _ O
the _ _ O
cache _ _ O
and _ _ O
simulate _ _ O
it _ _ O
) _ _ O
c. _ _ O
4-way _ _ O
set _ _ O
associative _ _ O
? _ _ O
No _ _ O
, _ _ O
because _ _ O
the _ _ O
block _ _ O
size _ _ O
is _ _ O
8 _ _ O
, _ _ O
multiplied _ _ O
by _ _ O
4 _ _ O
lines _ _ O
per _ _ O
set _ _ O
, _ _ O
and _ _ O
that _ _ O
’s _ _ O
32B _ _ O
, _ _ O
which _ _ O
is _ _ O
already _ _ O
bigger _ _ O
than _ _ O
the _ _ O
entire _ _ O
cache _ _ O
. _ _ O

Code _ _ O
Analysis _ _ O
Problem _ _ O
•Assuming _ _ O
the _ _ O
cache _ _ O
starts _ _ O
cold _ _ O
( _ _ O
all _ _ O
blocks _ _ O
invalid _ _ O
) _ _ O
and _ _ O
sum _ _ O
, _ _ O
i _ _ O
, _ _ O
and _ _ O
j _ _ O
are _ _ O
stored _ _ O
in _ _ O
registers _ _ O
, _ _ O
calculate _ _ O
the _ _ O
miss _ _ O
rate _ _ O
: _ _ O
𝑚 _ _ O
= _ _ O
12 _ _ O
bits _ _ O
( _ _ O
addr _ _ O
. _ _ O
range _ _ O
) _ _ O
, _ _ O
𝐶𝑎𝑐ℎ𝑒 _ _ O
= _ _ O
256 _ _ O
B _ _ O
, _ _ O
𝐵𝑙𝑜𝑐𝑘 _ _ O
= _ _ O
32 _ _ O
B _ _ O
, _ _ O
𝐴𝑠𝑠 _ _ O
= _ _ O
2 _ _ O
# _ _ O
define _ _ O
SIZE _ _ O
8 _ _ O
long _ _ O
ar _ _ O
[ _ _ O
SIZE _ _ O
] _ _ O
[ _ _ O
SIZE _ _ O
] _ _ O
, _ _ O
sum _ _ O
= _ _ O
0 _ _ O
; _ _ O
/ _ _ O
/ _ _ O
& _ _ O
ar=0x800 _ _ O
for _ _ O
( _ _ O
int _ _ O
i _ _ O
= _ _ O
0 _ _ O
; _ _ O
i _ _ O
< _ _ O
SIZE _ _ O
; _ _ O
i++ _ _ O
) _ _ O
for _ _ O
( _ _ O
int _ _ O
j _ _ O
= _ _ O
0 _ _ O
; _ _ O
j _ _ O
< _ _ O
SIZE _ _ O
; _ _ O
j++ _ _ O
) _ _ O
sum _ _ O
+ _ _ O
= _ _ O
ar _ _ O
[ _ _ O
i _ _ O
] _ _ O
[ _ _ O
j _ _ O
] _ _ O
; _ _ O
• _ _ O
Code _ _ O
employs _ _ O
a _ _ O
row-wise _ _ O
access _ _ O
pattern _ _ O
• _ _ O
Cache _ _ O
block _ _ O
( _ _ O
of _ _ O
32 _ _ O
bytes _ _ O
) _ _ O
holds _ _ O
4 _ _ O
long _ _ O
’s _ _ O
• _ _ O
There _ _ O
is _ _ O
a _ _ O
miss _ _ O
followed _ _ O
by _ _ O
3 _ _ O
hits _ _ O
( _ _ O
MR=25 _ _ O
% _ _ O
) _ _ O
53 _ _ O

Code _ _ O
Analysis _ _ O
Problem _ _ O
• _ _ O
How _ _ O
would _ _ O
the _ _ O
following _ _ O
changes _ _ O
change _ _ O
the _ _ O
miss _ _ O
rate _ _ O
? _ _ O
– _ _ O
Increasing _ _ O
the _ _ O
block _ _ O
size _ _ O
? _ _ O
– _ _ O
Doubling _ _ O
the _ _ O
cache _ _ O
size _ _ O
– _ _ O
Reducing _ _ O
/ _ _ O
increasing _ _ O
the _ _ O
associativity _ _ O
54 _ _ O



