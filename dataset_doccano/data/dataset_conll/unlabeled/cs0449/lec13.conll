unlabeled|cs0449|lec13
-DOCSTART- -X- -X- O

13 _ _ O
Virtual _ _ O
Memory _ _ O
CS _ _ O
/ _ _ O
COE _ _ O
0449 _ _ O
Introduction _ _ O
to _ _ O
Systems _ _ O
Software _ _ O
Luis _ _ O
Oliveira _ _ O
( _ _ O
with _ _ O
content _ _ O
borrowed _ _ O
from _ _ O
wilkie _ _ O
and _ _ O
Vinicius _ _ O
Petrucci _ _ O
) _ _ O

The _ _ O
Virtual _ _ O
I _ _ O
just _ _ O
want _ _ O
to _ _ O
use _ _ O
this _ _ O
time _ _ O
to _ _ O
point _ _ O
out _ _ O
that _ _ O
“ _ _ O
Virtual _ _ O
Reality _ _ O
” _ _ O
is _ _ O
an _ _ O
oxymoron _ _ O
. _ _ O
2 _ _ O

Our _ _ O
protagonist _ _ O
’s _ _ O
journey _ _ O
so _ _ O
far _ _ O
… _ _ O
• _ _ O
Processes _ _ O
have _ _ O
an _ _ O
addressable _ _ O
memory _ _ O
space _ _ O
. _ _ O
▪ _ _ O
We _ _ O
call _ _ O
this _ _ O
an _ _ O
address _ _ O
space _ _ O
. _ _ O
• _ _ O
Now _ _ O
, _ _ O
we _ _ O
know _ _ O
it _ _ O
has _ _ O
some _ _ O
obvious _ _ O
things _ _ O
… _ _ O
▪ _ _ O
The _ _ O
code _ _ O
( _ _ O
.text _ _ O
) _ _ O
▪ _ _ O
The _ _ O
data _ _ O
( _ _ O
.data _ _ O
) _ _ O
▪ _ _ O
A _ _ O
stack _ _ O
and _ _ O
some _ _ O
available _ _ O
space _ _ O
that _ _ O
can _ _ O
be _ _ O
allocated _ _ O
as _ _ O
we _ _ O
need _ _ O
it _ _ O
. _ _ O
• _ _ O
We _ _ O
added _ _ O
the _ _ O
“ _ _ O
Kernel _ _ O
” _ _ O
memory _ _ O
to _ _ O
our _ _ O
diagram _ _ O
. _ _ O
▪ _ _ O
This _ _ O
is _ _ O
the _ _ O
OS _ _ O
code _ _ O
and _ _ O
data _ _ O
. _ _ O
▪ _ _ O
For _ _ O
system _ _ O
processes _ _ O
to _ _ O
run _ _ O
, _ _ O
they _ _ O
need _ _ O
to _ _ O
be _ _ O
resident _ _ O
in _ _ O
memory _ _ O
as _ _ O
well _ _ O
. _ _ O
3 _ _ O

Random _ _ O
Access _ _ O
Memory _ _ O
• _ _ O
Memory _ _ O
is _ _ O
a _ _ O
physical _ _ O
device _ _ O
. _ _ O
Sense _ _ O
Line _ _ O
• _ _ O
It _ _ O
is _ _ O
a _ _ O
random _ _ O
access _ _ O
device _ _ O
. _ _ O
▪ _ _ O
Allows _ _ O
the _ _ O
machine _ _ O
to _ _ O
access _ _ O
data _ _ O
at _ _ O
any _ _ O
point _ _ O
. _ _ O
Capacitor _ _ O
Control _ _ O
Line _ _ O
• _ _ O
As _ _ O
opposed _ _ O
to _ _ O
sequential _ _ O
access _ _ O
. _ _ O
Dynamic _ _ O
RAM _ _ O
( _ _ O
DRAM _ _ O
) _ _ O
4 _ _ O

Let _ _ O
’s _ _ O
get _ _ O
physical _ _ O
• _ _ O
Physical _ _ O
addressing _ _ O
is _ _ O
when _ _ O
hardware _ _ O
relates _ _ O
a _ _ O
program _ _ O
address _ _ O
directly _ _ O
to _ _ O
the _ _ O
memory _ _ O
hardware _ _ O
. _ _ O
• _ _ O
The _ _ O
program _ _ O
addresses _ _ O
are _ _ O
the _ _ O
exact _ _ O
physical _ _ O
locations _ _ O
of _ _ O
data _ _ O
. _ _ O
Dynamic _ _ O
RAM _ _ O
( _ _ O
DRAM _ _ O
) _ _ O
5 _ _ O

Let _ _ O
’s _ _ O
get _ _ O
physical _ _ O
• _ _ O
Physical _ _ O
addressing _ _ O
is _ _ O
useful _ _ O
when _ _ O
you _ _ O
have _ _ O
only _ _ O
a _ _ O
single _ _ O
, _ _ O
simple _ _ O
process _ _ O
. _ _ O
• _ _ O
Embedded _ _ O
devices _ _ O
( _ _ O
small _ _ O
, _ _ O
specific _ _ O
uses _ _ O
) _ _ O
• _ _ O
Think _ _ O
of _ _ O
your _ _ O
toaster _ _ O
… _ _ O
or _ _ O
a _ _ O
thermostat _ _ O
. _ _ O
Memory _ _ O
load _ _ O
Address _ _ O
Space _ _ O
CPU _ _ O
Dynamic _ _ O
RAM _ _ O
( _ _ O
DRAM _ _ O
) _ _ O
6 _ _ O

The _ _ O
problem _ _ O
• _ _ O
However _ _ O
, _ _ O
we _ _ O
do _ _ O
n’t _ _ O
always _ _ O
have _ _ O
such _ _ O
simple _ _ O
cases _ _ O
. _ _ O
▪ _ _ O
A _ _ O
general-purpose _ _ O
system _ _ O
, _ _ O
like _ _ O
our _ _ O
phones _ _ O
and _ _ O
desktop _ _ O
machines _ _ O
, _ _ O
can _ _ O
run _ _ O
a _ _ O
variety _ _ O
of _ _ O
programs _ _ O
. _ _ O
▪ _ _ O
We _ _ O
often _ _ O
have _ _ O
multitasking _ _ O
operating _ _ O
systems _ _ O
running _ _ O
many _ _ O
programs _ _ O
at _ _ O
the _ _ O
same _ _ O
time _ _ O
. _ _ O
• _ _ O
When _ _ O
we _ _ O
have _ _ O
several _ _ O
processes _ _ O
, _ _ O
how _ _ O
to _ _ O
we _ _ O
manage _ _ O
memory _ _ O
? _ _ O
▪ _ _ O
How _ _ O
to _ _ O
present _ _ O
a _ _ O
consistent _ _ O
address _ _ O
space _ _ O
? _ _ O
▪ _ _ O
How _ _ O
to _ _ O
prevent _ _ O
other _ _ O
processes _ _ O
from _ _ O
interfering _ _ O
? _ _ O
▪ _ _ O
How _ _ O
to _ _ O
prevent _ _ O
address _ _ O
space _ _ O
fragmentation _ _ O
? _ _ O
• _ _ O
The _ _ O
solution _ _ O
, _ _ O
as _ _ O
usual _ _ O
: _ _ O
indirection _ _ O
: _ _ O
Virtual _ _ O
Memory _ _ O
. _ _ O
7 _ _ O

Virtual _ _ O
vs. _ _ O
Reality _ _ O
• _ _ O
Just _ _ O
like _ _ O
“ _ _ O
virtual _ _ O
reality _ _ O
, _ _ O
” _ _ O
we _ _ O
create _ _ O
a _ _ O
world _ _ O
that _ _ O
resembles _ _ O
reality _ _ O
, _ _ O
but _ _ O
it _ _ O
really _ _ O
is _ _ O
a _ _ O
facsimile _ _ O
. _ _ O
• _ _ O
We _ _ O
can _ _ O
provide _ _ O
a _ _ O
scheme _ _ O
, _ _ O
backed _ _ O
by _ _ O
hardware _ _ O
, _ _ O
that _ _ O
allows _ _ O
memory _ _ O
addresses _ _ O
to _ _ O
be _ _ O
seen _ _ O
by _ _ O
programs _ _ O
in _ _ O
a _ _ O
specific _ _ O
place _ _ O
… _ _ O
• _ _ O
Yet _ _ O
, _ _ O
those _ _ O
addresses _ _ O
differ _ _ O
from _ _ O
the _ _ O
actual _ _ O
physical _ _ O
memory _ _ O
location _ _ O
. _ _ O
Angela _ _ O
Lansbury _ _ O
as _ _ O
Jessica _ _ O
Fletcher _ _ O
, _ _ O
Director _ _ O
Lee _ _ O
Smith _ _ O
Murder _ _ O
, _ _ O
She _ _ O
Wrote _ _ O
; _ _ O
“ _ _ O
A _ _ O
Virtual _ _ O
Murder _ _ O
” _ _ O
Universal _ _ O
Studios _ _ O
, _ _ O
Universal _ _ O
Television _ _ O
, _ _ O
1993 _ _ O
8 _ _ O

Consistency _ _ O
, _ _ O
dear _ _ O
Watson _ _ O
. _ _ O
• _ _ O
When _ _ O
you _ _ O
write _ _ O
a _ _ O
program _ _ O
, _ _ O
do _ _ O
you _ _ O
write _ _ O
it _ _ O
deliberately _ _ O
for _ _ O
the _ _ O
memory _ _ O
layout _ _ O
of _ _ O
your _ _ O
OS _ _ O
? _ _ O
▪ _ _ O
No _ _ O
! _ _ O
• _ _ O
The _ _ O
OS _ _ O
loads _ _ O
executables _ _ O
to _ _ O
specific _ _ O
places _ _ O
in _ _ O
memory _ _ O
. _ _ O
▪ _ _ O
The _ _ O
program _ _ O
expects _ _ O
data _ _ O
to _ _ O
be _ _ O
in _ _ O
a _ _ O
specific _ _ O
place _ _ O
. _ _ O
▪ _ _ O
The _ _ O
program _ _ O
expects _ _ O
memory _ _ O
to _ _ O
be _ _ O
“ _ _ O
large _ _ O
enough _ _ O
. _ _ O
” _ _ O
• _ _ O
So _ _ O
, _ _ O
we _ _ O
will _ _ O
look _ _ O
at _ _ O
one _ _ O
strategy _ _ O
to _ _ O
define _ _ O
well-known _ _ O
stretches _ _ O
of _ _ O
memory _ _ O
( _ _ O
virtually _ _ O
) _ _ O
that _ _ O
are _ _ O
mapped _ _ O
to _ _ O
physical _ _ O
memory _ _ O
( _ _ O
in _ _ O
reality _ _ O
. _ _ O
) _ _ O
9 _ _ O

Segmentation _ _ O
It _ _ O
’s _ _ O
not _ _ O
just _ _ O
a _ _ O
type _ _ O
of _ _ O
fault _ _ O
. _ _ O
10 _ _ O

Segmentation _ _ O
• _ _ O
Segmentation _ _ O
is _ _ O
a _ _ O
virtual _ _ O
memory _ _ O
system _ _ O
where _ _ O
spans _ _ O
of _ _ O
physical _ _ O
memory _ _ O
called _ _ O
a _ _ O
segment _ _ O
are _ _ O
given _ _ O
a _ _ O
physical _ _ O
base _ _ O
address _ _ O
. _ _ O
• _ _ O
The _ _ O
application _ _ O
refers _ _ O
to _ _ O
the _ _ O
virtual _ _ O
address _ _ O
by _ _ O
its _ _ O
segment _ _ O
index _ _ O
which _ _ O
is _ _ O
translated _ _ O
by _ _ O
hardware _ _ O
into _ _ O
the _ _ O
real _ _ O
address _ _ O
behind-the-scenes _ _ O
. _ _ O
• _ _ O
Here _ _ O
, _ _ O
we _ _ O
have _ _ O
a _ _ O
segment _ _ O
table _ _ O
which _ _ O
defines _ _ O
two _ _ O
segments _ _ O
. _ _ O
▪ _ _ O
The _ _ O
first _ _ O
segment _ _ O
defines _ _ O
a _ _ O
range _ _ O
of _ _ O
addresses _ _ O
from _ _ O
to _ _ O
. _ _ O
▪ _ _ O
Second _ _ O
is _ _ O
to _ _ O
Segment _ _ O
Table _ _ O
Index _ _ O
Physical _ _ O
Base _ _ O
Size _ _ O
11 _ _ O

Address _ _ O
Translation _ _ O
• _ _ O
The _ _ O
Memory _ _ O
Management _ _ O
Unit _ _ O
( _ _ O
MMU _ _ O
) _ _ O
is _ _ O
a _ _ O
hardware _ _ O
component _ _ O
of _ _ O
your _ _ O
CPU _ _ O
that _ _ O
translates _ _ O
virtual _ _ O
addresses _ _ O
to _ _ O
physical _ _ O
addresses _ _ O
. _ _ O
• _ _ O
Here _ _ O
, _ _ O
it _ _ O
translates _ _ O
based _ _ O
on _ _ O
the _ _ O
segment _ _ O
table _ _ O
. _ _ O
Address _ _ O
Space _ _ O
Segment _ _ O
Table _ _ O
Index _ _ O
Physical _ _ O
Base _ _ O
Size _ _ O
MMU _ _ O
CPU _ _ O
Dynamic _ _ O
RAM _ _ O
( _ _ O
DRAM _ _ O
) _ _ O
12 _ _ O

Addressing _ _ O
the _ _ O
Code _ _ O
Segment _ _ O
• _ _ O
The _ _ O
MMU _ _ O
translates _ _ O
addresses _ _ O
by _ _ O
looking _ _ O
up _ _ O
the _ _ O
segment _ _ O
index _ _ O
and _ _ O
adding _ _ O
the _ _ O
base _ _ O
to _ _ O
the _ _ O
given _ _ O
offset _ _ O
. _ _ O
MMU _ _ O
Memory _ _ O
load _ _ O
Segment _ _ O
Table _ _ O
Index _ _ O
Physical _ _ O
Base _ _ O
Size _ _ O
Address _ _ O
Space _ _ O
CPU _ _ O
Dynamic _ _ O
RAM _ _ O
( _ _ O
DRAM _ _ O
) _ _ O
13 _ _ O

Addressing _ _ O
the _ _ O
Data _ _ O
Segment _ _ O
• _ _ O
The _ _ O
same _ _ O
offset _ _ O
might _ _ O
refer _ _ O
to _ _ O
a _ _ O
different _ _ O
physical _ _ O
address _ _ O
depending _ _ O
on _ _ O
the _ _ O
index _ _ O
and _ _ O
the _ _ O
table _ _ O
. _ _ O
MMU _ _ O
Memory _ _ O
load _ _ O
Segment _ _ O
Table _ _ O
Index _ _ O
Physical _ _ O
Base _ _ O
Size _ _ O
Address _ _ O
Space _ _ O
CPU _ _ O
Dynamic _ _ O
RAM _ _ O
( _ _ O
DRAM _ _ O
) _ _ O
14 _ _ O

Addressing _ _ O
… _ _ O
nothing _ _ O
• _ _ O
However _ _ O
, _ _ O
if _ _ O
the _ _ O
MMU _ _ O
can _ _ O
not _ _ O
translate _ _ O
an _ _ O
address _ _ O
, _ _ O
it _ _ O
will _ _ O
fault _ _ O
. _ _ O
• _ _ O
This _ _ O
is _ _ O
a _ _ O
segmentation _ _ O
fault _ _ O
. _ _ O
MMU _ _ O
Memory _ _ O
load _ _ O
Segment _ _ O
Table _ _ O
Index _ _ O
Physical _ _ O
Base _ _ O
Size _ _ O
Address _ _ O
Space _ _ O
CPU _ _ O
Dynamic _ _ O
RAM _ _ O
( _ _ O
DRAM _ _ O
) _ _ O
15 _ _ O

Addressing _ _ O
… _ _ O
out _ _ O
of _ _ O
range _ _ O
• _ _ O
This _ _ O
is _ _ O
true _ _ O
even _ _ O
if _ _ O
the _ _ O
address _ _ O
calculation _ _ O
results _ _ O
in _ _ O
an _ _ O
address _ _ O
that _ _ O
is _ _ O
allocated _ _ O
to _ _ O
another _ _ O
segment _ _ O
. _ _ O
• _ _ O
Fault _ _ O
: _ _ O
It _ _ O
goes _ _ O
beyond _ _ O
the _ _ O
size _ _ O
of _ _ O
the _ _ O
segment _ _ O
. _ _ O
MMU _ _ O
Memory _ _ O
load _ _ O
Segment _ _ O
Table _ _ O
Index _ _ O
Physical _ _ O
Base _ _ O
Size _ _ O
Address _ _ O
Space _ _ O
CPU _ _ O
Dynamic _ _ O
RAM _ _ O
( _ _ O
DRAM _ _ O
) _ _ O
16 _ _ O

It _ _ O
’s _ _ O
for _ _ O
your _ _ O
pwn _ _ O
protection _ _ O
• _ _ O
The _ _ O
lie _ _ O
only _ _ O
operates _ _ O
if _ _ O
processes _ _ O
can _ _ O
not _ _ O
see _ _ O
each _ _ O
other _ _ O
. _ _ O
▪ _ _ O
It _ _ O
’s _ _ O
not _ _ O
just _ _ O
about _ _ O
address _ _ O
spaces _ _ O
not _ _ O
overlapping _ _ O
… _ _ O
▪ _ _ O
It _ _ O
is _ _ O
also _ _ O
for _ _ O
security _ _ O
purposes _ _ O
! _ _ O
• _ _ O
You _ _ O
do _ _ O
n’t _ _ O
want _ _ O
your _ _ O
login _ _ O
process _ _ O
to _ _ O
be _ _ O
snooped _ _ O
on _ _ O
by _ _ O
another _ _ O
. _ _ O
• _ _ O
Yet _ _ O
, _ _ O
also _ _ O
, _ _ O
you _ _ O
do _ _ O
n’t _ _ O
want _ _ O
your _ _ O
own _ _ O
program _ _ O
to _ _ O
do _ _ O
ridiculous _ _ O
things _ _ O
it _ _ O
should _ _ O
not _ _ O
do _ _ O
! _ _ O
▪ _ _ O
Should _ _ O
your _ _ O
program _ _ O
be _ _ O
able _ _ O
to _ _ O
write _ _ O
to _ _ O
constant _ _ O
values _ _ O
? _ _ O
▪ _ _ O
Should _ _ O
your _ _ O
program _ _ O
be _ _ O
able _ _ O
to _ _ O
execute _ _ O
instructions _ _ O
in _ _ O
the _ _ O
segment _ _ O
? _ _ O
• _ _ O
Virtual _ _ O
memory _ _ O
generally _ _ O
also _ _ O
has _ _ O
ways _ _ O
to _ _ O
arbitrate _ _ O
access _ _ O
. _ _ O
17 _ _ O

Amending _ _ O
to _ _ O
add _ _ O
access _ _ O
control _ _ O
• _ _ O
The _ _ O
MMU _ _ O
can _ _ O
also _ _ O
arbitrate _ _ O
access _ _ O
to _ _ O
the _ _ O
segments _ _ O
by _ _ O
adding _ _ O
access _ _ O
control _ _ O
to _ _ O
the _ _ O
segment _ _ O
table _ _ O
. _ _ O
• _ _ O
Here _ _ O
, _ _ O
a _ _ O
in _ _ O
the _ _ O
table _ _ O
denotes _ _ O
the _ _ O
action _ _ O
is _ _ O
allowed _ _ O
. _ _ O
▪ _ _ O
▪ _ _ O
Writes _ _ O
allowed _ _ O
. _ _ O
Can _ _ O
be _ _ O
executed _ _ O
. _ _ O
Address _ _ O
Space _ _ O
Segment _ _ O
Table _ _ O
I _ _ O
Physical _ _ O
Base _ _ O
Size _ _ O
W _ _ O
X _ _ O
MMU _ _ O
CPU _ _ O
Dynamic _ _ O
RAM _ _ O
( _ _ O
DRAM _ _ O
) _ _ O
18 _ _ O

Writing _ _ O
to _ _ O
the _ _ O
Code _ _ O
Segment _ _ O
? _ _ O
NO _ _ O
! _ _ O
! _ _ O
• _ _ O
When _ _ O
the _ _ O
MMU _ _ O
decides _ _ O
if _ _ O
an _ _ O
action _ _ O
is _ _ O
allowed _ _ O
, _ _ O
it _ _ O
looks _ _ O
at _ _ O
the _ _ O
access _ _ O
control _ _ O
bits _ _ O
in _ _ O
the _ _ O
table _ _ O
. _ _ O
MMU _ _ O
Memory _ _ O
store _ _ O
Segment _ _ O
Table _ _ O
I _ _ O
Physical _ _ O
Base _ _ O
Size _ _ O
W _ _ O
X _ _ O
Address _ _ O
Space _ _ O
CPU _ _ O
Dynamic _ _ O
RAM _ _ O
( _ _ O
DRAM _ _ O
) _ _ O
19 _ _ O

Executing _ _ O
the _ _ O
Data _ _ O
Segment _ _ O
? _ _ O
ABSOLUTELY _ _ O
NOT _ _ O
! _ _ O
! _ _ O
• _ _ O
This _ _ O
feature _ _ O
can _ _ O
be _ _ O
used _ _ O
to _ _ O
effectively _ _ O
prevent _ _ O
many _ _ O
buffer _ _ O
overflow _ _ O
attacks _ _ O
. _ _ O
• _ _ O
Here _ _ O
, _ _ O
you _ _ O
ca _ _ O
n’t _ _ O
execute _ _ O
application _ _ O
data _ _ O
. _ _ O
MMU _ _ O
Instruction _ _ O
Fetch _ _ O
Segment _ _ O
Table _ _ O
I _ _ O
Physical _ _ O
Base _ _ O
Size _ _ O
W _ _ O
X _ _ O
Address _ _ O
Space _ _ O
CPU _ _ O
Dynamic _ _ O
RAM _ _ O
( _ _ O
DRAM _ _ O
) _ _ O
20 _ _ O

A _ _ O
Problem _ _ O
Remains _ _ O
: _ _ O
Fragmentation _ _ O
• _ _ O
In _ _ O
a _ _ O
purely _ _ O
segmented _ _ O
system _ _ O
, _ _ O
you _ _ O
can _ _ O
map _ _ O
regions _ _ O
of _ _ O
physical _ _ O
memory _ _ O
. _ _ O
? _ _ O
? _ _ O
? _ _ O
• _ _ O
However _ _ O
, _ _ O
the _ _ O
segments _ _ O
of _ _ O
virtual _ _ O
memory _ _ O
are _ _ O
continuous _ _ O
in _ _ O
physical _ _ O
memory _ _ O
and _ _ O
can _ _ O
not _ _ O
overlap _ _ O
other _ _ O
physical _ _ O
regions _ _ O
on _ _ O
the _ _ O
system _ _ O
. _ _ O
• _ _ O
We _ _ O
may _ _ O
run _ _ O
out _ _ O
of _ _ O
room _ _ O
as _ _ O
we _ _ O
run _ _ O
more _ _ O
processes _ _ O
… _ _ O
• _ _ O
… _ _ O
and _ _ O
as _ _ O
processes _ _ O
finish _ _ O
, _ _ O
they _ _ O
may _ _ O
leave _ _ O
awkward _ _ O
gaps _ _ O
in _ _ O
memory _ _ O
. _ _ O
( _ _ O
external _ _ O
fragmentation _ _ O
) _ _ O
21 _ _ O

Paging _ _ O
This _ _ O
wo _ _ O
n’t _ _ O
give _ _ O
you _ _ O
paper _ _ O
cuts _ _ O
... _ _ O
I _ _ O
do _ _ O
n’t _ _ O
think _ _ O
. _ _ O
22 _ _ O

Making _ _ O
things _ _ O
… _ _ O
smaller _ _ O
. _ _ O
• _ _ O
So _ _ O
, _ _ O
segmentation _ _ O
helped _ _ O
us _ _ O
isolate _ _ O
processes _ _ O
by _ _ O
allowing _ _ O
a _ _ O
virtual _ _ O
address _ _ O
space _ _ O
where _ _ O
large _ _ O
spans _ _ O
of _ _ O
memory _ _ O
were _ _ O
mapped _ _ O
continuously _ _ O
to _ _ O
a _ _ O
physical _ _ O
address _ _ O
range _ _ O
. _ _ O
• _ _ O
Since _ _ O
segments _ _ O
are _ _ O
large _ _ O
, _ _ O
managing _ _ O
that _ _ O
space _ _ O
is _ _ O
difficult _ _ O
. _ _ O
• _ _ O
So _ _ O
why _ _ O
do _ _ O
n’t _ _ O
we _ _ O
make _ _ O
the _ _ O
segments _ _ O
… _ _ O
small _ _ O
? _ _ O
And _ _ O
use _ _ O
more _ _ O
of _ _ O
them _ _ O
? _ _ O
• _ _ O
Welcome _ _ O
to _ _ O
the _ _ O
wonderful _ _ O
world _ _ O
of _ _ O
pages _ _ O
! _ _ O
Process _ _ O
’s _ _ O
Virtual _ _ O
Address _ _ O
Space _ _ O
23 _ _ O

Paging _ _ O
Mr. _ _ O
Herman _ _ O
… _ _ O
Mr. _ _ O
P. _ _ O
W. _ _ O
Herman _ _ O
… _ _ O
• _ _ O
Each _ _ O
segment _ _ O
is _ _ O
itself _ _ O
divided _ _ O
into _ _ O
smaller _ _ O
pieces _ _ O
called _ _ O
a _ _ O
page _ _ O
. _ _ O
• _ _ O
This _ _ O
allows _ _ O
us _ _ O
to _ _ O
even _ _ O
interleave _ _ O
the _ _ O
different _ _ O
pages _ _ O
that _ _ O
make _ _ O
up _ _ O
a _ _ O
section _ _ O
of _ _ O
memory _ _ O
. _ _ O
• _ _ O
Because _ _ O
of _ _ O
this _ _ O
interleaving _ _ O
and _ _ O
that _ _ O
every _ _ O
page _ _ O
is _ _ O
the _ _ O
same _ _ O
exact _ _ O
size _ _ O
, _ _ O
removing _ _ O
a _ _ O
page _ _ O
leaves _ _ O
room _ _ O
for _ _ O
exactly _ _ O
one _ _ O
page _ _ O
… _ _ O
no _ _ O
fragmentation _ _ O
. _ _ O
▪ _ _ O
At _ _ O
the _ _ O
cost _ _ O
of _ _ O
over-allocating _ _ O
, _ _ O
if _ _ O
we _ _ O
need _ _ O
less _ _ O
space _ _ O
than _ _ O
a _ _ O
single _ _ O
page _ _ O
. _ _ O
Allocating _ _ O
this _ _ O
: _ _ O
Removing _ _ O
this _ _ O
page _ _ O
left _ _ O
room _ _ O
big _ _ O
enough _ _ O
for _ _ O
… _ _ O
a _ _ O
new _ _ O
page _ _ O
! _ _ O
Process _ _ O
’s _ _ O
Virtual _ _ O
Address _ _ O
Space _ _ O
24 _ _ O

Page _ _ O
Tables _ _ O
• _ _ O
There _ _ O
are _ _ O
many _ _ O
strategies _ _ O
for _ _ O
maintaining _ _ O
the _ _ O
metadata _ _ O
that _ _ O
maps _ _ O
virtual _ _ O
addresses _ _ O
to _ _ O
physical _ _ O
addresses _ _ O
. _ _ O
CPU _ _ O
Virtual _ _ O
Address _ _ O
Page _ _ O
Index _ _ O
Page _ _ O
Offset _ _ O
• _ _ O
The _ _ O
first _ _ O
we _ _ O
will _ _ O
look _ _ O
at _ _ O
is _ _ O
the _ _ O
simple _ _ O
page _ _ O
table _ _ O
. _ _ O
• _ _ O
In _ _ O
this _ _ O
strategy _ _ O
, _ _ O
we _ _ O
will _ _ O
maintain _ _ O
a _ _ O
data _ _ O
structure _ _ O
that _ _ O
maps _ _ O
virtual _ _ O
addresses _ _ O
to _ _ O
physical _ _ O
addresses _ _ O
. _ _ O
Physical _ _ O
Address _ _ O
Page _ _ O
Index _ _ O
Page _ _ O
Offset _ _ O
25 _ _ O

Address _ _ O
Fields _ _ O
Virtual _ _ O
Address _ _ O
• _ _ O
First _ _ O
, _ _ O
you _ _ O
need _ _ O
to _ _ O
set _ _ O
a _ _ O
static _ _ O
page _ _ O
size _ _ O
. _ _ O
Page _ _ O
Index _ _ O
Page _ _ O
Offset _ _ O
▪ _ _ O
Every _ _ O
page _ _ O
is _ _ O
the _ _ O
same _ _ O
size _ _ O
. _ _ O
Process _ _ O
Page _ _ O
Table _ _ O
• _ _ O
Part _ _ O
of _ _ O
the _ _ O
virtual _ _ O
address _ _ O
is _ _ O
the _ _ O
offset _ _ O
, _ _ O
which _ _ O
is _ _ O
retained _ _ O
when _ _ O
the _ _ O
MMU _ _ O
translates _ _ O
the _ _ O
physical _ _ O
address _ _ O
. _ _ O
Valid _ _ O
Write _ _ O
Execute _ _ O
Page _ _ O
Address _ _ O
Index _ _ O
▪ _ _ O
This _ _ O
is _ _ O
determined _ _ O
by _ _ O
the _ _ O
page _ _ O
size _ _ O
. _ _ O
Physical _ _ O
Address _ _ O
• _ _ O
The _ _ O
remainder _ _ O
is _ _ O
used _ _ O
to _ _ O
determine _ _ O
the _ _ O
entry _ _ O
in _ _ O
the _ _ O
table _ _ O
. _ _ O
Page _ _ O
Index _ _ O
Page _ _ O
Offset _ _ O
26 _ _ O

It _ _ O
’s _ _ O
not _ _ O
your _ _ O
fault _ _ O
… _ _ O
Virtual _ _ O
Address _ _ O
• _ _ O
If _ _ O
there _ _ O
is _ _ O
no _ _ O
entry _ _ O
for _ _ O
the _ _ O
given _ _ O
page _ _ O
or _ _ O
the _ _ O
entry _ _ O
is _ _ O
n’t _ _ O
valid _ _ O
… _ _ O
Page _ _ O
Index _ _ O
Page _ _ O
Offset _ _ O
▪ _ _ O
Or _ _ O
if _ _ O
an _ _ O
operation _ _ O
is _ _ O
not _ _ O
allowed _ _ O
. _ _ O
Process _ _ O
Page _ _ O
Table _ _ O
Valid _ _ O
• _ _ O
This _ _ O
signals _ _ O
a _ _ O
page _ _ O
fault _ _ O
. _ _ O
Execute _ _ O
Page _ _ O
Address _ _ O
Index _ _ O
▪ _ _ O
Similar _ _ O
to _ _ O
a _ _ O
segmentation _ _ O
fault _ _ O
. _ _ O
▪ _ _ O
In _ _ O
fact _ _ O
, _ _ O
many _ _ O
OSes _ _ O
retain _ _ O
that _ _ O
term _ _ O
to _ _ O
this _ _ O
day _ _ O
, _ _ O
even _ _ O
when _ _ O
it _ _ O
is _ _ O
a _ _ O
page _ _ O
fault _ _ O
, _ _ O
technically _ _ O
. _ _ O
• _ _ O
This _ _ O
is _ _ O
a _ _ O
generic _ _ O
error _ _ O
that _ _ O
is _ _ O
triggered _ _ O
by _ _ O
the _ _ O
MMU _ _ O
on _ _ O
such _ _ O
invalid _ _ O
accesses _ _ O
. _ _ O
Write _ _ O
DRAM _ _ O
CPU _ _ O
Virtual _ _ O
Address _ _ O
X _ _ O
MMU _ _ O
27 _ _ O

Process _ _ O
Isolation _ _ O
• _ _ O
To _ _ O
give _ _ O
each _ _ O
process _ _ O
its _ _ O
own _ _ O
virtual _ _ O
address _ _ O
space _ _ O
, _ _ O
each _ _ O
process _ _ O
gets _ _ O
its _ _ O
own _ _ O
page _ _ O
table _ _ O
. _ _ O
Page _ _ O
Table _ _ O
Address _ _ O
Process _ _ O
Page _ _ O
Table _ _ O
Valid _ _ O
Write _ _ O
Execute _ _ O
Page _ _ O
Address _ _ O
Index _ _ O
• _ _ O
The _ _ O
CPU _ _ O
keeps _ _ O
track _ _ O
of _ _ O
which _ _ O
page _ _ O
table _ _ O
is _ _ O
active _ _ O
. _ _ O
DRAM _ _ O
CPU _ _ O
Virtual _ _ O
Address _ _ O
MMU _ _ O
Physical _ _ O
Address _ _ O
28 _ _ O

Context _ _ O
Switching _ _ O
: _ _ O
Getting _ _ O
to _ _ O
the _ _ O
root _ _ O
of _ _ O
it _ _ O
. _ _ O
• _ _ O
When _ _ O
an _ _ O
Operating _ _ O
System _ _ O
goes _ _ O
from _ _ O
one _ _ O
process _ _ O
to _ _ O
another _ _ O
, _ _ O
it _ _ O
performs _ _ O
a _ _ O
context _ _ O
switch _ _ O
. _ _ O
1 _ _ O
. _ _ O
Store _ _ O
registers _ _ O
( _ _ O
including _ _ O
stack _ _ O
pointer _ _ O
and _ _ O
program _ _ O
counter _ _ O
) _ _ O
to _ _ O
memory _ _ O
. _ _ O
2 _ _ O
. _ _ O
Determine _ _ O
next _ _ O
process _ _ O
to _ _ O
run _ _ O
. _ _ O
3 _ _ O
. _ _ O
Load _ _ O
those _ _ O
registers _ _ O
from _ _ O
memory _ _ O
. _ _ O
Switch _ _ O
address _ _ O
space _ _ O
. _ _ O
4 _ _ O
. _ _ O
Jump _ _ O
to _ _ O
old _ _ O
program _ _ O
counter _ _ O
. _ _ O
Go _ _ O
! _ _ O
Process _ _ O
A _ _ O
Process _ _ O
B _ _ O
Process _ _ O
C _ _ O
stack _ _ O
stack _ _ O
stack _ _ O
.bss _ _ O
.data _ _ O
.text _ _ O
.bss _ _ O
.data _ _ O
.text _ _ O
.bss _ _ O
.data _ _ O
.text _ _ O
CPU _ _ O
State _ _ O
A _ _ O
: _ _ O
Registers _ _ O
, _ _ O
CPU _ _ O
State _ _ O
B _ _ O
: _ _ O
Registers _ _ O
, _ _ O
CPU _ _ O
State _ _ O
C _ _ O
: _ _ O
Registers _ _ O
, _ _ O
Page _ _ O
Table _ _ O
Address _ _ O
A _ _ O
Page _ _ O
Table _ _ O
Address _ _ O
B _ _ O
Page _ _ O
Table _ _ O
Address _ _ O
C _ _ O
DRAM _ _ O
CPU _ _ O
Virtual _ _ O
Address _ _ O
MMU _ _ O
Physical _ _ O
Address _ _ O
29 _ _ O

Addressing _ _ O
the _ _ O
granularity _ _ O
issue _ _ O
• _ _ O
The _ _ O
table _ _ O
size _ _ O
has _ _ O
to _ _ O
do _ _ O
with _ _ O
how _ _ O
big _ _ O
you _ _ O
make _ _ O
each _ _ O
page _ _ O
. _ _ O
▪ _ _ O
The _ _ O
bigger _ _ O
the _ _ O
page _ _ O
, _ _ O
the _ _ O
less _ _ O
entries _ _ O
you _ _ O
’ll _ _ O
need _ _ O
for _ _ O
your _ _ O
process _ _ O
. _ _ O
▪ _ _ O
However _ _ O
, _ _ O
the _ _ O
more _ _ O
internal _ _ O
fragmentation _ _ O
if _ _ O
you _ _ O
do _ _ O
not _ _ O
need _ _ O
some _ _ O
of _ _ O
that _ _ O
space _ _ O
! _ _ O
• _ _ O
For _ _ O
a _ _ O
page _ _ O
size _ _ O
of _ _ O
𝐾 _ _ O
▪ _ _ O
Page _ _ O
offset _ _ O
will _ _ O
have _ _ O
log _ _ O
2 _ _ O
𝐾 _ _ O
bits _ _ O
. _ _ O
▪ _ _ O
Page _ _ O
index _ _ O
will _ _ O
be _ _ O
the _ _ O
remaining _ _ O
bits _ _ O
. _ _ O
• _ _ O
For _ _ O
32-bit _ _ O
address _ _ O
spaces _ _ O
: _ _ O
▪ _ _ O
Assuming _ _ O
table _ _ O
entries _ _ O
are _ _ O
also _ _ O
32-bits _ _ O
. _ _ O
Virtual _ _ O
Address _ _ O
Page _ _ O
Index _ _ O
Page _ _ O
Offset _ _ O
𝐾 _ _ O
= _ _ O
216 _ _ O
𝐾𝑖𝐵 _ _ O
= _ _ O
64𝐾𝑖𝐵 _ _ O
Mapping _ _ O
2MiB _ _ O
takes _ _ O
32 _ _ O
pages _ _ O
. _ _ O
Page _ _ O
table _ _ O
size _ _ O
: _ _ O
216 _ _ O
∗ _ _ O
4𝐵 _ _ O
= _ _ O
256𝐾𝑖𝐵 _ _ O
Page _ _ O
Index _ _ O
Page _ _ O
Offset _ _ O
𝐾 _ _ O
= _ _ O
212 _ _ O
𝐾𝑖𝐵 _ _ O
= _ _ O
4𝐾𝑖𝐵 _ _ O
Mapping _ _ O
2MiB _ _ O
takes _ _ O
512 _ _ O
pages _ _ O
. _ _ O
Page _ _ O
table _ _ O
size _ _ O
: _ _ O
220 _ _ O
∗ _ _ O
4𝐵 _ _ O
= _ _ O
4𝑀𝑖𝐵 _ _ O
Page _ _ O
Index _ _ O
Page _ _ O
Offset _ _ O
𝐾 _ _ O
= _ _ O
28 _ _ O
𝐵 _ _ O
= _ _ O
256𝐵 _ _ O
Mapping _ _ O
2MiB _ _ O
takes _ _ O
8192 _ _ O
pages _ _ O
. _ _ O
Page _ _ O
table _ _ O
size _ _ O
: _ _ O
224 _ _ O
∗ _ _ O
4𝐵 _ _ O
= _ _ O
64𝑀𝑖𝐵 _ _ O
30 _ _ O

Inverted _ _ O
Page _ _ O
Tables _ _ O
• _ _ O
There _ _ O
are _ _ O
many _ _ O
strategies _ _ O
for _ _ O
maintaining _ _ O
the _ _ O
metadata _ _ O
that _ _ O
maps _ _ O
virtual _ _ O
addresses _ _ O
to _ _ O
physical _ _ O
addresses _ _ O
. _ _ O
CPU _ _ O
Virtual _ _ O
Address _ _ O
Page _ _ O
Index _ _ O
Page _ _ O
Offset _ _ O
• _ _ O
Now _ _ O
we _ _ O
will _ _ O
look _ _ O
at _ _ O
the _ _ O
inverted _ _ O
page _ _ O
table _ _ O
. _ _ O
• _ _ O
In _ _ O
this _ _ O
strategy _ _ O
, _ _ O
we _ _ O
switch _ _ O
things _ _ O
around _ _ O
: _ _ O
we _ _ O
have _ _ O
just _ _ O
one _ _ O
table _ _ O
for _ _ O
the _ _ O
whole _ _ O
system _ _ O
and _ _ O
an _ _ O
entry _ _ O
for _ _ O
every _ _ O
possible _ _ O
physical _ _ O
page _ _ O
. _ _ O
Physical _ _ O
Address _ _ O
Page _ _ O
Index _ _ O
Page _ _ O
Offset _ _ O
31 _ _ O

Address _ _ O
Fields _ _ O
Virtual _ _ O
Address _ _ O
• _ _ O
In _ _ O
this _ _ O
case _ _ O
, _ _ O
you _ _ O
have _ _ O
a _ _ O
single _ _ O
table _ _ O
for _ _ O
the _ _ O
entire _ _ O
system _ _ O
. _ _ O
• _ _ O
When _ _ O
translating _ _ O
, _ _ O
you _ _ O
scan _ _ O
the _ _ O
table _ _ O
to _ _ O
find _ _ O
an _ _ O
entry _ _ O
that _ _ O
contains _ _ O
the _ _ O
page _ _ O
index _ _ O
. _ _ O
Page _ _ O
Tag _ _ O
Page _ _ O
Offset _ _ O
Inverted _ _ O
Page _ _ O
Table _ _ O
Page _ _ O
Tag _ _ O
Valid _ _ O
Write _ _ O
Execute _ _ O
Index _ _ O
▪ _ _ O
This _ _ O
may _ _ O
be _ _ O
intensive _ _ O
! _ _ O
• _ _ O
When _ _ O
you _ _ O
do _ _ O
, _ _ O
and _ _ O
it _ _ O
is _ _ O
valid _ _ O
, _ _ O
make _ _ O
a _ _ O
note _ _ O
of _ _ O
the _ _ O
index _ _ O
of _ _ O
the _ _ O
entry _ _ O
. _ _ O
That _ _ O
is _ _ O
the _ _ O
physical _ _ O
page _ _ O
index _ _ O
. _ _ O
Physical _ _ O
Address _ _ O
Page _ _ O
Index _ _ O
Page _ _ O
Offset _ _ O
32 _ _ O

Process _ _ O
Isolation _ _ O
• _ _ O
Many _ _ O
processes _ _ O
exist _ _ O
, _ _ O
and _ _ O
each _ _ O
may _ _ O
use _ _ O
the _ _ O
same _ _ O
virtual _ _ O
address _ _ O
. _ _ O
▪ _ _ O
And _ _ O
expect _ _ O
a _ _ O
different _ _ O
physical _ _ O
page _ _ O
! _ _ O
Virtual _ _ O
Address _ _ O
Page _ _ O
Tag _ _ O
Process _ _ O
ID _ _ O
Page _ _ O
Offset _ _ O
Inverted _ _ O
Page _ _ O
Table _ _ O
Page _ _ O
Tag _ _ O
Process _ _ O
ID _ _ O
Valid _ _ O
Write _ _ O
Execute _ _ O
Index _ _ O
• _ _ O
Since _ _ O
there _ _ O
is _ _ O
only _ _ O
one _ _ O
table _ _ O
on _ _ O
the _ _ O
entire _ _ O
system _ _ O
, _ _ O
we _ _ O
have _ _ O
to _ _ O
disambiguate _ _ O
. _ _ O
• _ _ O
Therefore _ _ O
, _ _ O
we _ _ O
also _ _ O
tag _ _ O
by _ _ O
the _ _ O
process _ _ O
identifier _ _ O
. _ _ O
Physical _ _ O
Address _ _ O
Page _ _ O
Index _ _ O
Page _ _ O
Offset _ _ O
33 _ _ O

What _ _ O
’s _ _ O
the _ _ O
size _ _ O
? _ _ O
? _ _ O
• _ _ O
One _ _ O
nice _ _ O
feature _ _ O
of _ _ O
an _ _ O
inverted _ _ O
page _ _ O
table _ _ O
is _ _ O
the _ _ O
size _ _ O
is _ _ O
bound _ _ O
. _ _ O
Inverted _ _ O
Page _ _ O
Table _ _ O
Page _ _ O
Tag _ _ O
Process _ _ O
ID _ _ O
Valid _ _ O
Write _ _ O
Execute _ _ O
• _ _ O
Since _ _ O
an _ _ O
inverted _ _ O
page _ _ O
table _ _ O
has _ _ O
an _ _ O
entry _ _ O
for _ _ O
every _ _ O
possible _ _ O
physical _ _ O
page _ _ O
… _ _ O
▪ _ _ O
You _ _ O
can _ _ O
simply _ _ O
allocate _ _ O
the _ _ O
table _ _ O
of _ _ O
a _ _ O
fixed _ _ O
size _ _ O
big _ _ O
enough _ _ O
to _ _ O
represent _ _ O
all _ _ O
of _ _ O
physical _ _ O
memory _ _ O
. _ _ O
• _ _ O
The _ _ O
size _ _ O
of _ _ O
the _ _ O
table _ _ O
is _ _ O
the _ _ O
product _ _ O
of _ _ O
the _ _ O
entry _ _ O
size _ _ O
and _ _ O
the _ _ O
number _ _ O
of _ _ O
physical _ _ O
pages _ _ O
. _ _ O
If _ _ O
the _ _ O
page _ _ O
size _ _ O
( _ _ O
K _ _ O
) _ _ O
is _ _ O
4KiB _ _ O
and _ _ O
our _ _ O
system _ _ O
has _ _ O
16GiB _ _ O
of _ _ O
RAM _ _ O
, _ _ O
how _ _ O
big _ _ O
is _ _ O
the _ _ O
inverted _ _ O
page _ _ O
table _ _ O
? _ _ O
234 _ _ O
16𝐺𝑖𝐵 _ _ O
/ _ _ O
4𝐾𝑖𝐵 _ _ O
= _ _ O
12 _ _ O
= _ _ O
222 _ _ O
𝑝𝑎𝑔𝑒𝑠 _ _ O
2 _ _ O
222 _ _ O
𝑝𝑎𝑔𝑒𝑠 _ _ O
∗ _ _ O
32 _ _ O
𝑏𝑖𝑡𝑠 _ _ O
= _ _ O
222 _ _ O
𝑝𝑎𝑔𝑒𝑠 _ _ O
∗ _ _ O
4𝐵 _ _ O
224 _ _ O
𝐵 _ _ O
= _ _ O
24 _ _ O
220 _ _ O
𝐵 _ _ O
= _ _ O
16𝑀𝑖𝐵 _ _ O
34 _ _ O

Trade-offs _ _ O
. _ _ O
Trade-offs _ _ O
everywhere _ _ O
! _ _ O
• _ _ O
What _ _ O
is _ _ O
best _ _ O
? _ _ O
… _ _ O
Who _ _ O
even _ _ O
knows _ _ O
. _ _ O
• _ _ O
Inverted _ _ O
page _ _ O
tables _ _ O
are _ _ O
very _ _ O
space _ _ O
efficient _ _ O
since _ _ O
entries _ _ O
are _ _ O
ordered _ _ O
by _ _ O
physical _ _ O
page _ _ O
. _ _ O
▪ _ _ O
However _ _ O
, _ _ O
translations _ _ O
mean _ _ O
scanning _ _ O
the _ _ O
table _ _ O
for _ _ O
entries _ _ O
… _ _ O
a _ _ O
time-consuming _ _ O
task _ _ O
. _ _ O
𝑂 _ _ O
( _ _ O
𝑛 _ _ O
) _ _ O
( _ _ O
Can _ _ O
implement _ _ O
with _ _ O
a _ _ O
hashing _ _ O
function _ _ O
, _ _ O
see _ _ O
your _ _ O
OS _ _ O
course _ _ O
. _ _ O
) _ _ O
▪ _ _ O
Normal _ _ O
page _ _ O
tables _ _ O
are _ _ O
a _ _ O
constant _ _ O
time _ _ O
lookup _ _ O
, _ _ O
𝑂 _ _ O
1 _ _ O
• _ _ O
Since _ _ O
they _ _ O
are _ _ O
indexed _ _ O
by _ _ O
virtual _ _ O
address _ _ O
, _ _ O
normal _ _ O
page _ _ O
tables _ _ O
require _ _ O
ordered _ _ O
virtual _ _ O
memory _ _ O
to _ _ O
be _ _ O
space _ _ O
efficient _ _ O
. _ _ O
▪ _ _ O
Gaps _ _ O
in _ _ O
virtual _ _ O
memory _ _ O
mean _ _ O
lots _ _ O
of _ _ O
page _ _ O
table _ _ O
entries _ _ O
going _ _ O
unused _ _ O
. _ _ O
▪ _ _ O
Perhaps _ _ O
we _ _ O
can _ _ O
solve _ _ O
this _ _ O
problem _ _ O
… _ _ O
35 _ _ O

Multi-level _ _ O
Page _ _ O
Tables _ _ O
( _ _ O
Not _ _ O
a _ _ O
pyramid _ _ O
scheme _ _ O
) _ _ O
• _ _ O
Perhaps _ _ O
we _ _ O
can _ _ O
allow _ _ O
gaps _ _ O
in _ _ O
virtual _ _ O
memory _ _ O
if _ _ O
we _ _ O
use _ _ O
MORE _ _ O
INDIRECTION _ _ O
! _ _ O
32-bit _ _ O
Virtual _ _ O
Address _ _ O
( _ _ O
Page _ _ O
Table _ _ O
Root _ _ O
Address _ _ O
Second _ _ O
Index _ _ O
First _ _ O
Index _ _ O
) _ _ O
Page _ _ O
Offset _ _ O
2nd _ _ O
Level _ _ O
Page _ _ O
Table _ _ O
• _ _ O
The _ _ O
use _ _ O
of _ _ O
multiple _ _ O
levels _ _ O
of _ _ O
indirection _ _ O
gives _ _ O
a _ _ O
lot _ _ O
of _ _ O
flexibility _ _ O
in _ _ O
defining _ _ O
the _ _ O
virtual _ _ O
address _ _ O
space _ _ O
. _ _ O
• _ _ O
Each _ _ O
page _ _ O
table _ _ O
is _ _ O
the _ _ O
size _ _ O
of _ _ O
a _ _ O
page _ _ O
. _ _ O
( _ _ O
) _ _ O
1st _ _ O
Level _ _ O
Page _ _ O
Table _ _ O
DRAM _ _ O
36 _ _ O

Indirection _ _ O
times _ _ O
two _ _ O
• _ _ O
We _ _ O
split _ _ O
up _ _ O
the _ _ O
virtual _ _ O
address _ _ O
into _ _ O
further _ _ O
index _ _ O
fields _ _ O
. _ _ O
32-bit _ _ O
Virtual _ _ O
Address _ _ O
( _ _ O
Page _ _ O
Table _ _ O
Root _ _ O
Address _ _ O
Second _ _ O
Index _ _ O
First _ _ O
Index _ _ O
) _ _ O
Page _ _ O
Offset _ _ O
2nd _ _ O
Level _ _ O
Page _ _ O
Table _ _ O
Index _ _ O
• _ _ O
The _ _ O
top-level _ _ O
index _ _ O
yields _ _ O
the _ _ O
real _ _ O
physical _ _ O
address _ _ O
of _ _ O
the _ _ O
page _ _ O
containing _ _ O
the _ _ O
next _ _ O
page _ _ O
table _ _ O
. _ _ O
Write _ _ O
Execute _ _ O
1st _ _ O
Level _ _ O
Page _ _ O
Table _ _ O
( _ _ O
Real _ _ O
Index _ _ O
• _ _ O
This _ _ O
table _ _ O
is _ _ O
used _ _ O
to _ _ O
determine _ _ O
the _ _ O
referred _ _ O
physical _ _ O
page _ _ O
. _ _ O
Valid _ _ O
Valid _ _ O
Write _ _ O
Execute _ _ O
Page _ _ O
Table _ _ O
Address _ _ O
) _ _ O
Page _ _ O
Address _ _ O
DRAM _ _ O
37 _ _ O

Home _ _ O
, _ _ O
home _ _ O
on _ _ O
the _ _ O
[ _ _ O
memory _ _ O
] _ _ O
range _ _ O
• _ _ O
Each _ _ O
entry _ _ O
in _ _ O
the _ _ O
toplevel _ _ O
page _ _ O
table _ _ O
represents _ _ O
an _ _ O
entire _ _ O
range _ _ O
of _ _ O
memory _ _ O
. _ _ O
32-bit _ _ O
Virtual _ _ O
Address _ _ O
( _ _ O
Page _ _ O
Table _ _ O
Root _ _ O
Address _ _ O
• _ _ O
Here _ _ O
, _ _ O
the _ _ O
2nd _ _ O
level _ _ O
index _ _ O
is _ _ O
. _ _ O
This _ _ O
represents _ _ O
all _ _ O
virtual _ _ O
memory _ _ O
addresses _ _ O
with _ _ O
the _ _ O
most _ _ O
significant _ _ O
binary _ _ O
digits _ _ O
: _ _ O
First _ _ O
Index _ _ O
Page _ _ O
Offset _ _ O
2nd _ _ O
Level _ _ O
Page _ _ O
Table _ _ O
Index _ _ O
Valid _ _ O
Write _ _ O
Execute _ _ O
Page _ _ O
Table _ _ O
Address _ _ O
1st _ _ O
Level _ _ O
Page _ _ O
Table _ _ O
( _ _ O
Real _ _ O
Index _ _ O
Maps _ _ O
4KiB _ _ O
virtual _ _ O
page _ _ O
starting _ _ O
at _ _ O
0x00400000 _ _ O
Maps _ _ O
4KiB _ _ O
virtual _ _ O
page _ _ O
starting _ _ O
at _ _ O
0x00401000 _ _ O
... _ _ O
Maps _ _ O
4KiB _ _ O
virtual _ _ O
page _ _ O
starting _ _ O
at _ _ O
0x007ff000 _ _ O
Second _ _ O
Index _ _ O
) _ _ O
Valid _ _ O
Write _ _ O
Execute _ _ O
) _ _ O
Page _ _ O
Address _ _ O
38 _ _ O

It _ _ O
’s _ _ O
a _ _ O
sparse _ _ O
world _ _ O
, _ _ O
after _ _ O
all _ _ O
• _ _ O
By _ _ O
marking _ _ O
entries _ _ O
invalid _ _ O
in _ _ O
the _ _ O
top-level _ _ O
page _ _ O
table _ _ O
, _ _ O
this _ _ O
invalidates _ _ O
the _ _ O
entire _ _ O
memory _ _ O
range _ _ O
. _ _ O
• _ _ O
Attempting _ _ O
to _ _ O
access _ _ O
such _ _ O
a _ _ O
virtual _ _ O
address _ _ O
would _ _ O
immediately _ _ O
page _ _ O
fault _ _ O
. _ _ O
32-bit _ _ O
Virtual _ _ O
Address _ _ O
( _ _ O
Page _ _ O
Table _ _ O
Root _ _ O
Address _ _ O
Second _ _ O
Index _ _ O
First _ _ O
Index _ _ O
) _ _ O
Page _ _ O
Offset _ _ O
2nd _ _ O
Level _ _ O
Page _ _ O
Table _ _ O
Index _ _ O
Valid _ _ O
Write _ _ O
Execute _ _ O
Page _ _ O
Table _ _ O
Address _ _ O
No _ _ O
1st _ _ O
level _ _ O
table _ _ O
. _ _ O
Therefore _ _ O
: _ _ O
all _ _ O
virtual _ _ O
addresses _ _ O
between _ _ O
and _ _ O
are _ _ O
not _ _ O
mapped _ _ O
( _ _ O
and _ _ O
are _ _ O
not _ _ O
referenceable _ _ O
. _ _ O
) _ _ O
39 _ _ O

A _ _ O
got _ _ O
a _ _ O
sparsity _ _ O
jacket _ _ O
, _ _ O
but _ _ O
it _ _ O
was _ _ O
just _ _ O
the _ _ O
sleeves _ _ O
. _ _ O
32-bit _ _ O
Virtual _ _ O
Address _ _ O
• _ _ O
Given _ _ O
a _ _ O
32-bit _ _ O
virtual _ _ O
address _ _ O
. _ _ O
Second _ _ O
Index _ _ O
▪ _ _ O
And _ _ O
multi-level _ _ O
paging _ _ O
with _ _ O
two _ _ O
levels _ _ O
, _ _ O
each _ _ O
index _ _ O
10 _ _ O
bits _ _ O
. _ _ O
• _ _ O
What _ _ O
is _ _ O
the _ _ O
page _ _ O
size _ _ O
? _ _ O
▪ _ _ O
32 _ _ O
− _ _ O
10 _ _ O
− _ _ O
10 _ _ O
= _ _ O
12 _ _ O
𝑏𝑖𝑡𝑠 _ _ O
for _ _ O
offset _ _ O
▪ _ _ O
212 _ _ O
𝐵 _ _ O
= _ _ O
4𝐾𝑖𝐵 _ _ O
( _ _ O
4 _ _ O
Kibibytes _ _ O
) _ _ O
First _ _ O
Index _ _ O
Page _ _ O
Offset _ _ O
2nd _ _ O
Level _ _ O
Page _ _ O
Table _ _ O
Index _ _ O
Valid _ _ O
Write _ _ O
Execute _ _ O
Page _ _ O
Table _ _ O
Address _ _ O
• _ _ O
Given _ _ O
the _ _ O
root _ _ O
page _ _ O
table _ _ O
here _ _ O
, _ _ O
and _ _ O
assuming _ _ O
unknown _ _ O
entries _ _ O
are _ _ O
invalid _ _ O
, _ _ O
what _ _ O
virtual _ _ O
address _ _ O
ranges _ _ O
are _ _ O
potentially _ _ O
used _ _ O
? _ _ O
▪ _ _ O
Let _ _ O
’s _ _ O
find _ _ O
out _ _ O
… _ _ O
40 _ _ O

Continuing _ _ O
: _ _ O
Filling _ _ O
in _ _ O
the _ _ O
blanks _ _ O
• _ _ O
Given _ _ O
the _ _ O
root _ _ O
page _ _ O
table _ _ O
here _ _ O
, _ _ O
and _ _ O
assuming _ _ O
unknown _ _ O
entries _ _ O
are _ _ O
invalid _ _ O
, _ _ O
what _ _ O
virtual _ _ O
address _ _ O
ranges _ _ O
are _ _ O
potentially _ _ O
used _ _ O
? _ _ O
Second _ _ O
Index _ _ O
First _ _ O
Index _ _ O
Page _ _ O
Offset _ _ O
2nd _ _ O
Level _ _ O
Page _ _ O
Table _ _ O
to _ _ O
Maps _ _ O
virtual _ _ O
pages _ _ O
from _ _ O
32-bit _ _ O
Virtual _ _ O
Address _ _ O
Index _ _ O
Valid _ _ O
Write _ _ O
Execute _ _ O
Page _ _ O
Table _ _ O
Address _ _ O
to _ _ O
to _ _ O
Maps _ _ O
virtual _ _ O
pages _ _ O
from _ _ O
to _ _ O
to _ _ O
Maps _ _ O
virtual _ _ O
pages _ _ O
from _ _ O
to _ _ O
41 _ _ O

Best _ _ O
of _ _ O
both _ _ O
worlds _ _ O
. _ _ O
• _ _ O
With _ _ O
multi-level _ _ O
page _ _ O
tables _ _ O
, _ _ O
we _ _ O
can _ _ O
represent _ _ O
large _ _ O
ranges _ _ O
of _ _ O
memory _ _ O
with _ _ O
gaps _ _ O
, _ _ O
much _ _ O
like _ _ O
segments _ _ O
! _ _ O
32-bit _ _ O
Virtual _ _ O
Address _ _ O
Second _ _ O
Index _ _ O
▪ _ _ O
All _ _ O
the _ _ O
while _ _ O
, _ _ O
we _ _ O
can _ _ O
satisfy _ _ O
each _ _ O
individual _ _ O
page _ _ O
in _ _ O
this _ _ O
“ _ _ O
segment _ _ O
” _ _ O
by _ _ O
interleaving _ _ O
them _ _ O
throughout _ _ O
physical _ _ O
ram _ _ O
. _ _ O
( _ _ O
flexibility _ _ O
, _ _ O
no _ _ O
external _ _ O
fragmentation _ _ O
) _ _ O
2nd _ _ O
Level _ _ O
Page _ _ O
Table _ _ O
1st _ _ O
Level _ _ O
Page _ _ O
Table _ _ O
▪ _ _ O
x86 _ _ O
- _ _ O
64 _ _ O
uses _ _ O
a _ _ O
4 _ _ O
level _ _ O
page _ _ O
table _ _ O
! _ _ O
to _ _ O
to _ _ O
to _ _ O
Page _ _ O
Offset _ _ O
Page _ _ O
Table _ _ O
Root _ _ O
Address _ _ O
• _ _ O
Modern _ _ O
architectures _ _ O
often _ _ O
use _ _ O
multi-level _ _ O
page _ _ O
tables _ _ O
. _ _ O
Maps _ _ O
virtual _ _ O
pages _ _ O
from _ _ O
Maps _ _ O
virtual _ _ O
pages _ _ O
from _ _ O
Maps _ _ O
virtual _ _ O
pages _ _ O
from _ _ O
First _ _ O
Index _ _ O
Segments _ _ O
? _ _ O
( _ _ O
kinda _ _ O
) _ _ O
DRAM _ _ O
42 _ _ O

Summary _ _ O
So _ _ O
, _ _ O
we _ _ O
have _ _ O
many _ _ O
complex _ _ O
processes _ _ O
running _ _ O
at _ _ O
the _ _ O
same _ _ O
time _ _ O
. _ _ O
• _ _ O
How _ _ O
to _ _ O
present _ _ O
a _ _ O
consistent _ _ O
address _ _ O
space _ _ O
? _ _ O
▪ _ _ O
Indirection _ _ O
using _ _ O
segments _ _ O
or _ _ O
page _ _ O
tables _ _ O
. _ _ O
▪ _ _ O
We _ _ O
translate _ _ O
virtual _ _ O
addresses _ _ O
to _ _ O
physical _ _ O
addresses _ _ O
. _ _ O
• _ _ O
How _ _ O
to _ _ O
prevent _ _ O
other _ _ O
processes _ _ O
from _ _ O
interfering _ _ O
? _ _ O
▪ _ _ O
We _ _ O
can _ _ O
mark _ _ O
segments _ _ O
or _ _ O
individual _ _ O
pages _ _ O
with _ _ O
access _ _ O
controls _ _ O
. _ _ O
( _ _ O
Read-only _ _ O
, _ _ O
non-execute _ _ O
, _ _ O
etc _ _ O
. _ _ O
) _ _ O
• _ _ O
How _ _ O
to _ _ O
prevent _ _ O
address _ _ O
space _ _ O
fragmentation _ _ O
? _ _ O
▪ _ _ O
We _ _ O
give _ _ O
each _ _ O
process _ _ O
its _ _ O
own _ _ O
address _ _ O
space _ _ O
. _ _ O
▪ _ _ O
When _ _ O
we _ _ O
context _ _ O
switch _ _ O
, _ _ O
we _ _ O
switch _ _ O
address _ _ O
spaces _ _ O
. _ _ O
43 _ _ O



