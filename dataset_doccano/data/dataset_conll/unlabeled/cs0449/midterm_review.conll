unlabeled|cs0449|midterm_review
-DOCSTART- -X- -X- O

Intro _ _ O
to _ _ O
Systems _ _ O
Software _ _ O
Midterm _ _ O
Review _ _ O
CS _ _ O
/ _ _ O
COE _ _ O
0449 _ _ O
Introduction _ _ O
to _ _ O
Systems _ _ O
Software _ _ O
Luis _ _ O
Oliveira _ _ O
( _ _ O
with _ _ O
content _ _ O
borrowed _ _ O
from _ _ O
wilkie _ _ O
and _ _ O
Vinicius _ _ O
Petrucci _ _ O
) _ _ O
1 _ _ O

Topics _ _ O
for _ _ O
the _ _ O
Midterm _ _ O
• _ _ O
Data _ _ O
Representation _ _ O
• _ _ O
2 _ _ O
’s _ _ O
complement _ _ O
, _ _ O
Floating _ _ O
point _ _ O
, _ _ O
Bitwise _ _ O
operations _ _ O
, _ _ O
Endianness _ _ O
• _ _ O
C _ _ O
Programming _ _ O
• _ _ O
Pointers _ _ O
, _ _ O
Arrays _ _ O
, _ _ O
Strings _ _ O
, _ _ O
Memory _ _ O
Management _ _ O
• _ _ O
Machine-level _ _ O
Representation _ _ O
( _ _ O
x86 _ _ O
- _ _ O
64 _ _ O
) _ _ O
• _ _ O
Assembly _ _ O
Basics _ _ O
, _ _ O
Control _ _ O
Flow _ _ O
, _ _ O
Calling _ _ O
Conventions _ _ O
, _ _ O
Buffer _ _ O
Overflow _ _ O
• _ _ O
Executables _ _ O
• _ _ O
Compilers _ _ O
, _ _ O
Assemblers _ _ O
, _ _ O
Linkers _ _ O
, _ _ O
Loaders _ _ O
2 _ _ O

Data _ _ O
representation _ _ O

Encoding _ _ O
Integers _ _ O
Two _ _ O
’s _ _ O
Complement _ _ O
Unsigned _ _ O
B2U _ _ O
( _ _ O
X _ _ O
) _ _ O
= _ _ O
w−1 _ _ O
 _ _ O
xi _ _ O
2 _ _ O
B2 _ _ O
T _ _ O
( _ _ O
X _ _ O
) _ _ O
= _ _ O
− _ _ O
xw−1 _ _ O
2 _ _ O
i _ _ O
w−1 _ _ O
Sign _ _ O
Bit _ _ O
• _ _ O
Two _ _ O
’s _ _ O
Complement _ _ O
Examples _ _ O
( _ _ O
w _ _ O
= _ _ O
5 _ _ O
) _ _ O
10 _ _ O
= _ _ O
-10 _ _ O
= _ _ O
8 _ _ O
4 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
1 _ _ O
0 _ _ O
1 _ _ O
0 _ _ O
-16 _ _ O
8 _ _ O
4 _ _ O
2 _ _ O
1 _ _ O
1 _ _ O
0 _ _ O
1 _ _ O
1 _ _ O
0 _ _ O
+ _ _ O
 _ _ O
xi _ _ O
2 _ _ O
i=0 _ _ O
i=0 _ _ O
-16 _ _ O
w−2 _ _ O
8+2 _ _ O
= _ _ O
10 _ _ O
-16+4+2 _ _ O
= _ _ O
-10 _ _ O
i _ _ O

Unsigned _ _ O
& _ _ O
Signed _ _ O
Numeric _ _ O
Values _ _ O
X _ _ O
0000 _ _ O
0001 _ _ O
0010 _ _ O
0011 _ _ O
0100 _ _ O
0101 _ _ O
0110 _ _ O
0111 _ _ O
1000 _ _ O
1001 _ _ O
1010 _ _ O
1011 _ _ O
1100 _ _ O
1101 _ _ O
1110 _ _ O
1111 _ _ O
B2U _ _ O
( _ _ O
X _ _ O
) _ _ O
0 _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
5 _ _ O
6 _ _ O
7 _ _ O
8 _ _ O
9 _ _ O
10 _ _ O
11 _ _ O
12 _ _ O
13 _ _ O
14 _ _ O
15 _ _ O
B2T _ _ O
( _ _ O
X _ _ O
) _ _ O
0 _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
5 _ _ O
6 _ _ O
7 _ _ O
– _ _ O
8 _ _ O
– _ _ O
7 _ _ O
– _ _ O
6 _ _ O
– _ _ O
5 _ _ O
– _ _ O
4 _ _ O
– _ _ O
3 _ _ O
– _ _ O
2 _ _ O
– _ _ O
1 _ _ O
• _ _ O
Equivalence _ _ O
• _ _ O
Same _ _ O
encodings _ _ O
for _ _ O
nonnegative _ _ O
values _ _ O
• _ _ O
Uniqueness _ _ O
• _ _ O
Every _ _ O
bit _ _ O
pattern _ _ O
represents _ _ O
unique _ _ O
integer _ _ O
value _ _ O
• _ _ O
Each _ _ O
representable _ _ O
integer _ _ O
has _ _ O
unique _ _ O
bit _ _ O
encoding _ _ O
• _ _ O
Expression _ _ O
containing _ _ O
signed _ _ O
and _ _ O
unsigned _ _ O
int _ _ O
: _ _ O
int _ _ O
is _ _ O
cast _ _ O
to _ _ O
unsigned _ _ O

Important _ _ O
: _ _ O
Numeric _ _ O
Ranges _ _ O
• _ _ O
Unsigned _ _ O
Values _ _ O
• _ _ O
UMin _ _ O
= _ _ O
• _ _ O
Two _ _ O
’s _ _ O
Complement _ _ O
Values _ _ O
• _ _ O
TMin _ _ O
= _ _ O
– _ _ O
2w–1 _ _ O
0 _ _ O
• _ _ O
000…0 _ _ O
• _ _ O
UMax _ _ O
= _ _ O
• _ _ O
100…0 _ _ O
• _ _ O
TMax _ _ O
2w _ _ O
– _ _ O
1 _ _ O
• _ _ O
111…1 _ _ O
= _ _ O
• _ _ O
011…1 _ _ O
• _ _ O
Minus _ _ O
1 _ _ O
• _ _ O
111…1 _ _ O
Values _ _ O
for _ _ O
W _ _ O
= _ _ O
16 _ _ O
UMax _ _ O
TMax _ _ O
TMin _ _ O
-1 _ _ O
0 _ _ O
Decimal _ _ O
65535 _ _ O
32767 _ _ O
-32768 _ _ O
-1 _ _ O
0 _ _ O
Hex _ _ O
FF _ _ O
FF _ _ O
7F _ _ O
FF _ _ O
80 _ _ O
00 _ _ O
FF _ _ O
FF _ _ O
00 _ _ O
00 _ _ O
Binary _ _ O
11111111 _ _ O
11111111 _ _ O
01111111 _ _ O
11111111 _ _ O
10000000 _ _ O
00000000 _ _ O
11111111 _ _ O
11111111 _ _ O
00000000 _ _ O
00000000 _ _ O
2w–1 _ _ O
– _ _ O
1 _ _ O

Three _ _ O
“ _ _ O
kinds _ _ O
” _ _ O
of _ _ O
floating _ _ O
point _ _ O
numbers _ _ O
s _ _ O
exp _ _ O
1 _ _ O
00…00 _ _ O
denormalized _ _ O
frac _ _ O
e-bits _ _ O
f-bits _ _ O
exp _ _ O
≠ _ _ O
0 _ _ O
and _ _ O
exp _ _ O
≠ _ _ O
11…11 _ _ O
normalized _ _ O
11…11 _ _ O
special _ _ O

“ _ _ O
Normalized _ _ O
” _ _ O
Values _ _ O
• _ _ O
When _ _ O
: _ _ O
exp _ _ O
≠ _ _ O
000…0 _ _ O
and _ _ O
exp _ _ O
≠ _ _ O
111…1 _ _ O
• _ _ O
Exponent _ _ O
coded _ _ O
as _ _ O
a _ _ O
biased _ _ O
value _ _ O
: _ _ O
E _ _ O
= _ _ O
exp _ _ O
– _ _ O
Bias _ _ O
• _ _ O
exp _ _ O
: _ _ O
unsigned _ _ O
value _ _ O
of _ _ O
exp _ _ O
field _ _ O
• _ _ O
Bias _ _ O
= _ _ O
2k-1 _ _ O
- _ _ O
1 _ _ O
, _ _ O
where _ _ O
k _ _ O
is _ _ O
number _ _ O
of _ _ O
exponent _ _ O
bits _ _ O
• _ _ O
Single _ _ O
precision _ _ O
: _ _ O
127 _ _ O
( _ _ O
exp _ _ O
: _ _ O
1…254 _ _ O
, _ _ O
E _ _ O
: _ _ O
-126…127 _ _ O
) _ _ O
• _ _ O
Double _ _ O
precision _ _ O
: _ _ O
1023 _ _ O
( _ _ O
exp _ _ O
: _ _ O
1…2046 _ _ O
, _ _ O
E _ _ O
: _ _ O
-1022…1023 _ _ O
) _ _ O
• _ _ O
Significand _ _ O
coded _ _ O
with _ _ O
implied _ _ O
leading _ _ O
1 _ _ O
: _ _ O
M _ _ O
= _ _ O
1.xxx…x2 _ _ O
• _ _ O
xxx…x _ _ O
: _ _ O
bits _ _ O
of _ _ O
frac _ _ O
field _ _ O
• _ _ O
Minimum _ _ O
when _ _ O
frac=000…0 _ _ O
( _ _ O
M _ _ O
= _ _ O
1.0 _ _ O
) _ _ O
• _ _ O
Maximum _ _ O
when _ _ O
frac=111…1 _ _ O
( _ _ O
M _ _ O
= _ _ O
2.0 _ _ O
– _ _ O
ε _ _ O
) _ _ O
• _ _ O
Get _ _ O
extra _ _ O
leading _ _ O
bit _ _ O
for _ _ O
“ _ _ O
free _ _ O
” _ _ O
v _ _ O
= _ _ O
( _ _ O
– _ _ O
1 _ _ O
) _ _ O
s _ _ O
M _ _ O
2E _ _ O

Denormalized _ _ O
Values _ _ O
• _ _ O
Condition _ _ O
: _ _ O
exp _ _ O
= _ _ O
000…0 _ _ O
• _ _ O
Exponent _ _ O
value _ _ O
: _ _ O
E _ _ O
= _ _ O
1 _ _ O
– _ _ O
Bias _ _ O
( _ _ O
instead _ _ O
of _ _ O
exp _ _ O
– _ _ O
Bias _ _ O
) _ _ O
( _ _ O
why _ _ O
? _ _ O
) _ _ O
• _ _ O
Significand _ _ O
coded _ _ O
with _ _ O
implied _ _ O
leading _ _ O
0 _ _ O
: _ _ O
M _ _ O
= _ _ O
0.xxx…x2 _ _ O
• _ _ O
xxx…x _ _ O
: _ _ O
bits _ _ O
of _ _ O
frac _ _ O
• _ _ O
Cases _ _ O
• _ _ O
exp _ _ O
= _ _ O
000…0 _ _ O
, _ _ O
frac _ _ O
= _ _ O
000…0 _ _ O
• _ _ O
Represents _ _ O
zero _ _ O
value _ _ O
• _ _ O
Note _ _ O
distinct _ _ O
values _ _ O
: _ _ O
+0 _ _ O
and _ _ O
– _ _ O
0 _ _ O
( _ _ O
why _ _ O
? _ _ O
) _ _ O
• _ _ O
exp _ _ O
= _ _ O
000…0 _ _ O
, _ _ O
frac _ _ O
≠ _ _ O
000…0 _ _ O
• _ _ O
Numbers _ _ O
closest _ _ O
to _ _ O
0.0 _ _ O
• _ _ O
Equispaced _ _ O
v _ _ O
= _ _ O
( _ _ O
– _ _ O
1 _ _ O
) _ _ O
s _ _ O
M _ _ O
2E _ _ O
E _ _ O
= _ _ O
1 _ _ O
– _ _ O
Bias _ _ O

Special _ _ O
Values _ _ O
• _ _ O
Condition _ _ O
: _ _ O
exp _ _ O
= _ _ O
111…1 _ _ O
• _ _ O
Case _ _ O
: _ _ O
exp _ _ O
= _ _ O
111…1 _ _ O
, _ _ O
frac _ _ O
= _ _ O
000…0 _ _ O
• _ _ O
Represents _ _ O
value _ _ O
 _ _ O
( _ _ O
infinity _ _ O
) _ _ O
• _ _ O
Operation _ _ O
that _ _ O
overflows _ _ O
• _ _ O
Both _ _ O
positive _ _ O
and _ _ O
negative _ _ O
• _ _ O
E.g. _ _ O
, _ _ O
1.0 _ _ O
/ _ _ O
0.0 _ _ O
= _ _ O
−1.0 _ _ O
/ _ _ O
−0.0 _ _ O
= _ _ O
+ _ _ O
 _ _ O
, _ _ O
1.0 _ _ O
/ _ _ O
−0.0 _ _ O
= _ _ O
− _ _ O
• _ _ O
Case _ _ O
: _ _ O
exp _ _ O
= _ _ O
111…1 _ _ O
, _ _ O
frac _ _ O
≠ _ _ O
000…0 _ _ O
• _ _ O
Not-a-Number _ _ O
( _ _ O
NaN _ _ O
) _ _ O
• _ _ O
Represents _ _ O
case _ _ O
when _ _ O
no _ _ O
numeric _ _ O
value _ _ O
can _ _ O
be _ _ O
determined _ _ O
• _ _ O
E.g. _ _ O
, _ _ O
sqrt _ _ O
( _ _ O
–1 _ _ O
) _ _ O
, _ _ O
 _ _ O
− _ _ O
 _ _ O
, _ _ O
 _ _ O
 _ _ O
0 _ _ O

Casting _ _ O
floats _ _ O
to _ _ O
ints _ _ O
and _ _ O
vice _ _ O
versa _ _ O
• _ _ O
( _ _ O
int _ _ O
) _ _ O
floating_point_expression _ _ O
• _ _ O
Coerces _ _ O
and _ _ O
converts _ _ O
it _ _ O
to _ _ O
the _ _ O
nearest _ _ O
integer _ _ O
( _ _ O
C _ _ O
uses _ _ O
truncation _ _ O
) _ _ O
i _ _ O
= _ _ O
( _ _ O
int _ _ O
) _ _ O
( _ _ O
3.14159 _ _ O
* _ _ O
f _ _ O
) _ _ O
; _ _ O
• _ _ O
( _ _ O
float _ _ O
) _ _ O
integer_expression _ _ O
• _ _ O
Converts _ _ O
integer _ _ O
to _ _ O
nearest _ _ O
floating _ _ O
point _ _ O
f _ _ O
= _ _ O
f _ _ O
+ _ _ O
( _ _ O
float _ _ O
) _ _ O
i _ _ O
; _ _ O

float _ _ O
→ _ _ O
int _ _ O
→ _ _ O
float _ _ O
if _ _ O
( _ _ O
f _ _ O
= _ _ O
= _ _ O
( _ _ O
float _ _ O
) _ _ O
( _ _ O
( _ _ O
int _ _ O
) _ _ O
f _ _ O
) _ _ O
) _ _ O
{ _ _ O
printf _ _ O
( _ _ O
“true _ _ O
” _ _ O
) _ _ O
; _ _ O
} _ _ O
• _ _ O
Does _ _ O
it _ _ O
always _ _ O
print _ _ O
“ _ _ O
true _ _ O
” _ _ O
? _ _ O
• _ _ O
No _ _ O
, _ _ O
small _ _ O
floating _ _ O
point _ _ O
numbers _ _ O
( _ _ O
< _ _ O
1 _ _ O
) _ _ O
do _ _ O
n’t _ _ O
have _ _ O
integer _ _ O
representations _ _ O
• _ _ O
For _ _ O
other _ _ O
numbers _ _ O
, _ _ O
often _ _ O
will _ _ O
be _ _ O
rounding _ _ O
errors _ _ O

int _ _ O
→ _ _ O
float _ _ O
→ _ _ O
int _ _ O
if _ _ O
( _ _ O
i _ _ O
= _ _ O
= _ _ O
( _ _ O
int _ _ O
) _ _ O
( _ _ O
( _ _ O
float _ _ O
) _ _ O
i _ _ O
) _ _ O
) _ _ O
{ _ _ O
printf _ _ O
( _ _ O
“true _ _ O
” _ _ O
) _ _ O
; _ _ O
} _ _ O
• _ _ O
Does _ _ O
it _ _ O
always _ _ O
print _ _ O
“ _ _ O
true _ _ O
” _ _ O
? _ _ O
• _ _ O
No _ _ O
, _ _ O
many _ _ O
large _ _ O
values _ _ O
of _ _ O
integers _ _ O
do _ _ O
n’t _ _ O
have _ _ O
exact _ _ O
floating _ _ O
point _ _ O
representations _ _ O
• _ _ O
What _ _ O
about _ _ O
double _ _ O
? _ _ O
• _ _ O
Yes _ _ O
, _ _ O
significand _ _ O
is _ _ O
now _ _ O
52 _ _ O
bits _ _ O
, _ _ O
which _ _ O
can _ _ O
hold _ _ O
all _ _ O
of _ _ O
32-bit _ _ O
integer _ _ O
, _ _ O
so _ _ O
will _ _ O
always _ _ O
print _ _ O
“ _ _ O
true _ _ O
” _ _ O

Bitwise _ _ O
Operations _ _ O
• _ _ O
Write _ _ O
a _ _ O
C _ _ O
expression _ _ O
that _ _ O
will _ _ O
yield _ _ O
a _ _ O
word _ _ O
consisting _ _ O
of _ _ O
the _ _ O
least _ _ O
significant _ _ O
byte _ _ O
of _ _ O
x _ _ O
and _ _ O
the _ _ O
remaining _ _ O
bytes _ _ O
of _ _ O
y _ _ O
• _ _ O
For _ _ O
operands _ _ O
x _ _ O
= _ _ O
0x89ABCDEF _ _ O
and _ _ O
y _ _ O
= _ _ O
0x76543210 _ _ O
, _ _ O
this _ _ O
would _ _ O
give _ _ O
0x765432EF _ _ O
Hint _ _ O
: _ _ O
use _ _ O
masking _ _ O
and _ _ O
bit _ _ O
manipulation _ _ O
20 _ _ O

Bitwise _ _ O
Operations _ _ O
• _ _ O
Write _ _ O
a _ _ O
C _ _ O
expression _ _ O
that _ _ O
will _ _ O
yield _ _ O
a _ _ O
word _ _ O
consisting _ _ O
of _ _ O
the _ _ O
least _ _ O
significant _ _ O
byte _ _ O
of _ _ O
x _ _ O
and _ _ O
the _ _ O
remaining _ _ O
bytes _ _ O
of _ _ O
y _ _ O
• _ _ O
For _ _ O
operands _ _ O
x _ _ O
= _ _ O
0x89ABCDEF _ _ O
and _ _ O
y _ _ O
= _ _ O
0x76543210 _ _ O
, _ _ O
this _ _ O
would _ _ O
give _ _ O
0x765432EF _ _ O
1 _ _ O
) _ _ O
How _ _ O
to _ _ O
extract _ _ O
the _ _ O
upper _ _ O
3 _ _ O
bytes _ _ O
of _ _ O
x _ _ O
? _ _ O
( _ _ O
x _ _ O
& _ _ O
0xFF _ _ O
) _ _ O
2 _ _ O
) _ _ O
How _ _ O
to _ _ O
extract _ _ O
the _ _ O
lower _ _ O
1 _ _ O
byte _ _ O
of _ _ O
y _ _ O
? _ _ O
( _ _ O
y _ _ O
& _ _ O
~0xFF _ _ O
) _ _ O
3 _ _ O
) _ _ O
How _ _ O
to _ _ O
combine _ _ O
them _ _ O
? _ _ O
( _ _ O
x _ _ O
& _ _ O
0xFF _ _ O
) _ _ O
| _ _ O
( _ _ O
y _ _ O
& _ _ O
~0xFF _ _ O
) _ _ O
21 _ _ O

Bitwise _ _ O
Operations _ _ O
• _ _ O
How _ _ O
to _ _ O
perform _ _ O
the _ _ O
operation _ _ O
below _ _ O
using _ _ O
shifts _ _ O
/ _ _ O
adders _ _ O
only _ _ O
? _ _ O
a _ _ O
* _ _ O
7 _ _ O
( _ _ O
a _ _ O
< _ _ O
< _ _ O
3 _ _ O
) _ _ O
- _ _ O
a _ _ O
long _ _ O
m12 _ _ O
( _ _ O
long _ _ O
x _ _ O
) _ _ O
{ _ _ O
return _ _ O
x*12 _ _ O
; _ _ O
} _ _ O
Converted _ _ O
to _ _ O
x86 _ _ O
- _ _ O
64 _ _ O
by _ _ O
compiler _ _ O
: _ _ O
leaq _ _ O
( _ _ O
% _ _ O
rdi _ _ O
, _ _ O
%rdi _ _ O
, _ _ O
2 _ _ O
) _ _ O
, _ _ O
% _ _ O
rax _ _ O
salq _ _ O
$ _ _ O
2 _ _ O
, _ _ O
% _ _ O
rax _ _ O
# _ _ O
t _ _ O
= _ _ O
x+2*x _ _ O
# _ _ O
return _ _ O
t _ _ O
< _ _ O
< _ _ O
2 _ _ O
22 _ _ O

Bitwise _ _ O
Operations _ _ O
• _ _ O
Suppose _ _ O
we _ _ O
number _ _ O
the _ _ O
bytes _ _ O
in _ _ O
a _ _ O
w-bit _ _ O
word _ _ O
from _ _ O
0 _ _ O
( _ _ O
least _ _ O
significant _ _ O
) _ _ O
to _ _ O
w _ _ O
/ _ _ O
8 _ _ O
– _ _ O
1 _ _ O
( _ _ O
most _ _ O
significant _ _ O
) _ _ O
• _ _ O
Write _ _ O
code _ _ O
for _ _ O
the _ _ O
following _ _ O
C _ _ O
function _ _ O
, _ _ O
which _ _ O
will _ _ O
return _ _ O
an _ _ O
unsigned _ _ O
value _ _ O
in _ _ O
which _ _ O
byte _ _ O
i _ _ O
of _ _ O
argument _ _ O
x _ _ O
has _ _ O
been _ _ O
replaced _ _ O
by _ _ O
byte _ _ O
b _ _ O
: _ _ O
unsigned _ _ O
replace_byte _ _ O
( _ _ O
unsigned _ _ O
x _ _ O
, _ _ O
int _ _ O
i _ _ O
, _ _ O
unsigned _ _ O
char _ _ O
b _ _ O
) _ _ O
; _ _ O
replace_byte _ _ O
( _ _ O
0x12345678 _ _ O
, _ _ O
2 _ _ O
, _ _ O
0xAB _ _ O
) _ _ O
-- _ _ O
> _ _ O
0x12AB5678 _ _ O
replace_byte _ _ O
( _ _ O
0x12345678 _ _ O
, _ _ O
0 _ _ O
, _ _ O
0xAB _ _ O
) _ _ O
-- _ _ O
> _ _ O
0x123456AB _ _ O
23 _ _ O

Bitwise _ _ O
Operations _ _ O
• _ _ O
Write _ _ O
code _ _ O
for _ _ O
the _ _ O
following _ _ O
C _ _ O
function _ _ O
, _ _ O
which _ _ O
will _ _ O
return _ _ O
an _ _ O
unsigned _ _ O
value _ _ O
in _ _ O
which _ _ O
byte _ _ O
i _ _ O
of _ _ O
argument _ _ O
x _ _ O
has _ _ O
been _ _ O
replaced _ _ O
by _ _ O
byte _ _ O
b _ _ O
: _ _ O
unsigned _ _ O
replace_byte _ _ O
( _ _ O
unsigned _ _ O
x _ _ O
, _ _ O
int _ _ O
i _ _ O
, _ _ O
unsigned _ _ O
char _ _ O
b _ _ O
) _ _ O
{ _ _ O
int _ _ O
itimes8 _ _ O
= _ _ O
i _ _ O
< _ _ O
< _ _ O
3 _ _ O
; _ _ O
unsigned _ _ O
mask _ _ O
= _ _ O
0xFF _ _ O
< _ _ O
< _ _ O
itimes8 _ _ O
; _ _ O
return _ _ O
( _ _ O
x _ _ O
& _ _ O
~mask _ _ O
) _ _ O
| _ _ O
( _ _ O
b _ _ O
< _ _ O
< _ _ O
itimes8 _ _ O
) _ _ O
; _ _ O
} _ _ O
24 _ _ O

Byte _ _ O
Ordering _ _ O
• _ _ O
Example _ _ O
• _ _ O
Variable _ _ O
x _ _ O
has _ _ O
4-byte _ _ O
value _ _ O
of _ _ O
0x01234567 _ _ O
• _ _ O
Address _ _ O
given _ _ O
by _ _ O
& _ _ O
x _ _ O
is _ _ O
0x100 _ _ O
Big _ _ O
Endian _ _ O
0x100 _ _ O
0x101 _ _ O
0x102 _ _ O
0x103 _ _ O
01 _ _ O
01 _ _ O
Little _ _ O
Endian _ _ O
23 _ _ O
23 _ _ O
45 _ _ O
45 _ _ O
67 _ _ O
67 _ _ O
0x100 _ _ O
0x101 _ _ O
0x102 _ _ O
0x103 _ _ O
67 _ _ O
67 _ _ O
45 _ _ O
45 _ _ O
23 _ _ O
23 _ _ O
01 _ _ O
01 _ _ O

C _ _ O
Programming _ _ O

C _ _ O
Memory _ _ O
Layout _ _ O
Analysis _ _ O
s1 _ _ O
[ _ _ O
0 _ _ O
] _ _ O
→ _ _ O
? _ _ O
? _ _ O
s2 _ _ O
[ _ _ O
0 _ _ O
] _ _ O
→ _ _ O
? _ _ O
? _ _ O
27 _ _ O

C _ _ O
Programming _ _ O
• _ _ O
What _ _ O
is _ _ O
wrong _ _ O
with _ _ O
the _ _ O
C _ _ O
code _ _ O
below _ _ O
? _ _ O
int _ _ O
* _ _ O
pi _ _ O
= _ _ O
malloc _ _ O
( _ _ O
314*sizeof _ _ O
( _ _ O
int _ _ O
) _ _ O
) _ _ O
; _ _ O
if _ _ O
( _ _ O
! _ _ O
raspberry _ _ O
) _ _ O
{ _ _ O
pi _ _ O
= _ _ O
malloc _ _ O
( _ _ O
1 _ _ O
* _ _ O
sizeof _ _ O
( _ _ O
int _ _ O
) _ _ O
) _ _ O
; _ _ O
} _ _ O
return _ _ O
pi _ _ O
; _ _ O
There _ _ O
’s _ _ O
a _ _ O
memory _ _ O
leak _ _ O
if _ _ O
raspberry _ _ O
is _ _ O
false _ _ O
as _ _ O
the _ _ O
original _ _ O
value _ _ O
of _ _ O
pi _ _ O
will _ _ O
be _ _ O
unreachable _ _ O
28 _ _ O

C _ _ O
programming _ _ O
Consider _ _ O
the _ _ O
following _ _ O
code _ _ O
snippet _ _ O
which _ _ O
allocates _ _ O
an _ _ O
array _ _ O
and _ _ O
sets _ _ O
the _ _ O
values _ _ O
: _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
5 _ _ O
6 _ _ O
7 _ _ O
8 _ _ O
int _ _ O
main _ _ O
( _ _ O
int _ _ O
argc _ _ O
, _ _ O
char _ _ O
* _ _ O
* _ _ O
argv _ _ O
) _ _ O
{ _ _ O
int _ _ O
* _ _ O
a _ _ O
= _ _ O
( _ _ O
int _ _ O
* _ _ O
) _ _ O
malloc _ _ O
( _ _ O
213 _ _ O
* _ _ O
sizeof _ _ O
( _ _ O
int _ _ O
) _ _ O
) _ _ O
; _ _ O
for _ _ O
( _ _ O
int _ _ O
i=0 _ _ O
; _ _ O
i _ _ O
< _ _ O
213 _ _ O
; _ _ O
i++ _ _ O
) _ _ O
{ _ _ O
if _ _ O
( _ _ O
a _ _ O
[ _ _ O
i _ _ O
] _ _ O
= _ _ O
= _ _ O
0 _ _ O
) _ _ O
a _ _ O
[ _ _ O
i _ _ O
] _ _ O
=i _ _ O
; _ _ O
else _ _ O
a _ _ O
[ _ _ O
i _ _ O
] _ _ O
=-i _ _ O
; _ _ O
} _ _ O
return _ _ O
0 _ _ O
; _ _ O
} _ _ O
Which _ _ O
lines _ _ O
have _ _ O
a _ _ O
problem _ _ O
and _ _ O
how _ _ O
can _ _ O
you _ _ O
fix _ _ O
it _ _ O
? _ _ O

C _ _ O
programming _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
5 _ _ O
6 _ _ O
7 _ _ O
8 _ _ O
int _ _ O
main _ _ O
( _ _ O
int _ _ O
argc _ _ O
, _ _ O
char _ _ O
* _ _ O
* _ _ O
argv _ _ O
) _ _ O
{ _ _ O
int _ _ O
* _ _ O
a _ _ O
= _ _ O
( _ _ O
int _ _ O
* _ _ O
) _ _ O
malloc _ _ O
( _ _ O
213 _ _ O
* _ _ O
sizeof _ _ O
( _ _ O
int _ _ O
) _ _ O
) _ _ O
; _ _ O
if _ _ O
( _ _ O
a _ _ O
= _ _ O
= _ _ O
NULL _ _ O
) _ _ O
return _ _ O
0 _ _ O
; _ _ O
for _ _ O
( _ _ O
int _ _ O
i=0 _ _ O
; _ _ O
i _ _ O
< _ _ O
213 _ _ O
; _ _ O
i++ _ _ O
) _ _ O
{ _ _ O
if _ _ O
( _ _ O
a _ _ O
[ _ _ O
i _ _ O
] _ _ O
= _ _ O
= _ _ O
0 _ _ O
) _ _ O
a _ _ O
[ _ _ O
i _ _ O
] _ _ O
=i _ _ O
; _ _ O
else _ _ O
a _ _ O
[ _ _ O
i _ _ O
] _ _ O
=-i _ _ O
; _ _ O
} _ _ O
return _ _ O
0 _ _ O
; _ _ O
} _ _ O
malloc _ _ O
can _ _ O
fail _ _ O
! _ _ O

C _ _ O
programming _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
5 _ _ O
6 _ _ O
7 _ _ O
8 _ _ O
int _ _ O
main _ _ O
( _ _ O
int _ _ O
argc _ _ O
, _ _ O
char _ _ O
* _ _ O
* _ _ O
argv _ _ O
) _ _ O
{ _ _ O
int _ _ O
* _ _ O
a _ _ O
= _ _ O
( _ _ O
int _ _ O
* _ _ O
) _ _ O
calloc _ _ O
( _ _ O
213 _ _ O
, _ _ O
sizeof _ _ O
( _ _ O
int _ _ O
) _ _ O
) _ _ O
; _ _ O
if _ _ O
( _ _ O
a _ _ O
= _ _ O
= _ _ O
NULL _ _ O
) _ _ O
return _ _ O
0 _ _ O
; _ _ O
for _ _ O
( _ _ O
int _ _ O
i=0 _ _ O
; _ _ O
i _ _ O
< _ _ O
213 _ _ O
; _ _ O
i++ _ _ O
) _ _ O
{ _ _ O
if _ _ O
( _ _ O
a _ _ O
[ _ _ O
i _ _ O
] _ _ O
= _ _ O
= _ _ O
0 _ _ O
) _ _ O
a _ _ O
[ _ _ O
i _ _ O
] _ _ O
=i _ _ O
; _ _ O
else _ _ O
a _ _ O
[ _ _ O
i _ _ O
] _ _ O
=-i _ _ O
; _ _ O
} _ _ O
return _ _ O
0 _ _ O
; _ _ O
} _ _ O
Allocated _ _ O
memory _ _ O
is _ _ O
not _ _ O
initialized _ _ O
! _ _ O

C _ _ O
programming _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
5 _ _ O
6 _ _ O
7 _ _ O
8 _ _ O
int _ _ O
main _ _ O
( _ _ O
int _ _ O
argc _ _ O
, _ _ O
char _ _ O
* _ _ O
* _ _ O
argv _ _ O
) _ _ O
{ _ _ O
int _ _ O
* _ _ O
a _ _ O
= _ _ O
( _ _ O
int _ _ O
* _ _ O
) _ _ O
calloc _ _ O
( _ _ O
213 _ _ O
, _ _ O
sizeof _ _ O
( _ _ O
int _ _ O
) _ _ O
) _ _ O
; _ _ O
if _ _ O
( _ _ O
a _ _ O
= _ _ O
= _ _ O
NULL _ _ O
) _ _ O
return _ _ O
0 _ _ O
; _ _ O
for _ _ O
( _ _ O
int _ _ O
i=0 _ _ O
; _ _ O
i _ _ O
< _ _ O
213 _ _ O
; _ _ O
i++ _ _ O
) _ _ O
{ _ _ O
if _ _ O
( _ _ O
a _ _ O
[ _ _ O
i _ _ O
] _ _ O
= _ _ O
= _ _ O
0 _ _ O
) _ _ O
a _ _ O
[ _ _ O
i _ _ O
] _ _ O
=i _ _ O
; _ _ O
else _ _ O
a _ _ O
[ _ _ O
i _ _ O
] _ _ O
=-i _ _ O
; _ _ O
} _ _ O
free _ _ O
( _ _ O
a _ _ O
) _ _ O
; _ _ O
return _ _ O
0 _ _ O
; _ _ O
} _ _ O
All _ _ O
allocated _ _ O
memory _ _ O
must _ _ O
be _ _ O
freed _ _ O
! _ _ O

C _ _ O
programming _ _ O
What _ _ O
lines _ _ O
make _ _ O
safe_int_malloc _ _ O
not _ _ O
so _ _ O
safe _ _ O
? _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
5 _ _ O
int _ _ O
* _ _ O
safe_int_malloc _ _ O
( _ _ O
int _ _ O
* _ _ O
pointer _ _ O
) _ _ O
{ _ _ O
pointer _ _ O
= _ _ O
malloc _ _ O
( _ _ O
sizeof _ _ O
( _ _ O
int _ _ O
) _ _ O
) _ _ O
; _ _ O
if _ _ O
( _ _ O
pointer _ _ O
= _ _ O
= _ _ O
NULL _ _ O
) _ _ O
exit _ _ O
( _ _ O
-1 _ _ O
) _ _ O
; _ _ O
return _ _ O
& _ _ O
pointer _ _ O
; _ _ O
} _ _ O
pointer _ _ O
is _ _ O
a _ _ O
local _ _ O
copy _ _ O
of _ _ O
the _ _ O
pointer _ _ O
! _ _ O
Modifying _ _ O
* _ _ O
pointer _ _ O
only _ _ O
changes _ _ O
the _ _ O
value _ _ O
within _ _ O
the _ _ O
scope _ _ O
of _ _ O
this _ _ O
function _ _ O
not _ _ O
outside _ _ O

C _ _ O
programming _ _ O
Passing _ _ O
in _ _ O
an _ _ O
int _ _ O
* _ _ O
* _ _ O
let _ _ O
’s _ _ O
us _ _ O
change _ _ O
the _ _ O
value _ _ O
of _ _ O
int _ _ O
* _ _ O
pointer _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
5 _ _ O
int _ _ O
* _ _ O
safe_int_malloc _ _ O
( _ _ O
int _ _ O
* _ _ O
* _ _ O
pointer _ _ O
) _ _ O
{ _ _ O
* _ _ O
pointer _ _ O
= _ _ O
malloc _ _ O
( _ _ O
sizeof _ _ O
( _ _ O
int _ _ O
) _ _ O
) _ _ O
; _ _ O
if _ _ O
( _ _ O
pointer _ _ O
= _ _ O
= _ _ O
NULL _ _ O
) _ _ O
exit _ _ O
( _ _ O
-1 _ _ O
) _ _ O
; _ _ O
return _ _ O
& _ _ O
pointer _ _ O
; _ _ O
} _ _ O
What _ _ O
’s _ _ O
STILL _ _ O
wrong _ _ O
? _ _ O

C _ _ O
programming _ _ O
The _ _ O
address _ _ O
of _ _ O
something _ _ O
on _ _ O
the _ _ O
stack _ _ O
will _ _ O
be _ _ O
invalid _ _ O
after _ _ O
the _ _ O
function _ _ O
’s _ _ O
execution _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
5 _ _ O
int _ _ O
* _ _ O
safe_int_malloc _ _ O
( _ _ O
int _ _ O
* _ _ O
* _ _ O
pointer _ _ O
) _ _ O
{ _ _ O
* _ _ O
pointer _ _ O
= _ _ O
malloc _ _ O
( _ _ O
sizeof _ _ O
( _ _ O
int _ _ O
) _ _ O
) _ _ O
; _ _ O
if _ _ O
( _ _ O
pointer _ _ O
= _ _ O
= _ _ O
NULL _ _ O
) _ _ O
exit _ _ O
( _ _ O
-1 _ _ O
) _ _ O
; _ _ O
return _ _ O
& _ _ O
pointer _ _ O
; _ _ O
} _ _ O
& _ _ O
pointer _ _ O
is _ _ O
a _ _ O
location _ _ O
on _ _ O
the _ _ O
stack _ _ O
in _ _ O
safe_int_malloc _ _ O
’s _ _ O
frame _ _ O
! _ _ O

C _ _ O
programming _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
5 _ _ O
int _ _ O
* _ _ O
* _ _ O
safe_int_malloc _ _ O
( _ _ O
int _ _ O
* _ _ O
* _ _ O
pointer _ _ O
) _ _ O
{ _ _ O
* _ _ O
pointer _ _ O
= _ _ O
malloc _ _ O
( _ _ O
sizeof _ _ O
( _ _ O
int _ _ O
) _ _ O
) _ _ O
; _ _ O
if _ _ O
( _ _ O
pointer _ _ O
= _ _ O
= _ _ O
NULL _ _ O
) _ _ O
exit _ _ O
( _ _ O
-1 _ _ O
) _ _ O
; _ _ O
return _ _ O
pointer _ _ O
; _ _ O
} _ _ O

Pointers _ _ O
• _ _ O
Pointer _ _ O
: _ _ O
stores _ _ O
address _ _ O
of _ _ O
some _ _ O
value _ _ O
in _ _ O
memory _ _ O
• _ _ O
Example _ _ O
: _ _ O
• _ _ O
Let _ _ O
us _ _ O
have _ _ O
a _ _ O
pointer _ _ O
a _ _ O
where _ _ O
int _ _ O
* _ _ O
a _ _ O
= _ _ O
0x100 _ _ O
* _ _ O
a _ _ O
= _ _ O
accesses _ _ O
value _ _ O
stored _ _ O
at _ _ O
location _ _ O
0x100 _ _ O
a _ _ O
+ _ _ O
i _ _ O
= _ _ O
0x100 _ _ O
+ _ _ O
sizeof _ _ O
( _ _ O
*a _ _ O
) _ _ O
* _ _ O
i _ _ O
• _ _ O
Dereferencing _ _ O
a _ _ O
NULL _ _ O
pointer _ _ O
or _ _ O
any _ _ O
other _ _ O
invalid _ _ O
memory _ _ O
address _ _ O
causes _ _ O
segmentation _ _ O
fault _ _ O

x86 _ _ O
programming _ _ O

x86 _ _ O
- _ _ O
64 _ _ O
: _ _ O
Stack _ _ O
Manipulation _ _ O
We _ _ O
execute _ _ O
: _ _ O
mov _ _ O
$ _ _ O
0x449 _ _ O
, _ _ O
% _ _ O
rax _ _ O
pushq _ _ O
% _ _ O
rax _ _ O
For _ _ O
each _ _ O
of _ _ O
the _ _ O
following _ _ O
instructions _ _ O
, _ _ O
determine _ _ O
if _ _ O
they _ _ O
will _ _ O
result _ _ O
in _ _ O
the _ _ O
value _ _ O
0x449 _ _ O
being _ _ O
placed _ _ O
in _ _ O
% _ _ O
rcx _ _ O
? _ _ O
1 _ _ O
) _ _ O
mov _ _ O
( _ _ O
% _ _ O
rsp _ _ O
) _ _ O
, _ _ O
% _ _ O
rcx _ _ O
2 _ _ O
) _ _ O
mov _ _ O
0x8 _ _ O
( _ _ O
%rsp _ _ O
) _ _ O
, _ _ O
% _ _ O
rcx _ _ O
3 _ _ O
) _ _ O
mov _ _ O
% _ _ O
rsp _ _ O
, _ _ O
% _ _ O
rcx _ _ O
4 _ _ O
) _ _ O
popq _ _ O
% _ _ O
rcx _ _ O

x86 _ _ O
- _ _ O
64 _ _ O
: _ _ O
Stack _ _ O
is _ _ O
memory _ _ O
We _ _ O
execute _ _ O
: _ _ O
mov _ _ O
$ _ _ O
0x449 _ _ O
, _ _ O
% _ _ O
rax _ _ O
pushq _ _ O
% _ _ O
rax _ _ O
popq _ _ O
% _ _ O
rax _ _ O
If _ _ O
we _ _ O
now _ _ O
execute _ _ O
: _ _ O
mov _ _ O
-0x8 _ _ O
( _ _ O
%rsp _ _ O
) _ _ O
, _ _ O
% _ _ O
rcx _ _ O
what _ _ O
value _ _ O
is _ _ O
in _ _ O
% _ _ O
rcx _ _ O
? _ _ O
1 _ _ O
) _ _ O
0x0 _ _ O
/ _ _ O
NULL _ _ O
2 _ _ O
) _ _ O
Seg _ _ O
fault _ _ O
3 _ _ O
) _ _ O
Unknown _ _ O
4 _ _ O
) _ _ O
0x449 _ _ O

x86 _ _ O
- _ _ O
64 _ _ O
: _ _ O
Sometimes _ _ O
arguments _ _ O
are _ _ O
implicit _ _ O
* _ _ O
How _ _ O
many _ _ O
arguments _ _ O
does _ _ O
“ _ _ O
rsr _ _ O
” _ _ O
take _ _ O
? _ _ O
* _ _ O
How _ _ O
many _ _ O
registers _ _ O
are _ _ O
changed _ _ O
before _ _ O
the _ _ O
function _ _ O
call _ _ O
? _ _ O
( _ _ O
Note _ _ O
, _ _ O
% _ _ O
sil _ _ O
is _ _ O
the _ _ O
lower _ _ O
1 _ _ O
byte _ _ O
of _ _ O
% _ _ O
rsi _ _ O
) _ _ O
0x0400596 _ _ O
< _ _ O
+0 _ _ O
> _ _ O
: _ _ O
0x040059a _ _ O
< _ _ O
+4 _ _ O
> _ _ O
: _ _ O
0x040059c _ _ O
< _ _ O
+6 _ _ O
> _ _ O
: _ _ O
0x04005a0 _ _ O
< _ _ O
+10 _ _ O
> _ _ O
: _ _ O
0x04005a4 _ _ O
< _ _ O
+14 _ _ O
> _ _ O
: _ _ O
0x04005a9 _ _ O
< _ _ O
+19 _ _ O
> _ _ O
: _ _ O
0x04005ad _ _ O
< _ _ O
+23 _ _ O
> _ _ O
: _ _ O
0x04005ae _ _ O
< _ _ O
+24 _ _ O
> _ _ O
: _ _ O
0x04005b0 _ _ O
< _ _ O
+26 _ _ O
> _ _ O
: _ _ O
cmp _ _ O
je _ _ O
sub _ _ O
sub _ _ O
callq _ _ O
add _ _ O
retq _ _ O
mov _ _ O
retq _ _ O
% _ _ O
sil _ _ O
, _ _ O
( _ _ O
%rdi _ _ O
, _ _ O
%rdx _ _ O
, _ _ O
1 _ _ O
) _ _ O
0x4005ae _ _ O
< _ _ O
rsr+24 _ _ O
> _ _ O
$ _ _ O
0x8 _ _ O
, _ _ O
%rsp _ _ O
$ _ _ O
0x1 _ _ O
, _ _ O
%rdx _ _ O
0x400596 _ _ O
< _ _ O
rsr _ _ O
> _ _ O
$ _ _ O
0x8 _ _ O
, _ _ O
%rsp _ _ O
% _ _ O
edx _ _ O
, _ _ O
%eax _ _ O

x86 _ _ O
- _ _ O
64 _ _ O
: _ _ O
Arguments _ _ O
can _ _ O
already _ _ O
be _ _ O
“ _ _ O
correct _ _ O
” _ _ O
rsr _ _ O
does _ _ O
not _ _ O
modify _ _ O
s _ _ O
and _ _ O
t _ _ O
, _ _ O
so _ _ O
the _ _ O
arguments _ _ O
in _ _ O
those _ _ O
registers _ _ O
are _ _ O
always _ _ O
correct _ _ O
int _ _ O
rsr _ _ O
( _ _ O
char _ _ O
* _ _ O
s _ _ O
, _ _ O
char _ _ O
t _ _ O
, _ _ O
size_t _ _ O
pos _ _ O
) _ _ O
{ _ _ O
if _ _ O
( _ _ O
s _ _ O
[ _ _ O
pos _ _ O
] _ _ O
= _ _ O
= _ _ O
t _ _ O
) _ _ O
return _ _ O
pos _ _ O
; _ _ O
return _ _ O
rsr _ _ O
( _ _ O
s _ _ O
, _ _ O
t _ _ O
, _ _ O
pos _ _ O
- _ _ O
1 _ _ O
) _ _ O
; _ _ O
} _ _ O

Example _ _ O
: _ _ O
Reverse-engineer _ _ O
Assembly _ _ O
to _ _ O
C _ _ O
mystery _ _ O
( _ _ O
long _ _ O
, _ _ O
long _ _ O
, _ _ O
long _ _ O
) _ _ O
: _ _ O
leaq _ _ O
( _ _ O
% _ _ O
rdi _ _ O
, _ _ O
%rsi _ _ O
) _ _ O
, _ _ O
% _ _ O
rax _ _ O
addq _ _ O
% _ _ O
rdx _ _ O
, _ _ O
% _ _ O
rax _ _ O
cmpq _ _ O
$ _ _ O
3 _ _ O
, _ _ O
% _ _ O
rdi _ _ O
jg _ _ O
.L2 _ _ O
cmpq _ _ O
% _ _ O
rdx _ _ O
, _ _ O
% _ _ O
rsi _ _ O
jge _ _ O
.L3 _ _ O
movq _ _ O
% _ _ O
rdi _ _ O
, _ _ O
% _ _ O
rax _ _ O
imulq _ _ O
% _ _ O
rsi _ _ O
, _ _ O
% _ _ O
rax _ _ O
ret _ _ O
.L3 _ _ O
: _ _ O
movq _ _ O
% _ _ O
rsi _ _ O
, _ _ O
% _ _ O
rax _ _ O
imulq _ _ O
% _ _ O
rdx _ _ O
, _ _ O
% _ _ O
rax _ _ O
ret _ _ O
.L2 _ _ O
: _ _ O
cmpq _ _ O
$ _ _ O
10 _ _ O
, _ _ O
% _ _ O
rdi _ _ O
jle _ _ O
.L1 _ _ O
movq _ _ O
% _ _ O
rdi _ _ O
, _ _ O
% _ _ O
rax _ _ O
imulq _ _ O
% _ _ O
rdx _ _ O
, _ _ O
% _ _ O
rax _ _ O
.L1 _ _ O
: _ _ O
ret _ _ O
long _ _ O
mystery _ _ O
( _ _ O
long _ _ O
x _ _ O
, _ _ O
long _ _ O
y _ _ O
, _ _ O
long _ _ O
z _ _ O
) _ _ O
{ _ _ O
long _ _ O
val _ _ O
= _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
; _ _ O
if _ _ O
( _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
) _ _ O
{ _ _ O
if _ _ O
( _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
) _ _ O
{ _ _ O
val _ _ O
= _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
; _ _ O
} _ _ O
else _ _ O
{ _ _ O
val _ _ O
= _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
; _ _ O
} _ _ O
} _ _ O
else _ _ O
if _ _ O
( _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
) _ _ O
{ _ _ O
val _ _ O
= _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
; _ _ O
} _ _ O
return _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
_ _ _ O
; _ _ O
} _ _ O
43 _ _ O

Example _ _ O
: _ _ O
increment _ _ O
long _ _ O
increment _ _ O
( _ _ O
long _ _ O
* _ _ O
p _ _ O
, _ _ O
long _ _ O
val _ _ O
) _ _ O
{ _ _ O
long _ _ O
x _ _ O
= _ _ O
* _ _ O
p _ _ O
; _ _ O
long _ _ O
y _ _ O
= _ _ O
x _ _ O
+ _ _ O
val _ _ O
; _ _ O
* _ _ O
p _ _ O
= _ _ O
y _ _ O
; _ _ O
return _ _ O
x _ _ O
; _ _ O
} _ _ O
increment _ _ O
: _ _ O
movq _ _ O
( _ _ O
% _ _ O
rdi _ _ O
) _ _ O
, _ _ O
% _ _ O
rax _ _ O
addq _ _ O
% _ _ O
rax _ _ O
, _ _ O
% _ _ O
rsi _ _ O
movq _ _ O
% _ _ O
rsi _ _ O
, _ _ O
( _ _ O
% _ _ O
rdi _ _ O
) _ _ O
ret _ _ O
44 _ _ O
Register _ _ O
Use _ _ O
( _ _ O
s _ _ O
) _ _ O
% _ _ O
rdi _ _ O
1st _ _ O
arg _ _ O
( _ _ O
p _ _ O
) _ _ O
% _ _ O
rsi _ _ O
2nd _ _ O
arg _ _ O
( _ _ O
val _ _ O
) _ _ O
, _ _ O
y _ _ O
% _ _ O
rax _ _ O
x _ _ O
, _ _ O
return _ _ O
value _ _ O

Procedure _ _ O
Call _ _ O
Example _ _ O
( _ _ O
initial _ _ O
state _ _ O
) _ _ O
long _ _ O
call_incr _ _ O
( _ _ O
) _ _ O
{ _ _ O
long _ _ O
v1 _ _ O
= _ _ O
449 _ _ O
; _ _ O
long _ _ O
v2 _ _ O
= _ _ O
increment _ _ O
( _ _ O
& _ _ O
v1 _ _ O
, _ _ O
100 _ _ O
) _ _ O
; _ _ O
return _ _ O
v1 _ _ O
+ _ _ O
v2 _ _ O
; _ _ O
} _ _ O
Initial _ _ O
Stack _ _ O
Structure _ _ O
••• _ _ O
Return _ _ O
addr _ _ O
< _ _ O
main+8 _ _ O
> _ _ O
call_incr _ _ O
: _ _ O
subq _ _ O
$ _ _ O
16 _ _ O
, _ _ O
% _ _ O
rsp _ _ O
movq _ _ O
$ _ _ O
449 _ _ O
, _ _ O
8 _ _ O
( _ _ O
%rsp _ _ O
) _ _ O
movl _ _ O
$ _ _ O
100 _ _ O
, _ _ O
% _ _ O
esi _ _ O
leaq _ _ O
8 _ _ O
( _ _ O
%rsp _ _ O
) _ _ O
, _ _ O
% _ _ O
rdi _ _ O
call _ _ O
increment _ _ O
addq _ _ O
8 _ _ O
( _ _ O
%rsp _ _ O
) _ _ O
, _ _ O
% _ _ O
rax _ _ O
addq _ _ O
$ _ _ O
16 _ _ O
, _ _ O
% _ _ O
rsp _ _ O
ret _ _ O
⟵%rsp _ _ O
• _ _ O
Return _ _ O
address _ _ O
on _ _ O
stack _ _ O
is _ _ O
the _ _ O
address _ _ O
of _ _ O
instruction _ _ O
immediately _ _ O
following _ _ O
the _ _ O
call _ _ O
to _ _ O
“ _ _ O
call_incr _ _ O
” _ _ O
• _ _ O
Shown _ _ O
here _ _ O
as _ _ O
main _ _ O
, _ _ O
but _ _ O
could _ _ O
be _ _ O
anything _ _ O
) _ _ O
• _ _ O
Pushed _ _ O
onto _ _ O
stack _ _ O
by _ _ O
call _ _ O
call_incr _ _ O

Procedure _ _ O
Call _ _ O
Example _ _ O
( _ _ O
step _ _ O
1 _ _ O
) _ _ O
Stack _ _ O
Structure _ _ O
long _ _ O
call_incr _ _ O
( _ _ O
) _ _ O
{ _ _ O
long _ _ O
v1 _ _ O
= _ _ O
449 _ _ O
; _ _ O
long _ _ O
v2 _ _ O
= _ _ O
increment _ _ O
( _ _ O
& _ _ O
v1 _ _ O
, _ _ O
100 _ _ O
) _ _ O
; _ _ O
return _ _ O
v1 _ _ O
+ _ _ O
v2 _ _ O
; _ _ O
} _ _ O
••• _ _ O
Return _ _ O
addr _ _ O
< _ _ O
main+8 _ _ O
> _ _ O
call_incr _ _ O
: _ _ O
subq _ _ O
$ _ _ O
16 _ _ O
, _ _ O
% _ _ O
rsp _ _ O
movq _ _ O
$ _ _ O
449 _ _ O
, _ _ O
8 _ _ O
( _ _ O
%rsp _ _ O
) _ _ O
movl _ _ O
$ _ _ O
100 _ _ O
, _ _ O
% _ _ O
esi _ _ O
leaq _ _ O
8 _ _ O
( _ _ O
%rsp _ _ O
) _ _ O
, _ _ O
% _ _ O
rdi _ _ O
call _ _ O
increment _ _ O
addq _ _ O
8 _ _ O
( _ _ O
%rsp _ _ O
) _ _ O
, _ _ O
% _ _ O
rax _ _ O
addq _ _ O
$ _ _ O
16 _ _ O
, _ _ O
% _ _ O
rsp _ _ O
ret _ _ O
Allocate _ _ O
space _ _ O
for _ _ O
local _ _ O
vars _ _ O
449 _ _ O
Unused _ _ O
⟵old _ _ O
% _ _ O
rsp _ _ O
⟵%rsp+8 _ _ O
⟵%rsp _ _ O
• _ _ O
Setup _ _ O
space _ _ O
for _ _ O
local _ _ O
variables _ _ O
• _ _ O
Only _ _ O
v1 _ _ O
needs _ _ O
space _ _ O
on _ _ O
the _ _ O
stack _ _ O
• _ _ O
Compiler _ _ O
allocated _ _ O
extra _ _ O
space _ _ O
• _ _ O
Often _ _ O
does _ _ O
this _ _ O
for _ _ O
a _ _ O
variety _ _ O
of _ _ O
reasons _ _ O
, _ _ O
including _ _ O
alignment _ _ O

Procedure _ _ O
Call _ _ O
Example _ _ O
( _ _ O
step _ _ O
2 _ _ O
) _ _ O
long _ _ O
call_incr _ _ O
( _ _ O
) _ _ O
{ _ _ O
long _ _ O
v1 _ _ O
= _ _ O
449 _ _ O
; _ _ O
long _ _ O
v2 _ _ O
= _ _ O
increment _ _ O
( _ _ O
& _ _ O
v1 _ _ O
, _ _ O
100 _ _ O
) _ _ O
; _ _ O
return _ _ O
v1 _ _ O
+ _ _ O
v2 _ _ O
; _ _ O
} _ _ O
Stack _ _ O
Structure _ _ O
••• _ _ O
Return _ _ O
addr _ _ O
< _ _ O
main+8 _ _ O
> _ _ O
call_incr _ _ O
: _ _ O
subq _ _ O
$ _ _ O
16 _ _ O
, _ _ O
% _ _ O
rsp _ _ O
movq _ _ O
$ _ _ O
449 _ _ O
, _ _ O
8 _ _ O
( _ _ O
%rsp _ _ O
) _ _ O
movl _ _ O
$ _ _ O
100 _ _ O
, _ _ O
% _ _ O
esi _ _ O
leaq _ _ O
8 _ _ O
( _ _ O
%rsp _ _ O
) _ _ O
, _ _ O
% _ _ O
rdi _ _ O
call _ _ O
increment _ _ O
addq _ _ O
8 _ _ O
( _ _ O
%rsp _ _ O
) _ _ O
, _ _ O
% _ _ O
rax _ _ O
addq _ _ O
$ _ _ O
16 _ _ O
, _ _ O
% _ _ O
rsp _ _ O
ret _ _ O
449 _ _ O
Unused _ _ O
Set _ _ O
up _ _ O
parameters _ _ O
for _ _ O
call _ _ O
to _ _ O
increment _ _ O
Aside _ _ O
: _ _ O
movl _ _ O
is _ _ O
used _ _ O
because _ _ O
100 _ _ O
is _ _ O
a _ _ O
small _ _ O
positive _ _ O
value _ _ O
that _ _ O
fits _ _ O
in _ _ O
32 _ _ O
bits _ _ O
. _ _ O
High _ _ O
order _ _ O
bits _ _ O
of _ _ O
rsi _ _ O
get _ _ O
set _ _ O
to _ _ O
zero _ _ O
automatically _ _ O
. _ _ O
It _ _ O
takes _ _ O
one _ _ O
less _ _ O
byte _ _ O
to _ _ O
encode _ _ O
a _ _ O
movl _ _ O
than _ _ O
a _ _ O
movq _ _ O
. _ _ O
⟵%rsp+8 _ _ O
⟵%rsp _ _ O
Register _ _ O
Use _ _ O
( _ _ O
s _ _ O
) _ _ O
% _ _ O
rdi _ _ O
& _ _ O
v1 _ _ O
% _ _ O
rsi _ _ O
100 _ _ O

Procedure _ _ O
Call _ _ O
Example _ _ O
( _ _ O
step _ _ O
3 _ _ O
) _ _ O
long _ _ O
call_incr _ _ O
( _ _ O
) _ _ O
{ _ _ O
long _ _ O
v1 _ _ O
= _ _ O
449 _ _ O
; _ _ O
long _ _ O
v2 _ _ O
= _ _ O
increment _ _ O
( _ _ O
& _ _ O
v1 _ _ O
, _ _ O
100 _ _ O
) _ _ O
; _ _ O
return _ _ O
v1 _ _ O
+ _ _ O
v2 _ _ O
; _ _ O
} _ _ O
Stack _ _ O
Structure _ _ O
••• _ _ O
Return _ _ O
addr _ _ O
< _ _ O
main+8 _ _ O
> _ _ O
call_incr _ _ O
: _ _ O
subq _ _ O
$ _ _ O
16 _ _ O
, _ _ O
% _ _ O
rsp _ _ O
movq _ _ O
$ _ _ O
449 _ _ O
, _ _ O
8 _ _ O
( _ _ O
%rsp _ _ O
) _ _ O
movl _ _ O
$ _ _ O
100 _ _ O
, _ _ O
% _ _ O
esi _ _ O
leaq _ _ O
8 _ _ O
( _ _ O
%rsp _ _ O
) _ _ O
, _ _ O
% _ _ O
rdi _ _ O
call _ _ O
increment _ _ O
addq _ _ O
8 _ _ O
( _ _ O
%rsp _ _ O
) _ _ O
, _ _ O
% _ _ O
rax _ _ O
addq _ _ O
$ _ _ O
16 _ _ O
, _ _ O
% _ _ O
rsp _ _ O
ret _ _ O
increment _ _ O
: _ _ O
movq _ _ O
( _ _ O
% _ _ O
rdi _ _ O
) _ _ O
, _ _ O
% _ _ O
rax _ _ O
addq _ _ O
% _ _ O
rax _ _ O
, _ _ O
% _ _ O
rsi _ _ O
movq _ _ O
% _ _ O
rsi _ _ O
, _ _ O
( _ _ O
% _ _ O
rdi _ _ O
) _ _ O
ret _ _ O
449 _ _ O
Unused _ _ O
Return _ _ O
addr _ _ O
< _ _ O
call_incr+ _ _ O
? _ _ O
> _ _ O
• _ _ O
State _ _ O
while _ _ O
inside _ _ O
increment _ _ O
⟵%rsp _ _ O
• _ _ O
Return _ _ O
address _ _ O
on _ _ O
top _ _ O
of _ _ O
stack _ _ O
is _ _ O
address _ _ O
of _ _ O
the _ _ O
addq _ _ O
instruction _ _ O
immediately _ _ O
following _ _ O
call _ _ O
to _ _ O
increment _ _ O
Register _ _ O
Use _ _ O
( _ _ O
s _ _ O
) _ _ O
% _ _ O
rdi _ _ O
& _ _ O
v1 _ _ O
% _ _ O
rsi _ _ O
100 _ _ O
% _ _ O
rax _ _ O
48 _ _ O

Procedure _ _ O
Call _ _ O
Example _ _ O
( _ _ O
step _ _ O
4 _ _ O
) _ _ O
Stack _ _ O
Structure _ _ O
long _ _ O
call_incr _ _ O
( _ _ O
) _ _ O
{ _ _ O
long _ _ O
v1 _ _ O
= _ _ O
449 _ _ O
; _ _ O
long _ _ O
v2 _ _ O
= _ _ O
increment _ _ O
( _ _ O
& _ _ O
v1 _ _ O
, _ _ O
100 _ _ O
) _ _ O
; _ _ O
return _ _ O
v1 _ _ O
+ _ _ O
v2 _ _ O
; _ _ O
} _ _ O
••• _ _ O
Return _ _ O
addr _ _ O
< _ _ O
main+8 _ _ O
> _ _ O
call_incr _ _ O
: _ _ O
subq _ _ O
$ _ _ O
16 _ _ O
, _ _ O
% _ _ O
rsp _ _ O
movq _ _ O
$ _ _ O
449 _ _ O
, _ _ O
8 _ _ O
( _ _ O
%rsp _ _ O
) _ _ O
movl _ _ O
$ _ _ O
100 _ _ O
, _ _ O
% _ _ O
esi _ _ O
leaq _ _ O
8 _ _ O
( _ _ O
%rsp _ _ O
) _ _ O
, _ _ O
% _ _ O
rdi _ _ O
call _ _ O
increment _ _ O
addq _ _ O
8 _ _ O
( _ _ O
%rsp _ _ O
) _ _ O
, _ _ O
% _ _ O
rax _ _ O
addq _ _ O
$ _ _ O
16 _ _ O
, _ _ O
% _ _ O
rsp _ _ O
ret _ _ O
549 _ _ O
Unused _ _ O
Return _ _ O
addr _ _ O
< _ _ O
call_incr+ _ _ O
? _ _ O
> _ _ O
⟵%rsp _ _ O
• _ _ O
State _ _ O
while _ _ O
inside _ _ O
increment _ _ O
• _ _ O
After _ _ O
code _ _ O
in _ _ O
body _ _ O
has _ _ O
been _ _ O
executed _ _ O
increment _ _ O
: _ _ O
movq _ _ O
( _ _ O
% _ _ O
rdi _ _ O
) _ _ O
, _ _ O
% _ _ O
rax _ _ O
# _ _ O
x _ _ O
= _ _ O
* _ _ O
p _ _ O
addq _ _ O
% _ _ O
rax _ _ O
, _ _ O
% _ _ O
rsi _ _ O
# _ _ O
y _ _ O
= _ _ O
x _ _ O
+ _ _ O
100 _ _ O
movq _ _ O
% _ _ O
rsi _ _ O
, _ _ O
( _ _ O
% _ _ O
rdi _ _ O
) _ _ O
# _ _ O
* _ _ O
p _ _ O
= _ _ O
y _ _ O
ret _ _ O
Register _ _ O
Use _ _ O
( _ _ O
s _ _ O
) _ _ O
% _ _ O
rdi _ _ O
& _ _ O
v1 _ _ O
% _ _ O
rsi _ _ O
549 _ _ O
% _ _ O
rax _ _ O
449 _ _ O
49 _ _ O

Procedure _ _ O
Call _ _ O
Example _ _ O
( _ _ O
step _ _ O
5 _ _ O
) _ _ O
long _ _ O
call_incr _ _ O
( _ _ O
) _ _ O
{ _ _ O
long _ _ O
v1 _ _ O
= _ _ O
449 _ _ O
; _ _ O
long _ _ O
v2 _ _ O
= _ _ O
increment _ _ O
( _ _ O
& _ _ O
v1 _ _ O
, _ _ O
100 _ _ O
) _ _ O
; _ _ O
return _ _ O
v1 _ _ O
+ _ _ O
v2 _ _ O
; _ _ O
} _ _ O
Stack _ _ O
Structure _ _ O
••• _ _ O
Return _ _ O
addr _ _ O
< _ _ O
main+8 _ _ O
> _ _ O
call_incr _ _ O
: _ _ O
subq _ _ O
$ _ _ O
16 _ _ O
, _ _ O
% _ _ O
rsp _ _ O
movq _ _ O
$ _ _ O
449 _ _ O
, _ _ O
8 _ _ O
( _ _ O
%rsp _ _ O
) _ _ O
movl _ _ O
$ _ _ O
100 _ _ O
, _ _ O
% _ _ O
esi _ _ O
leaq _ _ O
8 _ _ O
( _ _ O
%rsp _ _ O
) _ _ O
, _ _ O
% _ _ O
rdi _ _ O
call _ _ O
increment _ _ O
addq _ _ O
8 _ _ O
( _ _ O
%rsp _ _ O
) _ _ O
, _ _ O
% _ _ O
rax _ _ O
addq _ _ O
$ _ _ O
16 _ _ O
, _ _ O
% _ _ O
rsp _ _ O
ret _ _ O
549 _ _ O
⟵%rsp+8 _ _ O
Unused _ _ O
⟵%rsp _ _ O
• _ _ O
After _ _ O
returning _ _ O
from _ _ O
call _ _ O
to _ _ O
increment _ _ O
• _ _ O
Registers _ _ O
and _ _ O
memory _ _ O
have _ _ O
been _ _ O
modified _ _ O
and _ _ O
return _ _ O
address _ _ O
has _ _ O
been _ _ O
popped _ _ O
off _ _ O
stack _ _ O
Register _ _ O
Use _ _ O
( _ _ O
s _ _ O
) _ _ O
% _ _ O
rdi _ _ O
& _ _ O
v1 _ _ O
% _ _ O
rsi _ _ O
549 _ _ O
% _ _ O
rax _ _ O
449 _ _ O

Procedure _ _ O
Call _ _ O
Example _ _ O
( _ _ O
step _ _ O
6 _ _ O
) _ _ O
long _ _ O
call_incr _ _ O
( _ _ O
) _ _ O
{ _ _ O
long _ _ O
v1 _ _ O
= _ _ O
449 _ _ O
; _ _ O
long _ _ O
v2 _ _ O
= _ _ O
increment _ _ O
( _ _ O
& _ _ O
v1 _ _ O
, _ _ O
100 _ _ O
) _ _ O
; _ _ O
return _ _ O
v1 _ _ O
+ _ _ O
v2 _ _ O
; _ _ O
} _ _ O
Stack _ _ O
Structure _ _ O
••• _ _ O
Return _ _ O
addr _ _ O
< _ _ O
main+8 _ _ O
> _ _ O
call_incr _ _ O
: _ _ O
subq _ _ O
$ _ _ O
16 _ _ O
, _ _ O
% _ _ O
rsp _ _ O
movq _ _ O
$ _ _ O
449 _ _ O
, _ _ O
8 _ _ O
( _ _ O
%rsp _ _ O
) _ _ O
movl _ _ O
$ _ _ O
100 _ _ O
, _ _ O
% _ _ O
esi _ _ O
leaq _ _ O
8 _ _ O
( _ _ O
%rsp _ _ O
) _ _ O
, _ _ O
% _ _ O
rdi _ _ O
call _ _ O
increment _ _ O
addq _ _ O
8 _ _ O
( _ _ O
%rsp _ _ O
) _ _ O
, _ _ O
% _ _ O
rax _ _ O
addq _ _ O
$ _ _ O
16 _ _ O
, _ _ O
% _ _ O
rsp _ _ O
ret _ _ O
549 _ _ O
⟵%rsp+8 _ _ O
Unused _ _ O
⟵%rsp _ _ O
Update _ _ O
% _ _ O
rax _ _ O
to _ _ O
contain _ _ O
v1+v2 _ _ O
Register _ _ O
Use _ _ O
( _ _ O
s _ _ O
) _ _ O
% _ _ O
rdi _ _ O
& _ _ O
v1 _ _ O
% _ _ O
rsi _ _ O
549 _ _ O
% _ _ O
rax _ _ O
549+449 _ _ O

Procedure _ _ O
Call _ _ O
Example _ _ O
( _ _ O
step _ _ O
7 _ _ O
) _ _ O
long _ _ O
call_incr _ _ O
( _ _ O
) _ _ O
{ _ _ O
long _ _ O
v1 _ _ O
= _ _ O
449 _ _ O
; _ _ O
long _ _ O
v2 _ _ O
= _ _ O
increment _ _ O
( _ _ O
& _ _ O
v1 _ _ O
, _ _ O
100 _ _ O
) _ _ O
; _ _ O
return _ _ O
v1 _ _ O
+ _ _ O
v2 _ _ O
; _ _ O
} _ _ O
Stack _ _ O
Structure _ _ O
••• _ _ O
Return _ _ O
addr _ _ O
< _ _ O
main+8 _ _ O
> _ _ O
call_incr _ _ O
: _ _ O
subq _ _ O
$ _ _ O
16 _ _ O
, _ _ O
% _ _ O
rsp _ _ O
movq _ _ O
$ _ _ O
449 _ _ O
, _ _ O
8 _ _ O
( _ _ O
%rsp _ _ O
) _ _ O
movl _ _ O
$ _ _ O
100 _ _ O
, _ _ O
% _ _ O
esi _ _ O
leaq _ _ O
8 _ _ O
( _ _ O
%rsp _ _ O
) _ _ O
, _ _ O
% _ _ O
rdi _ _ O
call _ _ O
increment _ _ O
addq _ _ O
8 _ _ O
( _ _ O
%rsp _ _ O
) _ _ O
, _ _ O
% _ _ O
rax _ _ O
addq _ _ O
$ _ _ O
16 _ _ O
, _ _ O
% _ _ O
rsp _ _ O
ret _ _ O
549 _ _ O
Unused _ _ O
⟵%rsp _ _ O
⟵old _ _ O
% _ _ O
rsp _ _ O
De-allocate _ _ O
space _ _ O
for _ _ O
local _ _ O
vars _ _ O
Register _ _ O
Use _ _ O
( _ _ O
s _ _ O
) _ _ O
% _ _ O
rdi _ _ O
& _ _ O
v1 _ _ O
% _ _ O
rsi _ _ O
549 _ _ O
% _ _ O
rax _ _ O
998 _ _ O

Procedure _ _ O
Call _ _ O
Example _ _ O
( _ _ O
step _ _ O
8) _ _ O
long _ _ O
call_incr _ _ O
( _ _ O
) _ _ O
{ _ _ O
long _ _ O
v1 _ _ O
= _ _ O
449 _ _ O
; _ _ O
long _ _ O
v2 _ _ O
= _ _ O
increment _ _ O
( _ _ O
& _ _ O
v1 _ _ O
, _ _ O
100 _ _ O
) _ _ O
; _ _ O
return _ _ O
v1 _ _ O
+ _ _ O
v2 _ _ O
; _ _ O
} _ _ O
call_incr _ _ O
: _ _ O
subq _ _ O
$ _ _ O
16 _ _ O
, _ _ O
% _ _ O
rsp _ _ O
movq _ _ O
$ _ _ O
449 _ _ O
, _ _ O
8 _ _ O
( _ _ O
%rsp _ _ O
) _ _ O
movl _ _ O
$ _ _ O
100 _ _ O
, _ _ O
% _ _ O
esi _ _ O
leaq _ _ O
8 _ _ O
( _ _ O
%rsp _ _ O
) _ _ O
, _ _ O
% _ _ O
rdi _ _ O
call _ _ O
increment _ _ O
addq _ _ O
8 _ _ O
( _ _ O
%rsp _ _ O
) _ _ O
, _ _ O
% _ _ O
rax _ _ O
addq _ _ O
$ _ _ O
16 _ _ O
, _ _ O
% _ _ O
rsp _ _ O
ret _ _ O
Stack _ _ O
Structure _ _ O
••• _ _ O
Return _ _ O
addr _ _ O
< _ _ O
main+8 _ _ O
> _ _ O
⟵%rsp _ _ O
• _ _ O
State _ _ O
just _ _ O
before _ _ O
returning _ _ O
from _ _ O
call _ _ O
to _ _ O
call_incr _ _ O
Register _ _ O
Use _ _ O
( _ _ O
s _ _ O
) _ _ O
% _ _ O
rdi _ _ O
& _ _ O
v1 _ _ O
% _ _ O
rsi _ _ O
549 _ _ O
% _ _ O
rax _ _ O
998 _ _ O

Procedure _ _ O
Call _ _ O
Example _ _ O
( _ _ O
step _ _ O
9 _ _ O
) _ _ O
long _ _ O
call_incr _ _ O
( _ _ O
) _ _ O
{ _ _ O
long _ _ O
v1 _ _ O
= _ _ O
449 _ _ O
; _ _ O
long _ _ O
v2 _ _ O
= _ _ O
increment _ _ O
( _ _ O
& _ _ O
v1 _ _ O
, _ _ O
100 _ _ O
) _ _ O
; _ _ O
return _ _ O
v1 _ _ O
+ _ _ O
v2 _ _ O
; _ _ O
} _ _ O
call_incr _ _ O
: _ _ O
subq _ _ O
$ _ _ O
16 _ _ O
, _ _ O
% _ _ O
rsp _ _ O
movq _ _ O
$ _ _ O
449 _ _ O
, _ _ O
8 _ _ O
( _ _ O
%rsp _ _ O
) _ _ O
movl _ _ O
$ _ _ O
100 _ _ O
, _ _ O
% _ _ O
esi _ _ O
leaq _ _ O
8 _ _ O
( _ _ O
%rsp _ _ O
) _ _ O
, _ _ O
% _ _ O
rdi _ _ O
call _ _ O
increment _ _ O
addq _ _ O
8 _ _ O
( _ _ O
%rsp _ _ O
) _ _ O
, _ _ O
% _ _ O
rax _ _ O
addq _ _ O
$ _ _ O
16 _ _ O
, _ _ O
% _ _ O
rsp _ _ O
ret _ _ O
Final _ _ O
Stack _ _ O
Structure _ _ O
••• _ _ O
⟵%rsp _ _ O
• _ _ O
State _ _ O
immediately _ _ O
after _ _ O
returning _ _ O
from _ _ O
call _ _ O
to _ _ O
call_incr _ _ O
• _ _ O
Return _ _ O
addr _ _ O
has _ _ O
been _ _ O
popped _ _ O
off _ _ O
stack _ _ O
• _ _ O
Control _ _ O
has _ _ O
returned _ _ O
to _ _ O
the _ _ O
instruction _ _ O
immediately _ _ O
following _ _ O
the _ _ O
call _ _ O
to _ _ O
call_incr _ _ O
( _ _ O
not _ _ O
shown _ _ O
here _ _ O
) _ _ O
Register _ _ O
Use _ _ O
( _ _ O
s _ _ O
) _ _ O
% _ _ O
rdi _ _ O
& _ _ O
v1 _ _ O
% _ _ O
rsi _ _ O
549 _ _ O
% _ _ O
rax _ _ O
998 _ _ O



