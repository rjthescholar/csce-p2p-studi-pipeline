unlabeled|cs1502|lec27_time_complexity_02
-DOCSTART- -X- -X- O

Time _ _ O
Complexity _ _ O
02 _ _ O
Thumrongsak _ _ O
Kosiyatrakul _ _ O
tkosiyat@cs.pitt.edu _ _ O
Thumrongsak _ _ O
Kosiyatrakul _ _ O
tkosiyat@cs.pitt.edu _ _ O
Time _ _ O
Complexity _ _ O
02 _ _ O

Polynomial _ _ O
Time _ _ O
vs _ _ O
Exponential _ _ O
Time _ _ O
Polynomial _ _ O
time _ _ O
is _ _ O
considered _ _ O
small _ _ O
but _ _ O
exponential _ _ O
time _ _ O
is _ _ O
considered _ _ O
large _ _ O
Consider _ _ O
a _ _ O
problem _ _ O
size _ _ O
n _ _ O
= _ _ O
1000 _ _ O
Assume _ _ O
that _ _ O
algorithms _ _ O
A _ _ O
and _ _ O
B _ _ O
requires _ _ O
to _ _ O
execute _ _ O
n2 _ _ O
and _ _ O
2n _ _ O
instructions _ _ O
respectively _ _ O
Assume _ _ O
that _ _ O
each _ _ O
instruction _ _ O
takes _ _ O
1 _ _ O
nanosecond _ _ O
Algorithm _ _ O
A _ _ O
takes _ _ O
10002 _ _ O
× _ _ O
10−9 _ _ O
= _ _ O
106 _ _ O
× _ _ O
10−9 _ _ O
= _ _ O
10−3 _ _ O
= _ _ O
0.001second _ _ O
Algorithm _ _ O
B _ _ O
takes _ _ O
21000 _ _ O
× _ _ O
10−9 _ _ O
≈ _ _ O
10301 _ _ O
× _ _ O
10−9 _ _ O
= _ _ O
10292 _ _ O
seconds _ _ O
≈ _ _ O
10284 _ _ O
years _ _ O
Thumrongsak _ _ O
Kosiyatrakul _ _ O
tkosiyat@cs.pitt.edu _ _ O
Time _ _ O
Complexity _ _ O
02 _ _ O

Class _ _ O
P _ _ O
Definition _ _ O
7.12 _ _ O
P _ _ O
is _ _ O
the _ _ O
class _ _ O
of _ _ O
languages _ _ O
that _ _ O
are _ _ O
decidable _ _ O
in _ _ O
polynomial _ _ O
time _ _ O
on _ _ O
a _ _ O
deterministic _ _ O
single-tape _ _ O
Turing _ _ O
machine _ _ O
. _ _ O
In _ _ O
other _ _ O
words _ _ O
, _ _ O
[ _ _ O
P _ _ O
= _ _ O
TIME _ _ O
( _ _ O
nk _ _ O
) _ _ O
k _ _ O
Recall _ _ O
that _ _ O
TIME _ _ O
( _ _ O
nk _ _ O
) _ _ O
is _ _ O
a _ _ O
set _ _ O
of _ _ O
languages _ _ O
that _ _ O
can _ _ O
be _ _ O
decided _ _ O
in _ _ O
O _ _ O
( _ _ O
nk _ _ O
) _ _ O
time _ _ O
Turing _ _ O
machine _ _ O
P _ _ O
is _ _ O
a _ _ O
class _ _ O
of _ _ O
problems _ _ O
that _ _ O
are _ _ O
realistically _ _ O
solvable _ _ O
on _ _ O
a _ _ O
computer _ _ O
Thumrongsak _ _ O
Kosiyatrakul _ _ O
tkosiyat@cs.pitt.edu _ _ O
Time _ _ O
Complexity _ _ O
02 _ _ O

Class _ _ O
P _ _ O
Consider _ _ O
the _ _ O
following _ _ O
Turing _ _ O
machine _ _ O
: _ _ O
M _ _ O
= _ _ O
“ _ _ O
On _ _ O
input _ _ O
x _ _ O
: _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
Do _ _ O
this _ _ O
While _ _ O
this _ _ O
is _ _ O
true _ _ O
Do _ _ O
that _ _ O
There _ _ O
are _ _ O
two _ _ O
meanings _ _ O
of _ _ O
the _ _ O
word _ _ O
“ _ _ O
step _ _ O
” _ _ O
of _ _ O
a _ _ O
TM _ _ O
M _ _ O
: _ _ O
The _ _ O
above _ _ O
TM _ _ O
has _ _ O
three _ _ O
steps _ _ O
, _ _ O
step _ _ O
1 _ _ O
, _ _ O
step _ _ O
2 _ _ O
, _ _ O
and _ _ O
step _ _ O
3 _ _ O
Each _ _ O
step _ _ O
takes _ _ O
a _ _ O
number _ _ O
of _ _ O
steps _ _ O
to _ _ O
execute _ _ O
One _ _ O
step _ _ O
results _ _ O
in _ _ O
a _ _ O
configuration _ _ O
A _ _ O
TM _ _ O
runs _ _ O
in _ _ O
polynomial _ _ O
time _ _ O
if _ _ O
1 _ _ O
2 _ _ O
The _ _ O
number _ _ O
of _ _ O
times _ _ O
each _ _ O
step _ _ O
is _ _ O
executed _ _ O
( _ _ O
including _ _ O
repeated _ _ O
) _ _ O
is _ _ O
a _ _ O
polynomial _ _ O
( _ _ O
nk _ _ O
for _ _ O
some _ _ O
k _ _ O
) _ _ O
Each _ _ O
step _ _ O
takes _ _ O
a _ _ O
polynomial _ _ O
time _ _ O
( _ _ O
O _ _ O
( _ _ O
nk _ _ O
) _ _ O
for _ _ O
some _ _ O
k _ _ O
) _ _ O
Thumrongsak _ _ O
Kosiyatrakul _ _ O
tkosiyat@cs.pitt.edu _ _ O
Time _ _ O
Complexity _ _ O
02 _ _ O

Analyzing _ _ O
Algorithms _ _ O
Recall _ _ O
our _ _ O
Turing _ _ O
machine _ _ O
M1 _ _ O
that _ _ O
decides _ _ O
A _ _ O
= _ _ O
{ _ _ O
0k _ _ O
1k _ _ O
| _ _ O
k _ _ O
≥ _ _ O
0 _ _ O
} _ _ O
M1 _ _ O
= _ _ O
“ _ _ O
On _ _ O
input _ _ O
string _ _ O
w _ _ O
: _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
Scan _ _ O
across _ _ O
the _ _ O
tape _ _ O
and _ _ O
reject _ _ O
if _ _ O
a _ _ O
0 _ _ O
is _ _ O
found _ _ O
to _ _ O
the _ _ O
right _ _ O
of _ _ O
a _ _ O
1 _ _ O
. _ _ O
Repeat _ _ O
if _ _ O
both _ _ O
0s _ _ O
and _ _ O
1s _ _ O
remain _ _ O
on _ _ O
the _ _ O
tape _ _ O
: _ _ O
Scan _ _ O
across _ _ O
the _ _ O
tape _ _ O
, _ _ O
crossing _ _ O
off _ _ O
a _ _ O
single _ _ O
0 _ _ O
and _ _ O
a _ _ O
single _ _ O
1 _ _ O
. _ _ O
If _ _ O
0s _ _ O
still _ _ O
remain _ _ O
after _ _ O
all _ _ O
the _ _ O
1s _ _ O
have _ _ O
been _ _ O
crossed _ _ O
off _ _ O
, _ _ O
or _ _ O
if _ _ O
1s _ _ O
still _ _ O
remain _ _ O
after _ _ O
all _ _ O
the _ _ O
0s _ _ O
have _ _ O
been _ _ O
crossed _ _ O
off _ _ O
, _ _ O
reject _ _ O
. _ _ O
Otherwise _ _ O
, _ _ O
if _ _ O
neither _ _ O
0s _ _ O
nor _ _ O
1s _ _ O
remain _ _ O
on _ _ O
the _ _ O
tape _ _ O
, _ _ O
accept _ _ O
. _ _ O
” _ _ O
Thumrongsak _ _ O
Kosiyatrakul _ _ O
tkosiyat@cs.pitt.edu _ _ O
Time _ _ O
Complexity _ _ O
02 _ _ O

Analyzing _ _ O
Algorithm _ _ O
Input _ _ O
0k _ _ O
1k _ _ O
where _ _ O
k _ _ O
= _ _ O
n _ _ O
/ _ _ O
2 _ _ O
Number _ _ O
of _ _ O
times _ _ O
each _ _ O
step _ _ O
is _ _ O
executed _ _ O
: _ _ O
Step _ _ O
1 _ _ O
will _ _ O
be _ _ O
executed _ _ O
1 _ _ O
time _ _ O
Step _ _ O
2 _ _ O
and _ _ O
3 _ _ O
will _ _ O
be _ _ O
executed _ _ O
n _ _ O
/ _ _ O
2 _ _ O
times _ _ O
Step _ _ O
4 _ _ O
will _ _ O
be _ _ O
executed _ _ O
1 _ _ O
time _ _ O
Number _ _ O
of _ _ O
steps _ _ O
of _ _ O
each _ _ O
step _ _ O
Step _ _ O
1 _ _ O
takes _ _ O
O _ _ O
( _ _ O
n _ _ O
) _ _ O
steps _ _ O
Step _ _ O
2 _ _ O
and _ _ O
3 _ _ O
take _ _ O
O _ _ O
( _ _ O
n _ _ O
) _ _ O
steps _ _ O
Step _ _ O
4 _ _ O
takes _ _ O
O _ _ O
( _ _ O
n _ _ O
) _ _ O
steps _ _ O
From _ _ O
the _ _ O
analysis _ _ O
: _ _ O
The _ _ O
number _ _ O
of _ _ O
times _ _ O
each _ _ O
step _ _ O
is _ _ O
executed _ _ O
( _ _ O
including _ _ O
repeat _ _ O
) _ _ O
is _ _ O
polynomial _ _ O
Each _ _ O
step _ _ O
takes _ _ O
polynomial _ _ O
time _ _ O
Therefore _ _ O
, _ _ O
M1 _ _ O
runs _ _ O
in _ _ O
polynomial _ _ O
time _ _ O
Thumrongsak _ _ O
Kosiyatrakul _ _ O
tkosiyat@cs.pitt.edu _ _ O
Time _ _ O
Complexity _ _ O
02 _ _ O

Examples _ _ O
of _ _ O
Problems _ _ O
in _ _ O
P _ _ O
Let _ _ O
PATH _ _ O
= _ _ O
{ _ _ O
hG _ _ O
, _ _ O
s _ _ O
, _ _ O
ti _ _ O
| _ _ O
G _ _ O
is _ _ O
a _ _ O
directed _ _ O
graph _ _ O
that _ _ O
has _ _ O
a _ _ O
directed _ _ O
path _ _ O
from _ _ O
s _ _ O
to _ _ O
t _ _ O
} _ _ O
G _ _ O
s _ _ O
t _ _ O
Is _ _ O
PATH _ _ O
∈ _ _ O
P _ _ O
? _ _ O
If _ _ O
PATH _ _ O
can _ _ O
be _ _ O
decided _ _ O
by _ _ O
a _ _ O
TM _ _ O
in _ _ O
polynomial _ _ O
time _ _ O
, _ _ O
PATH _ _ O
∈ _ _ O
P _ _ O
Thumrongsak _ _ O
Kosiyatrakul _ _ O
tkosiyat@cs.pitt.edu _ _ O
Time _ _ O
Complexity _ _ O
02 _ _ O

Brute-Force _ _ O
Algorithm _ _ O
for _ _ O
PATH _ _ O
Suppose _ _ O
a _ _ O
directed _ _ O
graph _ _ O
G _ _ O
consists _ _ O
of _ _ O
m _ _ O
nodes _ _ O
A _ _ O
brute-force _ _ O
algorithm _ _ O
: _ _ O
Creating _ _ O
all _ _ O
possible _ _ O
paths _ _ O
of _ _ O
length _ _ O
at _ _ O
most _ _ O
m _ _ O
Search _ _ O
for _ _ O
a _ _ O
direct _ _ O
path _ _ O
from _ _ O
s _ _ O
to _ _ O
t _ _ O
Example _ _ O
: _ _ O
All _ _ O
possible _ _ O
paths _ _ O
of _ _ O
length _ _ O
at _ _ O
most _ _ O
3 _ _ O
: _ _ O
1 _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
2 _ _ O
3 _ _ O
1 _ _ O
2 _ _ O
1 _ _ O
1 _ _ O
1 _ _ O
2 _ _ O
1 _ _ O
2 _ _ O
1 _ _ O
2 _ _ O
2 _ _ O
2 _ _ O
3 _ _ O
3 _ _ O
3 _ _ O
3 _ _ O
1 _ _ O
2 _ _ O
1 _ _ O
3 _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
2 _ _ O
3 _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
3 _ _ O
1 _ _ O
2 _ _ O
1 _ _ O
3 _ _ O
1 _ _ O
Maximum _ _ O
Paths _ _ O
with _ _ O
3 _ _ O
nodes _ _ O
Thumrongsak _ _ O
Kosiyatrakul _ _ O
tkosiyat@cs.pitt.edu _ _ O
3 _ _ O
Time _ _ O
Complexity _ _ O
02 _ _ O
2 _ _ O
2 _ _ O
3 _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
3 _ _ O
1 _ _ O
2 _ _ O
3 _ _ O

Brute-Force _ _ O
Algorithm _ _ O
for _ _ O
PATH _ _ O
The _ _ O
number _ _ O
of _ _ O
possible _ _ O
paths _ _ O
is _ _ O
roughly _ _ O
mm _ _ O
For _ _ O
each _ _ O
path _ _ O
, _ _ O
you _ _ O
need _ _ O
to _ _ O
check _ _ O
whether _ _ O
it _ _ O
is _ _ O
a _ _ O
path _ _ O
from _ _ O
s _ _ O
to _ _ O
t _ _ O
There _ _ O
are _ _ O
roughly _ _ O
mm _ _ O
paths _ _ O
To _ _ O
search _ _ O
all _ _ O
possible _ _ O
paths _ _ O
is _ _ O
O _ _ O
( _ _ O
mm _ _ O
) _ _ O
O _ _ O
( _ _ O
mm _ _ O
) _ _ O
= _ _ O
O _ _ O
( _ _ O
( _ _ O
2log2 _ _ O
m _ _ O
) _ _ O
m _ _ O
) _ _ O
= _ _ O
O _ _ O
( _ _ O
2 _ _ O
m _ _ O
log2 _ _ O
m _ _ O
) _ _ O
This _ _ O
will _ _ O
take _ _ O
an _ _ O
exponential _ _ O
time _ _ O
Thumrongsak _ _ O
Kosiyatrakul _ _ O
tkosiyat@cs.pitt.edu _ _ O
Time _ _ O
Complexity _ _ O
02 _ _ O

Breadth-First _ _ O
Search _ _ O
for _ _ O
PATH _ _ O
Use _ _ O
breadth-first _ _ O
search _ _ O
to _ _ O
achieve _ _ O
polynomial _ _ O
time _ _ O
for _ _ O
PATH _ _ O
: _ _ O
M _ _ O
= _ _ O
“ _ _ O
On _ _ O
input _ _ O
hG _ _ O
, _ _ O
s _ _ O
, _ _ O
ti _ _ O
, _ _ O
where _ _ O
G _ _ O
is _ _ O
a _ _ O
directed _ _ O
graph _ _ O
with _ _ O
nodes _ _ O
s _ _ O
and _ _ O
t _ _ O
: _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
Place _ _ O
a _ _ O
mark _ _ O
on _ _ O
node _ _ O
s. _ _ O
Repeat _ _ O
the _ _ O
following _ _ O
until _ _ O
no _ _ O
additional _ _ O
nodes _ _ O
are _ _ O
marked _ _ O
: _ _ O
Scan _ _ O
all _ _ O
the _ _ O
edges _ _ O
of _ _ O
G. _ _ O
If _ _ O
an _ _ O
edge _ _ O
( _ _ O
a _ _ O
, _ _ O
b _ _ O
) _ _ O
is _ _ O
found _ _ O
going _ _ O
from _ _ O
a _ _ O
marked _ _ O
node _ _ O
a _ _ O
to _ _ O
an _ _ O
unmarked _ _ O
node _ _ O
b _ _ O
, _ _ O
mark _ _ O
node _ _ O
b. _ _ O
If _ _ O
t _ _ O
is _ _ O
marked _ _ O
, _ _ O
accept _ _ O
. _ _ O
Otherwise _ _ O
, _ _ O
reject _ _ O
. _ _ O
” _ _ O
For _ _ O
simplicity _ _ O
of _ _ O
analysis _ _ O
, _ _ O
we _ _ O
are _ _ O
going _ _ O
to _ _ O
assume _ _ O
the _ _ O
following _ _ O
: _ _ O
The _ _ O
number _ _ O
of _ _ O
nodes _ _ O
is _ _ O
n _ _ O
The _ _ O
number _ _ O
of _ _ O
edges _ _ O
is _ _ O
proportional _ _ O
to _ _ O
the _ _ O
number _ _ O
of _ _ O
nodes _ _ O
kn _ _ O
edges _ _ O
for _ _ O
some _ _ O
k _ _ O
The _ _ O
string _ _ O
representation _ _ O
of _ _ O
a _ _ O
graph _ _ O
is _ _ O
proportional _ _ O
to _ _ O
the _ _ O
number _ _ O
of _ _ O
nodes _ _ O
and _ _ O
the _ _ O
number _ _ O
of _ _ O
edges _ _ O
In _ _ O
doing _ _ O
so _ _ O
, _ _ O
we _ _ O
can _ _ O
simply _ _ O
use _ _ O
n _ _ O
( _ _ O
number _ _ O
of _ _ O
nodes _ _ O
) _ _ O
as _ _ O
the _ _ O
problem _ _ O
size _ _ O
instead _ _ O
of _ _ O
the _ _ O
length _ _ O
of _ _ O
the _ _ O
input _ _ O
string _ _ O
Thumrongsak _ _ O
Kosiyatrakul _ _ O
tkosiyat@cs.pitt.edu _ _ O
Time _ _ O
Complexity _ _ O
02 _ _ O

Breadth-First _ _ O
Search _ _ O
for _ _ O
PATH _ _ O
Analysis _ _ O
where _ _ O
input _ _ O
string _ _ O
is _ _ O
hG _ _ O
, _ _ O
s _ _ O
, _ _ O
ti _ _ O
where _ _ O
G _ _ O
is _ _ O
a _ _ O
directed _ _ O
graph _ _ O
and _ _ O
s _ _ O
and _ _ O
t _ _ O
are _ _ O
nodes _ _ O
Step _ _ O
1 _ _ O
: _ _ O
Place _ _ O
a _ _ O
mark _ _ O
on _ _ O
node _ _ O
s. _ _ O
This _ _ O
step _ _ O
will _ _ O
be _ _ O
executed _ _ O
one _ _ O
time _ _ O
and _ _ O
the _ _ O
number _ _ O
of _ _ O
steps _ _ O
is _ _ O
O _ _ O
( _ _ O
n _ _ O
) _ _ O
Step _ _ O
4 _ _ O
: _ _ O
If _ _ O
t _ _ O
is _ _ O
marked _ _ O
, _ _ O
accept _ _ O
. _ _ O
Otherwise _ _ O
, _ _ O
reject _ _ O
. _ _ O
This _ _ O
step _ _ O
will _ _ O
be _ _ O
executed _ _ O
one _ _ O
time _ _ O
and _ _ O
the _ _ O
number _ _ O
of _ _ O
steps _ _ O
is _ _ O
O _ _ O
( _ _ O
n _ _ O
) _ _ O
Steps _ _ O
2 _ _ O
and _ _ O
3 _ _ O
: _ _ O
Runs _ _ O
at _ _ O
most _ _ O
n _ _ O
times _ _ O
( _ _ O
mark _ _ O
one _ _ O
additional _ _ O
node _ _ O
every _ _ O
repetition _ _ O
) _ _ O
Recall _ _ O
that _ _ O
there _ _ O
are _ _ O
kn _ _ O
edges _ _ O
For _ _ O
each _ _ O
execution _ _ O
of _ _ O
step _ _ O
3 _ _ O
, _ _ O
it _ _ O
needs _ _ O
O _ _ O
( _ _ O
kn _ _ O
) _ _ O
= _ _ O
O _ _ O
( _ _ O
n _ _ O
) _ _ O
steps _ _ O
Conclusion _ _ O
: _ _ O
Number _ _ O
of _ _ O
times _ _ O
each _ _ O
step _ _ O
will _ _ O
be _ _ O
executed _ _ O
is _ _ O
polynomial _ _ O
Each _ _ O
step _ _ O
is _ _ O
polynomial _ _ O
Therefore _ _ O
, _ _ O
this _ _ O
algorithm _ _ O
M _ _ O
is _ _ O
polynomial _ _ O
Thumrongsak _ _ O
Kosiyatrakul _ _ O
tkosiyat@cs.pitt.edu _ _ O
Time _ _ O
Complexity _ _ O
02 _ _ O

Relatively _ _ O
Prime _ _ O
Two _ _ O
numbers _ _ O
are _ _ O
relatively _ _ O
prime _ _ O
if _ _ O
1 _ _ O
is _ _ O
the _ _ O
largest _ _ O
integer _ _ O
that _ _ O
evenly _ _ O
divides _ _ O
them _ _ O
both _ _ O
Formally _ _ O
, _ _ O
RELPRIME _ _ O
= _ _ O
{ _ _ O
hx _ _ O
, _ _ O
yi _ _ O
| _ _ O
x _ _ O
and _ _ O
y _ _ O
are _ _ O
relatively _ _ O
prime _ _ O
} _ _ O
Is _ _ O
RELPRIME _ _ O
∈ _ _ O
P _ _ O
? _ _ O
Brute-force _ _ O
algorithm _ _ O
: _ _ O
Find _ _ O
all _ _ O
possible _ _ O
divisors _ _ O
of _ _ O
both _ _ O
numbers _ _ O
and _ _ O
accept _ _ O
if _ _ O
none _ _ O
are _ _ O
greater _ _ O
than _ _ O
1 _ _ O
If _ _ O
a _ _ O
number _ _ O
is _ _ O
represented _ _ O
by _ _ O
n-bit _ _ O
binary _ _ O
, _ _ O
the _ _ O
number _ _ O
of _ _ O
possible _ _ O
value _ _ O
is _ _ O
2n _ _ O
Thus _ _ O
, _ _ O
to _ _ O
find _ _ O
all _ _ O
possible _ _ O
divisor _ _ O
of _ _ O
x _ _ O
and _ _ O
y _ _ O
is _ _ O
O _ _ O
( _ _ O
2n _ _ O
) _ _ O
( _ _ O
exponential _ _ O
) _ _ O
Thumrongsak _ _ O
Kosiyatrakul _ _ O
tkosiyat@cs.pitt.edu _ _ O
Time _ _ O
Complexity _ _ O
02 _ _ O

Euclidean _ _ O
Algorithm _ _ O
for _ _ O
Greatest _ _ O
Common _ _ O
Divisor _ _ O
We _ _ O
can _ _ O
check _ _ O
whether _ _ O
x _ _ O
and _ _ O
y _ _ O
are _ _ O
relatively _ _ O
prime _ _ O
by _ _ O
computing _ _ O
their _ _ O
Greatest _ _ O
Common _ _ O
Divisor _ _ O
( _ _ O
GCD _ _ O
) _ _ O
If _ _ O
gcd _ _ O
( _ _ O
x _ _ O
, _ _ O
y _ _ O
) _ _ O
= _ _ O
1 _ _ O
, _ _ O
x _ _ O
and _ _ O
y _ _ O
are _ _ O
relatively _ _ O
prime _ _ O
Computing _ _ O
a _ _ O
gcd _ _ O
can _ _ O
be _ _ O
done _ _ O
using _ _ O
Euclidean _ _ O
Algorithm _ _ O
in _ _ O
a _ _ O
form _ _ O
of _ _ O
a _ _ O
TM _ _ O
as _ _ O
follows _ _ O
: _ _ O
E _ _ O
= _ _ O
“ _ _ O
On _ _ O
input _ _ O
hx _ _ O
, _ _ O
yi _ _ O
, _ _ O
where _ _ O
x _ _ O
and _ _ O
y _ _ O
are _ _ O
natural _ _ O
numbers _ _ O
: _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
Repeat _ _ O
until _ _ O
y _ _ O
= _ _ O
0 _ _ O
: _ _ O
Assign _ _ O
x _ _ O
← _ _ O
x _ _ O
mod _ _ O
y. _ _ O
Exchange _ _ O
x _ _ O
and _ _ O
y. _ _ O
Output _ _ O
x. _ _ O
” _ _ O
When _ _ O
we _ _ O
run _ _ O
TM _ _ O
E _ _ O
on _ _ O
input _ _ O
hx _ _ O
, _ _ O
yi _ _ O
where _ _ O
x _ _ O
and _ _ O
y _ _ O
are _ _ O
natural _ _ O
numbers _ _ O
, _ _ O
it _ _ O
simply _ _ O
output _ _ O
their _ _ O
GCD _ _ O
Thumrongsak _ _ O
Kosiyatrakul _ _ O
tkosiyat@cs.pitt.edu _ _ O
Time _ _ O
Complexity _ _ O
02 _ _ O

Euclidean _ _ O
Algorithm _ _ O
for _ _ O
Greatest _ _ O
Common _ _ O
Divisor _ _ O
This _ _ O
algorithm _ _ O
R _ _ O
solves _ _ O
RELPRIME _ _ O
R _ _ O
= _ _ O
“ _ _ O
On _ _ O
input _ _ O
hx _ _ O
, _ _ O
yi _ _ O
, _ _ O
where _ _ O
x _ _ O
and _ _ O
y _ _ O
are _ _ O
natural _ _ O
numbers _ _ O
in _ _ O
binary _ _ O
: _ _ O
1 _ _ O
2 _ _ O
Run _ _ O
E _ _ O
on _ _ O
hx _ _ O
, _ _ O
yi _ _ O
. _ _ O
If _ _ O
the _ _ O
result _ _ O
is _ _ O
1 _ _ O
, _ _ O
accept _ _ O
. _ _ O
Otherwise _ _ O
, _ _ O
reject _ _ O
. _ _ O
Analysis _ _ O
: _ _ O
There _ _ O
is _ _ O
no _ _ O
loop _ _ O
in _ _ O
TM _ _ O
R _ _ O
Step _ _ O
1 _ _ O
will _ _ O
be _ _ O
executed _ _ O
one _ _ O
time _ _ O
Step _ _ O
2 _ _ O
will _ _ O
be _ _ O
executed _ _ O
one _ _ O
time _ _ O
For _ _ O
the _ _ O
number _ _ O
of _ _ O
steps _ _ O
in _ _ O
each _ _ O
step _ _ O
: _ _ O
For _ _ O
step _ _ O
1 _ _ O
, _ _ O
it _ _ O
depends _ _ O
on _ _ O
the _ _ O
number _ _ O
of _ _ O
steps _ _ O
of _ _ O
TM _ _ O
E _ _ O
For _ _ O
step _ _ O
2 _ _ O
, _ _ O
at _ _ O
most _ _ O
O _ _ O
( _ _ O
n _ _ O
) _ _ O
Thumrongsak _ _ O
Kosiyatrakul _ _ O
tkosiyat@cs.pitt.edu _ _ O
Time _ _ O
Complexity _ _ O
02 _ _ O

RELPRIME _ _ O
∈ _ _ O
P _ _ O
Analysis _ _ O
of _ _ O
Algorithm _ _ O
E _ _ O
: _ _ O
Given _ _ O
two _ _ O
numbers _ _ O
x _ _ O
and _ _ O
y _ _ O
, _ _ O
there _ _ O
are _ _ O
two _ _ O
possibilities _ _ O
: _ _ O
1 _ _ O
2 _ _ O
x _ _ O
/ _ _ O
2 _ _ O
≥ _ _ O
y _ _ O
or _ _ O
x _ _ O
/ _ _ O
2 _ _ O
< _ _ O
y _ _ O
If _ _ O
x _ _ O
/ _ _ O
2 _ _ O
≥ _ _ O
y _ _ O
, _ _ O
x _ _ O
mod _ _ O
y _ _ O
< _ _ O
y _ _ O
< _ _ O
x _ _ O
/ _ _ O
2 _ _ O
If _ _ O
x _ _ O
/ _ _ O
2 _ _ O
< _ _ O
y _ _ O
, _ _ O
x _ _ O
mod _ _ O
y _ _ O
= _ _ O
x _ _ O
− _ _ O
y _ _ O
< _ _ O
x _ _ O
/ _ _ O
2 _ _ O
In _ _ O
other _ _ O
words _ _ O
, _ _ O
performing _ _ O
x _ _ O
= _ _ O
x _ _ O
mod _ _ O
y _ _ O
reduces _ _ O
the _ _ O
value _ _ O
of _ _ O
x _ _ O
roughly _ _ O
in _ _ O
half _ _ O
Thus _ _ O
, _ _ O
steps _ _ O
2 _ _ O
and _ _ O
3 _ _ O
will _ _ O
be _ _ O
repeated _ _ O
roughly _ _ O
2 _ _ O
log2 _ _ O
x _ _ O
or _ _ O
2 _ _ O
log2 _ _ O
y _ _ O
( _ _ O
proportional _ _ O
to _ _ O
the _ _ O
length _ _ O
of _ _ O
either _ _ O
x _ _ O
or _ _ O
y _ _ O
) _ _ O
Multiplied _ _ O
by _ _ O
2 _ _ O
because _ _ O
of _ _ O
the _ _ O
swap _ _ O
in _ _ O
step _ _ O
3 _ _ O
Algorithm _ _ O
E _ _ O
runs _ _ O
in _ _ O
polynomial _ _ O
time _ _ O
RELPRIME _ _ O
∈ _ _ O
P _ _ O
Thumrongsak _ _ O
Kosiyatrakul _ _ O
tkosiyat@cs.pitt.edu _ _ O
Time _ _ O
Complexity _ _ O
02 _ _ O

Hamiltonian _ _ O
Path _ _ O
A _ _ O
Hamiltonian _ _ O
path _ _ O
in _ _ O
a _ _ O
directed _ _ O
graph _ _ O
G _ _ O
is _ _ O
a _ _ O
directed _ _ O
path _ _ O
that _ _ O
goes _ _ O
through _ _ O
each _ _ O
node _ _ O
exactly _ _ O
once _ _ O
Formally _ _ O
, _ _ O
HAMPATH _ _ O
= _ _ O
{ _ _ O
hG _ _ O
, _ _ O
s _ _ O
, _ _ O
ti _ _ O
| _ _ O
G _ _ O
is _ _ O
a _ _ O
directed _ _ O
graph _ _ O
with _ _ O
a _ _ O
Hamiltonian _ _ O
path _ _ O
from _ _ O
s _ _ O
to _ _ O
t _ _ O
} _ _ O
s _ _ O
t _ _ O
Is _ _ O
HAMPATH _ _ O
∈ _ _ O
P _ _ O
? _ _ O
Thumrongsak _ _ O
Kosiyatrakul _ _ O
tkosiyat@cs.pitt.edu _ _ O
Time _ _ O
Complexity _ _ O
02 _ _ O

Polynomial _ _ O
Verifiability _ _ O
Unfortunately _ _ O
, _ _ O
we _ _ O
need _ _ O
the _ _ O
brute-force _ _ O
algorithm _ _ O
: _ _ O
First _ _ O
, _ _ O
we _ _ O
generate _ _ O
all _ _ O
possible _ _ O
paths _ _ O
Then _ _ O
check _ _ O
each _ _ O
path _ _ O
whether _ _ O
it _ _ O
is _ _ O
a _ _ O
Hamiltonian _ _ O
path _ _ O
from _ _ O
s _ _ O
to _ _ O
t _ _ O
This _ _ O
requires _ _ O
exponential _ _ O
time _ _ O
since _ _ O
there _ _ O
are _ _ O
roughly _ _ O
mm _ _ O
possible _ _ O
paths _ _ O
No _ _ O
one _ _ O
know _ _ O
an _ _ O
algorithm _ _ O
that _ _ O
can _ _ O
solve _ _ O
Hamiltonian _ _ O
path _ _ O
in _ _ O
polynomial _ _ O
time _ _ O
yet _ _ O
No _ _ O
one _ _ O
can _ _ O
prove _ _ O
that _ _ O
the _ _ O
Hamiltonian _ _ O
path _ _ O
problem _ _ O
can _ _ O
not _ _ O
be _ _ O
solved _ _ O
in _ _ O
polynomial _ _ O
time _ _ O
yet _ _ O
Thumrongsak _ _ O
Kosiyatrakul _ _ O
tkosiyat@cs.pitt.edu _ _ O
Time _ _ O
Complexity _ _ O
02 _ _ O

PATH _ _ O
vs _ _ O
HAMPATH _ _ O
Recall _ _ O
languages _ _ O
PATH _ _ O
and _ _ O
HAMPATH _ _ O
PATH _ _ O
= _ _ O
{ _ _ O
hG _ _ O
, _ _ O
s _ _ O
, _ _ O
ti _ _ O
| _ _ O
G _ _ O
is _ _ O
a _ _ O
directed _ _ O
graph _ _ O
that _ _ O
has _ _ O
a _ _ O
directed _ _ O
path _ _ O
from _ _ O
s _ _ O
to _ _ O
t _ _ O
} _ _ O
HAMPATH _ _ O
= _ _ O
{ _ _ O
hG _ _ O
, _ _ O
s _ _ O
, _ _ O
ti _ _ O
| _ _ O
G _ _ O
is _ _ O
a _ _ O
directed _ _ O
graph _ _ O
with _ _ O
a _ _ O
Hamiltonian _ _ O
path _ _ O
from _ _ O
s _ _ O
to _ _ O
t _ _ O
} _ _ O
Given _ _ O
hG _ _ O
, _ _ O
s _ _ O
, _ _ O
ti _ _ O
: _ _ O
to _ _ O
decide _ _ O
whether _ _ O
it _ _ O
is _ _ O
in _ _ O
PATH _ _ O
can _ _ O
be _ _ O
done _ _ O
in _ _ O
polynomial _ _ O
time _ _ O
to _ _ O
decide _ _ O
whether _ _ O
it _ _ O
is _ _ O
in _ _ O
HAMPATH _ _ O
( _ _ O
as _ _ O
of _ _ O
now _ _ O
) _ _ O
can _ _ O
not _ _ O
be _ _ O
done _ _ O
in _ _ O
polynomial _ _ O
time _ _ O
Thumrongsak _ _ O
Kosiyatrakul _ _ O
tkosiyat@cs.pitt.edu _ _ O
Time _ _ O
Complexity _ _ O
02 _ _ O

COMPOSITES _ _ O
Another _ _ O
problem _ _ O
is _ _ O
called _ _ O
COMPOSITES _ _ O
Formally _ _ O
, _ _ O
COMPOSITES _ _ O
= _ _ O
{ _ _ O
x _ _ O
| _ _ O
x _ _ O
= _ _ O
pq _ _ O
, _ _ O
for _ _ O
integers _ _ O
p _ _ O
, _ _ O
q _ _ O
> _ _ O
1 _ _ O
} _ _ O
Given _ _ O
a _ _ O
composite _ _ O
number _ _ O
x _ _ O
= _ _ O
pq _ _ O
where _ _ O
p _ _ O
and _ _ O
q _ _ O
are _ _ O
large _ _ O
prime _ _ O
numbers _ _ O
, _ _ O
it _ _ O
takes _ _ O
a _ _ O
very _ _ O
long _ _ O
time _ _ O
to _ _ O
find _ _ O
p _ _ O
and _ _ O
q _ _ O
The _ _ O
RSA _ _ O
algorithm _ _ O
is _ _ O
based _ _ O
on _ _ O
the _ _ O
fact _ _ O
that _ _ O
COMPOSITES _ _ O
requires _ _ O
an _ _ O
exponential _ _ O
time _ _ O
Thumrongsak _ _ O
Kosiyatrakul _ _ O
tkosiyat@cs.pitt.edu _ _ O
Time _ _ O
Complexity _ _ O
02 _ _ O



