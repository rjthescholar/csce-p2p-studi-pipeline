unlabeled|cs1541|lec2.1_processor_review
-DOCSTART- -X- -X- O

Processor _ _ O
Review _ _ O
CS _ _ O
1541 _ _ O
Wonsun _ _ O
Ahn _ _ O

Clocking _ _ O
Review _ _ O
Stuff _ _ O
you _ _ O
learned _ _ O
in _ _ O
CS _ _ O
447 _ _ O

Logic _ _ O
components _ _ O
● _ _ O
Do _ _ O
you _ _ O
remember _ _ O
what _ _ O
all _ _ O
these _ _ O
do _ _ O
? _ _ O
NOT _ _ O
gate _ _ O
Multiplexer _ _ O
( _ _ O
MUX _ _ O
) _ _ O
32 _ _ O
AND _ _ O
gate _ _ O
32 _ _ O
Decoder _ _ O
OR _ _ O
gate _ _ O
XOR _ _ O
gate _ _ O
ALU _ _ O
32 _ _ O
These _ _ O
wires _ _ O
carry _ _ O
several _ _ O
bits _ _ O
at _ _ O
once _ _ O
. _ _ O
Blue _ _ O
wires _ _ O
are _ _ O
control _ _ O
signals _ _ O
. _ _ O
3 _ _ O

Uses _ _ O
of _ _ O
a _ _ O
Decoder _ _ O
● _ _ O
Translates _ _ O
a _ _ O
set _ _ O
of _ _ O
input _ _ O
signals _ _ O
to _ _ O
a _ _ O
bunch _ _ O
of _ _ O
output _ _ O
signals _ _ O
. _ _ O
o _ _ O
E.g. _ _ O
a _ _ O
binary _ _ O
decoder _ _ O
: _ _ O
Truth _ _ O
Table _ _ O
for _ _ O
Decoder _ _ O
Q0 _ _ O
A _ _ O
Q1 _ _ O
B _ _ O
Q2 _ _ O
Q3 _ _ O
A _ _ O
B _ _ O
Q0 _ _ O
Q1 _ _ O
Q2 _ _ O
Q3 _ _ O
0 _ _ O
0 _ _ O
1 _ _ O
0 _ _ O
0 _ _ O
0 _ _ O
0 _ _ O
1 _ _ O
0 _ _ O
1 _ _ O
0 _ _ O
0 _ _ O
1 _ _ O
0 _ _ O
0 _ _ O
0 _ _ O
1 _ _ O
0 _ _ O
1 _ _ O
1 _ _ O
0 _ _ O
0 _ _ O
0 _ _ O
1 _ _ O
o _ _ O
You _ _ O
can _ _ O
come _ _ O
up _ _ O
with _ _ O
any _ _ O
truth _ _ O
table _ _ O
and _ _ O
make _ _ O
a _ _ O
decoder _ _ O
for _ _ O
it _ _ O
! _ _ O
4 _ _ O

Uses _ _ O
of _ _ O
a _ _ O
Multiplexer _ _ O
● _ _ O
No _ _ O
problem _ _ O
in _ _ O
fanning _ _ O
out _ _ O
one _ _ O
signal _ _ O
to _ _ O
two _ _ O
points _ _ O
A _ _ O
+ _ _ O
= _ _ O
B _ _ O
A _ _ O
B _ _ O
● _ _ O
Can _ _ O
not _ _ O
connect _ _ O
two _ _ O
signals _ _ O
to _ _ O
one _ _ O
point _ _ O
o _ _ O
Must _ _ O
use _ _ O
a _ _ O
multiplexer _ _ O
to _ _ O
select _ _ O
between _ _ O
the _ _ O
two _ _ O
+ _ _ O
Path _ _ O
A _ _ O
= _ _ O
Path _ _ O
B _ _ O
Mux _ _ O
control _ _ O
= _ _ O
0 _ _ O
for _ _ O
path _ _ O
A _ _ O
1 _ _ O
for _ _ O
path _ _ O
B _ _ O
5 _ _ O

Gates _ _ O
are _ _ O
made _ _ O
of _ _ O
transistors _ _ O
( _ _ O
of _ _ O
course _ _ O
) _ _ O
• _ _ O
NOT _ _ O
gate _ _ O
• _ _ O
NAND _ _ O
gate _ _ O
6 _ _ O

The _ _ O
clock _ _ O
signal _ _ O
● _ _ O
The _ _ O
clock _ _ O
is _ _ O
a _ _ O
signal _ _ O
that _ _ O
alternates _ _ O
regularly _ _ O
between _ _ O
0 _ _ O
and _ _ O
1 _ _ O
: _ _ O
1 _ _ O
0 _ _ O
time _ _ O
● _ _ O
Bits _ _ O
are _ _ O
latched _ _ O
on _ _ O
to _ _ O
registers _ _ O
and _ _ O
flip-flops _ _ O
on _ _ O
rising _ _ O
edges _ _ O
● _ _ O
In _ _ O
between _ _ O
rising _ _ O
edges _ _ O
, _ _ O
bits _ _ O
propagate _ _ O
through _ _ O
the _ _ O
logic _ _ O
circuit _ _ O
o _ _ O
Composed _ _ O
of _ _ O
ALUs _ _ O
, _ _ O
muxes _ _ O
, _ _ O
decoders _ _ O
, _ _ O
etc _ _ O
. _ _ O
o _ _ O
Propagation _ _ O
delay _ _ O
: _ _ O
amount _ _ O
of _ _ O
time _ _ O
it _ _ O
takes _ _ O
from _ _ O
input _ _ O
to _ _ O
output _ _ O
7 _ _ O

Critical _ _ O
Path _ _ O
● _ _ O
Critical _ _ O
path _ _ O
: _ _ O
path _ _ O
in _ _ O
a _ _ O
circuit _ _ O
that _ _ O
has _ _ O
longest _ _ O
propagation _ _ O
delay _ _ O
o _ _ O
Determines _ _ O
the _ _ O
overall _ _ O
clock _ _ O
speed _ _ O
. _ _ O
5 _ _ O
ns _ _ O
A _ _ O
D _ _ O
Q _ _ O
EN _ _ O
B _ _ O
D _ _ O
Q _ _ O
1 _ _ O
+ _ _ O
IN _ _ O
5 _ _ O
ns _ _ O
OUT _ _ O
EN _ _ O
Select _ _ O
o _ _ O
The _ _ O
ALU _ _ O
and _ _ O
the _ _ O
multiplexer _ _ O
both _ _ O
have _ _ O
a _ _ O
5 _ _ O
ns _ _ O
delay _ _ O
● _ _ O
How _ _ O
fast _ _ O
can _ _ O
we _ _ O
clock _ _ O
this _ _ O
circuit _ _ O
? _ _ O
o _ _ O
Is _ _ O
it _ _ O
1 _ _ O
/ _ _ O
5 _ _ O
ns _ _ O
( _ _ O
5 _ _ O
× _ _ O
10 _ _ O
- _ _ O
9s _ _ O
) _ _ O
= _ _ O
200 _ _ O
MHz _ _ O
? _ _ O
o _ _ O
Or _ _ O
is _ _ O
it _ _ O
1 _ _ O
/ _ _ O
10 _ _ O
ns _ _ O
( _ _ O
10 _ _ O
× _ _ O
10 _ _ O
- _ _ O
9s _ _ O
) _ _ O
= _ _ O
100 _ _ O
MHz _ _ O
? _ _ O
8 _ _ O

MIPS _ _ O
Review _ _ O
Stuff _ _ O
you _ _ O
learned _ _ O
in _ _ O
CS _ _ O
447 _ _ O

The _ _ O
MIPS _ _ O
ISA _ _ O
- _ _ O
Registers _ _ O
● _ _ O
MIPS _ _ O
has _ _ O
32 _ _ O
32-bit _ _ O
registers _ _ O
, _ _ O
with _ _ O
the _ _ O
following _ _ O
usage _ _ O
conventions _ _ O
o _ _ O
But _ _ O
really _ _ O
, _ _ O
all _ _ O
are _ _ O
general _ _ O
purpose _ _ O
registers _ _ O
( _ _ O
nothing _ _ O
special _ _ O
about _ _ O
them _ _ O
) _ _ O
Name _ _ O
$ _ _ O
zero _ _ O
$ _ _ O
at _ _ O
$ _ _ O
v0-$v1 _ _ O
$ _ _ O
a0-$a3 _ _ O
$ _ _ O
t0-$t7 _ _ O
$ _ _ O
s0-$s7 _ _ O
$ _ _ O
t8-$t9 _ _ O
$ _ _ O
k0-$k1 _ _ O
$ _ _ O
gp _ _ O
$ _ _ O
sp _ _ O
$ _ _ O
fp _ _ O
$ _ _ O
ra _ _ O
Register _ _ O
number _ _ O
Usage _ _ O
0 _ _ O
the _ _ O
constant _ _ O
value _ _ O
0 _ _ O
( _ _ O
ca _ _ O
n't _ _ O
be _ _ O
written _ _ O
) _ _ O
1 _ _ O
assembler _ _ O
temporary _ _ O
2 _ _ O
- _ _ O
3 _ _ O
values _ _ O
for _ _ O
results _ _ O
and _ _ O
expression _ _ O
evaluation _ _ O
4 _ _ O
- _ _ O
7 _ _ O
function _ _ O
arguments _ _ O
8 _ _ O
- _ _ O
15 _ _ O
unsaved _ _ O
temporaries _ _ O
16 _ _ O
- _ _ O
23 _ _ O
saved _ _ O
temporaries _ _ O
( _ _ O
like _ _ O
program _ _ O
variables _ _ O
) _ _ O
24 _ _ O
- _ _ O
25 _ _ O
more _ _ O
unsaved _ _ O
temporaries _ _ O
26 _ _ O
- _ _ O
27 _ _ O
reserved _ _ O
for _ _ O
OS _ _ O
kernel _ _ O
28 _ _ O
global _ _ O
pointer _ _ O
29 _ _ O
stack _ _ O
pointer _ _ O
30 _ _ O
frame _ _ O
pointer _ _ O
31 _ _ O
return _ _ O
address _ _ O
10 _ _ O

The _ _ O
MIPS _ _ O
ISA _ _ O
- _ _ O
Memory _ _ O
● _ _ O
MIPS _ _ O
is _ _ O
a _ _ O
RISC _ _ O
( _ _ O
reduced _ _ O
instruction _ _ O
set _ _ O
computer _ _ O
) _ _ O
architecture _ _ O
● _ _ O
It _ _ O
is _ _ O
also _ _ O
a _ _ O
load-store _ _ O
architecture _ _ O
o _ _ O
All _ _ O
memory _ _ O
accesses _ _ O
performed _ _ O
by _ _ O
load _ _ O
and _ _ O
store _ _ O
instructions _ _ O
● _ _ O
Memory _ _ O
is _ _ O
a _ _ O
giant _ _ O
array _ _ O
of _ _ O
232 _ _ O
bytes _ _ O
Addr _ _ O
Data _ _ O
Addr _ _ O
Data _ _ O
Addr _ _ O
Data _ _ O
0 _ _ O
0x3F _ _ O
0 _ _ O
0x3F00 _ _ O
0 _ _ O
0x3F002A08 _ _ O
1 _ _ O
0x00 _ _ O
2 _ _ O
0x2A08 _ _ O
4 _ _ O
0x47F426B9 _ _ O
2 _ _ O
0x2A _ _ O
4 _ _ O
0x47F4 _ _ O
... _ _ O
... _ _ O
3 _ _ O
0x08 _ _ O
6 _ _ O
0x26B9 _ _ O
4 _ _ O
0x47 _ _ O
... _ _ O
... _ _ O
5 _ _ O
0xF4 _ _ O
6 _ _ O
0x26 _ _ O
7 _ _ O
0xB9 _ _ O
... _ _ O
... _ _ O
• _ _ O
The _ _ O
same _ _ O
memory _ _ O
viewed _ _ O
as _ _ O
bytes _ _ O
, _ _ O
16-bit _ _ O
halfwords _ _ O
, _ _ O
and _ _ O
32-bit _ _ O
words _ _ O
( _ _ O
using _ _ O
big-endian _ _ O
) _ _ O
• _ _ O
All _ _ O
addresses _ _ O
are _ _ O
aligned _ _ O
( _ _ O
multiples _ _ O
of _ _ O
data _ _ O
size _ _ O
) _ _ O
11 _ _ O

The _ _ O
MIPS _ _ O
ISA _ _ O
- _ _ O
Memory _ _ O
• _ _ O
Loads _ _ O
move _ _ O
data _ _ O
from _ _ O
memory _ _ O
into _ _ O
the _ _ O
registers _ _ O
. _ _ O
lw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
8 _ _ O
( _ _ O
$s4 _ _ O
) _ _ O
0x0000CAFE _ _ O
0x0000BEEF _ _ O
s4 _ _ O
0x00000004 _ _ O
Registers _ _ O
registers _ _ O
into _ _ O
memory _ _ O
. _ _ O
sw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
12 _ _ O
( _ _ O
$s4 _ _ O
) _ _ O
This _ _ O
is _ _ O
the _ _ O
address _ _ O
, _ _ O
and _ _ O
it _ _ O
means _ _ O
" _ _ O
the _ _ O
value _ _ O
of _ _ O
$ _ _ O
s4 _ _ O
+ _ _ O
8 _ _ O
. _ _ O
" _ _ O
t0 _ _ O
• _ _ O
Stores _ _ O
move _ _ O
data _ _ O
from _ _ O
the _ _ O
$ _ _ O
t0 _ _ O
is _ _ O
the _ _ O
SOURCE _ _ O
! _ _ O
0 _ _ O
0x3F002A08 _ _ O
4 _ _ O
0x47F426B9 _ _ O
8 _ _ O
0x00000000 _ _ O
$ _ _ O
s4 _ _ O
+ _ _ O
8 _ _ O
12 _ _ O
0x0000BEEF _ _ O
$ _ _ O
s4 _ _ O
+ _ _ O
12 _ _ O
16 _ _ O
0x0000DEAD _ _ O
0x0000BEEF _ _ O
... _ _ O
... _ _ O
lw _ _ O
sw _ _ O
Memory _ _ O
12 _ _ O

The _ _ O
MIPS _ _ O
ISA _ _ O
– _ _ O
Flow _ _ O
control _ _ O
● _ _ O
Jump _ _ O
and _ _ O
branch _ _ O
instructions _ _ O
change _ _ O
the _ _ O
flow _ _ O
of _ _ O
execution _ _ O
. _ _ O
_ _ _ O
top _ _ O
: _ _ O
# _ _ O
.... _ _ O
# _ _ O
lots _ _ O
o _ _ O
' _ _ O
code _ _ O
# _ _ O
.... _ _ O
j _ _ O
_ _ _ O
top _ _ O
li _ _ O
$ _ _ O
s0 _ _ O
, _ _ O
10 _ _ O
_ _ _ O
loop _ _ O
: _ _ O
# _ _ O
.... _ _ O
addi _ _ O
$ _ _ O
s0 _ _ O
, _ _ O
$ _ _ O
s0 _ _ O
, _ _ O
-1 _ _ O
bne _ _ O
$ _ _ O
s0 _ _ O
, _ _ O
$ _ _ O
zero _ _ O
, _ _ O
_ _ _ O
loop _ _ O
jr _ _ O
$ _ _ O
ra _ _ O
j _ _ O
: _ _ O
jumps _ _ O
unconditionally _ _ O
• _ _ O
jumps _ _ O
to _ _ O
_ _ _ O
top _ _ O
bne _ _ O
: _ _ O
jumps _ _ O
conditionally _ _ O
If _ _ O
$ _ _ O
s0 _ _ O
! _ _ O
= _ _ O
$ _ _ O
zero _ _ O
, _ _ O
jumps _ _ O
to _ _ O
_ _ _ O
loop _ _ O
If _ _ O
$ _ _ O
s0 _ _ O
= _ _ O
= _ _ O
$ _ _ O
zero _ _ O
, _ _ O
continues _ _ O
to _ _ O
jr _ _ O
$ _ _ O
ra _ _ O
13 _ _ O

Phases _ _ O
of _ _ O
instruction _ _ O
execution _ _ O
● _ _ O
In _ _ O
most _ _ O
architectures _ _ O
, _ _ O
there _ _ O
are _ _ O
five _ _ O
phases _ _ O
: _ _ O
1 _ _ O
. _ _ O
IF _ _ O
( _ _ O
Instruction _ _ O
Fetch _ _ O
) _ _ O
– _ _ O
get _ _ O
next _ _ O
instruction _ _ O
from _ _ O
memory _ _ O
2 _ _ O
. _ _ O
ID _ _ O
( _ _ O
Instruction _ _ O
Decode _ _ O
) _ _ O
– _ _ O
figure _ _ O
out _ _ O
what _ _ O
instruction _ _ O
it _ _ O
is _ _ O
3 _ _ O
. _ _ O
EX _ _ O
( _ _ O
Execute _ _ O
– _ _ O
ALU _ _ O
) _ _ O
– _ _ O
do _ _ O
any _ _ O
arithmetic _ _ O
4 _ _ O
. _ _ O
MEM _ _ O
( _ _ O
Memory _ _ O
) _ _ O
– _ _ O
read _ _ O
or _ _ O
write _ _ O
data _ _ O
from _ _ O
/ _ _ O
to _ _ O
memory _ _ O
5 _ _ O
. _ _ O
WB _ _ O
( _ _ O
Register _ _ O
Writeback _ _ O
) _ _ O
– _ _ O
write _ _ O
any _ _ O
results _ _ O
to _ _ O
the _ _ O
registers _ _ O
● _ _ O
Sometimes _ _ O
these _ _ O
phases _ _ O
are _ _ O
chopped _ _ O
into _ _ O
smaller _ _ O
stages _ _ O
14 _ _ O

A _ _ O
simple _ _ O
single-cycle _ _ O
implementation _ _ O
Instruction _ _ O
Memory _ _ O
Control _ _ O
PC _ _ O
Register _ _ O
File _ _ O
IF _ _ O
ID _ _ O
WB _ _ O
ALU _ _ O
EX _ _ O
Data _ _ O
Memory _ _ O
MEM _ _ O
● _ _ O
An _ _ O
instruction _ _ O
goes _ _ O
through _ _ O
IF _ _ O
/ _ _ O
ID _ _ O
/ _ _ O
EX _ _ O
/ _ _ O
MEM _ _ O
/ _ _ O
WB _ _ O
in _ _ O
one _ _ O
cycle _ _ O
15 _ _ O

" _ _ O
Minimal _ _ O
MIPS _ _ O
" _ _ O
16 _ _ O

It _ _ O
’s _ _ O
a _ _ O
“ _ _ O
subset _ _ O
” _ _ O
of _ _ O
MIPS _ _ O
● _ _ O
For _ _ O
pedagogical _ _ O
( _ _ O
teaching _ _ O
) _ _ O
purposes _ _ O
● _ _ O
Contains _ _ O
only _ _ O
a _ _ O
minimal _ _ O
number _ _ O
of _ _ O
instructions _ _ O
: _ _ O
o _ _ O
lw _ _ O
, _ _ O
sw _ _ O
, _ _ O
add _ _ O
, _ _ O
sub _ _ O
, _ _ O
and _ _ O
, _ _ O
or _ _ O
, _ _ O
slt _ _ O
, _ _ O
beq _ _ O
, _ _ O
and _ _ O
j _ _ O
o _ _ O
Other _ _ O
instructions _ _ O
in _ _ O
MIPS _ _ O
are _ _ O
variations _ _ O
on _ _ O
these _ _ O
anyway _ _ O
● _ _ O
Let _ _ O
's _ _ O
review _ _ O
the _ _ O
Minimal _ _ O
MIPS _ _ O
CPU _ _ O
focusing _ _ O
on _ _ O
the _ _ O
control _ _ O
signals _ _ O
o _ _ O
Again _ _ O
, _ _ O
these _ _ O
control _ _ O
signals _ _ O
are _ _ O
decoded _ _ O
from _ _ O
the _ _ O
instruction _ _ O
17 _ _ O

The _ _ O
Minimal _ _ O
MIPS _ _ O
single-cycle _ _ O
CPU _ _ O
● _ _ O
A _ _ O
more _ _ O
detailed _ _ O
view _ _ O
of _ _ O
the _ _ O
5-phase _ _ O
implementation _ _ O
Instruction _ _ O
Memory _ _ O
Ins _ _ O
. _ _ O
Decoder _ _ O
PC _ _ O
PCSrc _ _ O
+ _ _ O
4 _ _ O
+ _ _ O
imm _ _ O
field _ _ O
dst _ _ O
src1 _ _ O
src2 _ _ O
RegDataSrc _ _ O
Data _ _ O
Memory _ _ O
Register _ _ O
File _ _ O
RegWrite _ _ O
imm _ _ O
field _ _ O
sxt _ _ O
MemWrite _ _ O
ALUSrc _ _ O
ALUOp _ _ O
18 _ _ O

Control _ _ O
signals _ _ O
● _ _ O
Registers _ _ O
o _ _ O
RegDataSrc _ _ O
: _ _ O
controls _ _ O
source _ _ O
of _ _ O
a _ _ O
register _ _ O
write _ _ O
( _ _ O
ALU _ _ O
/ _ _ O
memory _ _ O
) _ _ O
o _ _ O
RegWrite _ _ O
: _ _ O
enables _ _ O
a _ _ O
write _ _ O
to _ _ O
the _ _ O
register _ _ O
file _ _ O
o _ _ O
src1 _ _ O
, _ _ O
src2 _ _ O
, _ _ O
dst _ _ O
: _ _ O
the _ _ O
register _ _ O
number _ _ O
for _ _ O
each _ _ O
respective _ _ O
operand _ _ O
● _ _ O
ALU _ _ O
o _ _ O
ALUSrc _ _ O
: _ _ O
whether _ _ O
second _ _ O
operand _ _ O
of _ _ O
ALU _ _ O
is _ _ O
a _ _ O
register _ _ O
/ _ _ O
immediate _ _ O
o _ _ O
ALUOp _ _ O
: _ _ O
controls _ _ O
what _ _ O
the _ _ O
ALU _ _ O
will _ _ O
do _ _ O
( _ _ O
add _ _ O
, _ _ O
sub _ _ O
, _ _ O
and _ _ O
, _ _ O
or _ _ O
etc _ _ O
) _ _ O
● _ _ O
Memory _ _ O
o _ _ O
MemWrite _ _ O
: _ _ O
enables _ _ O
a _ _ O
write _ _ O
to _ _ O
data _ _ O
memory _ _ O
● _ _ O
PC _ _ O
o _ _ O
PCSrc _ _ O
: _ _ O
controls _ _ O
source _ _ O
of _ _ O
next _ _ O
PC _ _ O
( _ _ O
PC _ _ O
+ _ _ O
4 _ _ O
/ _ _ O
PC _ _ O
+ _ _ O
4 _ _ O
+ _ _ O
imm _ _ O
) _ _ O
→ _ _ O
All _ _ O
these _ _ O
signals _ _ O
are _ _ O
decoded _ _ O
from _ _ O
the _ _ O
instruction _ _ O
! _ _ O
19 _ _ O

How _ _ O
an _ _ O
add _ _ O
/ _ _ O
sub _ _ O
/ _ _ O
and _ _ O
/ _ _ O
or _ _ O
/ _ _ O
slt _ _ O
work _ _ O
Instruction _ _ O
Memory _ _ O
Ins _ _ O
. _ _ O
Decoder _ _ O
PC _ _ O
PCSrc _ _ O
+ _ _ O
4 _ _ O
add _ _ O
t0 _ _ O
, _ _ O
t3 _ _ O
, _ _ O
s0 _ _ O
+ _ _ O
imm _ _ O
field _ _ O
next _ _ O
instruction _ _ O
t0 _ _ O
dst _ _ O
t3 _ _ O
src1 _ _ O
s0 _ _ O
src2 _ _ O
Register _ _ O
Data _ _ O
Memory _ _ O
MemWrite _ _ O
File _ _ O
RegDataSrc _ _ O
from _ _ O
ALU _ _ O
RegWrite _ _ O
enable _ _ O
imm _ _ O
field _ _ O
sxt _ _ O
disable _ _ O
ALUSrc _ _ O
from _ _ O
reg _ _ O
ALUOp _ _ O
add _ _ O
20 _ _ O

How _ _ O
an _ _ O
lw _ _ O
works _ _ O
Instruction _ _ O
Memory _ _ O
Ins _ _ O
. _ _ O
Decoder _ _ O
PC _ _ O
PCSrc _ _ O
+ _ _ O
4 _ _ O
lw _ _ O
s4 _ _ O
, _ _ O
12 _ _ O
( _ _ O
s0 _ _ O
) _ _ O
+ _ _ O
imm _ _ O
field _ _ O
next _ _ O
instruction _ _ O
s4 _ _ O
dst _ _ O
s0src1 _ _ O
x _ _ O
src2 _ _ O
Register _ _ O
Data _ _ O
Memory _ _ O
MemWrite _ _ O
File _ _ O
RegWrite _ _ O
RegDataSrc _ _ O
enable _ _ O
from _ _ O
Mem _ _ O
12 _ _ O
sxt _ _ O
imm _ _ O
field _ _ O
disable _ _ O
ALUSrc _ _ O
from _ _ O
imm _ _ O
ALUOp _ _ O
add _ _ O
21 _ _ O

How _ _ O
an _ _ O
sw _ _ O
works _ _ O
Instruction _ _ O
Memory _ _ O
Ins _ _ O
. _ _ O
Decoder _ _ O
PC _ _ O
PCSrc _ _ O
+ _ _ O
4 _ _ O
sw _ _ O
t3 _ _ O
, _ _ O
8 _ _ O
( _ _ O
sp _ _ O
) _ _ O
+ _ _ O
imm _ _ O
field _ _ O
next _ _ O
instruction _ _ O
x _ _ O
dst _ _ O
spsrc1 _ _ O
t3 _ _ O
src2 _ _ O
Register _ _ O
Data _ _ O
Memory _ _ O
MemWrite _ _ O
File _ _ O
RegWrite _ _ O
RegDataSrc _ _ O
disable _ _ O
x _ _ O
8 _ _ O
sxt _ _ O
imm _ _ O
field _ _ O
enable _ _ O
ALUSrc _ _ O
from _ _ O
imm _ _ O
ALUOp _ _ O
add _ _ O
22 _ _ O

What _ _ O
about _ _ O
beq _ _ O
? _ _ O
● _ _ O
Compares _ _ O
numbers _ _ O
by _ _ O
subtracting _ _ O
and _ _ O
see _ _ O
if _ _ O
result _ _ O
is _ _ O
0 _ _ O
o _ _ O
If _ _ O
result _ _ O
is _ _ O
0 _ _ O
, _ _ O
we _ _ O
set _ _ O
PCSrc _ _ O
to _ _ O
use _ _ O
the _ _ O
branch _ _ O
target _ _ O
. _ _ O
o _ _ O
Otherwise _ _ O
, _ _ O
we _ _ O
set _ _ O
PCSrc _ _ O
to _ _ O
PC _ _ O
+ _ _ O
4 _ _ O
. _ _ O
isBEQ _ _ O
isZero _ _ O
• _ _ O
Instruction _ _ O
decoder _ _ O
outputs _ _ O
isBEQ _ _ O
• _ _ O
1 _ _ O
: _ _ O
When _ _ O
instruction _ _ O
is _ _ O
beq _ _ O
• _ _ O
0 _ _ O
: _ _ O
When _ _ O
instruction _ _ O
not _ _ O
beq _ _ O
ALU _ _ O
PCSrc _ _ O
• _ _ O
When _ _ O
PCSrc _ _ O
is _ _ O
1 _ _ O
, _ _ O
PC _ _ O
= _ _ O
PC _ _ O
+ _ _ O
4 _ _ O
+ _ _ O
imm _ _ O
( _ _ O
relative _ _ O
branch _ _ O
target _ _ O
) _ _ O
• _ _ O
When _ _ O
PCSrc _ _ O
is _ _ O
0 _ _ O
, _ _ O
PC _ _ O
= _ _ O
PC _ _ O
+ _ _ O
4 _ _ O
23 _ _ O

How _ _ O
a _ _ O
beq _ _ O
works _ _ O
beq _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
loop _ _ O
Instruction _ _ O
Memory _ _ O
Ins _ _ O
. _ _ O
Decoder _ _ O
PC _ _ O
PCSrc _ _ O
+ _ _ O
4 _ _ O
Take _ _ O
green _ _ O
PC _ _ O
path _ _ O
when _ _ O
t0 _ _ O
= _ _ O
= _ _ O
t1 _ _ O
Take _ _ O
red _ _ O
PC _ _ O
path _ _ O
when _ _ O
t0 _ _ O
! _ _ O
= _ _ O
t1 _ _ O
+ _ _ O
imm _ _ O
field _ _ O
loop _ _ O
x _ _ O
dst _ _ O
t0 _ _ O
src1 _ _ O
t1 _ _ O
src2 _ _ O
RegDataSrc _ _ O
x _ _ O
Data _ _ O
Memory _ _ O
Register _ _ O
File _ _ O
RegWrite _ _ O
disable _ _ O
imm _ _ O
field _ _ O
sxt _ _ O
MemWrite _ _ O
disable _ _ O
ALUSrc _ _ O
from _ _ O
reg _ _ O
ALUOp _ _ O
sub _ _ O
24 _ _ O

What _ _ O
about _ _ O
j _ _ O
? _ _ O
● _ _ O
We _ _ O
have _ _ O
to _ _ O
add _ _ O
another _ _ O
input _ _ O
to _ _ O
the _ _ O
PCSrc _ _ O
mux _ _ O
. _ _ O
j _ _ O
top _ _ O
PC+4 _ _ O
PC+4+imm _ _ O
jump _ _ O
target _ _ O
( _ _ O
now _ _ O
2 _ _ O
bits _ _ O
) _ _ O
PCSrc _ _ O
25 _ _ O

A _ _ O
Single-cycle _ _ O
Implementation _ _ O
is _ _ O
not _ _ O
Optimal _ _ O
Instruction _ _ O
Memory _ _ O
Control _ _ O
PC _ _ O
Register _ _ O
File _ _ O
IF _ _ O
ID _ _ O
WB _ _ O
ALU _ _ O
EX _ _ O
Data _ _ O
Memory _ _ O
MEM _ _ O
● _ _ O
Why _ _ O
? _ _ O
Since _ _ O
the _ _ O
longest _ _ O
critical _ _ O
path _ _ O
must _ _ O
be _ _ O
chosen _ _ O
for _ _ O
cycle _ _ O
time _ _ O
o _ _ O
And _ _ O
there _ _ O
is _ _ O
a _ _ O
wide _ _ O
variation _ _ O
among _ _ O
different _ _ O
instructions _ _ O
26 _ _ O

A _ _ O
Single-cycle _ _ O
Implementation _ _ O
is _ _ O
not _ _ O
Optimal _ _ O
● _ _ O
In _ _ O
our _ _ O
CPU _ _ O
, _ _ O
the _ _ O
lw _ _ O
instruction _ _ O
has _ _ O
the _ _ O
longest _ _ O
critical _ _ O
path _ _ O
o _ _ O
Must _ _ O
go _ _ O
through _ _ O
all _ _ O
5 _ _ O
stages _ _ O
: _ _ O
IF _ _ O
/ _ _ O
ID _ _ O
/ _ _ O
EX _ _ O
/ _ _ O
MEM _ _ O
/ _ _ O
WB _ _ O
o _ _ O
Whereas _ _ O
add _ _ O
goes _ _ O
through _ _ O
just _ _ O
4 _ _ O
stages _ _ O
: _ _ O
IF _ _ O
/ _ _ O
ID _ _ O
/ _ _ O
EX _ _ O
/ _ _ O
WB _ _ O
● _ _ O
If _ _ O
each _ _ O
phase _ _ O
takes _ _ O
1 _ _ O
ns _ _ O
each _ _ O
, _ _ O
cycle _ _ O
time _ _ O
must _ _ O
be _ _ O
5 _ _ O
ns _ _ O
: _ _ O
o _ _ O
Because _ _ O
it _ _ O
needs _ _ O
to _ _ O
be _ _ O
able _ _ O
to _ _ O
handle _ _ O
lw _ _ O
, _ _ O
which _ _ O
takes _ _ O
5 _ _ O
ns _ _ O
o _ _ O
add _ _ O
also _ _ O
takes _ _ O
5 _ _ O
ns _ _ O
when _ _ O
it _ _ O
could _ _ O
have _ _ O
been _ _ O
done _ _ O
in _ _ O
4 _ _ O
ns _ _ O
Q _ _ O
) _ _ O
If _ _ O
lw _ _ O
is _ _ O
1 _ _ O
% _ _ O
and _ _ O
add _ _ O
is _ _ O
99 _ _ O
% _ _ O
of _ _ O
instruction _ _ O
mix _ _ O
, _ _ O
what _ _ O
is _ _ O
the _ _ O
average _ _ O
instruction _ _ O
execution _ _ O
time _ _ O
? _ _ O
A _ _ O
) _ _ O
Still _ _ O
5 _ _ O
ns _ _ O
! _ _ O
Even _ _ O
if _ _ O
lw _ _ O
is _ _ O
only _ _ O
1 _ _ O
% _ _ O
of _ _ O
instructions _ _ O
! _ _ O
27 _ _ O

A _ _ O
Multi-cycle _ _ O
Implementation _ _ O
● _ _ O
It _ _ O
takes _ _ O
one _ _ O
cycle _ _ O
for _ _ O
each _ _ O
phase _ _ O
through _ _ O
the _ _ O
use _ _ O
of _ _ O
internal _ _ O
latches _ _ O
Memory _ _ O
ID _ _ O
Ins _ _ O
. _ _ O
Decoder _ _ O
IF _ _ O
Register _ _ O
File _ _ O
EX _ _ O
ALU _ _ O
MEM _ _ O
Memory _ _ O
WB _ _ O
28 _ _ O

A _ _ O
Multi-cycle _ _ O
Implementation _ _ O
is _ _ O
Faster _ _ O
! _ _ O
● _ _ O
Now _ _ O
each _ _ O
instruction _ _ O
takes _ _ O
different _ _ O
number _ _ O
of _ _ O
cycles _ _ O
to _ _ O
complete _ _ O
o _ _ O
lw _ _ O
takes _ _ O
5 _ _ O
cycles _ _ O
: _ _ O
IF _ _ O
/ _ _ O
ID _ _ O
/ _ _ O
EX _ _ O
/ _ _ O
MEM _ _ O
/ _ _ O
WB _ _ O
o _ _ O
add _ _ O
takes _ _ O
4 _ _ O
cycles _ _ O
: _ _ O
IF _ _ O
/ _ _ O
ID _ _ O
/ _ _ O
EX _ _ O
/ _ _ O
WB _ _ O
● _ _ O
If _ _ O
each _ _ O
phase _ _ O
takes _ _ O
1 _ _ O
ns _ _ O
as _ _ O
before _ _ O
: _ _ O
o _ _ O
lw _ _ O
takes _ _ O
5 _ _ O
ns _ _ O
and _ _ O
add _ _ O
takes _ _ O
4 _ _ O
ns _ _ O
Q _ _ O
) _ _ O
If _ _ O
lw _ _ O
is _ _ O
1 _ _ O
% _ _ O
and _ _ O
add _ _ O
is _ _ O
99 _ _ O
% _ _ O
of _ _ O
instruction _ _ O
mix _ _ O
, _ _ O
what _ _ O
is _ _ O
the _ _ O
average _ _ O
instruction _ _ O
execution _ _ O
time _ _ O
? _ _ O
A _ _ O
) _ _ O
0.01 _ _ O
* _ _ O
5 _ _ O
ns _ _ O
+ _ _ O
0.99 _ _ O
* _ _ O
4 _ _ O
ns _ _ O
= _ _ O
4.01 _ _ O
ns _ _ O
( _ _ O
25 _ _ O
% _ _ O
faster _ _ O
than _ _ O
single _ _ O
cycle _ _ O
) _ _ O
* _ _ O
Caveat _ _ O
: _ _ O
delay _ _ O
due _ _ O
to _ _ O
the _ _ O
added _ _ O
latches _ _ O
not _ _ O
shown _ _ O
, _ _ O
but _ _ O
net _ _ O
win _ _ O
29 _ _ O

And _ _ O
we _ _ O
can _ _ O
do _ _ O
even _ _ O
better _ _ O
! _ _ O
● _ _ O
Did _ _ O
you _ _ O
notice _ _ O
? _ _ O
o _ _ O
When _ _ O
an _ _ O
instruction _ _ O
is _ _ O
on _ _ O
a _ _ O
particular _ _ O
phase _ _ O
( _ _ O
e.g. _ _ O
IF _ _ O
) _ _ O
… _ _ O
o _ _ O
… _ _ O
other _ _ O
phases _ _ O
( _ _ O
ID _ _ O
/ _ _ O
EX _ _ O
/ _ _ O
MEM _ _ O
/ _ _ O
WB _ _ O
) _ _ O
are _ _ O
not _ _ O
doing _ _ O
any _ _ O
work _ _ O
! _ _ O
● _ _ O
Our _ _ O
CPU _ _ O
is _ _ O
getting _ _ O
chronically _ _ O
underutilized _ _ O
! _ _ O
o _ _ O
If _ _ O
CPU _ _ O
is _ _ O
a _ _ O
factory _ _ O
, _ _ O
80 _ _ O
% _ _ O
( _ _ O
4 _ _ O
/ _ _ O
5 _ _ O
) _ _ O
of _ _ O
the _ _ O
workers _ _ O
are _ _ O
idling _ _ O
! _ _ O
● _ _ O
Car _ _ O
factories _ _ O
create _ _ O
an _ _ O
assembly _ _ O
line _ _ O
to _ _ O
solve _ _ O
this _ _ O
problem _ _ O
o _ _ O
No _ _ O
need _ _ O
to _ _ O
wait _ _ O
until _ _ O
a _ _ O
car _ _ O
is _ _ O
finished _ _ O
before _ _ O
starting _ _ O
on _ _ O
next _ _ O
one _ _ O
o _ _ O
Our _ _ O
CPU _ _ O
is _ _ O
going _ _ O
to _ _ O
use _ _ O
a _ _ O
pipeline _ _ O
( _ _ O
similar _ _ O
concept _ _ O
) _ _ O
30 _ _ O



