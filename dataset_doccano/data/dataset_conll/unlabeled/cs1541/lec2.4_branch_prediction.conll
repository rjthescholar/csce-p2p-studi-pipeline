unlabeled|cs1541|lec2.4_branch_prediction
-DOCSTART- -X- -X- O

Branch _ _ O
Prediction _ _ O
and _ _ O
Predication _ _ O
CS _ _ O
1541 _ _ O
Wonsun _ _ O
Ahn _ _ O

Branch _ _ O
Prediction _ _ O
2 _ _ O

Solution _ _ O
3 _ _ O
: _ _ O
Branch _ _ O
Prediction _ _ O
● _ _ O
Comparator _ _ O
at _ _ O
ID _ _ O
stage _ _ O
is _ _ O
not _ _ O
completely _ _ O
satisfactory _ _ O
o _ _ O
Still _ _ O
creates _ _ O
one _ _ O
bubble _ _ O
on _ _ O
a _ _ O
taken _ _ O
branch _ _ O
o _ _ O
Also _ _ O
extra _ _ O
bubbles _ _ O
due _ _ O
to _ _ O
data _ _ O
hazards _ _ O
at _ _ O
the _ _ O
ID _ _ O
stage _ _ O
● _ _ O
What _ _ O
if _ _ O
… _ _ O
o _ _ O
We _ _ O
were _ _ O
able _ _ O
to _ _ O
predict _ _ O
the _ _ O
branch _ _ O
outcome _ _ O
? _ _ O
o _ _ O
But _ _ O
without _ _ O
comparing _ _ O
registers _ _ O
? _ _ O
● _ _ O
What _ _ O
would _ _ O
that _ _ O
get _ _ O
us _ _ O
? _ _ O
1 _ _ O
. _ _ O
We _ _ O
could _ _ O
make _ _ O
the _ _ O
prediction _ _ O
at _ _ O
the _ _ O
IF _ _ O
stage _ _ O
▪ _ _ O
We _ _ O
can _ _ O
start _ _ O
fetching _ _ O
on _ _ O
the _ _ O
correct _ _ O
path _ _ O
at _ _ O
very _ _ O
next _ _ O
cycle _ _ O
! _ _ O
2 _ _ O
. _ _ O
No _ _ O
extra _ _ O
data _ _ O
hazard _ _ O
bubbles _ _ O
▪ _ _ O
We _ _ O
are _ _ O
not _ _ O
even _ _ O
reading _ _ O
register _ _ O
values _ _ O
, _ _ O
remember _ _ O
? _ _ O
3 _ _ O

What _ _ O
if _ _ O
branch _ _ O
is _ _ O
mispredicted _ _ O
? _ _ O
● _ _ O
HDU _ _ O
can _ _ O
flush _ _ O
pipeline _ _ O
of _ _ O
wrong _ _ O
path _ _ O
instructions _ _ O
, _ _ O
just _ _ O
like _ _ O
before _ _ O
o _ _ O
Misprediction _ _ O
becomes _ _ O
a _ _ O
performance _ _ O
, _ _ O
not _ _ O
a _ _ O
correctness _ _ O
issue _ _ O
Time _ _ O
blt _ _ O
s0 _ _ O
, _ _ O
10 _ _ O
, _ _ O
top _ _ O
la _ _ O
a0 _ _ O
, _ _ O
done_msg _ _ O
jal _ _ O
printf _ _ O
s0 _ _ O
< _ _ O
10 _ _ O
... _ _ O
OOPS _ _ O
! _ _ O
move _ _ O
a0 _ _ O
, _ _ O
s0 _ _ O
0 _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
IF _ _ O
ID _ _ O
EX _ _ O
MEM _ _ O
WB _ _ O
IF _ _ O
ID _ _ O
IF _ _ O
ID _ _ O
5 _ _ O
6 _ _ O
7 _ _ O
EX _ _ O
MEM _ _ O
WB _ _ O
IF _ _ O
4 _ _ O

Taken _ _ O
/ _ _ O
Not _ _ O
Taken _ _ O
Branch _ _ O
Prediction _ _ O
● _ _ O
We _ _ O
have _ _ O
been _ _ O
doing _ _ O
a _ _ O
form _ _ O
of _ _ O
branch _ _ O
prediction _ _ O
all _ _ O
along _ _ O
! _ _ O
o _ _ O
We _ _ O
assumed _ _ O
that _ _ O
all _ _ O
branches _ _ O
will _ _ O
be _ _ O
not _ _ O
taken _ _ O
● _ _ O
Two _ _ O
simple _ _ O
policies _ _ O
: _ _ O
o _ _ O
Predict _ _ O
not _ _ O
taken _ _ O
: _ _ O
continue _ _ O
fetching _ _ O
PC _ _ O
+ _ _ O
4 _ _ O
, _ _ O
flush _ _ O
if _ _ O
taken _ _ O
Pro _ _ O
: _ _ O
Can _ _ O
start _ _ O
fetching _ _ O
the _ _ O
next _ _ O
instruction _ _ O
immediately _ _ O
Con _ _ O
: _ _ O
~67 _ _ O
% _ _ O
of _ _ O
branches _ _ O
are _ _ O
taken _ _ O
( _ _ O
due _ _ O
to _ _ O
loops _ _ O
) _ _ O
→ _ _ O
many _ _ O
flushes _ _ O
o _ _ O
Predict _ _ O
taken _ _ O
: _ _ O
fetch _ _ O
branch _ _ O
target _ _ O
, _ _ O
flush _ _ O
if _ _ O
not _ _ O
taken _ _ O
Pro _ _ O
: _ _ O
~67 _ _ O
% _ _ O
of _ _ O
branches _ _ O
are _ _ O
taken _ _ O
( _ _ O
due _ _ O
to _ _ O
loops _ _ O
) _ _ O
→ _ _ O
less _ _ O
flushes _ _ O
Con _ _ O
: _ _ O
ID _ _ O
stage _ _ O
must _ _ O
decode _ _ O
branch _ _ O
target _ _ O
before _ _ O
fetch _ _ O
→ _ _ O
bubble _ _ O
● _ _ O
Both _ _ O
are _ _ O
non-ideal _ _ O
: _ _ O
there _ _ O
are _ _ O
better _ _ O
ways _ _ O
to _ _ O
predict _ _ O
! _ _ O
5 _ _ O

Types _ _ O
of _ _ O
Branch _ _ O
Prediction _ _ O
● _ _ O
Static _ _ O
Branch _ _ O
Prediction _ _ O
o _ _ O
Predicting _ _ O
branch _ _ O
behavior _ _ O
based _ _ O
on _ _ O
code _ _ O
analysis _ _ O
o _ _ O
Compiler _ _ O
gives _ _ O
hints _ _ O
about _ _ O
branch _ _ O
direction _ _ O
through _ _ O
ISA _ _ O
o _ _ O
Not _ _ O
used _ _ O
nowadays _ _ O
due _ _ O
to _ _ O
inaccuracy _ _ O
of _ _ O
compiler _ _ O
predictions _ _ O
● _ _ O
Dynamic _ _ O
Branch _ _ O
Prediction _ _ O
o _ _ O
Predicting _ _ O
branch _ _ O
behavior _ _ O
based _ _ O
on _ _ O
( _ _ O
dynamic _ _ O
) _ _ O
branch _ _ O
history _ _ O
o _ _ O
Typically _ _ O
using _ _ O
hardware _ _ O
that _ _ O
tracks _ _ O
history _ _ O
information _ _ O
o _ _ O
Premise _ _ O
: _ _ O
history _ _ O
repeats _ _ O
itself _ _ O
▪ _ _ O
Branches _ _ O
not _ _ O
taken _ _ O
in _ _ O
the _ _ O
past _ _ O
→ _ _ O
likely _ _ O
not _ _ O
taken _ _ O
in _ _ O
the _ _ O
future _ _ O
( _ _ O
e.g. _ _ O
branches _ _ O
to _ _ O
error _ _ O
handling _ _ O
code _ _ O
) _ _ O
▪ _ _ O
Branches _ _ O
taken _ _ O
in _ _ O
the _ _ O
past _ _ O
→ _ _ O
likely _ _ O
taken _ _ O
in _ _ O
the _ _ O
future _ _ O
( _ _ O
e.g. _ _ O
branch _ _ O
back _ _ O
to _ _ O
the _ _ O
next _ _ O
iteration _ _ O
of _ _ O
the _ _ O
loop _ _ O
) _ _ O
6 _ _ O

The _ _ O
Branch _ _ O
History _ _ O
Table _ _ O
( _ _ O
BHT _ _ O
) _ _ O
● _ _ O
BHT _ _ O
stores _ _ O
Taken _ _ O
( _ _ O
T _ _ O
) _ _ O
or _ _ O
Not _ _ O
Taken _ _ O
( _ _ O
NT _ _ O
) _ _ O
history _ _ O
info _ _ O
for _ _ O
each _ _ O
branch _ _ O
o _ _ O
If _ _ O
branch _ _ O
was _ _ O
taken _ _ O
most _ _ O
recently _ _ O
, _ _ O
T _ _ O
is _ _ O
recorded _ _ O
o _ _ O
If _ _ O
branch _ _ O
was _ _ O
not _ _ O
taken _ _ O
most _ _ O
recently _ _ O
, _ _ O
NT _ _ O
is _ _ O
recorded _ _ O
● _ _ O
BHT _ _ O
is _ _ O
indexed _ _ O
using _ _ O
PC _ _ O
( _ _ O
Program _ _ O
Counter _ _ O
) _ _ O
o _ _ O
Each _ _ O
branch _ _ O
has _ _ O
a _ _ O
unique _ _ O
PC _ _ O
, _ _ O
so _ _ O
a _ _ O
unique _ _ O
entry _ _ O
per _ _ O
branch _ _ O
● _ _ O
BHT _ _ O
, _ _ O
being _ _ O
hardware _ _ O
, _ _ O
is _ _ O
limited _ _ O
in _ _ O
capacity _ _ O
o _ _ O
Can _ _ O
not _ _ O
have _ _ O
a _ _ O
huge _ _ O
table _ _ O
with _ _ O
all _ _ O
PCs _ _ O
possible _ _ O
in _ _ O
a _ _ O
program _ _ O
o _ _ O
Besides _ _ O
, _ _ O
not _ _ O
every _ _ O
PC _ _ O
address _ _ O
contains _ _ O
a _ _ O
branch _ _ O
o _ _ O
Best _ _ O
to _ _ O
use _ _ O
hash _ _ O
table _ _ O
to _ _ O
map _ _ O
branch _ _ O
PCs _ _ O
to _ _ O
( _ _ O
limited _ _ O
) _ _ O
entries _ _ O
7 _ _ O

The _ _ O
Branch _ _ O
History _ _ O
Table _ _ O
( _ _ O
BHT _ _ O
) _ _ O
Hash _ _ O
PC _ _ O
: _ _ O
0x007FA004 _ _ O
0 _ _ O
= _ _ O
= _ _ O
? _ _ O
entry _ _ O
= _ _ O
Hash _ _ O
( _ _ O
PC _ _ O
) _ _ O
if _ _ O
( _ _ O
entry.PC _ _ O
= _ _ O
= _ _ O
PC _ _ O
& _ _ O
& _ _ O
entry.pred _ _ O
= _ _ O
= _ _ O
T _ _ O
) _ _ O
NextPC _ _ O
= _ _ O
inst.target _ _ O
else _ _ O
NextPC _ _ O
= _ _ O
PC+4 _ _ O
# _ _ O
Branch _ _ O
PC _ _ O
Pred _ _ O
. _ _ O
0 _ _ O
0x007FA004 _ _ O
T _ _ O
1 _ _ O
0x007FC60C _ _ O
NT _ _ O
2 _ _ O
0x007FA058 _ _ O
T _ _ O
3 _ _ O
NT _ _ O
... _ _ O
4 _ _ O
0x007FC380 _ _ O
T _ _ O
5 _ _ O
... _ _ O
T _ _ O
6 _ _ O
... _ _ O
NT _ _ O
7 _ _ O
... _ _ O
NT _ _ O
T _ _ O
? _ _ O
To _ _ O
filter _ _ O
out _ _ O
conflicts _ _ O
in _ _ O
hash _ _ O
function _ _ O
8 _ _ O

Limitations _ _ O
of _ _ O
Branch _ _ O
History _ _ O
Table _ _ O
( _ _ O
BHT _ _ O
) _ _ O
● _ _ O
Ideally _ _ O
, _ _ O
we _ _ O
would _ _ O
like _ _ O
know _ _ O
what _ _ O
next _ _ O
to _ _ O
fetch _ _ O
at _ _ O
the _ _ O
IF _ _ O
stage _ _ O
o _ _ O
So _ _ O
that _ _ O
correct _ _ O
instruction _ _ O
is _ _ O
immediately _ _ O
fetched _ _ O
in _ _ O
next _ _ O
cycle _ _ O
● _ _ O
BHT _ _ O
can _ _ O
give _ _ O
us _ _ O
branch _ _ O
direction _ _ O
IF _ _ O
stage _ _ O
o _ _ O
All _ _ O
the _ _ O
information _ _ O
needed _ _ O
is _ _ O
the _ _ O
PC _ _ O
( _ _ O
which _ _ O
is _ _ O
available _ _ O
at _ _ O
IF _ _ O
) _ _ O
● _ _ O
But _ _ O
also _ _ O
need _ _ O
the _ _ O
branch _ _ O
target _ _ O
to _ _ O
know _ _ O
what _ _ O
to _ _ O
fetch _ _ O
o _ _ O
Must _ _ O
wait _ _ O
until _ _ O
the _ _ O
ID _ _ O
stage _ _ O
for _ _ O
branch _ _ O
target _ _ O
to _ _ O
be _ _ O
decoded _ _ O
o _ _ O
If _ _ O
NT _ _ O
in _ _ O
BHT _ _ O
: _ _ O
no _ _ O
need _ _ O
to _ _ O
wait _ _ O
( _ _ O
branch _ _ O
target _ _ O
is _ _ O
irrelevant _ _ O
) _ _ O
But _ _ O
if _ _ O
T _ _ O
in _ _ O
BHT _ _ O
: _ _ O
need _ _ O
to _ _ O
wait _ _ O
until _ _ O
ID _ _ O
stage _ _ O
● _ _ O
That _ _ O
introduces _ _ O
a _ _ O
bubble _ _ O
for _ _ O
taken _ _ O
branches _ _ O
9 _ _ O

The _ _ O
Branch _ _ O
Target _ _ O
Buffer _ _ O
( _ _ O
BTB _ _ O
) _ _ O
● _ _ O
BTB _ _ O
stores _ _ O
branch _ _ O
target _ _ O
for _ _ O
each _ _ O
branch _ _ O
● _ _ O
BTB _ _ O
is _ _ O
also _ _ O
indexed _ _ O
using _ _ O
PC _ _ O
of _ _ O
branch _ _ O
using _ _ O
a _ _ O
hash _ _ O
table _ _ O
● _ _ O
BTB _ _ O
allows _ _ O
branch _ _ O
target _ _ O
to _ _ O
be _ _ O
known _ _ O
at _ _ O
the _ _ O
IF _ _ O
stage _ _ O
o _ _ O
No _ _ O
need _ _ O
to _ _ O
wait _ _ O
until _ _ O
ID _ _ O
stage _ _ O
for _ _ O
branch _ _ O
target _ _ O
to _ _ O
be _ _ O
decoded _ _ O
10 _ _ O

The _ _ O
Branch _ _ O
Target _ _ O
Buffer _ _ O
( _ _ O
BTB _ _ O
) _ _ O
Hash _ _ O
PC _ _ O
: _ _ O
0x007FA004 _ _ O
0 _ _ O
= _ _ O
= _ _ O
? _ _ O
entry _ _ O
= _ _ O
Hash _ _ O
( _ _ O
PC _ _ O
) _ _ O
if _ _ O
( _ _ O
entry.PC _ _ O
= _ _ O
= _ _ O
PC _ _ O
) _ _ O
NextPC _ _ O
= _ _ O
entry.target _ _ O
else _ _ O
NextPC _ _ O
= _ _ O
PC+4 _ _ O
# _ _ O
Branch _ _ O
PC _ _ O
Branch _ _ O
Target _ _ O
0 _ _ O
0x007FA004 _ _ O
0x007FA03C _ _ O
1 _ _ O
0x007FC60C _ _ O
0x007FC704 _ _ O
2 _ _ O
0x007FA058 _ _ O
0x007FA040 _ _ O
3 _ _ O
... _ _ O
4 _ _ O
0x007FC380 _ _ O
... _ _ O
0x007FC398 _ _ O
5 _ _ O
... _ _ O
... _ _ O
6 _ _ O
... _ _ O
... _ _ O
7 _ _ O
... _ _ O
... _ _ O
11 _ _ O

BHT _ _ O
+ _ _ O
BTB _ _ O
Combined _ _ O
Branch _ _ O
Predictor _ _ O
Hash _ _ O
PC _ _ O
: _ _ O
0x007FA004 _ _ O
0 _ _ O
= _ _ O
= _ _ O
? _ _ O
entry _ _ O
= _ _ O
Hash _ _ O
( _ _ O
PC _ _ O
) _ _ O
if _ _ O
( _ _ O
entry.PC _ _ O
= _ _ O
= _ _ O
PC _ _ O
& _ _ O
& _ _ O
entry.pred _ _ O
= _ _ O
= _ _ O
T _ _ O
) _ _ O
NextPC _ _ O
= _ _ O
entry.target _ _ O
else _ _ O
NextPC _ _ O
= _ _ O
PC+4 _ _ O
# _ _ O
Branch _ _ O
PC _ _ O
Pred _ _ O
. _ _ O
Branch _ _ O
Target _ _ O
0 _ _ O
0x007FA004 _ _ O
NT _ _ O
0x007FA03C _ _ O
1 _ _ O
0x007FC60C _ _ O
NT _ _ O
0x007FC704 _ _ O
2 _ _ O
0x007FA058 _ _ O
T _ _ O
0x007FA040 _ _ O
3 _ _ O
NT _ _ O
... _ _ O
4 _ _ O
0x007FC380 _ _ O
T _ _ O
0x007FC398 _ _ O
5 _ _ O
... _ _ O
T _ _ O
... _ _ O
6 _ _ O
... _ _ O
NT _ _ O
... _ _ O
7 _ _ O
... _ _ O
NT _ _ O
... _ _ O
... _ _ O
12 _ _ O

Branch _ _ O
Prediction _ _ O
Decision _ _ O
Tree _ _ O
Assuming _ _ O
that _ _ O
branch _ _ O
condition _ _ O
and _ _ O
target _ _ O
are _ _ O
resolved _ _ O
in _ _ O
ID _ _ O
stage _ _ O
Send _ _ O
PC _ _ O
to _ _ O
Instruction _ _ O
memory _ _ O
and _ _ O
BTB _ _ O
IF _ _ O
no _ _ O
ID _ _ O
no _ _ O
Set _ _ O
PC _ _ O
= _ _ O
PC+4 _ _ O
Is _ _ O
instruction _ _ O
a _ _ O
branch _ _ O
? _ _ O
Normal _ _ O
instruction _ _ O
execution _ _ O
Entry _ _ O
found _ _ O
in _ _ O
BTB _ _ O
? _ _ O
yes _ _ O
Branch _ _ O
taken _ _ O
? _ _ O
no _ _ O
Record _ _ O
the _ _ O
entry _ _ O
in _ _ O
BTB _ _ O
yes _ _ O
no _ _ O
yes _ _ O
Branch _ _ O
predictor _ _ O
Set _ _ O
PC _ _ O
= _ _ O
predicted _ _ O
target _ _ O
or _ _ O
PC+4 _ _ O
Prediction _ _ O
was _ _ O
correct _ _ O
? _ _ O
1 _ _ O
. _ _ O
PC _ _ O
= _ _ O
correct _ _ O
target _ _ O
PC _ _ O
2 _ _ O
. _ _ O
Kill _ _ O
instruction _ _ O
in _ _ O
IF _ _ O
3 _ _ O
. _ _ O
Add _ _ O
/ _ _ O
correct _ _ O
the _ _ O
entry _ _ O
in _ _ O
BTB _ _ O
condition _ _ O
target _ _ O
IF.Flush _ _ O
M _ _ O
u _ _ O
x _ _ O
PC _ _ O
+ _ _ O
4 _ _ O
4 _ _ O
yes _ _ O
Normal _ _ O
instruction _ _ O
execution _ _ O
P _ _ O
C _ _ O
+ _ _ O
Registers _ _ O
Instruction _ _ O
memory _ _ O
IF _ _ O
/ _ _ O
ID _ _ O
Immediate _ _ O
constant _ _ O
ID _ _ O
/ _ _ O
EX _ _ O
13 _ _ O

Limitations _ _ O
of _ _ O
1-bit _ _ O
BHT _ _ O
Predictor _ _ O
● _ _ O
Is _ _ O
1-bit _ _ O
( _ _ O
T _ _ O
/ _ _ O
NT _ _ O
) _ _ O
enough _ _ O
history _ _ O
to _ _ O
make _ _ O
a _ _ O
good _ _ O
decision _ _ O
? _ _ O
● _ _ O
Take _ _ O
a _ _ O
look _ _ O
at _ _ O
this _ _ O
example _ _ O
: _ _ O
for _ _ O
( _ _ O
j=0 _ _ O
; _ _ O
j _ _ O
< _ _ O
100 _ _ O
; _ _ O
j++ _ _ O
) _ _ O
{ _ _ O
for _ _ O
( _ _ O
i=0 _ _ O
; _ _ O
i _ _ O
< _ _ O
5 _ _ O
; _ _ O
i++ _ _ O
) _ _ O
{ _ _ O
A _ _ O
[ _ _ O
i _ _ O
] _ _ O
= _ _ O
B _ _ O
[ _ _ O
i _ _ O
] _ _ O
* _ _ O
C _ _ O
[ _ _ O
i _ _ O
] _ _ O
; _ _ O
D _ _ O
[ _ _ O
i _ _ O
] _ _ O
= _ _ O
E _ _ O
[ _ _ O
i _ _ O
] _ _ O
/ _ _ O
F _ _ O
[ _ _ O
i _ _ O
] _ _ O
; _ _ O
} _ _ O
} _ _ O
Predicted _ _ O
- _ _ O
T _ _ O
T _ _ O
T _ _ O
T _ _ O
NT _ _ O
T _ _ O
T _ _ O
T _ _ O
T _ _ O
NT _ _ O
T _ _ O
T _ _ O
Actual _ _ O
T _ _ O
T _ _ O
T _ _ O
T _ _ O
NT _ _ O
T _ _ O
T _ _ O
T _ _ O
T _ _ O
NT _ _ O
T _ _ O
T _ _ O
T _ _ O
this _ _ O
branch _ _ O
is _ _ O
predicted _ _ O
wrong _ _ O
twice _ _ O
every _ _ O
inner _ _ O
loop _ _ O
invocation _ _ O
( _ _ O
every _ _ O
5 _ _ O
branches _ _ O
) _ _ O
● _ _ O
It _ _ O
would _ _ O
have _ _ O
been _ _ O
better _ _ O
to _ _ O
stay _ _ O
with _ _ O
T _ _ O
than _ _ O
flip _ _ O
back _ _ O
and _ _ O
forth _ _ O
! _ _ O
● _ _ O
Idea _ _ O
behind _ _ O
the _ _ O
2-bit _ _ O
predictor _ _ O
: _ _ O
make _ _ O
predictions _ _ O
more _ _ O
stable _ _ O
o _ _ O
So _ _ O
that _ _ O
predictions _ _ O
do _ _ O
n’t _ _ O
flip _ _ O
immediately _ _ O
14 _ _ O

2-bit _ _ O
BHT _ _ O
Predictor _ _ O
● _ _ O
State _ _ O
transition _ _ O
diagram _ _ O
of _ _ O
2-bit _ _ O
predictor _ _ O
: _ _ O
change _ _ O
in _ _ O
prediction _ _ O
● _ _ O
Can _ _ O
be _ _ O
implemented _ _ O
using _ _ O
a _ _ O
2-bit _ _ O
saturating _ _ O
counter _ _ O
o _ _ O
Strongly _ _ O
not _ _ O
taken _ _ O
: _ _ O
00 _ _ O
o _ _ O
Weakly _ _ O
not _ _ O
taken _ _ O
: _ _ O
01 _ _ O
o _ _ O
Weakly _ _ O
taken _ _ O
: _ _ O
10 _ _ O
o _ _ O
Strongly _ _ O
taken _ _ O
: _ _ O
11 _ _ O
15 _ _ O

2-bit _ _ O
BHT _ _ O
Predictor _ _ O
● _ _ O
How _ _ O
well _ _ O
does _ _ O
the _ _ O
2-bit _ _ O
predictor _ _ O
do _ _ O
with _ _ O
our _ _ O
previous _ _ O
example _ _ O
? _ _ O
● _ _ O
Our _ _ O
previous _ _ O
example _ _ O
: _ _ O
for _ _ O
( _ _ O
j=0 _ _ O
; _ _ O
j _ _ O
< _ _ O
100 _ _ O
; _ _ O
j++ _ _ O
) _ _ O
{ _ _ O
for _ _ O
( _ _ O
i=0 _ _ O
; _ _ O
i _ _ O
< _ _ O
5 _ _ O
; _ _ O
i++ _ _ O
) _ _ O
{ _ _ O
A _ _ O
[ _ _ O
i _ _ O
] _ _ O
= _ _ O
B _ _ O
[ _ _ O
i _ _ O
] _ _ O
* _ _ O
C _ _ O
[ _ _ O
i _ _ O
] _ _ O
; _ _ O
D _ _ O
[ _ _ O
i _ _ O
] _ _ O
= _ _ O
E _ _ O
[ _ _ O
i _ _ O
] _ _ O
/ _ _ O
F _ _ O
[ _ _ O
i _ _ O
] _ _ O
; _ _ O
} _ _ O
} _ _ O
Predicted _ _ O
- _ _ O
T _ _ O
T _ _ O
T _ _ O
T _ _ O
T _ _ O
T _ _ O
T _ _ O
T _ _ O
T _ _ O
T _ _ O
T _ _ O
T _ _ O
Actual _ _ O
T _ _ O
T _ _ O
T _ _ O
T _ _ O
NT _ _ O
T _ _ O
T _ _ O
T _ _ O
T _ _ O
NT _ _ O
T _ _ O
T _ _ O
T _ _ O
this _ _ O
branch _ _ O
is _ _ O
predicted _ _ O
wrong _ _ O
only _ _ O
once _ _ O
every _ _ O
inner _ _ O
loop _ _ O
invocation _ _ O
( _ _ O
every _ _ O
5 _ _ O
branches _ _ O
) _ _ O
● _ _ O
Does _ _ O
it _ _ O
help _ _ O
beyond _ _ O
2 _ _ O
bits _ _ O
? _ _ O
( _ _ O
e.g. _ _ O
3-bit _ _ O
predictor _ _ O
, _ _ O
or _ _ O
4-bit _ _ O
predictor _ _ O
) _ _ O
o _ _ O
Empirically _ _ O
, _ _ O
no _ _ O
. _ _ O
2 _ _ O
bits _ _ O
already _ _ O
cover _ _ O
loop _ _ O
which _ _ O
is _ _ O
most _ _ O
common _ _ O
. _ _ O
o _ _ O
2 _ _ O
bits _ _ O
+ _ _ O
large _ _ O
BHT _ _ O
gets _ _ O
you _ _ O
~93 _ _ O
% _ _ O
accuracy _ _ O
● _ _ O
We _ _ O
need _ _ O
other _ _ O
tricks _ _ O
to _ _ O
improve _ _ O
accuracy _ _ O
! _ _ O
16 _ _ O

Limitations _ _ O
of _ _ O
2-bit _ _ O
BHT _ _ O
Predictor _ _ O
● _ _ O
Here _ _ O
is _ _ O
an _ _ O
example _ _ O
where _ _ O
1-bit _ _ O
BHT _ _ O
predictor _ _ O
fails _ _ O
miserably _ _ O
for _ _ O
( _ _ O
j=0 _ _ O
; _ _ O
j _ _ O
< _ _ O
100 _ _ O
; _ _ O
j++ _ _ O
) _ _ O
{ _ _ O
if _ _ O
( _ _ O
j _ _ O
% _ _ O
2 _ _ O
) _ _ O
{ _ _ O
} _ _ O
} _ _ O
You _ _ O
get _ _ O
the _ _ O
prediction _ _ O
wrong _ _ O
every _ _ O
single _ _ O
time _ _ O
! _ _ O
Predicted _ _ O
- _ _ O
NT _ _ O
T _ _ O
NT _ _ O
T _ _ O
NT _ _ O
T _ _ O
NT _ _ O
T _ _ O
NT _ _ O
T _ _ O
NT _ _ O
T _ _ O
Actual _ _ O
NT _ _ O
T _ _ O
NT _ _ O
T _ _ O
NT _ _ O
T _ _ O
NT _ _ O
T _ _ O
NT _ _ O
T _ _ O
NT _ _ O
T _ _ O
NT _ _ O
● _ _ O
And _ _ O
a _ _ O
2-bit _ _ O
predictor _ _ O
does _ _ O
n’t _ _ O
do _ _ O
very _ _ O
well _ _ O
either _ _ O
for _ _ O
( _ _ O
j=0 _ _ O
; _ _ O
j _ _ O
< _ _ O
100 _ _ O
; _ _ O
j++ _ _ O
) _ _ O
{ _ _ O
if _ _ O
( _ _ O
j _ _ O
% _ _ O
2 _ _ O
) _ _ O
{ _ _ O
} _ _ O
} _ _ O
You _ _ O
get _ _ O
the _ _ O
prediction _ _ O
wrong _ _ O
every _ _ O
other _ _ O
time _ _ O
! _ _ O
Predicted _ _ O
- _ _ O
NT _ _ O
NT _ _ O
NT _ _ O
NT _ _ O
NT _ _ O
NT _ _ O
NT _ _ O
NT _ _ O
NT _ _ O
NT _ _ O
NT _ _ O
NT _ _ O
Actual _ _ O
NT _ _ O
T _ _ O
NT _ _ O
T _ _ O
NT _ _ O
T _ _ O
NT _ _ O
T _ _ O
NT _ _ O
T _ _ O
NT _ _ O
T _ _ O
NT _ _ O
o _ _ O
Would _ _ O
a _ _ O
3-bit _ _ O
predictor _ _ O
do _ _ O
any _ _ O
better _ _ O
? _ _ O
● _ _ O
Idea _ _ O
: _ _ O
Base _ _ O
prediction _ _ O
on _ _ O
a _ _ O
pattern _ _ O
found _ _ O
in _ _ O
history _ _ O
of _ _ O
branches _ _ O
! _ _ O
o _ _ O
Rather _ _ O
than _ _ O
relying _ _ O
on _ _ O
a _ _ O
single _ _ O
prediction _ _ O
for _ _ O
a _ _ O
branch _ _ O
o _ _ O
If _ _ O
History _ _ O
: _ _ O
T _ _ O
→ _ _ O
predict _ _ O
NT _ _ O
, _ _ O
if _ _ O
History _ _ O
: _ _ O
NT _ _ O
→ _ _ O
predict _ _ O
T _ _ O
17 _ _ O

Correlating _ _ O
Predictors _ _ O
leverage _ _ O
patterns _ _ O
● _ _ O
Correlating _ _ O
Predictor _ _ O
: _ _ O
Uses _ _ O
patterns _ _ O
in _ _ O
past _ _ O
branches _ _ O
for _ _ O
prediction _ _ O
o _ _ O
Often _ _ O
branch _ _ O
behavior _ _ O
more _ _ O
complex _ _ O
than _ _ O
just _ _ O
taken _ _ O
or _ _ O
not _ _ O
taken _ _ O
o _ _ O
Often _ _ O
correlates _ _ O
to _ _ O
a _ _ O
pattern _ _ O
of _ _ O
past _ _ O
branches _ _ O
● _ _ O
Pattern _ _ O
may _ _ O
exist _ _ O
in _ _ O
two _ _ O
ways _ _ O
: _ _ O
o _ _ O
Pattern _ _ O
in _ _ O
local _ _ O
branch _ _ O
history _ _ O
( _ _ O
history _ _ O
of _ _ O
only _ _ O
current _ _ O
branch _ _ O
) _ _ O
o _ _ O
Pattern _ _ O
in _ _ O
global _ _ O
branch _ _ O
history _ _ O
( _ _ O
history _ _ O
of _ _ O
all _ _ O
branches _ _ O
) _ _ O
● _ _ O
Maintaining _ _ O
longer _ _ O
history _ _ O
allows _ _ O
detection _ _ O
of _ _ O
longer _ _ O
patterns _ _ O
o _ _ O
Local _ _ O
branch _ _ O
history _ _ O
for _ _ O
each _ _ O
branch _ _ O
maintained _ _ O
at _ _ O
all _ _ O
times _ _ O
o _ _ O
One _ _ O
global _ _ O
branch _ _ O
history _ _ O
maintained _ _ O
at _ _ O
all _ _ O
times _ _ O
18 _ _ O

Local _ _ O
Branch _ _ O
History _ _ O
Correlating _ _ O
Predictor _ _ O
● _ _ O
With _ _ O
a _ _ O
local _ _ O
branch _ _ O
history _ _ O
of _ _ O
1 _ _ O
, _ _ O
can _ _ O
predict _ _ O
perfectly _ _ O
! _ _ O
for _ _ O
( _ _ O
j=0 _ _ O
; _ _ O
j _ _ O
< _ _ O
100 _ _ O
; _ _ O
j++ _ _ O
) _ _ O
{ _ _ O
if _ _ O
( _ _ O
j _ _ O
% _ _ O
2 _ _ O
) _ _ O
{ _ _ O
} _ _ O
} _ _ O
Predict _ _ O
with _ _ O
branch _ _ O
PC _ _ O
+ _ _ O
1 _ _ O
local _ _ O
branch _ _ O
history _ _ O
Predicted _ _ O
- _ _ O
- _ _ O
NT _ _ O
T _ _ O
NT _ _ O
T _ _ O
NT _ _ O
T _ _ O
NT _ _ O
T _ _ O
NT _ _ O
T _ _ O
NT _ _ O
Actual _ _ O
NT _ _ O
T _ _ O
NT _ _ O
T _ _ O
NT _ _ O
T _ _ O
NT _ _ O
T _ _ O
NT _ _ O
T _ _ O
NT _ _ O
T _ _ O
NT _ _ O
● _ _ O
Local _ _ O
branch _ _ O
history _ _ O
changes _ _ O
as _ _ O
such _ _ O
: _ _ O
o _ _ O
NT _ _ O
→ _ _ O
T _ _ O
→ _ _ O
NT _ _ O
→ _ _ O
T _ _ O
→ _ _ O
NT _ _ O
→ _ _ O
T _ _ O
→ _ _ O
NT _ _ O
→ _ _ O
T _ _ O
→ _ _ O
NT _ _ O
→ _ _ O
T _ _ O
→ _ _ O
… _ _ O
● _ _ O
Prediction _ _ O
based _ _ O
on _ _ O
branch _ _ O
PC _ _ O
and _ _ O
local _ _ O
branch _ _ O
history _ _ O
: _ _ O
o _ _ O
PC _ _ O
: _ _ O
if _ _ O
( _ _ O
j _ _ O
% _ _ O
2 _ _ O
) _ _ O
+ _ _ O
History _ _ O
: _ _ O
NT _ _ O
→ _ _ O
Prediction _ _ O
: _ _ O
T _ _ O
o _ _ O
PC _ _ O
: _ _ O
if _ _ O
( _ _ O
j _ _ O
% _ _ O
2 _ _ O
) _ _ O
+ _ _ O
History _ _ O
: _ _ O
T _ _ O
→ _ _ O
Prediction _ _ O
: _ _ O
NT _ _ O
19 _ _ O

Local _ _ O
Branch _ _ O
History _ _ O
Correlating _ _ O
Predictor _ _ O
● _ _ O
You _ _ O
need _ _ O
a _ _ O
local _ _ O
branch _ _ O
history _ _ O
of _ _ O
2 _ _ O
for _ _ O
this _ _ O
one _ _ O
. _ _ O
for _ _ O
( _ _ O
j=0 _ _ O
; _ _ O
j _ _ O
< _ _ O
100 _ _ O
; _ _ O
j++ _ _ O
) _ _ O
{ _ _ O
if _ _ O
( _ _ O
j _ _ O
% _ _ O
3 _ _ O
) _ _ O
{ _ _ O
} _ _ O
} _ _ O
Predict _ _ O
with _ _ O
branch _ _ O
PC _ _ O
+ _ _ O
2 _ _ O
local _ _ O
branch _ _ O
history _ _ O
Predicted _ _ O
- _ _ O
- _ _ O
- _ _ O
- _ _ O
- _ _ O
T _ _ O
NT _ _ O
T _ _ O
T _ _ O
NT _ _ O
T _ _ O
T _ _ O
NT _ _ O
Actual _ _ O
NT _ _ O
T _ _ O
T _ _ O
NT _ _ O
T _ _ O
T _ _ O
NT _ _ O
T _ _ O
T _ _ O
NT _ _ O
T _ _ O
T _ _ O
NT _ _ O
● _ _ O
Local _ _ O
branch _ _ O
history _ _ O
changes _ _ O
as _ _ O
such _ _ O
: _ _ O
o _ _ O
NT _ _ O
, _ _ O
T _ _ O
→ _ _ O
T _ _ O
, _ _ O
T _ _ O
→ _ _ O
T _ _ O
, _ _ O
NT _ _ O
→ _ _ O
NT _ _ O
, _ _ O
T _ _ O
→ _ _ O
T _ _ O
, _ _ O
T _ _ O
→ _ _ O
T _ _ O
, _ _ O
NT _ _ O
→ _ _ O
NT _ _ O
, _ _ O
T _ _ O
→ _ _ O
… _ _ O
● _ _ O
Prediction _ _ O
based _ _ O
on _ _ O
branch _ _ O
PC _ _ O
and _ _ O
local _ _ O
branch _ _ O
history _ _ O
: _ _ O
o _ _ O
PC _ _ O
: _ _ O
if _ _ O
( _ _ O
j _ _ O
% _ _ O
3 _ _ O
) _ _ O
+ _ _ O
History _ _ O
: _ _ O
NT _ _ O
, _ _ O
T _ _ O
→ _ _ O
Prediction _ _ O
: _ _ O
T _ _ O
o _ _ O
PC _ _ O
: _ _ O
if _ _ O
( _ _ O
j _ _ O
% _ _ O
3 _ _ O
) _ _ O
+ _ _ O
History _ _ O
: _ _ O
T _ _ O
, _ _ O
T _ _ O
→ _ _ O
Prediction _ _ O
: _ _ O
NT _ _ O
o _ _ O
PC _ _ O
: _ _ O
if _ _ O
( _ _ O
j _ _ O
% _ _ O
3 _ _ O
) _ _ O
+ _ _ O
History _ _ O
: _ _ O
T _ _ O
, _ _ O
NT _ _ O
→ _ _ O
Prediction _ _ O
: _ _ O
T _ _ O
o _ _ O
PC _ _ O
: _ _ O
if _ _ O
( _ _ O
j _ _ O
% _ _ O
3 _ _ O
) _ _ O
+ _ _ O
History _ _ O
: _ _ O
NT _ _ O
, _ _ O
NT _ _ O
→ _ _ O
No _ _ O
prediction _ _ O
20 _ _ O

Global _ _ O
Branch _ _ O
History _ _ O
Correlating _ _ O
Predictor _ _ O
● _ _ O
Knowing _ _ O
the _ _ O
result _ _ O
of _ _ O
other _ _ O
branches _ _ O
in _ _ O
your _ _ O
history _ _ O
also _ _ O
helps _ _ O
If _ _ O
( _ _ O
j _ _ O
= _ _ O
= _ _ O
0 _ _ O
) _ _ O
{ _ _ O
} _ _ O
… _ _ O
If _ _ O
( _ _ O
j _ _ O
! _ _ O
= _ _ O
0 _ _ O
) _ _ O
{ _ _ O
} _ _ O
current _ _ O
Knowing _ _ O
result _ _ O
of _ _ O
a _ _ O
previous _ _ O
different _ _ O
branch _ _ O
in _ _ O
your _ _ O
history _ _ O
helps _ _ O
in _ _ O
predicting _ _ O
current _ _ O
branch _ _ O
! _ _ O
● _ _ O
This _ _ O
is _ _ O
called _ _ O
global _ _ O
branch _ _ O
history _ _ O
( _ _ O
involves _ _ O
all _ _ O
branches _ _ O
) _ _ O
. _ _ O
● _ _ O
Can _ _ O
be _ _ O
helpful _ _ O
when _ _ O
local _ _ O
branch _ _ O
history _ _ O
ca _ _ O
n’t _ _ O
capture _ _ O
pattern _ _ O
. _ _ O
21 _ _ O

Unified _ _ O
Correlating _ _ O
Predictor _ _ O
● _ _ O
Correlates _ _ O
prediction _ _ O
with _ _ O
branch _ _ O
history _ _ O
as _ _ O
well _ _ O
as _ _ O
branch _ _ O
PC _ _ O
o _ _ O
Local _ _ O
branch _ _ O
history _ _ O
+ _ _ O
Global _ _ O
branch _ _ O
history _ _ O
o _ _ O
An _ _ O
entry _ _ O
with _ _ O
matching _ _ O
history _ _ O
gives _ _ O
more _ _ O
precise _ _ O
prediction _ _ O
! _ _ O
● _ _ O
Now _ _ O
, _ _ O
instead _ _ O
of _ _ O
indexing _ _ O
into _ _ O
BHT _ _ O
by _ _ O
branch _ _ O
PC _ _ O
only _ _ O
o _ _ O
Use _ _ O
hash _ _ O
( _ _ O
PC _ _ O
, _ _ O
Local _ _ O
branch _ _ O
history _ _ O
, _ _ O
Global _ _ O
branch _ _ O
history _ _ O
) _ _ O
● _ _ O
History _ _ O
is _ _ O
stored _ _ O
in _ _ O
register _ _ O
called _ _ O
Branch _ _ O
History _ _ O
Shift _ _ O
Register _ _ O
( _ _ O
BHR _ _ O
) _ _ O
o _ _ O
T _ _ O
/ _ _ O
NT _ _ O
bit _ _ O
is _ _ O
shifted _ _ O
on _ _ O
to _ _ O
BHR _ _ O
whenever _ _ O
branch _ _ O
is _ _ O
encountered _ _ O
1 _ _ O
. _ _ O
One _ _ O
Global _ _ O
BHR _ _ O
( _ _ O
there _ _ O
is _ _ O
just _ _ O
one _ _ O
global _ _ O
history _ _ O
) _ _ O
2 _ _ O
. _ _ O
Multiple _ _ O
Local _ _ O
BHRs _ _ O
( _ _ O
local _ _ O
histories _ _ O
for _ _ O
each _ _ O
branch _ _ O
PC _ _ O
) _ _ O
22 _ _ O

Correlating _ _ O
Predictors _ _ O
Hash _ _ O
0 _ _ O
PC _ _ O
# _ _ O
Tags _ _ O
Local _ _ O
BHRs _ _ O
0 _ _ O
PC _ _ O
T _ _ O
, _ _ O
NT _ _ O
, _ _ O
NT _ _ O
, _ _ O
T _ _ O
, _ _ O
… _ _ O
1 _ _ O
PC _ _ O
T _ _ O
, _ _ O
T _ _ O
, _ _ O
NT _ _ O
, _ _ O
T _ _ O
, _ _ O
… _ _ O
2 _ _ O
PC _ _ O
T _ _ O
, _ _ O
T _ _ O
, _ _ O
T _ _ O
, _ _ O
T _ _ O
, _ _ O
… _ _ O
3 _ _ O
... _ _ O
... _ _ O
Global _ _ O
BHR _ _ O
T _ _ O
, _ _ O
NT _ _ O
, _ _ O
NT _ _ O
, _ _ O
T _ _ O
, _ _ O
T _ _ O
, _ _ O
NT _ _ O
, _ _ O
… _ _ O
# _ _ O
Tags _ _ O
Pred _ _ O
. _ _ O
Branch _ _ O
Target _ _ O
0 _ _ O
PC+History _ _ O
01 _ _ O
0x007FA03C _ _ O
1 _ _ O
PC+History _ _ O
00 _ _ O
0x007FC704 _ _ O
2 _ _ O
PC+History _ _ O
11 _ _ O
0x007FA040 _ _ O
3 _ _ O
... _ _ O
01 _ _ O
... _ _ O
4 _ _ O
PC+History _ _ O
10 _ _ O
0x007FC398 _ _ O
5 _ _ O
... _ _ O
00 _ _ O
... _ _ O
6 _ _ O
... _ _ O
10 _ _ O
... _ _ O
7 _ _ O
... _ _ O
11 _ _ O
... _ _ O
● _ _ O
Can _ _ O
reach _ _ O
up _ _ O
to _ _ O
97 _ _ O
% _ _ O
accuracy _ _ O
! _ _ O
23 _ _ O

How _ _ O
about _ _ O
jr _ _ O
$ _ _ O
ra _ _ O
? _ _ O
● _ _ O
jr _ _ O
$ _ _ O
ra _ _ O
: _ _ O
Jump _ _ O
return _ _ O
to _ _ O
address _ _ O
stored _ _ O
in _ _ O
$ _ _ O
ra _ _ O
o _ _ O
When _ _ O
a _ _ O
function _ _ O
is _ _ O
called _ _ O
, _ _ O
the _ _ O
caller _ _ O
stores _ _ O
return _ _ O
address _ _ O
to _ _ O
$ _ _ O
ra _ _ O
( _ _ O
jal _ _ O
funcAddr _ _ O
stores _ _ O
PC _ _ O
of _ _ O
next _ _ O
instruction _ _ O
to _ _ O
$ _ _ O
ra _ _ O
) _ _ O
o _ _ O
When _ _ O
a _ _ O
function _ _ O
returns _ _ O
, _ _ O
jr _ _ O
$ _ _ O
ra _ _ O
jumps _ _ O
to _ _ O
return _ _ O
address _ _ O
in _ _ O
$ _ _ O
ra _ _ O
● _ _ O
Why _ _ O
is _ _ O
this _ _ O
a _ _ O
problem _ _ O
? _ _ O
o _ _ O
Unlike _ _ O
other _ _ O
branches _ _ O
, _ _ O
branch _ _ O
target _ _ O
is _ _ O
not _ _ O
an _ _ O
immediate _ _ O
value _ _ O
! _ _ O
( _ _ O
Jumping _ _ O
to _ _ O
a _ _ O
variable _ _ O
target _ _ O
is _ _ O
called _ _ O
an _ _ O
indirect _ _ O
branch _ _ O
) _ _ O
o _ _ O
Target _ _ O
can _ _ O
change _ _ O
for _ _ O
same _ _ O
jr _ _ O
depending _ _ O
on _ _ O
who _ _ O
caller _ _ O
is _ _ O
o _ _ O
Makes _ _ O
life _ _ O
difficult _ _ O
for _ _ O
BTB _ _ O
which _ _ O
relies _ _ O
on _ _ O
target _ _ O
being _ _ O
constant _ _ O
● _ _ O
Target _ _ O
of _ _ O
jr _ _ O
is _ _ O
predicted _ _ O
using _ _ O
the _ _ O
Return _ _ O
Stack _ _ O
Buffer _ _ O
o _ _ O
Not _ _ O
the _ _ O
Branch _ _ O
Target _ _ O
Buffer _ _ O
( _ _ O
BTB _ _ O
) _ _ O
24 _ _ O

The _ _ O
Return _ _ O
Stack _ _ O
Buffer _ _ O
● _ _ O
Since _ _ O
functions _ _ O
return _ _ O
to _ _ O
where _ _ O
they _ _ O
were _ _ O
called _ _ O
every _ _ O
time _ _ O
, _ _ O
it _ _ O
makes _ _ O
sense _ _ O
to _ _ O
cache _ _ O
the _ _ O
return _ _ O
addresses _ _ O
( _ _ O
in _ _ O
a _ _ O
stack _ _ O
) _ _ O
When _ _ O
we _ _ O
encounter _ _ O
4AB33C _ _ O
jal _ _ O
someFunc _ _ O
the _ _ O
jal _ _ O
, _ _ O
push _ _ O
the _ _ O
4AB340 _ _ O
beq _ _ O
v0 _ _ O
, _ _ O
$ _ _ O
0 _ _ O
, _ _ O
blah _ _ O
return _ _ O
address _ _ O
. _ _ O
... _ _ O
When _ _ O
we _ _ O
encounter _ _ O
the _ _ O
jr _ _ O
$ _ _ O
ra _ _ O
, _ _ O
pop _ _ O
the _ _ O
someFunc _ _ O
: _ _ O
return _ _ O
address _ _ O
. _ _ O
Easy _ _ O
! _ _ O
... _ _ O
jr _ _ O
$ _ _ O
ra _ _ O
● _ _ O
On _ _ O
misprediction _ _ O
or _ _ O
stack _ _ O
overflow _ _ O
, _ _ O
empty _ _ O
stack _ _ O
o _ _ O
Not _ _ O
a _ _ O
problem _ _ O
since _ _ O
this _ _ O
is _ _ O
for _ _ O
prediction _ _ O
anyway _ _ O
40CC00 _ _ O
46280C _ _ O
4AB108 _ _ O
000000 _ _ O
4AB340 _ _ O
000000 _ _ O
000000 _ _ O
000000 _ _ O
000000 _ _ O
25 _ _ O

Performance _ _ O
Impact _ _ O
with _ _ O
Branch _ _ O
Prediction _ _ O
● _ _ O
Now _ _ O
, _ _ O
CPI _ _ O
= _ _ O
CPInch _ _ O
+ _ _ O
a _ _ O
* _ _ O
p _ _ O
* _ _ O
K _ _ O
o _ _ O
CPInch _ _ O
: _ _ O
CPI _ _ O
with _ _ O
no _ _ O
control _ _ O
hazard _ _ O
o _ _ O
a _ _ O
: _ _ O
fraction _ _ O
of _ _ O
branch _ _ O
instructions _ _ O
in _ _ O
the _ _ O
instruction _ _ O
mix _ _ O
o _ _ O
p _ _ O
: _ _ O
probability _ _ O
a _ _ O
branch _ _ O
is _ _ O
mispredicted _ _ O
o _ _ O
K _ _ O
: _ _ O
penalty _ _ O
per _ _ O
pipeline _ _ O
flush _ _ O
● _ _ O
With _ _ O
deep _ _ O
pipelines _ _ O
, _ _ O
mispredictions _ _ O
can _ _ O
have _ _ O
outsize _ _ O
impact _ _ O
Example _ _ O
: _ _ O
If _ _ O
20 _ _ O
% _ _ O
of _ _ O
instructions _ _ O
are _ _ O
branches _ _ O
and _ _ O
the _ _ O
misprediction _ _ O
rate _ _ O
is _ _ O
5 _ _ O
% _ _ O
, _ _ O
and _ _ O
pipeline _ _ O
flush _ _ O
penalty _ _ O
20 _ _ O
cycles _ _ O
, _ _ O
then _ _ O
: _ _ O
CPI _ _ O
= _ _ O
CPInch _ _ O
+ _ _ O
0.2 _ _ O
* _ _ O
0.05 _ _ O
* _ _ O
20 _ _ O
= _ _ O
CPInch _ _ O
+ _ _ O
0.2 _ _ O
cycles _ _ O
per _ _ O
instruction _ _ O
● _ _ O
If _ _ O
, _ _ O
CPInch _ _ O
is _ _ O
0.5 _ _ O
, _ _ O
then _ _ O
that _ _ O
is _ _ O
40 _ _ O
% _ _ O
added _ _ O
to _ _ O
execution _ _ O
time _ _ O
! _ _ O
● _ _ O
Problem _ _ O
is _ _ O
a _ _ O
small _ _ O
percentage _ _ O
of _ _ O
hard _ _ O
to _ _ O
predict _ _ O
branches _ _ O
o _ _ O
How _ _ O
do _ _ O
we _ _ O
deal _ _ O
with _ _ O
these _ _ O
? _ _ O
26 _ _ O

Predication _ _ O
27 _ _ O

Branch _ _ O
Mispredictions _ _ O
have _ _ O
Outsize _ _ O
Impact _ _ O
● _ _ O
Assume _ _ O
a _ _ O
deep _ _ O
pipeline _ _ O
and _ _ O
if _ _ O
( _ _ O
s1 _ _ O
> _ _ O
= _ _ O
0 _ _ O
) _ _ O
is _ _ O
hard _ _ O
to _ _ O
predict _ _ O
if _ _ O
( _ _ O
s1 _ _ O
> _ _ O
= _ _ O
0 _ _ O
) _ _ O
s2 _ _ O
= _ _ O
0 _ _ O
; _ _ O
for _ _ O
( _ _ O
s0 _ _ O
= _ _ O
0 _ _ O
.. _ _ O
10 _ _ O
) _ _ O
s3 _ _ O
= _ _ O
s3 _ _ O
+ _ _ O
s0 _ _ O
; _ _ O
blt _ _ O
li _ _ O
s1 _ _ O
, _ _ O
0 _ _ O
, _ _ O
top _ _ O
s2 _ _ O
, _ _ O
0 _ _ O
top _ _ O
: _ _ O
add _ _ O
s3 _ _ O
, _ _ O
s3 _ _ O
, _ _ O
s0 _ _ O
addi _ _ O
s0 _ _ O
, _ _ O
s0 _ _ O
, _ _ O
1 _ _ O
blt _ _ O
s0 _ _ O
, _ _ O
10 _ _ O
, _ _ O
top _ _ O
Mispredict _ _ O
Flush _ _ O
! _ _ O
● _ _ O
On _ _ O
a _ _ O
misprediction _ _ O
, _ _ O
every _ _ O
following _ _ O
instruction _ _ O
is _ _ O
flushed _ _ O
o _ _ O
Not _ _ O
only _ _ O
the _ _ O
control _ _ O
dependent _ _ O
instructions _ _ O
( _ _ O
li _ _ O
s2 _ _ O
, _ _ O
0 _ _ O
) _ _ O
o _ _ O
But _ _ O
also _ _ O
multiple _ _ O
iterations _ _ O
of _ _ O
the _ _ O
“ _ _ O
bystander _ _ O
” _ _ O
loop _ _ O
that _ _ O
were _ _ O
fetched _ _ O
28 _ _ O

Solution _ _ O
4 _ _ O
: _ _ O
Predication _ _ O
● _ _ O
Predicate _ _ O
: _ _ O
a _ _ O
Boolean _ _ O
value _ _ O
used _ _ O
for _ _ O
conditional _ _ O
execution _ _ O
o _ _ O
Instructions _ _ O
that _ _ O
use _ _ O
predicates _ _ O
are _ _ O
said _ _ O
to _ _ O
be _ _ O
predicated _ _ O
o _ _ O
A _ _ O
predicated _ _ O
instruction _ _ O
will _ _ O
modify _ _ O
state _ _ O
only _ _ O
if _ _ O
predicate _ _ O
is _ _ O
true _ _ O
o _ _ O
ISA _ _ O
is _ _ O
modified _ _ O
to _ _ O
add _ _ O
predicated _ _ O
versions _ _ O
for _ _ O
all _ _ O
instructions _ _ O
● _ _ O
Example _ _ O
of _ _ O
code _ _ O
generation _ _ O
using _ _ O
predication _ _ O
: _ _ O
pge _ _ O
p1 _ _ O
, _ _ O
s1 _ _ O
, _ _ O
0 _ _ O
# _ _ O
Store _ _ O
boolean _ _ O
s1 _ _ O
> _ _ O
= _ _ O
0 _ _ O
to _ _ O
predicate _ _ O
p1 _ _ O
li.p _ _ O
s2 _ _ O
, _ _ O
0 _ _ O
, _ _ O
p1 _ _ O
# _ _ O
Assign _ _ O
0 _ _ O
to _ _ O
s2 _ _ O
if _ _ O
p1 _ _ O
is _ _ O
true _ _ O
sw.p _ _ O
s3 _ _ O
, _ _ O
0 _ _ O
( _ _ O
s4 _ _ O
) _ _ O
, _ _ O
p1 _ _ O
# _ _ O
Store _ _ O
s3 _ _ O
to _ _ O
address _ _ O
0 _ _ O
( _ _ O
s4 _ _ O
) _ _ O
if _ _ O
p1 _ _ O
is _ _ O
true _ _ O
● _ _ O
Now _ _ O
there _ _ O
is _ _ O
no _ _ O
branch _ _ O
. _ _ O
It _ _ O
is _ _ O
just _ _ O
straight-line _ _ O
code _ _ O
! _ _ O
o _ _ O
Control _ _ O
dependencies _ _ O
have _ _ O
been _ _ O
converted _ _ O
to _ _ O
data _ _ O
dependencies _ _ O
29 _ _ O

Code _ _ O
with _ _ O
predication _ _ O
● _ _ O
Now _ _ O
there _ _ O
are _ _ O
no _ _ O
branches _ _ O
! _ _ O
if _ _ O
( _ _ O
s1 _ _ O
> _ _ O
= _ _ O
0 _ _ O
) _ _ O
s2 _ _ O
= _ _ O
0 _ _ O
; _ _ O
for _ _ O
( _ _ O
s0 _ _ O
= _ _ O
0 _ _ O
.. _ _ O
10 _ _ O
) _ _ O
s3 _ _ O
= _ _ O
s3 _ _ O
+ _ _ O
s0 _ _ O
; _ _ O
pge _ _ O
p1 _ _ O
, _ _ O
0 _ _ O
, _ _ O
s1 _ _ O
li.p _ _ O
s2 _ _ O
, _ _ O
0 _ _ O
, _ _ O
p1 _ _ O
top _ _ O
: _ _ O
add _ _ O
s3 _ _ O
, _ _ O
s3 _ _ O
, _ _ O
s0 _ _ O
addi _ _ O
s0 _ _ O
, _ _ O
s0 _ _ O
, _ _ O
1 _ _ O
blt _ _ O
s0 _ _ O
, _ _ O
10 _ _ O
, _ _ O
top _ _ O
● _ _ O
Drawback _ _ O
: _ _ O
even _ _ O
if _ _ O
branch _ _ O
not _ _ O
taken _ _ O
, _ _ O
li.p _ _ O
fetched _ _ O
( _ _ O
acts _ _ O
like _ _ O
a _ _ O
bubble _ _ O
) _ _ O
o _ _ O
But _ _ O
often _ _ O
worth _ _ O
it _ _ O
for _ _ O
hard _ _ O
to _ _ O
predict _ _ O
branches _ _ O
! _ _ O
o _ _ O
For _ _ O
easy _ _ O
to _ _ O
predict _ _ O
branches _ _ O
, _ _ O
often _ _ O
not _ _ O
worth _ _ O
it _ _ O
. _ _ O
30 _ _ O

What _ _ O
does _ _ O
predication _ _ O
mean _ _ O
for _ _ O
the _ _ O
pipeline _ _ O
? _ _ O
● _ _ O
Again _ _ O
, _ _ O
predicates _ _ O
are _ _ O
registers _ _ O
just _ _ O
like _ _ O
any _ _ O
other _ _ O
register _ _ O
● _ _ O
Predicate _ _ O
dependencies _ _ O
work _ _ O
just _ _ O
like _ _ O
other _ _ O
data _ _ O
dependencies _ _ O
Time _ _ O
0 _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
pge _ _ O
p1 _ _ O
, _ _ O
0 _ _ O
, _ _ O
s1 _ _ O
IF _ _ O
ID _ _ O
EX _ _ O
MEM _ _ O
WB _ _ O
IF _ _ O
ID _ _ O
EX _ _ O
MEM _ _ O
li.p _ _ O
s2 _ _ O
, _ _ O
0 _ _ O
, _ _ O
p1 _ _ O
5 _ _ O
6 _ _ O
7 _ _ O
WB _ _ O
● _ _ O
With _ _ O
data _ _ O
forwarding _ _ O
, _ _ O
no _ _ O
stalls _ _ O
required _ _ O
! _ _ O
o _ _ O
Predicate _ _ O
forwarded _ _ O
to _ _ O
li.p _ _ O
EX _ _ O
stage _ _ O
o _ _ O
Later _ _ O
predicate _ _ O
enables _ _ O
/ _ _ O
disables _ _ O
regwrite _ _ O
control _ _ O
in _ _ O
li.p _ _ O
WB _ _ O
stage _ _ O
31 _ _ O

What _ _ O
does _ _ O
predication _ _ O
mean _ _ O
for _ _ O
the _ _ O
compiler _ _ O
? _ _ O
● _ _ O
Compiler _ _ O
can _ _ O
schedule _ _ O
instruction _ _ O
more _ _ O
freely _ _ O
! _ _ O
if _ _ O
( _ _ O
s1 _ _ O
> _ _ O
= _ _ O
0 _ _ O
) _ _ O
s2 _ _ O
= _ _ O
0 _ _ O
; _ _ O
for _ _ O
( _ _ O
s0 _ _ O
= _ _ O
0 _ _ O
.. _ _ O
10 _ _ O
) _ _ O
s3 _ _ O
= _ _ O
s3 _ _ O
+ _ _ O
s0 _ _ O
; _ _ O
pge _ _ O
p1 _ _ O
, _ _ O
0 _ _ O
, _ _ O
s1 _ _ O
top _ _ O
: _ _ O
add _ _ O
s3 _ _ O
, _ _ O
s3 _ _ O
, _ _ O
s0 _ _ O
addi _ _ O
s0 _ _ O
, _ _ O
s0 _ _ O
, _ _ O
1 _ _ O
blt _ _ O
s0 _ _ O
, _ _ O
10 _ _ O
, _ _ O
top _ _ O
li.p _ _ O
s2 _ _ O
, _ _ O
0 _ _ O
, _ _ O
p1 _ _ O
● _ _ O
Low-power _ _ O
compiler-scheduled _ _ O
processors _ _ O
often _ _ O
support _ _ O
predicates _ _ O
32 _ _ O

Predication _ _ O
in _ _ O
the _ _ O
Real _ _ O
World _ _ O
● _ _ O
Predication _ _ O
is _ _ O
only _ _ O
beneficial _ _ O
for _ _ O
hard _ _ O
to _ _ O
predict _ _ O
branches _ _ O
● _ _ O
So _ _ O
how _ _ O
does _ _ O
the _ _ O
compiler _ _ O
figure _ _ O
out _ _ O
the _ _ O
hard _ _ O
to _ _ O
predict _ _ O
branches _ _ O
? _ _ O
o _ _ O
Through _ _ O
code _ _ O
analysis _ _ O
o _ _ O
Through _ _ O
software _ _ O
profiling _ _ O
( _ _ O
model _ _ O
a _ _ O
branch _ _ O
predictor _ _ O
) _ _ O
● _ _ O
Supported _ _ O
in _ _ O
various _ _ O
ISAs _ _ O
o _ _ O
ARM _ _ O
allows _ _ O
most _ _ O
instructions _ _ O
to _ _ O
be _ _ O
predicated _ _ O
o _ _ O
Intel _ _ O
x86 _ _ O
has _ _ O
conditional _ _ O
move _ _ O
instructions _ _ O
( _ _ O
cmov _ _ O
) _ _ O
o _ _ O
SIMD _ _ O
architectures _ _ O
use _ _ O
predication _ _ O
in _ _ O
the _ _ O
form _ _ O
of _ _ O
a _ _ O
logical _ _ O
mask _ _ O
▪ _ _ O
Only _ _ O
data _ _ O
items _ _ O
that _ _ O
are _ _ O
not _ _ O
masked _ _ O
are _ _ O
updated _ _ O
▪ _ _ O
Intel _ _ O
AVX _ _ O
vector _ _ O
instructions _ _ O
▪ _ _ O
GPU _ _ O
instructions _ _ O
( _ _ O
e.g. _ _ O
CUDA _ _ O
) _ _ O
33 _ _ O



