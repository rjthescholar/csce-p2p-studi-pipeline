unlabeled|cs1541|lec2.5_vliw_processors
-DOCSTART- -X- -X- O

VLIW _ _ O
Processors _ _ O
CS _ _ O
1541 _ _ O
Wonsun _ _ O
Ahn _ _ O

Limits _ _ O
on _ _ O
Deep _ _ O
Pipelining _ _ O
● _ _ O
Ideally _ _ O
, _ _ O
CycleTimePipelined _ _ O
= _ _ O
CycleTimeSingleCycle _ _ O
/ _ _ O
Number _ _ O
of _ _ O
Stages _ _ O
o _ _ O
In _ _ O
theory _ _ O
, _ _ O
can _ _ O
indefinitely _ _ O
improve _ _ O
performance _ _ O
with _ _ O
more _ _ O
stages _ _ O
● _ _ O
Limitation _ _ O
1 _ _ O
: _ _ O
Cycle _ _ O
time _ _ O
does _ _ O
not _ _ O
improve _ _ O
indefinitely _ _ O
o _ _ O
With _ _ O
shorter _ _ O
stages _ _ O
, _ _ O
delay _ _ O
due _ _ O
to _ _ O
latches _ _ O
become _ _ O
significant _ _ O
o _ _ O
With _ _ O
many _ _ O
stages _ _ O
, _ _ O
hard _ _ O
to _ _ O
keep _ _ O
stage _ _ O
lengths _ _ O
perfectly _ _ O
balanced _ _ O
o _ _ O
Manufacturing _ _ O
variability _ _ O
exacerbates _ _ O
the _ _ O
stage _ _ O
length _ _ O
unbalance _ _ O
● _ _ O
Limitation _ _ O
2 _ _ O
: _ _ O
CPI _ _ O
tends _ _ O
to _ _ O
increase _ _ O
with _ _ O
deep _ _ O
pipelines _ _ O
o _ _ O
Penalty _ _ O
due _ _ O
to _ _ O
branch _ _ O
misprediction _ _ O
increases _ _ O
o _ _ O
Stalls _ _ O
due _ _ O
to _ _ O
data _ _ O
hazards _ _ O
cause _ _ O
more _ _ O
bubbles _ _ O
● _ _ O
Limitation _ _ O
3 _ _ O
: _ _ O
Power _ _ O
consumption _ _ O
increases _ _ O
with _ _ O
deep _ _ O
pipelines _ _ O
o _ _ O
Wires _ _ O
for _ _ O
data _ _ O
forwarding _ _ O
increase _ _ O
quadratically _ _ O
with _ _ O
depth _ _ O
● _ _ O
Is _ _ O
there _ _ O
another _ _ O
way _ _ O
to _ _ O
improve _ _ O
performance _ _ O
? _ _ O
2 _ _ O

What _ _ O
if _ _ O
we _ _ O
improve _ _ O
CPI _ _ O
? _ _ O
● _ _ O
Remember _ _ O
the _ _ O
three _ _ O
components _ _ O
of _ _ O
performance _ _ O
? _ _ O
instructions _ _ O
X _ _ O
program _ _ O
cycles _ _ O
instruction _ _ O
X _ _ O
seconds _ _ O
cycle _ _ O
● _ _ O
Pipelining _ _ O
focused _ _ O
on _ _ O
seconds _ _ O
/ _ _ O
cycle _ _ O
, _ _ O
or _ _ O
cycle _ _ O
time _ _ O
● _ _ O
Can _ _ O
we _ _ O
improve _ _ O
cycles _ _ O
/ _ _ O
instruction _ _ O
, _ _ O
or _ _ O
CPI _ _ O
? _ _ O
o _ _ O
But _ _ O
the _ _ O
best _ _ O
we _ _ O
can _ _ O
get _ _ O
is _ _ O
CPI _ _ O
= _ _ O
1 _ _ O
, _ _ O
right _ _ O
? _ _ O
o _ _ O
How _ _ O
can _ _ O
an _ _ O
instruction _ _ O
be _ _ O
executed _ _ O
in _ _ O
less _ _ O
than _ _ O
a _ _ O
cycle _ _ O
? _ _ O
3 _ _ O

Wide _ _ O
Issue _ _ O
Processors _ _ O
4 _ _ O

From _ _ O
CPI _ _ O
to _ _ O
IPC _ _ O
● _ _ O
How _ _ O
about _ _ O
if _ _ O
we _ _ O
fetch _ _ O
two _ _ O
instructions _ _ O
each _ _ O
cycle _ _ O
? _ _ O
o _ _ O
Maybe _ _ O
, _ _ O
fetch _ _ O
one _ _ O
ALU _ _ O
instruction _ _ O
and _ _ O
one _ _ O
load _ _ O
/ _ _ O
store _ _ O
instruction _ _ O
● _ _ O
Then _ _ O
, _ _ O
IPC _ _ O
( _ _ O
Instructions _ _ O
per _ _ O
Cycle _ _ O
) _ _ O
= _ _ O
2 _ _ O
o _ _ O
And _ _ O
by _ _ O
extension _ _ O
, _ _ O
CPI _ _ O
= _ _ O
1 _ _ O
/ _ _ O
IPC _ _ O
= _ _ O
0.5 _ _ O
! _ _ O
● _ _ O
Wide-issue _ _ O
processors _ _ O
can _ _ O
execute _ _ O
multiple _ _ O
instructions _ _ O
per _ _ O
cycle _ _ O
5 _ _ O

Pipeline _ _ O
design _ _ O
for _ _ O
previous _ _ O
example _ _ O
● _ _ O
One _ _ O
pipeline _ _ O
for _ _ O
ALU _ _ O
/ _ _ O
Branches _ _ O
and _ _ O
one _ _ O
for _ _ O
loads _ _ O
and _ _ O
stores _ _ O
I-Mem _ _ O
Ins _ _ O
. _ _ O
Decoder _ _ O
ALU _ _ O
Pipeline _ _ O
Register _ _ O
File _ _ O
Memory _ _ O
Pipeline _ _ O
ALU _ _ O
+ _ _ O
D-Mem _ _ O
● _ _ O
This _ _ O
introduces _ _ O
new _ _ O
structural _ _ O
hazards _ _ O
that _ _ O
we _ _ O
did _ _ O
n’t _ _ O
have _ _ O
before _ _ O
! _ _ O
6 _ _ O

Structural _ _ O
Hazard _ _ O
in _ _ O
Storage _ _ O
Locations _ _ O
( _ _ O
Solved _ _ O
) _ _ O
I-Mem _ _ O
Ins _ _ O
. _ _ O
Decoder _ _ O
● _ _ O
Two _ _ O
instructions _ _ O
must _ _ O
be _ _ O
fetched _ _ O
from _ _ O
instruction _ _ O
memory _ _ O
→ _ _ O
Add _ _ O
extra _ _ O
read _ _ O
ports _ _ O
to _ _ O
the _ _ O
instruction _ _ O
memory _ _ O
● _ _ O
Two _ _ O
ALUs _ _ O
must _ _ O
read _ _ O
from _ _ O
the _ _ O
register _ _ O
file _ _ O
at _ _ O
the _ _ O
same _ _ O
time _ _ O
→ _ _ O
Add _ _ O
extra _ _ O
read _ _ O
ports _ _ O
to _ _ O
the _ _ O
register _ _ O
file _ _ O
● _ _ O
Two _ _ O
instructions _ _ O
must _ _ O
write _ _ O
to _ _ O
register _ _ O
file _ _ O
at _ _ O
WB _ _ O
stage _ _ O
( _ _ O
not _ _ O
shown _ _ O
) _ _ O
→ _ _ O
Add _ _ O
extra _ _ O
write _ _ O
ports _ _ O
to _ _ O
the _ _ O
register _ _ O
file _ _ O
Register _ _ O
File _ _ O
ALU _ _ O
+ _ _ O
D-Mem _ _ O
7 _ _ O

Structural _ _ O
Hazard _ _ O
in _ _ O
Functional _ _ O
Units _ _ O
( _ _ O
Still _ _ O
Remaining _ _ O
) _ _ O
I-Mem _ _ O
Ins _ _ O
. _ _ O
Decoder _ _ O
● _ _ O
Structural _ _ O
hazard _ _ O
on _ _ O
EX _ _ O
units _ _ O
o _ _ O
Top _ _ O
ALU _ _ O
can _ _ O
handle _ _ O
all _ _ O
arithmetic _ _ O
( _ _ O
+ _ _ O
, _ _ O
- _ _ O
, _ _ O
* _ _ O
, _ _ O
/ _ _ O
) _ _ O
o _ _ O
Bottom _ _ O
ALU _ _ O
can _ _ O
only _ _ O
handle _ _ O
+ _ _ O
, _ _ O
needed _ _ O
for _ _ O
address _ _ O
calculation _ _ O
● _ _ O
Structural _ _ O
hazard _ _ O
on _ _ O
MEM _ _ O
unit _ _ O
o _ _ O
ALU _ _ O
pipeline _ _ O
does _ _ O
not _ _ O
have _ _ O
a _ _ O
MEM _ _ O
unit _ _ O
to _ _ O
access _ _ O
memory _ _ O
Register _ _ O
File _ _ O
ALU _ _ O
+ _ _ O
D-Mem _ _ O
8 _ _ O

Structural _ _ O
Hazard _ _ O
in _ _ O
Functional _ _ O
Units _ _ O
: _ _ O
Example _ _ O
● _ _ O
Code _ _ O
on _ _ O
the _ _ O
left _ _ O
will _ _ O
result _ _ O
in _ _ O
a _ _ O
timeline _ _ O
on _ _ O
the _ _ O
right _ _ O
o _ _ O
If _ _ O
it _ _ O
were _ _ O
not _ _ O
for _ _ O
the _ _ O
bubbles _ _ O
, _ _ O
we _ _ O
could _ _ O
have _ _ O
finished _ _ O
in _ _ O
4 _ _ O
cycles _ _ O
! _ _ O
lw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
lw _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
-4 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
addi _ _ O
$ _ _ O
t2 _ _ O
, _ _ O
$ _ _ O
t2 _ _ O
, _ _ O
-8 _ _ O
add _ _ O
$ _ _ O
t3 _ _ O
, _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
$ _ _ O
s1 _ _ O
add _ _ O
$ _ _ O
t4 _ _ O
, _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
s1 _ _ O
sw _ _ O
$ _ _ O
t5 _ _ O
, _ _ O
8 _ _ O
( _ _ O
$t3 _ _ O
) _ _ O
sw _ _ O
$ _ _ O
t6 _ _ O
, _ _ O
4 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
CC _ _ O
ALU _ _ O
Pipeline _ _ O
1 _ _ O
lw _ _ O
t0 _ _ O
2 _ _ O
addi _ _ O
t2 _ _ O
3 _ _ O
add _ _ O
t3 _ _ O
4 _ _ O
add _ _ O
t4 _ _ O
5 _ _ O
Mem _ _ O
Pipeline _ _ O
lw _ _ O
t1 _ _ O
sw _ _ O
t5 _ _ O
sw _ _ O
t6 _ _ O
9 _ _ O

Structural _ _ O
Hazard _ _ O
Solution _ _ O
: _ _ O
Reordering _ _ O
● _ _ O
Of _ _ O
course _ _ O
we _ _ O
can _ _ O
come _ _ O
up _ _ O
with _ _ O
a _ _ O
better _ _ O
schedule _ _ O
o _ _ O
While _ _ O
still _ _ O
adhering _ _ O
to _ _ O
the _ _ O
data _ _ O
dependencies _ _ O
lw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
lw _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
-4 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
addi _ _ O
$ _ _ O
t2 _ _ O
, _ _ O
$ _ _ O
t2 _ _ O
, _ _ O
-8 _ _ O
add _ _ O
$ _ _ O
t3 _ _ O
, _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
$ _ _ O
s1 _ _ O
add _ _ O
$ _ _ O
t4 _ _ O
, _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
s1 _ _ O
sw _ _ O
$ _ _ O
t5 _ _ O
, _ _ O
8 _ _ O
( _ _ O
$t3 _ _ O
) _ _ O
sw _ _ O
$ _ _ O
t6 _ _ O
, _ _ O
4 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
CC _ _ O
ALU _ _ O
Pipeline _ _ O
1 _ _ O
lw _ _ O
t0 _ _ O
2 _ _ O
addi _ _ O
t2 _ _ O
3 _ _ O
add _ _ O
t3 _ _ O
4 _ _ O
add _ _ O
t4 _ _ O
5 _ _ O
Mem _ _ O
Pipeline _ _ O
lw _ _ O
t1 _ _ O
sw _ _ O
t5 _ _ O
sw _ _ O
t6 _ _ O
10 _ _ O

Why _ _ O
not _ _ O
just _ _ O
duplicate _ _ O
all _ _ O
resources _ _ O
? _ _ O
● _ _ O
Why _ _ O
not _ _ O
have _ _ O
two _ _ O
full _ _ O
ALUs _ _ O
, _ _ O
have _ _ O
MEM _ _ O
units _ _ O
at _ _ O
both _ _ O
pipelines _ _ O
? _ _ O
o _ _ O
That _ _ O
way _ _ O
, _ _ O
we _ _ O
can _ _ O
avoid _ _ O
those _ _ O
structural _ _ O
hazards _ _ O
in _ _ O
the _ _ O
first _ _ O
place _ _ O
o _ _ O
But _ _ O
that _ _ O
leads _ _ O
to _ _ O
low _ _ O
utilization _ _ O
§ _ _ O
ALU _ _ O
/ _ _ O
Branch _ _ O
type _ _ O
instructions _ _ O
will _ _ O
not _ _ O
use _ _ O
the _ _ O
MEM _ _ O
unit _ _ O
§ _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
instructions _ _ O
will _ _ O
not _ _ O
need _ _ O
the _ _ O
full _ _ O
ALU _ _ O
● _ _ O
Most _ _ O
processors _ _ O
have _ _ O
specialized _ _ O
pipelines _ _ O
for _ _ O
different _ _ O
instructions _ _ O
o _ _ O
Integer _ _ O
ALU _ _ O
pipeline _ _ O
, _ _ O
FP _ _ O
ALU _ _ O
pipeline _ _ O
, _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
pipeline _ _ O
, _ _ O
… _ _ O
o _ _ O
With _ _ O
scheduling _ _ O
, _ _ O
can _ _ O
achieve _ _ O
high _ _ O
utilization _ _ O
and _ _ O
performance _ _ O
● _ _ O
Who _ _ O
does _ _ O
the _ _ O
scheduling _ _ O
? _ _ O
Well _ _ O
, _ _ O
we _ _ O
talked _ _ O
about _ _ O
this _ _ O
already _ _ O
: _ _ O
o _ _ O
Static _ _ O
scheduling _ _ O
→ _ _ O
Compiler _ _ O
o _ _ O
Dynamic _ _ O
scheduling _ _ O
→ _ _ O
Processor _ _ O
11 _ _ O

VLIW _ _ O
vs. _ _ O
Superscalar _ _ O
● _ _ O
There _ _ O
are _ _ O
two _ _ O
types _ _ O
of _ _ O
wide-issue _ _ O
processors _ _ O
● _ _ O
If _ _ O
the _ _ O
compiler _ _ O
does _ _ O
static _ _ O
scheduling _ _ O
, _ _ O
the _ _ O
processor _ _ O
is _ _ O
called _ _ O
: _ _ O
o _ _ O
VLIW _ _ O
( _ _ O
Very _ _ O
Long _ _ O
Instruction _ _ O
Word _ _ O
) _ _ O
processor _ _ O
o _ _ O
This _ _ O
is _ _ O
what _ _ O
we _ _ O
will _ _ O
learn _ _ O
this _ _ O
chapter _ _ O
● _ _ O
If _ _ O
the _ _ O
processor _ _ O
does _ _ O
dynamic _ _ O
scheduling _ _ O
, _ _ O
the _ _ O
processor _ _ O
is _ _ O
called _ _ O
: _ _ O
o _ _ O
Superscalar _ _ O
processor _ _ O
o _ _ O
This _ _ O
is _ _ O
what _ _ O
we _ _ O
will _ _ O
learn _ _ O
next _ _ O
chapter _ _ O
12 _ _ O

VLIW _ _ O
Processors _ _ O
13 _ _ O

VLIW _ _ O
Processor _ _ O
Overview _ _ O
● _ _ O
What _ _ O
does _ _ O
Very _ _ O
Long _ _ O
Instruction _ _ O
Word _ _ O
mean _ _ O
anyway _ _ O
? _ _ O
o _ _ O
It _ _ O
means _ _ O
one _ _ O
instruction _ _ O
is _ _ O
very _ _ O
long _ _ O
! _ _ O
o _ _ O
Why _ _ O
? _ _ O
Because _ _ O
it _ _ O
contains _ _ O
multiple _ _ O
operations _ _ O
in _ _ O
one _ _ O
instruction _ _ O
● _ _ O
A _ _ O
( _ _ O
64 _ _ O
bits _ _ O
long _ _ O
) _ _ O
VLIW _ _ O
instruction _ _ O
for _ _ O
our _ _ O
example _ _ O
architecture _ _ O
: _ _ O
ALU _ _ O
/ _ _ O
Branch _ _ O
Operation _ _ O
( _ _ O
32 _ _ O
bits _ _ O
) _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
Operation _ _ O
( _ _ O
32 _ _ O
bits _ _ O
) _ _ O
● _ _ O
An _ _ O
example _ _ O
instruction _ _ O
could _ _ O
be _ _ O
: _ _ O
addi _ _ O
$ _ _ O
t2 _ _ O
, _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
-8 _ _ O
lw _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
-4 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
● _ _ O
Or _ _ O
another _ _ O
example _ _ O
could _ _ O
be _ _ O
: _ _ O
nop _ _ O
lw _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
-4 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
14 _ _ O

A _ _ O
VLIW _ _ O
instruction _ _ O
is _ _ O
one _ _ O
instruction _ _ O
Ins _ _ O
. _ _ O
Decoder _ _ O
I-Mem _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
Op _ _ O
ALU _ _ O
Op _ _ O
● _ _ O
For _ _ O
all _ _ O
purposes _ _ O
, _ _ O
a _ _ O
VLIW _ _ O
instruction _ _ O
acts _ _ O
like _ _ O
one _ _ O
instruction _ _ O
o _ _ O
It _ _ O
moves _ _ O
as _ _ O
a _ _ O
unit _ _ O
through _ _ O
the _ _ O
pipeline _ _ O
Register _ _ O
File _ _ O
ALU _ _ O
+ _ _ O
D-Mem _ _ O
15 _ _ O

VLIW _ _ O
instruction _ _ O
encoding _ _ O
for _ _ O
example _ _ O
nop _ _ O
lw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
addi _ _ O
$ _ _ O
t2 _ _ O
, _ _ O
$ _ _ O
t2 _ _ O
, _ _ O
-8 _ _ O
lw _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
-4 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
add _ _ O
$ _ _ O
t3 _ _ O
, _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
$ _ _ O
s1 _ _ O
nop _ _ O
add _ _ O
$ _ _ O
t4 _ _ O
, _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
s1 _ _ O
sw _ _ O
$ _ _ O
t5 _ _ O
, _ _ O
8 _ _ O
( _ _ O
$t3 _ _ O
) _ _ O
nop _ _ O
sw _ _ O
$ _ _ O
t6 _ _ O
, _ _ O
4 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
Inst _ _ O
ALU _ _ O
Op _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
Op _ _ O
1 _ _ O
nop _ _ O
lw _ _ O
t0 _ _ O
2 _ _ O
addi _ _ O
t2 _ _ O
lw _ _ O
t1 _ _ O
3 _ _ O
add _ _ O
t3 _ _ O
nop _ _ O
4 _ _ O
add _ _ O
t4 _ _ O
sw _ _ O
t5 _ _ O
5 _ _ O
nop _ _ O
sw _ _ O
t6 _ _ O
• _ _ O
• _ _ O
Each _ _ O
square _ _ O
is _ _ O
an _ _ O
instruction _ _ O
. _ _ O
( _ _ O
There _ _ O
are _ _ O
5 _ _ O
instructions _ _ O
. _ _ O
) _ _ O
Nops _ _ O
are _ _ O
inserted _ _ O
by _ _ O
the _ _ O
compiler _ _ O
. _ _ O
16 _ _ O

VLIW _ _ O
instruction _ _ O
encoding _ _ O
( _ _ O
after _ _ O
reordering _ _ O
) _ _ O
add _ _ O
$ _ _ O
t4 _ _ O
, _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
s1 _ _ O
lw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
addi _ _ O
$ _ _ O
t2 _ _ O
, _ _ O
$ _ _ O
t2 _ _ O
, _ _ O
-8 _ _ O
lw _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
-4 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
add _ _ O
$ _ _ O
t3 _ _ O
, _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
$ _ _ O
s1 _ _ O
sw _ _ O
$ _ _ O
t6 _ _ O
, _ _ O
4 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
nop _ _ O
sw _ _ O
$ _ _ O
t5 _ _ O
, _ _ O
8 _ _ O
( _ _ O
$t3 _ _ O
) _ _ O
Inst _ _ O
ALU _ _ O
Op _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
Op _ _ O
1 _ _ O
add _ _ O
t4 _ _ O
lw _ _ O
t0 _ _ O
2 _ _ O
addi _ _ O
t2 _ _ O
lw _ _ O
t1 _ _ O
3 _ _ O
add _ _ O
t3 _ _ O
sw _ _ O
t6 _ _ O
4 _ _ O
nop _ _ O
sw _ _ O
t5 _ _ O
• _ _ O
Same _ _ O
program _ _ O
with _ _ O
4 _ _ O
instructions _ _ O
! _ _ O
17 _ _ O

VLIW _ _ O
Architectures _ _ O
are _ _ O
( _ _ O
Very _ _ O
) _ _ O
Power _ _ O
Efficient _ _ O
● _ _ O
All _ _ O
scheduling _ _ O
is _ _ O
done _ _ O
by _ _ O
the _ _ O
compiler _ _ O
offline _ _ O
● _ _ O
No _ _ O
need _ _ O
for _ _ O
the _ _ O
Hazard _ _ O
Detection _ _ O
Unit _ _ O
o _ _ O
Nops _ _ O
are _ _ O
inserted _ _ O
by _ _ O
the _ _ O
compiler _ _ O
when _ _ O
necessary _ _ O
● _ _ O
No _ _ O
need _ _ O
for _ _ O
a _ _ O
dynamic _ _ O
scheduler _ _ O
o _ _ O
Which _ _ O
can _ _ O
be _ _ O
even _ _ O
more _ _ O
power _ _ O
hungry _ _ O
than _ _ O
the _ _ O
HDU _ _ O
● _ _ O
Even _ _ O
no _ _ O
need _ _ O
for _ _ O
the _ _ O
Forwarding _ _ O
Unit _ _ O
o _ _ O
If _ _ O
compiler _ _ O
is _ _ O
good _ _ O
enough _ _ O
and _ _ O
fill _ _ O
all _ _ O
bubbles _ _ O
with _ _ O
instructions _ _ O
o _ _ O
Or _ _ O
, _ _ O
may _ _ O
have _ _ O
cheap _ _ O
compiler-controlled _ _ O
forwarding _ _ O
in _ _ O
ISA _ _ O
18 _ _ O

Challenges _ _ O
of _ _ O
VLIW _ _ O
● _ _ O
All _ _ O
the _ _ O
challenges _ _ O
of _ _ O
static _ _ O
scheduling _ _ O
apply _ _ O
here _ _ O
X _ _ O
2 _ _ O
● _ _ O
Review _ _ O
: _ _ O
what _ _ O
were _ _ O
the _ _ O
limitations _ _ O
? _ _ O
o _ _ O
Compiler _ _ O
must _ _ O
make _ _ O
assumptions _ _ O
about _ _ O
the _ _ O
pipeline _ _ O
→ _ _ O
ISA _ _ O
now _ _ O
becomes _ _ O
much _ _ O
more _ _ O
than _ _ O
instruction _ _ O
set _ _ O
+ _ _ O
registers _ _ O
→ _ _ O
ISA _ _ O
restricts _ _ O
modification _ _ O
of _ _ O
pipeline _ _ O
in _ _ O
future _ _ O
generations _ _ O
o _ _ O
Compiler _ _ O
must _ _ O
do _ _ O
scheduling _ _ O
without _ _ O
runtime _ _ O
information _ _ O
→ _ _ O
Length _ _ O
of _ _ O
MEM _ _ O
stage _ _ O
is _ _ O
hard _ _ O
to _ _ O
predict _ _ O
( _ _ O
due _ _ O
to _ _ O
Memory _ _ O
Wall _ _ O
) _ _ O
→ _ _ O
Data _ _ O
dependencies _ _ O
are _ _ O
hard _ _ O
( _ _ O
must _ _ O
do _ _ O
pointer _ _ O
analysis _ _ O
) _ _ O
● _ _ O
These _ _ O
limitations _ _ O
are _ _ O
exacerbated _ _ O
with _ _ O
VLIW _ _ O
19 _ _ O

Not _ _ O
Portable _ _ O
due _ _ O
to _ _ O
Assumptions _ _ O
About _ _ O
Pipeline _ _ O
● _ _ O
VLIW _ _ O
ties _ _ O
ISA _ _ O
to _ _ O
a _ _ O
particular _ _ O
processor _ _ O
design _ _ O
o _ _ O
One _ _ O
that _ _ O
is _ _ O
2-wide _ _ O
and _ _ O
has _ _ O
an _ _ O
ALU _ _ O
op _ _ O
and _ _ O
a _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
op _ _ O
o _ _ O
What _ _ O
if _ _ O
future _ _ O
processors _ _ O
are _ _ O
wider _ _ O
or _ _ O
contain _ _ O
different _ _ O
ops _ _ O
? _ _ O
● _ _ O
Code _ _ O
must _ _ O
be _ _ O
recompiled _ _ O
repeatedly _ _ O
for _ _ O
future _ _ O
processors _ _ O
o _ _ O
Not _ _ O
suitable _ _ O
for _ _ O
releasing _ _ O
general _ _ O
purpose _ _ O
software _ _ O
o _ _ O
Reason _ _ O
VLIW _ _ O
is _ _ O
most _ _ O
often _ _ O
used _ _ O
for _ _ O
embedded _ _ O
software _ _ O
( _ _ O
Because _ _ O
embedded _ _ O
software _ _ O
is _ _ O
not _ _ O
expected _ _ O
to _ _ O
be _ _ O
portable _ _ O
) _ _ O
● _ _ O
Is _ _ O
there _ _ O
any _ _ O
way _ _ O
to _ _ O
get _ _ O
around _ _ O
this _ _ O
problem _ _ O
? _ _ O
20 _ _ O

Making _ _ O
VLIW _ _ O
Software _ _ O
Portable _ _ O
● _ _ O
There _ _ O
are _ _ O
mainly _ _ O
two _ _ O
ways _ _ O
VLIW _ _ O
software _ _ O
can _ _ O
become _ _ O
portable _ _ O
1 _ _ O
. _ _ O
Allow _ _ O
CPU _ _ O
to _ _ O
exploit _ _ O
parallelism _ _ O
according _ _ O
to _ _ O
capability _ _ O
o _ _ O
Analogy _ _ O
: _ _ O
multithreaded _ _ O
software _ _ O
does _ _ O
not _ _ O
specify _ _ O
number _ _ O
of _ _ O
cores _ _ O
§ _ _ O
SW _ _ O
: _ _ O
Makes _ _ O
parallelism _ _ O
explicit _ _ O
by _ _ O
coding _ _ O
using _ _ O
threads _ _ O
§ _ _ O
CPU _ _ O
: _ _ O
Exploits _ _ O
parallelism _ _ O
to _ _ O
the _ _ O
extent _ _ O
it _ _ O
has _ _ O
number _ _ O
of _ _ O
cores _ _ O
o _ _ O
Portable _ _ O
VLIW _ _ O
: _ _ O
ISA _ _ O
does _ _ O
not _ _ O
specify _ _ O
number _ _ O
of _ _ O
ops _ _ O
in _ _ O
instruction _ _ O
§ _ _ O
SW _ _ O
: _ _ O
Makes _ _ O
parallelism _ _ O
explicit _ _ O
by _ _ O
using _ _ O
bundles _ _ O
– _ _ O
Bundle _ _ O
: _ _ O
a _ _ O
group _ _ O
of _ _ O
ops _ _ O
that _ _ O
can _ _ O
execute _ _ O
together _ _ O
– _ _ O
Wider _ _ O
processors _ _ O
fetch _ _ O
several _ _ O
bundles _ _ O
to _ _ O
form _ _ O
one _ _ O
instruction _ _ O
– _ _ O
A _ _ O
“ _ _ O
stop _ _ O
bit _ _ O
” _ _ O
tells _ _ O
processor _ _ O
to _ _ O
stop _ _ O
fetching _ _ O
the _ _ O
next _ _ O
bundle _ _ O
§ _ _ O
Intel _ _ O
Itanium _ _ O
EPIC _ _ O
( _ _ O
Explicitly _ _ O
Parallel _ _ O
Instruction _ _ O
Computing _ _ O
) _ _ O
– _ _ O
A _ _ O
general-purpose _ _ O
ISA _ _ O
that _ _ O
uses _ _ O
bundles _ _ O
21 _ _ O

Making _ _ O
VLIW _ _ O
Software _ _ O
Portable _ _ O
● _ _ O
There _ _ O
are _ _ O
mainly _ _ O
two _ _ O
ways _ _ O
VLIW _ _ O
software _ _ O
can _ _ O
become _ _ O
portable _ _ O
2 _ _ O
. _ _ O
Binary _ _ O
translation _ _ O
o _ _ O
Have _ _ O
firmware _ _ O
translate _ _ O
binary _ _ O
to _ _ O
new _ _ O
VLIW _ _ O
ISA _ _ O
on _ _ O
the _ _ O
fly _ _ O
o _ _ O
Very _ _ O
similar _ _ O
to _ _ O
how _ _ O
Apple _ _ O
Rosetta _ _ O
converts _ _ O
x86 _ _ O
to _ _ O
ARM _ _ O
ISA _ _ O
o _ _ O
Does _ _ O
n’t _ _ O
this _ _ O
go _ _ O
against _ _ O
the _ _ O
power _ _ O
efficiency _ _ O
of _ _ O
VLIWs _ _ O
? _ _ O
§ _ _ O
Yes _ _ O
, _ _ O
but _ _ O
if _ _ O
SW _ _ O
runs _ _ O
for _ _ O
long _ _ O
time _ _ O
, _ _ O
one-time _ _ O
translation _ _ O
is _ _ O
nothing _ _ O
§ _ _ O
Translation _ _ O
can _ _ O
be _ _ O
cached _ _ O
in _ _ O
file _ _ O
system _ _ O
for _ _ O
next _ _ O
run _ _ O
o _ _ O
Transmeta _ _ O
Crusoe _ _ O
converted _ _ O
x86 _ _ O
to _ _ O
an _ _ O
ultra _ _ O
low-power _ _ O
VLIW _ _ O
22 _ _ O

Scheduling _ _ O
without _ _ O
Runtime _ _ O
Information _ _ O
● _ _ O
Up _ _ O
to _ _ O
the _ _ O
compiler _ _ O
to _ _ O
create _ _ O
schedule _ _ O
with _ _ O
minimal _ _ O
nops _ _ O
o _ _ O
Use _ _ O
reordering _ _ O
to _ _ O
fill _ _ O
nops _ _ O
with _ _ O
useful _ _ O
operations _ _ O
● _ _ O
All _ _ O
the _ _ O
challenges _ _ O
of _ _ O
static _ _ O
scheduling _ _ O
remain _ _ O
o _ _ O
Length _ _ O
of _ _ O
MEM _ _ O
stage _ _ O
is _ _ O
hard _ _ O
to _ _ O
predict _ _ O
( _ _ O
due _ _ O
to _ _ O
Memory _ _ O
Wall _ _ O
) _ _ O
o _ _ O
Data _ _ O
dependencies _ _ O
are _ _ O
hard _ _ O
to _ _ O
figure _ _ O
out _ _ O
( _ _ O
due _ _ O
to _ _ O
pointer _ _ O
analysis _ _ O
) _ _ O
● _ _ O
But _ _ O
these _ _ O
challenges _ _ O
become _ _ O
especially _ _ O
acute _ _ O
for _ _ O
VLIW _ _ O
o _ _ O
For _ _ O
4-wide _ _ O
VLIW _ _ O
, _ _ O
need _ _ O
to _ _ O
find _ _ O
4 _ _ O
operations _ _ O
to _ _ O
fill _ _ O
“ _ _ O
one _ _ O
” _ _ O
bubble _ _ O
! _ _ O
o _ _ O
Operations _ _ O
in _ _ O
one _ _ O
instruction _ _ O
must _ _ O
be _ _ O
data _ _ O
independent _ _ O
§ _ _ O
Data _ _ O
forwarding _ _ O
will _ _ O
not _ _ O
work _ _ O
within _ _ O
one _ _ O
instruction _ _ O
( _ _ O
Obviously _ _ O
because _ _ O
they _ _ O
are _ _ O
executing _ _ O
on _ _ O
the _ _ O
same _ _ O
cycle _ _ O
) _ _ O
23 _ _ O

Predicates _ _ O
Help _ _ O
in _ _ O
Compiler _ _ O
Scheduling _ _ O
● _ _ O
Use _ _ O
of _ _ O
predicates _ _ O
can _ _ O
be _ _ O
a _ _ O
big _ _ O
help _ _ O
in _ _ O
finding _ _ O
useful _ _ O
operations _ _ O
o _ _ O
Reordering _ _ O
can _ _ O
not _ _ O
happen _ _ O
across _ _ O
control _ _ O
dependencies _ _ O
lw _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s0 _ _ O
) _ _ O
addi _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
1 _ _ O
bne _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
s2 _ _ O
, _ _ O
else _ _ O
then _ _ O
: _ _ O
li _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
1 _ _ O
Can _ _ O
only _ _ O
reorder _ _ O
within _ _ O
this _ _ O
block _ _ O
else _ _ O
: _ _ O
li _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
o _ _ O
Predicates _ _ O
can _ _ O
convert _ _ O
if-then-else _ _ O
code _ _ O
into _ _ O
one _ _ O
big _ _ O
block _ _ O
pne _ _ O
$ _ _ O
p1 _ _ O
, _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
s2 _ _ O
lw _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s0 _ _ O
) _ _ O
li.p _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
1 _ _ O
, _ _ O
! _ _ O
$ _ _ O
p1 _ _ O
li.p _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
, _ _ O
$ _ _ O
p1 _ _ O
addi _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
1 _ _ O
Can _ _ O
reorder _ _ O
within _ _ O
a _ _ O
larger _ _ O
window _ _ O
! _ _ O
24 _ _ O

But _ _ O
Predicates _ _ O
Can _ _ O
not _ _ O
Remove _ _ O
Loopback _ _ O
Branches _ _ O
● _ _ O
Loops _ _ O
are _ _ O
particularly _ _ O
challenging _ _ O
to _ _ O
the _ _ O
compiler _ _ O
. _ _ O
Why _ _ O
? _ _ O
o _ _ O
Scheduling _ _ O
is _ _ O
limited _ _ O
to _ _ O
within _ _ O
the _ _ O
loop _ _ O
o _ _ O
For _ _ O
tight _ _ O
loops _ _ O
, _ _ O
not _ _ O
much _ _ O
compiler _ _ O
can _ _ O
do _ _ O
with _ _ O
a _ _ O
handful _ _ O
of _ _ O
insts _ _ O
loop _ _ O
: _ _ O
lw _ _ O
$ _ _ O
s0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$t1 _ _ O
) _ _ O
addi _ _ O
$ _ _ O
s0 _ _ O
, _ _ O
$ _ _ O
s0 _ _ O
, _ _ O
10 _ _ O
addi _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
1 _ _ O
bne _ _ O
$ _ _ O
s0 _ _ O
, _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
loop _ _ O
Can _ _ O
only _ _ O
reorder _ _ O
within _ _ O
this _ _ O
block _ _ O
… _ _ O
This _ _ O
block _ _ O
is _ _ O
off _ _ O
limits _ _ O
! _ _ O
25 _ _ O

Compiler _ _ O
Scheduling _ _ O
of _ _ O
a _ _ O
Loop _ _ O
● _ _ O
Suppose _ _ O
we _ _ O
had _ _ O
this _ _ O
example _ _ O
loop _ _ O
( _ _ O
in _ _ O
MIPS _ _ O
) _ _ O
: _ _ O
Loop _ _ O
: _ _ O
lw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
add _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
$ _ _ O
s2 _ _ O
sw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
addi _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
-4 _ _ O
bne _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
zero _ _ O
, _ _ O
Loop _ _ O
/ _ _ O
/ _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
array _ _ O
[ _ _ O
$s1 _ _ O
] _ _ O
/ _ _ O
/ _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
$ _ _ O
t0 _ _ O
+ _ _ O
$ _ _ O
s2 _ _ O
/ _ _ O
/ _ _ O
array _ _ O
[ _ _ O
$s1 _ _ O
] _ _ O
= _ _ O
$ _ _ O
t0 _ _ O
/ _ _ O
/ _ _ O
$ _ _ O
s1++ _ _ O
/ _ _ O
/ _ _ O
loopback _ _ O
if _ _ O
$ _ _ O
s1 _ _ O
! _ _ O
= _ _ O
0 _ _ O
● _ _ O
Loop _ _ O
iterates _ _ O
over _ _ O
an _ _ O
array _ _ O
adding _ _ O
$ _ _ O
s2 _ _ O
to _ _ O
each _ _ O
element _ _ O
26 _ _ O

Compiler _ _ O
Scheduling _ _ O
of _ _ O
a _ _ O
Loop _ _ O
● _ _ O
Let _ _ O
’s _ _ O
first _ _ O
reschedule _ _ O
to _ _ O
hide _ _ O
the _ _ O
use-after-load _ _ O
hazard _ _ O
Loop _ _ O
: _ _ O
lw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
add _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
$ _ _ O
s2 _ _ O
sw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
addi _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
-4 _ _ O
bne _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
zero _ _ O
, _ _ O
Loop _ _ O
Loop _ _ O
: _ _ O
lw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
addi _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
-4 _ _ O
add _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
$ _ _ O
s2 _ _ O
sw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
4 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
bne _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
zero _ _ O
, _ _ O
Loop _ _ O
● _ _ O
Now _ _ O
dependence _ _ O
on _ _ O
$ _ _ O
t0 _ _ O
is _ _ O
further _ _ O
away _ _ O
● _ _ O
Note _ _ O
we _ _ O
broke _ _ O
a _ _ O
WAR _ _ O
( _ _ O
Write-After-Read _ _ O
) _ _ O
dependence _ _ O
on _ _ O
$ _ _ O
s1 _ _ O
o _ _ O
Now _ _ O
$ _ _ O
s1 _ _ O
in _ _ O
sw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
is _ _ O
result _ _ O
of _ _ O
addi _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
-4 _ _ O
● _ _ O
We _ _ O
must _ _ O
compensate _ _ O
by _ _ O
changing _ _ O
the _ _ O
sw _ _ O
offset _ _ O
by _ _ O
+4 _ _ O
: _ _ O
o _ _ O
sw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
→ _ _ O
sw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
4 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
27 _ _ O

Compiler _ _ O
Scheduling _ _ O
of _ _ O
a _ _ O
Loop _ _ O
● _ _ O
Below _ _ O
is _ _ O
the _ _ O
VLIW _ _ O
representation _ _ O
of _ _ O
the _ _ O
rescheduled _ _ O
MIPS _ _ O
code _ _ O
: _ _ O
Loop _ _ O
: _ _ O
ALU _ _ O
/ _ _ O
Branch _ _ O
Op _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
Op _ _ O
lw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
Loop _ _ O
: _ _ O
addi _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
-4 _ _ O
lw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
addi _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
-4 _ _ O
nop _ _ O
nop _ _ O
add _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
$ _ _ O
s2 _ _ O
add _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
$ _ _ O
s2 _ _ O
nop _ _ O
sw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
4 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
bne _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
0 _ _ O
, _ _ O
Loop _ _ O
sw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
4 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
bne _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
zero _ _ O
, _ _ O
Loop _ _ O
● _ _ O
We _ _ O
ca _ _ O
n’t _ _ O
fill _ _ O
any _ _ O
further _ _ O
nops _ _ O
due _ _ O
to _ _ O
data _ _ O
hazards _ _ O
● _ _ O
In _ _ O
terms _ _ O
of _ _ O
MIPS _ _ O
instructions _ _ O
, _ _ O
IPC _ _ O
= _ _ O
5 _ _ O
/ _ _ O
4 _ _ O
= _ _ O
1.25 _ _ O
o _ _ O
Ideally _ _ O
, _ _ O
IPC _ _ O
can _ _ O
reach _ _ O
2 _ _ O
so _ _ O
we _ _ O
are _ _ O
not _ _ O
doing _ _ O
very _ _ O
well _ _ O
here _ _ O
● _ _ O
Is _ _ O
there _ _ O
a _ _ O
way _ _ O
compiler _ _ O
can _ _ O
expand _ _ O
the _ _ O
“ _ _ O
window _ _ O
” _ _ O
for _ _ O
scheduling _ _ O
? _ _ O
o _ _ O
Idea _ _ O
: _ _ O
use _ _ O
multiple _ _ O
iterations _ _ O
of _ _ O
the _ _ O
loop _ _ O
for _ _ O
scheduling _ _ O
! _ _ O
28 _ _ O

Loop _ _ O
unrolling _ _ O
29 _ _ O

What _ _ O
is _ _ O
Loop _ _ O
Unrolling _ _ O
? _ _ O
● _ _ O
Loop _ _ O
unrolling _ _ O
: _ _ O
a _ _ O
compiler _ _ O
technique _ _ O
to _ _ O
enlarge _ _ O
loop _ _ O
body _ _ O
o _ _ O
By _ _ O
duplicating _ _ O
loop _ _ O
body _ _ O
for _ _ O
an _ _ O
X _ _ O
number _ _ O
of _ _ O
iterations _ _ O
for _ _ O
( _ _ O
i _ _ O
= _ _ O
0 _ _ O
; _ _ O
i _ _ O
< _ _ O
100 _ _ O
; _ _ O
i++ _ _ O
) _ _ O
Unrolled _ _ O
loop _ _ O
( _ _ O
2X _ _ O
) _ _ O
a _ _ O
[ _ _ O
i _ _ O
] _ _ O
= _ _ O
b _ _ O
[ _ _ O
i _ _ O
] _ _ O
+ _ _ O
c _ _ O
[ _ _ O
i _ _ O
] _ _ O
; _ _ O
for _ _ O
( _ _ O
i _ _ O
= _ _ O
0 _ _ O
; _ _ O
i _ _ O
< _ _ O
100 _ _ O
; _ _ O
i _ _ O
+ _ _ O
= _ _ O
2 _ _ O
) _ _ O
{ _ _ O
Original _ _ O
loop _ _ O
a _ _ O
[ _ _ O
i _ _ O
] _ _ O
= _ _ O
b _ _ O
[ _ _ O
i _ _ O
] _ _ O
+ _ _ O
c _ _ O
[ _ _ O
i _ _ O
] _ _ O
; _ _ O
a _ _ O
[ _ _ O
i+1 _ _ O
] _ _ O
= _ _ O
b _ _ O
[ _ _ O
i+1 _ _ O
] _ _ O
+ _ _ O
c _ _ O
[ _ _ O
i+1 _ _ O
] _ _ O
; _ _ O
} _ _ O
● _ _ O
What _ _ O
does _ _ O
this _ _ O
buy _ _ O
us _ _ O
? _ _ O
o _ _ O
More _ _ O
instructions _ _ O
inside _ _ O
loop _ _ O
to _ _ O
reorder _ _ O
and _ _ O
hide _ _ O
bubbles _ _ O
o _ _ O
And _ _ O
less _ _ O
instructions _ _ O
to _ _ O
execute _ _ O
as _ _ O
a _ _ O
whole _ _ O
§ _ _ O
Less _ _ O
frequent _ _ O
loop _ _ O
branches _ _ O
§ _ _ O
Two _ _ O
i++ _ _ O
are _ _ O
merged _ _ O
into _ _ O
one _ _ O
i+= _ _ O
2 _ _ O
30 _ _ O

Let _ _ O
’s _ _ O
try _ _ O
unrolling _ _ O
our _ _ O
example _ _ O
code _ _ O
Loop _ _ O
: _ _ O
lw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
addi _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
-4 _ _ O
add _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
$ _ _ O
s2 _ _ O
sw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
4 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
bne _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
zero _ _ O
, _ _ O
Loop _ _ O
Loop _ _ O
: _ _ O
lw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
Unroll _ _ O
2X _ _ O
addi _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
-4 _ _ O
add _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
$ _ _ O
s2 _ _ O
sw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
4 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
lw _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
-4 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
addi _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
-4 _ _ O
add _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
$ _ _ O
s2 _ _ O
sw _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
4 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
bne _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
zero _ _ O
, _ _ O
Loop _ _ O
● _ _ O
Instructions _ _ O
are _ _ O
duplicated _ _ O
but _ _ O
using _ _ O
$ _ _ O
t1 _ _ O
instead _ _ O
of _ _ O
$ _ _ O
t0 _ _ O
● _ _ O
This _ _ O
is _ _ O
intentional _ _ O
to _ _ O
minimize _ _ O
false _ _ O
dependencies _ _ O
during _ _ O
reordering _ _ O
31 _ _ O

Now _ _ O
time _ _ O
to _ _ O
reorder _ _ O
the _ _ O
code _ _ O
! _ _ O
Loop _ _ O
: _ _ O
lw _ _ O
lw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
-4 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
addi _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
-4 _ _ O
addi _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
-4 _ _ O
add _ _ O
add _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
$ _ _ O
s2 _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
$ _ _ O
s2 _ _ O
sw _ _ O
sw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
8 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
4 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
bne _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
zero _ _ O
, _ _ O
Loop _ _ O
Reorder _ _ O
! _ _ O
Loop _ _ O
: _ _ O
lw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
addi _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
-4 _ _ O
add _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
$ _ _ O
s2 _ _ O
sw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
4 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
lw _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
-4 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
addi _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
-4 _ _ O
add _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
$ _ _ O
s2 _ _ O
sw _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
4 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
bne _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
zero _ _ O
, _ _ O
Loop _ _ O
● _ _ O
Interleaving _ _ O
iterations _ _ O
spaces _ _ O
out _ _ O
dependencies _ _ O
( _ _ O
2X _ _ O
= _ _ O
unroll _ _ O
factor _ _ O
) _ _ O
32 _ _ O

Merge _ _ O
induction _ _ O
variable _ _ O
increment _ _ O
Loop _ _ O
: _ _ O
lw _ _ O
lw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
-4 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
addi _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
-4 _ _ O
addi _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
-4 _ _ O
add _ _ O
add _ _ O
sw _ _ O
sw _ _ O
bne _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
$ _ _ O
s2 _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
$ _ _ O
s2 _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
8 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
4 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
Merge _ _ O
Loop _ _ O
: _ _ O
lw _ _ O
lw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
-4 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
addi _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
-8 _ _ O
add _ _ O
add _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
$ _ _ O
s2 _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
$ _ _ O
s2 _ _ O
sw _ _ O
sw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
8 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
4 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
bne _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
zero _ _ O
, _ _ O
Loop _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
zero _ _ O
, _ _ O
Loop _ _ O
● _ _ O
Two _ _ O
addi _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
-4 _ _ O
are _ _ O
merged _ _ O
into _ _ O
addi _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
-8 _ _ O
33 _ _ O

Scheduling _ _ O
unrolled _ _ O
loop _ _ O
onto _ _ O
VLIW _ _ O
Loop _ _ O
: _ _ O
lw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
ALU _ _ O
/ _ _ O
Branch _ _ O
Op _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
Op _ _ O
lw _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
-4 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
Loop _ _ O
: _ _ O
nop _ _ O
lw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
addi _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
-8 _ _ O
add _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
$ _ _ O
s2 _ _ O
addi _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
-8 _ _ O
lw _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
-4 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
add _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
$ _ _ O
s2 _ _ O
add _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
$ _ _ O
s2 _ _ O
nop _ _ O
sw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
8 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
add _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
$ _ _ O
s2 _ _ O
sw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
8 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
sw _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
4 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
bne _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
0 _ _ O
, _ _ O
Loop _ _ O
sw _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
4 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
bne _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
zero _ _ O
, _ _ O
Loop _ _ O
● _ _ O
Now _ _ O
we _ _ O
spend _ _ O
5 _ _ O
cycles _ _ O
for _ _ O
2 _ _ O
iterations _ _ O
of _ _ O
the _ _ O
loop _ _ O
o _ _ O
So _ _ O
, _ _ O
5 _ _ O
/ _ _ O
2 _ _ O
= _ _ O
2.5 _ _ O
cycles _ _ O
per _ _ O
iteration _ _ O
o _ _ O
Much _ _ O
better _ _ O
than _ _ O
the _ _ O
previous _ _ O
4 _ _ O
cycles _ _ O
for _ _ O
1 _ _ O
iteration _ _ O
! _ _ O
34 _ _ O

Let _ _ O
’s _ _ O
try _ _ O
unrolling _ _ O
our _ _ O
example _ _ O
code _ _ O
4X _ _ O
● _ _ O
4X _ _ O
Unrolled _ _ O
loop _ _ O
converted _ _ O
to _ _ O
VLIW _ _ O
: _ _ O
ALU _ _ O
/ _ _ O
Branch _ _ O
Op _ _ O
Loop _ _ O
: _ _ O
addi _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
-16 _ _ O
nop _ _ O
add _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
$ _ _ O
s2 _ _ O
add _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
$ _ _ O
s2 _ _ O
add _ _ O
$ _ _ O
t2 _ _ O
, _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
$ _ _ O
s2 _ _ O
add _ _ O
$ _ _ O
t3 _ _ O
, _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
$ _ _ O
s2 _ _ O
nop _ _ O
bne _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
0 _ _ O
, _ _ O
Loop _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
Op _ _ O
lw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
lw _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
12 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
lw _ _ O
$ _ _ O
t2 _ _ O
, _ _ O
8 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
lw _ _ O
$ _ _ O
t3 _ _ O
, _ _ O
4 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
sw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
16 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
sw _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
12 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
sw _ _ O
$ _ _ O
t2 _ _ O
, _ _ O
8 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
sw _ _ O
$ _ _ O
t3 _ _ O
, _ _ O
4 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
Inst _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
5 _ _ O
6 _ _ O
7 _ _ O
8 _ _ O
● _ _ O
Now _ _ O
we _ _ O
spend _ _ O
8 _ _ O
cycles _ _ O
for _ _ O
4 _ _ O
iterations _ _ O
of _ _ O
the _ _ O
loop _ _ O
o _ _ O
So _ _ O
, _ _ O
8 _ _ O
/ _ _ O
4 _ _ O
= _ _ O
2 _ _ O
cycles _ _ O
per _ _ O
iteration _ _ O
o _ _ O
Even _ _ O
better _ _ O
2.5 _ _ O
cycles _ _ O
per _ _ O
iteration _ _ O
for _ _ O
2X _ _ O
unrolling _ _ O
35 _ _ O

What _ _ O
happens _ _ O
when _ _ O
you _ _ O
unroll _ _ O
8X _ _ O
? _ _ O
● _ _ O
8X _ _ O
Unrolled _ _ O
loop _ _ O
converted _ _ O
to _ _ O
VLIW _ _ O
: _ _ O
ALU _ _ O
/ _ _ O
Branch _ _ O
Op _ _ O
Loop _ _ O
: _ _ O
addi _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
-32 _ _ O
nop _ _ O
… _ _ O
add _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
$ _ _ O
s2 _ _ O
add _ _ O
$ _ _ O
t2 _ _ O
, _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
$ _ _ O
s2 _ _ O
add _ _ O
$ _ _ O
t3 _ _ O
, _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
$ _ _ O
s2 _ _ O
… _ _ O
bne _ _ O
$ _ _ O
s1 _ _ O
, _ _ O
$ _ _ O
0 _ _ O
, _ _ O
Loop _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
Op _ _ O
lw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
lw _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
28 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
… _ _ O
lw _ _ O
$ _ _ O
t7 _ _ O
, _ _ O
4 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
sw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
32 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
sw _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
28 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
… _ _ O
sw _ _ O
$ _ _ O
t7 _ _ O
, _ _ O
4 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
Inst _ _ O
1 _ _ O
2 _ _ O
… _ _ O
8 _ _ O
9 _ _ O
10 _ _ O
… _ _ O
16 _ _ O
● _ _ O
Now _ _ O
we _ _ O
spend _ _ O
16 _ _ O
cycles _ _ O
for _ _ O
8 _ _ O
iterations _ _ O
of _ _ O
the _ _ O
loop _ _ O
o _ _ O
So _ _ O
, _ _ O
16 _ _ O
/ _ _ O
8 _ _ O
= _ _ O
2 _ _ O
cycles _ _ O
per _ _ O
iteration _ _ O
( _ _ O
no _ _ O
improvement _ _ O
over _ _ O
4X _ _ O
) _ _ O
o _ _ O
2 _ _ O
is _ _ O
minimum _ _ O
because _ _ O
you _ _ O
need _ _ O
one _ _ O
lw _ _ O
and _ _ O
one _ _ O
sw _ _ O
per _ _ O
iteration _ _ O
36 _ _ O

When _ _ O
should _ _ O
the _ _ O
compiler _ _ O
stop _ _ O
unrolling _ _ O
? _ _ O
● _ _ O
Obviously _ _ O
when _ _ O
there _ _ O
is _ _ O
no _ _ O
longer _ _ O
a _ _ O
benefit _ _ O
as _ _ O
we _ _ O
saw _ _ O
just _ _ O
now _ _ O
● _ _ O
But _ _ O
there _ _ O
are _ _ O
other _ _ O
constraints _ _ O
that _ _ O
can _ _ O
prevent _ _ O
unrolling _ _ O
1 _ _ O
. _ _ O
Limitation _ _ O
in _ _ O
number _ _ O
of _ _ O
registers _ _ O
o _ _ O
More _ _ O
unrolling _ _ O
uses _ _ O
more _ _ O
registers _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
$ _ _ O
t2 _ _ O
, _ _ O
… _ _ O
o _ _ O
For _ _ O
this _ _ O
reason _ _ O
, _ _ O
VLIW _ _ O
ISAs _ _ O
have _ _ O
many _ _ O
more _ _ O
registers _ _ O
than _ _ O
MIPS _ _ O
§ _ _ O
Intel _ _ O
Itanium _ _ O
has _ _ O
256 _ _ O
registers _ _ O
! _ _ O
2 _ _ O
. _ _ O
Limitation _ _ O
in _ _ O
code _ _ O
space _ _ O
o _ _ O
More _ _ O
unrolling _ _ O
means _ _ O
more _ _ O
code _ _ O
bloat _ _ O
o _ _ O
Embedded _ _ O
processors _ _ O
do _ _ O
n’t _ _ O
have _ _ O
lots _ _ O
of _ _ O
code _ _ O
memory _ _ O
o _ _ O
Matters _ _ O
even _ _ O
for _ _ O
general _ _ O
purpose _ _ O
processors _ _ O
because _ _ O
of _ _ O
caching _ _ O
( _ _ O
Code _ _ O
that _ _ O
overflows _ _ O
i-cache _ _ O
can _ _ O
lead _ _ O
to _ _ O
lots _ _ O
of _ _ O
cache _ _ O
misses _ _ O
) _ _ O
37 _ _ O

List _ _ O
Scheduling _ _ O
38 _ _ O

How _ _ O
does _ _ O
the _ _ O
compiler _ _ O
schedule _ _ O
instructions _ _ O
? _ _ O
● _ _ O
Compiler _ _ O
will _ _ O
first _ _ O
expand _ _ O
the _ _ O
instruction _ _ O
window _ _ O
that _ _ O
it _ _ O
looks _ _ O
at _ _ O
o _ _ O
Instruction _ _ O
window _ _ O
: _ _ O
block _ _ O
of _ _ O
code _ _ O
without _ _ O
branches _ _ O
o _ _ O
Compiler _ _ O
uses _ _ O
predication _ _ O
and _ _ O
loop _ _ O
unrolling _ _ O
● _ _ O
Once _ _ O
compiler _ _ O
has _ _ O
a _ _ O
sizable _ _ O
window _ _ O
, _ _ O
it _ _ O
will _ _ O
construct _ _ O
the _ _ O
schedule _ _ O
● _ _ O
A _ _ O
popular _ _ O
scheduling _ _ O
algorithm _ _ O
is _ _ O
list _ _ O
scheduling _ _ O
o _ _ O
Idea _ _ O
: _ _ O
list _ _ O
instructions _ _ O
in _ _ O
some _ _ O
order _ _ O
of _ _ O
priority _ _ O
and _ _ O
schedule _ _ O
o _ _ O
Instructions _ _ O
on _ _ O
the _ _ O
critical _ _ O
path _ _ O
should _ _ O
be _ _ O
prioritized _ _ O
● _ _ O
List _ _ O
scheduling _ _ O
can _ _ O
be _ _ O
used _ _ O
with _ _ O
any _ _ O
statically _ _ O
scheduled _ _ O
processor _ _ O
o _ _ O
Simple _ _ O
single-issue _ _ O
statically _ _ O
scheduled _ _ O
processor _ _ O
( _ _ O
not _ _ O
just _ _ O
VLIW _ _ O
) _ _ O
o _ _ O
GPUs _ _ O
are _ _ O
also _ _ O
statically _ _ O
scheduled _ _ O
using _ _ O
list _ _ O
scheduling _ _ O
39 _ _ O

Critical _ _ O
Path _ _ O
in _ _ O
Code _ _ O
● _ _ O
At _ _ O
below _ _ O
is _ _ O
a _ _ O
data _ _ O
dependence _ _ O
graph _ _ O
for _ _ O
a _ _ O
code _ _ O
with _ _ O
7 _ _ O
instructions _ _ O
o _ _ O
Nodes _ _ O
are _ _ O
instructions _ _ O
o _ _ O
Arrows _ _ O
are _ _ O
data _ _ O
dependencies _ _ O
annotated _ _ O
with _ _ O
required _ _ O
delay _ _ O
● _ _ O
Q _ _ O
: _ _ O
How _ _ O
long _ _ O
is _ _ O
the _ _ O
critical _ _ O
path _ _ O
in _ _ O
this _ _ O
code _ _ O
? _ _ O
3 _ _ O
2 _ _ O
1 _ _ O
1 _ _ O
2 _ _ O
1 _ _ O
1 _ _ O
1 _ _ O
2 _ _ O
2 _ _ O
That _ _ O
means _ _ O
, _ _ O
at _ _ O
minimum _ _ O
, _ _ O
this _ _ O
code _ _ O
will _ _ O
take _ _ O
7 _ _ O
cycles _ _ O
, _ _ O
period _ _ O
. _ _ O
Regardless _ _ O
of _ _ O
how _ _ O
wide _ _ O
your _ _ O
processor _ _ O
is _ _ O
or _ _ O
how _ _ O
well _ _ O
you _ _ O
do _ _ O
your _ _ O
scheduling _ _ O
. _ _ O
total _ _ O
7 _ _ O
cycles _ _ O
40 _ _ O

Instruction _ _ O
Level _ _ O
Parallelism _ _ O
( _ _ O
ILP _ _ O
) _ _ O
● _ _ O
The _ _ O
7 _ _ O
cycles _ _ O
is _ _ O
achievable _ _ O
only _ _ O
through _ _ O
instruction _ _ O
level _ _ O
parallelism _ _ O
o _ _ O
That _ _ O
is _ _ O
, _ _ O
parallel _ _ O
execution _ _ O
of _ _ O
instructions _ _ O
o _ _ O
The _ _ O
nodes _ _ O
marked _ _ O
in _ _ O
red _ _ O
can _ _ O
execute _ _ O
in _ _ O
parallel _ _ O
with _ _ O
blue _ _ O
nodes _ _ O
● _ _ O
This _ _ O
tell _ _ O
us _ _ O
that _ _ O
this _ _ O
code _ _ O
is _ _ O
where _ _ O
a _ _ O
VLIW _ _ O
processor _ _ O
can _ _ O
shine _ _ O
3 _ _ O
2 _ _ O
1 _ _ O
1 _ _ O
2 _ _ O
1 _ _ O
1 _ _ O
1 _ _ O
2 _ _ O
2 _ _ O
total _ _ O
7 _ _ O
cycles _ _ O
41 _ _ O

Maximizing _ _ O
Instruction _ _ O
Level _ _ O
Parallelism _ _ O
( _ _ O
ILP _ _ O
) _ _ O
● _ _ O
The _ _ O
more _ _ O
ILP _ _ O
code _ _ O
has _ _ O
, _ _ O
the _ _ O
more _ _ O
VLIW _ _ O
will _ _ O
shine _ _ O
● _ _ O
So _ _ O
before _ _ O
list _ _ O
scheduling _ _ O
, _ _ O
compiler _ _ O
maximizes _ _ O
ILP _ _ O
in _ _ O
code _ _ O
o _ _ O
What _ _ O
constrains _ _ O
ILP _ _ O
? _ _ O
Data _ _ O
dependencies _ _ O
! _ _ O
o _ _ O
Some _ _ O
data _ _ O
dependencies _ _ O
can _ _ O
be _ _ O
removed _ _ O
by _ _ O
the _ _ O
compiler _ _ O
● _ _ O
There _ _ O
are _ _ O
3 _ _ O
types _ _ O
of _ _ O
data _ _ O
dependencies _ _ O
actually _ _ O
: _ _ O
o _ _ O
RAW _ _ O
( _ _ O
Read-After-Write _ _ O
) _ _ O
: _ _ O
can _ _ O
not _ _ O
be _ _ O
removed _ _ O
o _ _ O
WAR _ _ O
( _ _ O
Write-After-Read _ _ O
) _ _ O
: _ _ O
can _ _ O
be _ _ O
removed _ _ O
o _ _ O
WAW _ _ O
( _ _ O
Write-After-Write _ _ O
) _ _ O
: _ _ O
can _ _ O
also _ _ O
be _ _ O
removed _ _ O
● _ _ O
How _ _ O
about _ _ O
Read-After-Read _ _ O
? _ _ O
Not _ _ O
a _ _ O
data _ _ O
dependency _ _ O
. _ _ O
42 _ _ O

Read-After-Write _ _ O
( _ _ O
RAW _ _ O
) _ _ O
Dependency _ _ O
● _ _ O
RAW _ _ O
dependencies _ _ O
are _ _ O
also _ _ O
called _ _ O
true _ _ O
dependencies _ _ O
o _ _ O
In _ _ O
the _ _ O
sense _ _ O
that _ _ O
other _ _ O
dependencies _ _ O
are _ _ O
not _ _ O
“ _ _ O
real _ _ O
” _ _ O
dependencies _ _ O
● _ _ O
Suppose _ _ O
we _ _ O
reorder _ _ O
this _ _ O
snippet _ _ O
of _ _ O
code _ _ O
: _ _ O
RAW _ _ O
! _ _ O
lw _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
s0 _ _ O
) _ _ O
addi _ _ O
t1 _ _ O
, _ _ O
t0 _ _ O
, _ _ O
4 _ _ O
Reorder _ _ O
addi _ _ O
t1 _ _ O
, _ _ O
t0 _ _ O
, _ _ O
4 _ _ O
lw _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
s0 _ _ O
) _ _ O
● _ _ O
The _ _ O
code _ _ O
is _ _ O
incorrect _ _ O
because _ _ O
now _ _ O
t1 _ _ O
has _ _ O
a _ _ O
wrong _ _ O
value _ _ O
o _ _ O
No _ _ O
amount _ _ O
of _ _ O
compiler _ _ O
tinkering _ _ O
will _ _ O
allow _ _ O
this _ _ O
reordering _ _ O
o _ _ O
Value _ _ O
must _ _ O
be _ _ O
loaded _ _ O
into _ _ O
t0 _ _ O
before _ _ O
being _ _ O
used _ _ O
to _ _ O
compute _ _ O
t1 _ _ O
43 _ _ O

Write-After-Read _ _ O
( _ _ O
WAR _ _ O
) _ _ O
Dependency _ _ O
● _ _ O
WAR _ _ O
dependencies _ _ O
are _ _ O
also _ _ O
called _ _ O
anti-dependencies _ _ O
o _ _ O
In _ _ O
the _ _ O
sense _ _ O
that _ _ O
they _ _ O
are _ _ O
the _ _ O
opposite _ _ O
of _ _ O
true _ _ O
dependencies _ _ O
● _ _ O
Suppose _ _ O
we _ _ O
reorder _ _ O
this _ _ O
snippet _ _ O
of _ _ O
code _ _ O
: _ _ O
WAR _ _ O
! _ _ O
lw _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
s0 _ _ O
) _ _ O
addi _ _ O
t1 _ _ O
, _ _ O
t0 _ _ O
, _ _ O
4 _ _ O
lw _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
s1 _ _ O
) _ _ O
Reorder _ _ O
lw _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
s0 _ _ O
) _ _ O
lw _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
s1 _ _ O
) _ _ O
addi _ _ O
t1 _ _ O
, _ _ O
t0 _ _ O
, _ _ O
4 _ _ O
● _ _ O
The _ _ O
code _ _ O
is _ _ O
again _ _ O
incorrect _ _ O
because _ _ O
t1 _ _ O
has _ _ O
the _ _ O
wrong _ _ O
value _ _ O
o _ _ O
addi _ _ O
should _ _ O
not _ _ O
read _ _ O
t0 _ _ O
produced _ _ O
by _ _ O
lw _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
s1 _ _ O
) _ _ O
● _ _ O
Q _ _ O
: _ _ O
Is _ _ O
there _ _ O
a _ _ O
way _ _ O
for _ _ O
addi _ _ O
to _ _ O
not _ _ O
use _ _ O
that _ _ O
value _ _ O
? _ _ O
o _ _ O
t0 _ _ O
and _ _ O
t0 _ _ O
contain _ _ O
different _ _ O
values _ _ O
. _ _ O
Why _ _ O
use _ _ O
the _ _ O
same _ _ O
register _ _ O
? _ _ O
o _ _ O
Just _ _ O
rename _ _ O
register _ _ O
t0 _ _ O
to _ _ O
some _ _ O
other _ _ O
register _ _ O
! _ _ O
44 _ _ O

Removing _ _ O
WAR _ _ O
with _ _ O
SSA _ _ O
● _ _ O
Static _ _ O
Single _ _ O
Assignment _ _ O
: _ _ O
Renaming _ _ O
registers _ _ O
with _ _ O
different _ _ O
values _ _ O
o _ _ O
A _ _ O
register _ _ O
is _ _ O
assigned _ _ O
a _ _ O
value _ _ O
only _ _ O
a _ _ O
single _ _ O
time _ _ O
( _ _ O
never _ _ O
reused _ _ O
) _ _ O
● _ _ O
Reordering _ _ O
after _ _ O
converting _ _ O
to _ _ O
SSA _ _ O
form _ _ O
: _ _ O
NO _ _ O
WAR _ _ O
! _ _ O
lw _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
s0 _ _ O
) _ _ O
addi _ _ O
t1 _ _ O
, _ _ O
t0 _ _ O
, _ _ O
4 _ _ O
lw _ _ O
t2 _ _ O
, _ _ O
0 _ _ O
( _ _ O
s1 _ _ O
) _ _ O
Reorder _ _ O
lw _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
s0 _ _ O
) _ _ O
lw _ _ O
t2 _ _ O
, _ _ O
0 _ _ O
( _ _ O
s1 _ _ O
) _ _ O
addi _ _ O
t1 _ _ O
, _ _ O
t0 _ _ O
, _ _ O
4 _ _ O
● _ _ O
Note _ _ O
how _ _ O
destination _ _ O
registers _ _ O
always _ _ O
use _ _ O
a _ _ O
new _ _ O
register _ _ O
o _ _ O
Yes _ _ O
, _ _ O
if _ _ O
you _ _ O
do _ _ O
this _ _ O
, _ _ O
you _ _ O
will _ _ O
need _ _ O
lots _ _ O
of _ _ O
registers _ _ O
o _ _ O
But _ _ O
, _ _ O
no _ _ O
more _ _ O
WAR _ _ O
dependencies _ _ O
! _ _ O
45 _ _ O

Write-After-Write _ _ O
( _ _ O
WAW _ _ O
) _ _ O
Dependency _ _ O
● _ _ O
WAW _ _ O
dependencies _ _ O
are _ _ O
also _ _ O
called _ _ O
false _ _ O
dependencies _ _ O
o _ _ O
In _ _ O
the _ _ O
sense _ _ O
that _ _ O
they _ _ O
are _ _ O
not _ _ O
real _ _ O
dependencies _ _ O
● _ _ O
Suppose _ _ O
we _ _ O
reorder _ _ O
this _ _ O
snippet _ _ O
of _ _ O
code _ _ O
: _ _ O
WAW _ _ O
! _ _ O
lw _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
s0 _ _ O
) _ _ O
lw _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
s1 _ _ O
) _ _ O
addi _ _ O
t1 _ _ O
, _ _ O
t0 _ _ O
, _ _ O
4 _ _ O
Reorder _ _ O
lw _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
s1 _ _ O
) _ _ O
lw _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
s0 _ _ O
) _ _ O
addi _ _ O
t1 _ _ O
, _ _ O
t0 _ _ O
, _ _ O
4 _ _ O
● _ _ O
The _ _ O
code _ _ O
is _ _ O
again _ _ O
incorrect _ _ O
because _ _ O
t1 _ _ O
has _ _ O
the _ _ O
wrong _ _ O
value _ _ O
o _ _ O
addi _ _ O
should _ _ O
not _ _ O
read _ _ O
t0 _ _ O
produced _ _ O
by _ _ O
lw _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
s0 _ _ O
) _ _ O
● _ _ O
Q _ _ O
: _ _ O
Is _ _ O
there _ _ O
a _ _ O
way _ _ O
for _ _ O
addi _ _ O
to _ _ O
not _ _ O
use _ _ O
that _ _ O
value _ _ O
? _ _ O
o _ _ O
Again _ _ O
, _ _ O
rename _ _ O
register _ _ O
t0 _ _ O
to _ _ O
some _ _ O
other _ _ O
register _ _ O
! _ _ O
46 _ _ O

Removing _ _ O
WAW _ _ O
with _ _ O
SSA _ _ O
● _ _ O
Again _ _ O
, _ _ O
Static _ _ O
Single _ _ O
Assignment _ _ O
( _ _ O
SSA _ _ O
) _ _ O
to _ _ O
the _ _ O
rescue _ _ O
! _ _ O
o _ _ O
SSA _ _ O
removes _ _ O
both _ _ O
WAR _ _ O
and _ _ O
WAW _ _ O
dependencies _ _ O
● _ _ O
Reordering _ _ O
after _ _ O
converting _ _ O
to _ _ O
SSA _ _ O
form _ _ O
: _ _ O
NO _ _ O
WAW _ _ O
! _ _ O
lw _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
s0 _ _ O
) _ _ O
lw _ _ O
t1 _ _ O
, _ _ O
0 _ _ O
( _ _ O
s1 _ _ O
) _ _ O
addi _ _ O
t2 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
4 _ _ O
Reorder _ _ O
lw _ _ O
t1 _ _ O
, _ _ O
0 _ _ O
( _ _ O
s1 _ _ O
) _ _ O
lw _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
s0 _ _ O
) _ _ O
addi _ _ O
t2 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
4 _ _ O
● _ _ O
SSA _ _ O
form _ _ O
is _ _ O
now _ _ O
the _ _ O
norm _ _ O
in _ _ O
all _ _ O
mature _ _ O
compilers _ _ O
o _ _ O
Clang _ _ O
/ _ _ O
LLVM _ _ O
( _ _ O
“ _ _ O
Apple _ _ O
” _ _ O
Compiler _ _ O
) _ _ O
o _ _ O
GCC _ _ O
( _ _ O
GNU _ _ O
C _ _ O
Compiler _ _ O
) _ _ O
o _ _ O
Java _ _ O
Hotspot _ _ O
/ _ _ O
OpenJDK _ _ O
Compiler _ _ O
o _ _ O
Chrome _ _ O
JavaScript _ _ O
Compiler _ _ O
47 _ _ O

List _ _ O
scheduling _ _ O
guarantees _ _ O
< _ _ O
2X _ _ O
of _ _ O
optimal _ _ O
cycles _ _ O
● _ _ O
Back _ _ O
to _ _ O
our _ _ O
original _ _ O
example _ _ O
. _ _ O
● _ _ O
The _ _ O
critical _ _ O
path _ _ O
length _ _ O
is _ _ O
7 _ _ O
cycles _ _ O
but _ _ O
that _ _ O
is _ _ O
not _ _ O
always _ _ O
achievable _ _ O
o _ _ O
If _ _ O
processor _ _ O
is _ _ O
not _ _ O
wide _ _ O
enough _ _ O
for _ _ O
the _ _ O
available _ _ O
parallelism _ _ O
o _ _ O
If _ _ O
compiler _ _ O
does _ _ O
a _ _ O
bad _ _ O
job _ _ O
at _ _ O
scheduling _ _ O
instructions _ _ O
→ _ _ O
List _ _ O
scheduling _ _ O
guarantees _ _ O
compiler _ _ O
is _ _ O
within _ _ O
2X _ _ O
of _ _ O
optimal _ _ O
3 _ _ O
2 _ _ O
1 _ _ O
1 _ _ O
2 _ _ O
1 _ _ O
1 _ _ O
1 _ _ O
2 _ _ O
Q _ _ O
: _ _ O
Can _ _ O
the _ _ O
graph _ _ O
be _ _ O
cyclic _ _ O
? _ _ O
2 _ _ O
total _ _ O
7 _ _ O
cycles _ _ O
48 _ _ O

List _ _ O
Scheduling _ _ O
is _ _ O
a _ _ O
Greedy _ _ O
Algorithm _ _ O
● _ _ O
Idea _ _ O
: _ _ O
Greedily _ _ O
prioritize _ _ O
instructions _ _ O
on _ _ O
the _ _ O
critical _ _ O
path _ _ O
● _ _ O
Steps _ _ O
: _ _ O
1 _ _ O
. _ _ O
Create _ _ O
a _ _ O
data _ _ O
dependence _ _ O
graph _ _ O
2 _ _ O
. _ _ O
Assign _ _ O
a _ _ O
priority _ _ O
to _ _ O
each _ _ O
node _ _ O
( _ _ O
instruction _ _ O
) _ _ O
§ _ _ O
Priority _ _ O
= _ _ O
critical _ _ O
path _ _ O
length _ _ O
starting _ _ O
from _ _ O
that _ _ O
node _ _ O
3 _ _ O
. _ _ O
Schedule _ _ O
nodes _ _ O
one _ _ O
by _ _ O
one _ _ O
starting _ _ O
from _ _ O
ready _ _ O
instructions _ _ O
§ _ _ O
Ready _ _ O
= _ _ O
all _ _ O
dependencies _ _ O
have _ _ O
been _ _ O
fulfilled _ _ O
( _ _ O
Initially _ _ O
, _ _ O
only _ _ O
roots _ _ O
of _ _ O
dependency _ _ O
chains _ _ O
are _ _ O
ready _ _ O
) _ _ O
§ _ _ O
When _ _ O
there _ _ O
are _ _ O
multiple _ _ O
nodes _ _ O
that _ _ O
are _ _ O
ready _ _ O
→ _ _ O
Choose _ _ O
the _ _ O
node _ _ O
with _ _ O
the _ _ O
highest _ _ O
priority _ _ O
● _ _ O
2 _ _ O
– _ _ O
2 _ _ O
/ _ _ O
( _ _ O
n+1 _ _ O
) _ _ O
X _ _ O
of _ _ O
optimal _ _ O
schedule _ _ O
, _ _ O
where _ _ O
n _ _ O
= _ _ O
processor _ _ O
width _ _ O
o _ _ O
Graham _ _ O
, _ _ O
Ronald _ _ O
L _ _ O
.. _ _ O
“ _ _ O
Bounds _ _ O
on _ _ O
Multiprocessing _ _ O
Timing _ _ O
Anomalies _ _ O
. _ _ O
” _ _ O
SIAM _ _ O
Journal _ _ O
of _ _ O
Applied _ _ O
Mathematics _ _ O
17 _ _ O
( _ _ O
1969 _ _ O
) _ _ O
: _ _ O
416 _ _ O
- _ _ O
429 _ _ O
. _ _ O
49 _ _ O

List _ _ O
Scheduling _ _ O
Example _ _ O
● _ _ O
Assume _ _ O
all _ _ O
edges _ _ O
have _ _ O
a _ _ O
delay _ _ O
of _ _ O
1 _ _ O
o _ _ O
Red _ _ O
dashed _ _ O
lines _ _ O
indicate _ _ O
priority _ _ O
levels _ _ O
n _ _ O
insertions _ _ O
+ _ _ O
n _ _ O
removals _ _ O
. _ _ O
If _ _ O
using _ _ O
priority _ _ O
heap _ _ O
= _ _ O
O _ _ O
( _ _ O
nlogn _ _ O
) _ _ O
6 _ _ O
Ready _ _ O
instructions _ _ O
List _ _ O
5 _ _ O
4 _ _ O
Operation _ _ O
1 _ _ O
3 _ _ O
Operation _ _ O
2 _ _ O
2 _ _ O
1 _ _ O
50 _ _ O

List _ _ O
Scheduling _ _ O
Example _ _ O
● _ _ O
This _ _ O
will _ _ O
result _ _ O
in _ _ O
the _ _ O
following _ _ O
schedule _ _ O
: _ _ O
Operation _ _ O
1 _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
6 _ _ O
8 _ _ O
10 _ _ O
12 _ _ O
13 _ _ O
Operation _ _ O
2 _ _ O
6 _ _ O
5 _ _ O
7 _ _ O
9 _ _ O
11 _ _ O
● _ _ O
9 _ _ O
cycles _ _ O
. _ _ O
We _ _ O
could _ _ O
n’t _ _ O
achieve _ _ O
7 _ _ O
cycles _ _ O
! _ _ O
o _ _ O
But _ _ O
could _ _ O
’ve _ _ O
if _ _ O
we _ _ O
had _ _ O
a _ _ O
wider _ _ O
processor _ _ O
5 _ _ O
4 _ _ O
3 _ _ O
2 _ _ O
1 _ _ O
51 _ _ O



