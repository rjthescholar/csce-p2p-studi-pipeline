unlabeled|cs1541|lec2.6_superscalar_processors
-DOCSTART- -X- -X- O

SuperScalar _ _ O
Processors _ _ O
CS _ _ O
1541 _ _ O
Wonsun _ _ O
Ahn _ _ O

In-order _ _ O
vs. _ _ O
Out-of-order _ _ O
superscalars _ _ O
● _ _ O
Superscalar _ _ O
: _ _ O
a _ _ O
wide-issue _ _ O
processor _ _ O
that _ _ O
does _ _ O
dynamic _ _ O
scheduling _ _ O
o _ _ O
Extracts _ _ O
instruction _ _ O
level _ _ O
parallelism _ _ O
( _ _ O
ILP _ _ O
) _ _ O
within _ _ O
the _ _ O
processor _ _ O
● _ _ O
In-order _ _ O
superscalar _ _ O
: _ _ O
does _ _ O
not _ _ O
reorder _ _ O
instructions _ _ O
o _ _ O
Only _ _ O
detects _ _ O
hazards _ _ O
between _ _ O
instructions _ _ O
to _ _ O
insert _ _ O
bubbles _ _ O
o _ _ O
Only _ _ O
extracts _ _ O
ILP _ _ O
that _ _ O
arises _ _ O
from _ _ O
given _ _ O
ordering _ _ O
of _ _ O
instructions _ _ O
o _ _ O
The _ _ O
processor _ _ O
simulated _ _ O
in _ _ O
Project _ _ O
1 _ _ O
● _ _ O
Out-of-order _ _ O
superscalar _ _ O
: _ _ O
does _ _ O
reorder _ _ O
instructions _ _ O
o _ _ O
Reorders _ _ O
instructions _ _ O
to _ _ O
remove _ _ O
hazards _ _ O
and _ _ O
increase _ _ O
utilization _ _ O
o _ _ O
Typically _ _ O
results _ _ O
in _ _ O
higher _ _ O
performance _ _ O
compared _ _ O
to _ _ O
in-order _ _ O
o _ _ O
But _ _ O
dynamic _ _ O
reordering _ _ O
consumes _ _ O
lots _ _ O
of _ _ O
power _ _ O
● _ _ O
Out-of-order _ _ O
sounds _ _ O
more _ _ O
exciting _ _ O
so _ _ O
let _ _ O
’s _ _ O
talk _ _ O
about _ _ O
that _ _ O
2 _ _ O

Name _ _ O
of _ _ O
the _ _ O
game _ _ O
is _ _ O
still _ _ O
ILP _ _ O
● _ _ O
The _ _ O
processor _ _ O
internally _ _ O
constructs _ _ O
the _ _ O
data _ _ O
dependency _ _ O
graph _ _ O
● _ _ O
The _ _ O
processor _ _ O
tries _ _ O
to _ _ O
take _ _ O
advantage _ _ O
of _ _ O
ILP _ _ O
as _ _ O
much _ _ O
as _ _ O
possible _ _ O
o _ _ O
By _ _ O
executing _ _ O
the _ _ O
red _ _ O
nodes _ _ O
in _ _ O
parallel _ _ O
with _ _ O
the _ _ O
blue _ _ O
nodes _ _ O
3 _ _ O
2 _ _ O
1 _ _ O
2 _ _ O
1 _ _ O
1 _ _ O
2 _ _ O
1 _ _ O
1 _ _ O
2 _ _ O
total _ _ O
7 _ _ O
cycles _ _ O
illustration _ _ O
courtesy _ _ O
of _ _ O
Dr. _ _ O
Melhem _ _ O
3 _ _ O

Instruction _ _ O
Queue _ _ O
Register _ _ O
File _ _ O
Instruction _ _ O
Queue _ _ O
I-Mem _ _ O
Ins _ _ O
. _ _ O
Decoder _ _ O
● _ _ O
In _ _ O
order _ _ O
to _ _ O
expose _ _ O
ILP _ _ O
, _ _ O
superscalars _ _ O
need _ _ O
a _ _ O
big _ _ O
instruction _ _ O
window _ _ O
o _ _ O
Just _ _ O
like _ _ O
the _ _ O
compiler _ _ O
did _ _ O
for _ _ O
VLIWs _ _ O
o _ _ O
HW _ _ O
structure _ _ O
for _ _ O
storing _ _ O
instructions _ _ O
is _ _ O
called _ _ O
instruction _ _ O
queue _ _ O
o _ _ O
Now _ _ O
EX _ _ O
stage _ _ O
has _ _ O
a _ _ O
big _ _ O
pool _ _ O
of _ _ O
instructions _ _ O
to _ _ O
choose _ _ O
from _ _ O
ALU _ _ O
+ _ _ O
D-Mem _ _ O
4 _ _ O

Instruction _ _ O
Queue _ _ O
Instruction _ _ O
Queue _ _ O
● _ _ O
In _ _ O
order _ _ O
to _ _ O
expose _ _ O
ILP _ _ O
, _ _ O
superscalars _ _ O
need _ _ O
a _ _ O
big _ _ O
instruction _ _ O
window _ _ O
o _ _ O
Just _ _ O
like _ _ O
the _ _ O
compiler _ _ O
did _ _ O
for _ _ O
VLIWs _ _ O
o _ _ O
HW _ _ O
structure _ _ O
for _ _ O
storing _ _ O
instructions _ _ O
is _ _ O
called _ _ O
instruction _ _ O
queue _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
Instruction _ _ O
Scheduler _ _ O
Int _ _ O
ALU _ _ O
1 _ _ O
Int _ _ O
ALU _ _ O
2 _ _ O
Float _ _ O
ALU _ _ O
● _ _ O
At _ _ O
ID _ _ O
, _ _ O
instructions _ _ O
are _ _ O
decoded _ _ O
o _ _ O
And _ _ O
dispatched _ _ O
to _ _ O
the _ _ O
i-queue _ _ O
● _ _ O
At _ _ O
EX _ _ O
, _ _ O
ready _ _ O
instructions _ _ O
are _ _ O
chosen _ _ O
from _ _ O
the _ _ O
instruction _ _ O
queue _ _ O
o _ _ O
Ready _ _ O
as _ _ O
in _ _ O
operands _ _ O
are _ _ O
available _ _ O
o _ _ O
And _ _ O
issued _ _ O
to _ _ O
an _ _ O
EX _ _ O
unit _ _ O
● _ _ O
Typically _ _ O
queue _ _ O
is _ _ O
always _ _ O
full _ _ O
o _ _ O
Insts _ _ O
start _ _ O
queueing _ _ O
up _ _ O
when _ _ O
insts _ _ O
fail _ _ O
to _ _ O
issue _ _ O
due _ _ O
to _ _ O
hazards _ _ O
5 _ _ O

Scheduling _ _ O
the _ _ O
Instruction _ _ O
Queue _ _ O
[ _ _ O
Dispatched _ _ O
] _ _ O
li _ _ O
t0 _ _ O
, _ _ O
1 _ _ O
li _ _ O
t1 _ _ O
, _ _ O
2 _ _ O
add _ _ O
t2 _ _ O
, _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
Instruction _ _ O
Queue _ _ O
● _ _ O
Now _ _ O
we _ _ O
have _ _ O
pool _ _ O
of _ _ O
instructions _ _ O
. _ _ O
When _ _ O
do _ _ O
they _ _ O
become _ _ O
ready _ _ O
? _ _ O
o _ _ O
Ready _ _ O
operands _ _ O
and _ _ O
instructions _ _ O
are _ _ O
in _ _ O
green _ _ O
o _ _ O
Not _ _ O
ready _ _ O
operands _ _ O
and _ _ O
instructions _ _ O
are _ _ O
in _ _ O
red _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
[ _ _ O
Issued _ _ O
] _ _ O
Instruction _ _ O
Scheduler _ _ O
Int _ _ O
ALU _ _ O
1 _ _ O
Int _ _ O
ALU _ _ O
2 _ _ O
Float _ _ O
ALU _ _ O
6 _ _ O

Scheduling _ _ O
the _ _ O
Instruction _ _ O
Queue _ _ O
[ _ _ O
Dispatched _ _ O
] _ _ O
li _ _ O
t0 _ _ O
, _ _ O
1 _ _ O
li _ _ O
t1 _ _ O
, _ _ O
2 _ _ O
add _ _ O
t2 _ _ O
, _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
Instruction _ _ O
Queue _ _ O
● _ _ O
Initially _ _ O
both _ _ O
li _ _ O
t0 _ _ O
, _ _ O
1 _ _ O
and _ _ O
li _ _ O
t1 _ _ O
, _ _ O
2 _ _ O
are _ _ O
ready _ _ O
o _ _ O
The _ _ O
li _ _ O
instruction _ _ O
does _ _ O
not _ _ O
have _ _ O
any _ _ O
register _ _ O
operands _ _ O
o _ _ O
Instruction _ _ O
scheduler _ _ O
has _ _ O
a _ _ O
choice _ _ O
of _ _ O
what _ _ O
to _ _ O
issue _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
[ _ _ O
Issued _ _ O
] _ _ O
Instruction _ _ O
Scheduler _ _ O
Int _ _ O
ALU _ _ O
1 _ _ O
Int _ _ O
ALU _ _ O
2 _ _ O
Float _ _ O
ALU _ _ O
7 _ _ O

Scheduling _ _ O
the _ _ O
Instruction _ _ O
Queue _ _ O
[ _ _ O
Dispatched _ _ O
] _ _ O
li _ _ O
t0 _ _ O
, _ _ O
1 _ _ O
li _ _ O
t1 _ _ O
, _ _ O
2 _ _ O
add _ _ O
t2 _ _ O
, _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
Instruction _ _ O
Queue _ _ O
● _ _ O
Let _ _ O
’s _ _ O
say _ _ O
the _ _ O
scheduler _ _ O
issues _ _ O
li _ _ O
t1 _ _ O
, _ _ O
2 _ _ O
first _ _ O
● _ _ O
Then _ _ O
the _ _ O
t1 _ _ O
operand _ _ O
becomes _ _ O
ready _ _ O
after _ _ O
it _ _ O
completes _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
Instruction _ _ O
Scheduler _ _ O
Int _ _ O
ALU _ _ O
1 _ _ O
[ _ _ O
Issued _ _ O
] _ _ O
li _ _ O
t1 _ _ O
, _ _ O
2 _ _ O
Int _ _ O
ALU _ _ O
2 _ _ O
Float _ _ O
ALU _ _ O
8 _ _ O

Scheduling _ _ O
the _ _ O
Instruction _ _ O
Queue _ _ O
[ _ _ O
Dispatched _ _ O
] _ _ O
li _ _ O
t0 _ _ O
, _ _ O
1 _ _ O
add _ _ O
t2 _ _ O
, _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
Instruction _ _ O
Queue _ _ O
● _ _ O
Now _ _ O
the _ _ O
only _ _ O
ready _ _ O
instruction _ _ O
li _ _ O
t0 _ _ O
, _ _ O
1 _ _ O
issues _ _ O
● _ _ O
Then _ _ O
the _ _ O
t0 _ _ O
operand _ _ O
becomes _ _ O
ready _ _ O
after _ _ O
it _ _ O
completes _ _ O
● _ _ O
Now _ _ O
add _ _ O
t2 _ _ O
, _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
is _ _ O
finally _ _ O
ready _ _ O
to _ _ O
issue _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
Instruction _ _ O
Scheduler _ _ O
Int _ _ O
ALU _ _ O
1 _ _ O
[ _ _ O
Issued _ _ O
] _ _ O
li _ _ O
t1 _ _ O
, _ _ O
2 _ _ O
li _ _ O
t0 _ _ O
, _ _ O
1 _ _ O
Int _ _ O
ALU _ _ O
2 _ _ O
Float _ _ O
ALU _ _ O
9 _ _ O

Scheduling _ _ O
the _ _ O
Instruction _ _ O
Queue _ _ O
[ _ _ O
Dispatched _ _ O
] _ _ O
Instruction _ _ O
Queue _ _ O
● _ _ O
And _ _ O
we _ _ O
are _ _ O
done _ _ O
! _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
Instruction _ _ O
Scheduler _ _ O
Int _ _ O
ALU _ _ O
1 _ _ O
Int _ _ O
ALU _ _ O
2 _ _ O
[ _ _ O
Issued _ _ O
] _ _ O
li _ _ O
t1 _ _ O
, _ _ O
2 _ _ O
li _ _ O
t0 _ _ O
, _ _ O
1 _ _ O
add _ _ O
t2 _ _ O
, _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
Float _ _ O
ALU _ _ O
10 _ _ O

Scheduling _ _ O
the _ _ O
Instruction _ _ O
Queue _ _ O
[ _ _ O
Dispatched _ _ O
] _ _ O
li _ _ O
t0 _ _ O
, _ _ O
1 _ _ O
li _ _ O
t1 _ _ O
, _ _ O
2 _ _ O
add _ _ O
t2 _ _ O
, _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
Instruction _ _ O
Queue _ _ O
● _ _ O
Note _ _ O
how _ _ O
we _ _ O
reordered _ _ O
li _ _ O
t0 _ _ O
, _ _ O
1 _ _ O
and _ _ O
li _ _ O
t1 _ _ O
, _ _ O
2 _ _ O
o _ _ O
There _ _ O
are _ _ O
no _ _ O
dependencies _ _ O
between _ _ O
the _ _ O
two _ _ O
, _ _ O
so _ _ O
no _ _ O
issues _ _ O
o _ _ O
Also _ _ O
, _ _ O
RAW _ _ O
dependency _ _ O
with _ _ O
add _ _ O
t2 _ _ O
, _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
was _ _ O
enforced _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
Instruction _ _ O
Scheduler _ _ O
Int _ _ O
ALU _ _ O
1 _ _ O
Int _ _ O
ALU _ _ O
2 _ _ O
[ _ _ O
Issued _ _ O
] _ _ O
li _ _ O
t1 _ _ O
, _ _ O
2 _ _ O
li _ _ O
t0 _ _ O
, _ _ O
1 _ _ O
add _ _ O
t2 _ _ O
, _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
Float _ _ O
ALU _ _ O
11 _ _ O

What _ _ O
if _ _ O
we _ _ O
had _ _ O
a _ _ O
WAW _ _ O
dependency _ _ O
? _ _ O
[ _ _ O
Dispatched _ _ O
] _ _ O
li _ _ O
t0 _ _ O
, _ _ O
1 _ _ O
WAW _ _ O
! _ _ O
li _ _ O
t0 _ _ O
, _ _ O
2 _ _ O
add _ _ O
t2 _ _ O
, _ _ O
t0 _ _ O
, _ _ O
t0 _ _ O
Instruction _ _ O
Queue _ _ O
● _ _ O
Reordering _ _ O
li _ _ O
t0 _ _ O
, _ _ O
1 _ _ O
and _ _ O
li _ _ O
t0 _ _ O
, _ _ O
2 _ _ O
still _ _ O
allowed _ _ O
( _ _ O
both _ _ O
are _ _ O
ready _ _ O
) _ _ O
o _ _ O
Now _ _ O
t2 _ _ O
= _ _ O
4 _ _ O
in _ _ O
original _ _ O
code _ _ O
, _ _ O
but _ _ O
t2 _ _ O
= _ _ O
2 _ _ O
during _ _ O
execution _ _ O
! _ _ O
o _ _ O
How _ _ O
do _ _ O
we _ _ O
disallow _ _ O
this _ _ O
from _ _ O
happening _ _ O
? _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
Instruction _ _ O
Scheduler _ _ O
Int _ _ O
ALU _ _ O
1 _ _ O
Int _ _ O
ALU _ _ O
2 _ _ O
[ _ _ O
Issued _ _ O
] _ _ O
li _ _ O
t0 _ _ O
, _ _ O
2 _ _ O
li _ _ O
t0 _ _ O
, _ _ O
1 _ _ O
add _ _ O
t2 _ _ O
, _ _ O
t0 _ _ O
, _ _ O
t0 _ _ O
Float _ _ O
ALU _ _ O
12 _ _ O

WAW _ _ O
and _ _ O
WAR _ _ O
dependencies _ _ O
are _ _ O
tricky _ _ O
● _ _ O
RAW _ _ O
( _ _ O
true _ _ O
) _ _ O
dependencies _ _ O
are _ _ O
automatically _ _ O
enforced _ _ O
o _ _ O
Instructions _ _ O
can _ _ O
not _ _ O
issue _ _ O
until _ _ O
all _ _ O
operands _ _ O
are _ _ O
ready _ _ O
( _ _ O
written _ _ O
) _ _ O
● _ _ O
WAW _ _ O
and _ _ O
WAR _ _ O
dependencies _ _ O
are _ _ O
not _ _ O
enforced _ _ O
o _ _ O
There _ _ O
is _ _ O
no _ _ O
data _ _ O
passing _ _ O
between _ _ O
the _ _ O
two _ _ O
instructions _ _ O
o _ _ O
The _ _ O
two _ _ O
instructions _ _ O
can _ _ O
become _ _ O
ready _ _ O
in _ _ O
any _ _ O
order _ _ O
● _ _ O
We _ _ O
could _ _ O
somehow _ _ O
enforce _ _ O
WAW _ _ O
and _ _ O
WAR _ _ O
dependencies _ _ O
o _ _ O
But _ _ O
there _ _ O
is _ _ O
a _ _ O
better _ _ O
solution _ _ O
: _ _ O
register _ _ O
renaming _ _ O
! _ _ O
o _ _ O
Remember _ _ O
? _ _ O
That _ _ O
’s _ _ O
what _ _ O
the _ _ O
compiler _ _ O
did _ _ O
to _ _ O
remove _ _ O
WAW _ _ O
/ _ _ O
WAR _ _ O
. _ _ O
13 _ _ O

Register _ _ O
Renamer _ _ O
and _ _ O
the _ _ O
RAT _ _ O
[ _ _ O
Decoded _ _ O
] _ _ O
li _ _ O
t0 _ _ O
, _ _ O
1 _ _ O
WAW _ _ O
! _ _ O
li _ _ O
t0 _ _ O
, _ _ O
2 _ _ O
add _ _ O
t2 _ _ O
, _ _ O
t0 _ _ O
, _ _ O
t0 _ _ O
All _ _ O
32 _ _ O
MIPS _ _ O
registers _ _ O
Register _ _ O
Renamer _ _ O
RAT _ _ O
t0 _ _ O
p1 _ _ O
t1 _ _ O
- _ _ O
t2 _ _ O
p2 _ _ O
… _ _ O
… _ _ O
[ _ _ O
Dispatched _ _ O
] _ _ O
li _ _ O
p0 _ _ O
, _ _ O
1 _ _ O
No _ _ O
li _ _ O
p1 _ _ O
, _ _ O
2 _ _ O
WAW _ _ O
! _ _ O
add _ _ O
p2 _ _ O
, _ _ O
p1 _ _ O
, _ _ O
p1 _ _ O
Instruction _ _ O
Queue _ _ O
● _ _ O
As _ _ O
soon _ _ O
as _ _ O
decode _ _ O
, _ _ O
Register _ _ O
Renamer _ _ O
renames _ _ O
all _ _ O
registers _ _ O
o _ _ O
Done _ _ O
with _ _ O
the _ _ O
help _ _ O
of _ _ O
the _ _ O
Register _ _ O
Alias _ _ O
Table _ _ O
( _ _ O
RAT _ _ O
) _ _ O
o _ _ O
RAT _ _ O
is _ _ O
current _ _ O
mapping _ _ O
between _ _ O
architectural _ _ O
and _ _ O
physical _ _ O
registers _ _ O
▪ _ _ O
Architectural _ _ O
registers _ _ O
: _ _ O
Registers _ _ O
in _ _ O
ISA _ _ O
used _ _ O
in _ _ O
programs _ _ O
( _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t2 _ _ O
, _ _ O
… _ _ O
) _ _ O
▪ _ _ O
Physical _ _ O
registers _ _ O
: _ _ O
Renamed _ _ O
registers _ _ O
used _ _ O
in _ _ O
processor _ _ O
( _ _ O
p0 _ _ O
, _ _ O
p1 _ _ O
, _ _ O
p2 _ _ O
, _ _ O
… _ _ O
) _ _ O
14 _ _ O

Register _ _ O
Renamer _ _ O
and _ _ O
the _ _ O
RAT _ _ O
● _ _ O
So _ _ O
how _ _ O
does _ _ O
the _ _ O
RAT _ _ O
work _ _ O
? _ _ O
● _ _ O
Initially _ _ O
, _ _ O
no _ _ O
assignments _ _ O
have _ _ O
been _ _ O
done _ _ O
, _ _ O
so _ _ O
mapping _ _ O
is _ _ O
empty _ _ O
. _ _ O
Register _ _ O
Renamer _ _ O
RAT _ _ O
All _ _ O
32 _ _ O
MIPS _ _ O
registers _ _ O
t0 _ _ O
- _ _ O
t1 _ _ O
- _ _ O
t2 _ _ O
- _ _ O
… _ _ O
… _ _ O
[ _ _ O
Dispatched _ _ O
] _ _ O
Instruction _ _ O
Queue _ _ O
[ _ _ O
Decoded _ _ O
] _ _ O
15 _ _ O

Register _ _ O
Renamer _ _ O
and _ _ O
the _ _ O
RAT _ _ O
[ _ _ O
Decoded _ _ O
] _ _ O
li _ _ O
t0 _ _ O
, _ _ O
1 _ _ O
Register _ _ O
Renamer _ _ O
RAT _ _ O
All _ _ O
32 _ _ O
MIPS _ _ O
registers _ _ O
t0 _ _ O
p0 _ _ O
t1 _ _ O
- _ _ O
t2 _ _ O
- _ _ O
… _ _ O
… _ _ O
[ _ _ O
Dispatched _ _ O
] _ _ O
li _ _ O
p0 _ _ O
, _ _ O
1 _ _ O
Instruction _ _ O
Queue _ _ O
1 _ _ O
. _ _ O
li _ _ O
t0 _ _ O
, _ _ O
1 _ _ O
is _ _ O
decoded _ _ O
, _ _ O
destination _ _ O
t0 _ _ O
is _ _ O
renamed _ _ O
to _ _ O
p0 _ _ O
16 _ _ O

Register _ _ O
Renamer _ _ O
and _ _ O
the _ _ O
RAT _ _ O
[ _ _ O
Decoded _ _ O
] _ _ O
li _ _ O
t0 _ _ O
, _ _ O
1 _ _ O
li _ _ O
t0 _ _ O
, _ _ O
2 _ _ O
Register _ _ O
Renamer _ _ O
RAT _ _ O
All _ _ O
32 _ _ O
MIPS _ _ O
registers _ _ O
t0 _ _ O
p1 _ _ O
t1 _ _ O
- _ _ O
t2 _ _ O
- _ _ O
… _ _ O
… _ _ O
[ _ _ O
Dispatched _ _ O
] _ _ O
li _ _ O
p0 _ _ O
, _ _ O
1 _ _ O
li _ _ O
p1 _ _ O
, _ _ O
2 _ _ O
Instruction _ _ O
Queue _ _ O
1 _ _ O
. _ _ O
li _ _ O
t0 _ _ O
, _ _ O
1 _ _ O
is _ _ O
decoded _ _ O
, _ _ O
destination _ _ O
t0 _ _ O
is _ _ O
renamed _ _ O
to _ _ O
p0 _ _ O
2 _ _ O
. _ _ O
li _ _ O
t0 _ _ O
, _ _ O
2 _ _ O
is _ _ O
decoded _ _ O
, _ _ O
destination _ _ O
t0 _ _ O
is _ _ O
renamed _ _ O
to _ _ O
p1 _ _ O
o _ _ O
Remember _ _ O
the _ _ O
single _ _ O
assignment _ _ O
rule _ _ O
? _ _ O
o _ _ O
A _ _ O
new _ _ O
value _ _ O
always _ _ O
gets _ _ O
a _ _ O
new _ _ O
register _ _ O
17 _ _ O

Register _ _ O
Renamer _ _ O
and _ _ O
the _ _ O
RAT _ _ O
[ _ _ O
Decoded _ _ O
] _ _ O
li _ _ O
t0 _ _ O
, _ _ O
1 _ _ O
li _ _ O
t0 _ _ O
, _ _ O
2 _ _ O
add _ _ O
t2 _ _ O
, _ _ O
t0 _ _ O
, _ _ O
t0 _ _ O
All _ _ O
32 _ _ O
MIPS _ _ O
registers _ _ O
Register _ _ O
Renamer _ _ O
RAT _ _ O
t0 _ _ O
p1 _ _ O
t1 _ _ O
- _ _ O
t2 _ _ O
p2 _ _ O
… _ _ O
… _ _ O
[ _ _ O
Dispatched _ _ O
] _ _ O
li _ _ O
p0 _ _ O
, _ _ O
1 _ _ O
li _ _ O
p1 _ _ O
, _ _ O
2 _ _ O
add _ _ O
p2 _ _ O
, _ _ O
p1 _ _ O
, _ _ O
p1 _ _ O
Instruction _ _ O
Queue _ _ O
1 _ _ O
. _ _ O
li _ _ O
t0 _ _ O
, _ _ O
1 _ _ O
is _ _ O
decoded _ _ O
, _ _ O
destination _ _ O
t0 _ _ O
is _ _ O
renamed _ _ O
to _ _ O
p0 _ _ O
2 _ _ O
. _ _ O
li _ _ O
t0 _ _ O
, _ _ O
2 _ _ O
is _ _ O
decoded _ _ O
, _ _ O
destination _ _ O
t0 _ _ O
is _ _ O
renamed _ _ O
to _ _ O
p1 _ _ O
3 _ _ O
. _ _ O
add _ _ O
t2 _ _ O
, _ _ O
t0 _ _ O
, _ _ O
t0 _ _ O
is _ _ O
decoded _ _ O
: _ _ O
o _ _ O
Two _ _ O
t0 _ _ O
input _ _ O
registers _ _ O
use _ _ O
current _ _ O
mapping _ _ O
p1 _ _ O
o _ _ O
Destination _ _ O
register _ _ O
t2 _ _ O
is _ _ O
renamed _ _ O
to _ _ O
p2 _ _ O
18 _ _ O

Register _ _ O
Rename _ _ O
Removes _ _ O
all _ _ O
WAW _ _ O
/ _ _ O
WAR _ _ O
Deps _ _ O
[ _ _ O
Decoded _ _ O
] _ _ O
li _ _ O
t0 _ _ O
, _ _ O
1 _ _ O
WAW _ _ O
! _ _ O
li _ _ O
t0 _ _ O
, _ _ O
2 _ _ O
add _ _ O
t2 _ _ O
, _ _ O
t0 _ _ O
, _ _ O
t0 _ _ O
Register _ _ O
Renamer _ _ O
t0 _ _ O
RAT _ _ O
renamed _ _ O
p _ _ O
… _ _ O
… _ _ O
t9 _ _ O
renamed _ _ O
p _ _ O
Instruction _ _ O
Queue _ _ O
● _ _ O
By _ _ O
the _ _ O
time _ _ O
instructions _ _ O
are _ _ O
dispatched _ _ O
to _ _ O
i-queue _ _ O
o _ _ O
All _ _ O
architectural _ _ O
registers _ _ O
have _ _ O
been _ _ O
renamed _ _ O
to _ _ O
physical _ _ O
registers _ _ O
o _ _ O
All _ _ O
WAR _ _ O
and _ _ O
WAR _ _ O
dependencies _ _ O
have _ _ O
been _ _ O
removed _ _ O
[ _ _ O
Dispatched _ _ O
] _ _ O
li _ _ O
p0 _ _ O
, _ _ O
1 _ _ O
No _ _ O
li _ _ O
p1 _ _ O
, _ _ O
2 _ _ O
WAW _ _ O
! _ _ O
add _ _ O
p2 _ _ O
, _ _ O
p1 _ _ O
, _ _ O
p1 _ _ O
Instruction _ _ O
Scheduler _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
Int _ _ O
ALU _ _ O
1 _ _ O
[ _ _ O
Issued _ _ O
] _ _ O
li _ _ O
p1 _ _ O
, _ _ O
2 _ _ O
li _ _ O
p0 _ _ O
, _ _ O
1 _ _ O
add _ _ O
p2 _ _ O
, _ _ O
p1 _ _ O
, _ _ O
p1 _ _ O
Int _ _ O
ALU _ _ O
2 _ _ O
Float _ _ O
ALU _ _ O
19 _ _ O

All _ _ O
Computation _ _ O
Done _ _ O
using _ _ O
Physical _ _ O
Registers _ _ O
Physical _ _ O
Register _ _ O
File _ _ O
p0 _ _ O
p1 _ _ O
Register _ _ O
Renamer _ _ O
t0 _ _ O
RAT _ _ O
renamed _ _ O
p _ _ O
… _ _ O
… _ _ O
t9 _ _ O
renamed _ _ O
p _ _ O
p2 _ _ O
… _ _ O
p _ _ O
( _ _ O
n-1 _ _ O
) _ _ O
p _ _ O
( _ _ O
n _ _ O
) _ _ O
Instruction _ _ O
Queue _ _ O
Instruction _ _ O
Decoder _ _ O
● _ _ O
Now _ _ O
ID _ _ O
stage _ _ O
( _ _ O
dispatch _ _ O
) _ _ O
reads _ _ O
registers _ _ O
from _ _ O
physical _ _ O
register _ _ O
file _ _ O
● _ _ O
All _ _ O
data _ _ O
forwarding _ _ O
also _ _ O
done _ _ O
based _ _ O
on _ _ O
physical _ _ O
registers _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
Instruction _ _ O
Scheduler _ _ O
Int _ _ O
ALU _ _ O
1 _ _ O
Int _ _ O
ALU _ _ O
2 _ _ O
Float _ _ O
ALU _ _ O
20 _ _ O

ILP _ _ O
limits _ _ O
performance _ _ O
improvements _ _ O
of _ _ O
wide-issue _ _ O
● _ _ O
We _ _ O
already _ _ O
discussed _ _ O
limits _ _ O
on _ _ O
pipelining _ _ O
. _ _ O
● _ _ O
Time _ _ O
to _ _ O
discuss _ _ O
limits _ _ O
on _ _ O
IPC _ _ O
improvements _ _ O
through _ _ O
wide-issue _ _ O
! _ _ O
● _ _ O
There _ _ O
is _ _ O
a _ _ O
fundamental _ _ O
limit _ _ O
to _ _ O
achievable _ _ O
IPC _ _ O
o _ _ O
Amount _ _ O
of _ _ O
ILP _ _ O
( _ _ O
Instruction _ _ O
Level _ _ O
Parallelism _ _ O
) _ _ O
in _ _ O
code _ _ O
o _ _ O
Remember _ _ O
the _ _ O
data _ _ O
dependence _ _ O
graph _ _ O
? _ _ O
o _ _ O
ILP _ _ O
is _ _ O
constrained _ _ O
only _ _ O
by _ _ O
true _ _ O
RAW _ _ O
dependencies _ _ O
o _ _ O
How _ _ O
about _ _ O
control _ _ O
dependencies _ _ O
? _ _ O
▪ _ _ O
Not _ _ O
a _ _ O
fundamental _ _ O
limit _ _ O
→ _ _ O
can _ _ O
elide _ _ O
using _ _ O
branch _ _ O
prediction _ _ O
● _ _ O
ILP _ _ O
is _ _ O
a _ _ O
property _ _ O
of _ _ O
the _ _ O
program _ _ O
, _ _ O
not _ _ O
the _ _ O
processor _ _ O
o _ _ O
This _ _ O
limit _ _ O
applies _ _ O
to _ _ O
both _ _ O
VLIW _ _ O
and _ _ O
superscalar _ _ O
processors _ _ O
21 _ _ O

ILP _ _ O
present _ _ O
in _ _ O
different _ _ O
programs _ _ O
● _ _ O
After _ _ O
renaming _ _ O
, _ _ O
theoretical _ _ O
limit _ _ O
of _ _ O
IPC _ _ O
is _ _ O
35 _ _ O
~ _ _ O
4003 _ _ O
! _ _ O
Matthew _ _ O
Postiff _ _ O
et _ _ O
al _ _ O
. _ _ O
“ _ _ O
The _ _ O
Limits _ _ O
of _ _ O
Instruction _ _ O
Level _ _ O
Parallelism _ _ O
in _ _ O
SPEC95 _ _ O
Applications _ _ O
” _ _ O
. _ _ O
ACM _ _ O
SIGARCH _ _ O
Computer _ _ O
Architecture _ _ O
News _ _ O
, _ _ O
1999 _ _ O
22 _ _ O

Practical _ _ O
limits _ _ O
on _ _ O
performance _ _ O
of _ _ O
Superscalar _ _ O
● _ _ O
Achieving _ _ O
the _ _ O
theoretical _ _ O
limit _ _ O
would _ _ O
be _ _ O
awesome _ _ O
o _ _ O
In _ _ O
reality _ _ O
, _ _ O
superscalars _ _ O
are _ _ O
typically _ _ O
no _ _ O
more _ _ O
than _ _ O
10-wide _ _ O
● _ _ O
Practical _ _ O
limits _ _ O
on _ _ O
superscalar _ _ O
processors _ _ O
o _ _ O
Number _ _ O
of _ _ O
execution _ _ O
units _ _ O
( _ _ O
e.g. _ _ O
ALU _ _ O
, _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
) _ _ O
not _ _ O
really _ _ O
a _ _ O
limit _ _ O
o _ _ O
Practical _ _ O
limits _ _ O
on _ _ O
the _ _ O
IPC _ _ O
you _ _ O
can _ _ O
achieve _ _ O
▪ _ _ O
Instruction _ _ O
queue _ _ O
size _ _ O
( _ _ O
impacts _ _ O
scheduling _ _ O
window _ _ O
) _ _ O
▪ _ _ O
Physical _ _ O
register _ _ O
file _ _ O
size _ _ O
( _ _ O
also _ _ O
impacts _ _ O
scheduling _ _ O
window _ _ O
) _ _ O
o _ _ O
Upsizing _ _ O
above _ _ O
structures _ _ O
negatively _ _ O
impacts _ _ O
cycle _ _ O
time _ _ O
▪ _ _ O
Time _ _ O
to _ _ O
search _ _ O
and _ _ O
schedule _ _ O
instruction _ _ O
queue _ _ O
▪ _ _ O
Time _ _ O
to _ _ O
access _ _ O
register _ _ O
file _ _ O
( _ _ O
increased _ _ O
size _ _ O
and _ _ O
number _ _ O
of _ _ O
ports _ _ O
) _ _ O
o _ _ O
Upsizing _ _ O
above _ _ O
structures _ _ O
negatively _ _ O
impacts _ _ O
energy _ _ O
efficiency _ _ O
23 _ _ O

Exceptions _ _ O
24 _ _ O

Exceptions _ _ O
Review _ _ O
● _ _ O
Exception _ _ O
: _ _ O
an _ _ O
event _ _ O
which _ _ O
causes _ _ O
the _ _ O
CPU _ _ O
to _ _ O
stop _ _ O
the _ _ O
normal _ _ O
flow _ _ O
of _ _ O
execution _ _ O
and _ _ O
go _ _ O
somewhere _ _ O
else _ _ O
( _ _ O
the _ _ O
exception _ _ O
handler _ _ O
) _ _ O
● _ _ O
There _ _ O
are _ _ O
mainly _ _ O
two _ _ O
causes _ _ O
of _ _ O
exceptions _ _ O
: _ _ O
o _ _ O
Software _ _ O
exceptions _ _ O
( _ _ O
or _ _ O
traps _ _ O
) _ _ O
: _ _ O
Triggered _ _ O
by _ _ O
a _ _ O
program _ _ O
instruction _ _ O
▪ _ _ O
Trap _ _ O
instruction _ _ O
: _ _ O
typically _ _ O
used _ _ O
to _ _ O
call _ _ O
OS _ _ O
routines _ _ O
( _ _ O
system _ _ O
calls _ _ O
) _ _ O
▪ _ _ O
Page _ _ O
fault _ _ O
: _ _ O
instruction _ _ O
accessed _ _ O
a _ _ O
page _ _ O
not _ _ O
mapped _ _ O
to _ _ O
memory _ _ O
▪ _ _ O
Divide-by-0 _ _ O
: _ _ O
instruction _ _ O
performed _ _ O
a _ _ O
divide-by-0 _ _ O
arithmetic _ _ O
▪ _ _ O
Arithmetic _ _ O
overflow _ _ O
: _ _ O
instruction _ _ O
overflowed _ _ O
MAX_INT _ _ O
of _ _ O
register _ _ O
o _ _ O
Hardware _ _ O
exceptions _ _ O
( _ _ O
or _ _ O
interrupts _ _ O
) _ _ O
: _ _ O
Triggered _ _ O
by _ _ O
hardware _ _ O
event _ _ O
▪ _ _ O
User _ _ O
has _ _ O
typed _ _ O
on _ _ O
the _ _ O
keyboard _ _ O
▪ _ _ O
A _ _ O
network _ _ O
packet _ _ O
has _ _ O
arrived _ _ O
▪ _ _ O
A _ _ O
file _ _ O
block _ _ O
read _ _ O
has _ _ O
completed _ _ O
● _ _ O
In _ _ O
all _ _ O
cases _ _ O
, _ _ O
the _ _ O
OS _ _ O
exception _ _ O
handler _ _ O
is _ _ O
invoked _ _ O
25 _ _ O

Handling _ _ O
exceptions _ _ O
● _ _ O
What _ _ O
happens _ _ O
when _ _ O
an _ _ O
exception _ _ O
is _ _ O
triggered _ _ O
: _ _ O
1 _ _ O
. _ _ O
Processor _ _ O
stops _ _ O
execution _ _ O
of _ _ O
user _ _ O
program _ _ O
. _ _ O
2 _ _ O
. _ _ O
Processor _ _ O
stores _ _ O
information _ _ O
about _ _ O
exception _ _ O
( _ _ O
cause _ _ O
, _ _ O
PC _ _ O
) _ _ O
. _ _ O
3 _ _ O
. _ _ O
Processor _ _ O
jumps _ _ O
to _ _ O
the _ _ O
OS _ _ O
exception _ _ O
handler _ _ O
. _ _ O
4 _ _ O
. _ _ O
Handler _ _ O
creates _ _ O
backup _ _ O
of _ _ O
program _ _ O
register _ _ O
values _ _ O
in _ _ O
memory _ _ O
. _ _ O
5 _ _ O
. _ _ O
Handler _ _ O
inspects _ _ O
exception _ _ O
info _ _ O
and _ _ O
handles _ _ O
it _ _ O
accordingly _ _ O
. _ _ O
▪ _ _ O
While _ _ O
overwriting _ _ O
some _ _ O
of _ _ O
the _ _ O
registers _ _ O
that _ _ O
were _ _ O
backed _ _ O
up _ _ O
. _ _ O
6 _ _ O
. _ _ O
Handler _ _ O
restores _ _ O
program _ _ O
register _ _ O
values _ _ O
from _ _ O
memory _ _ O
. _ _ O
7 _ _ O
. _ _ O
Processor _ _ O
resumes _ _ O
execution _ _ O
of _ _ O
user _ _ O
program _ _ O
. _ _ O
● _ _ O
Processor _ _ O
must _ _ O
provide _ _ O
precise _ _ O
register _ _ O
values _ _ O
at _ _ O
point _ _ O
of _ _ O
exception _ _ O
o _ _ O
Otherwise _ _ O
, _ _ O
when _ _ O
processor _ _ O
resumes _ _ O
, _ _ O
program _ _ O
will _ _ O
malfunction _ _ O
o _ _ O
Guaranteeing _ _ O
this _ _ O
is _ _ O
called _ _ O
a _ _ O
precise _ _ O
exception _ _ O
26 _ _ O

Rules _ _ O
for _ _ O
Precise _ _ O
Exceptions _ _ O
1 _ _ O
. _ _ O
All _ _ O
instructions _ _ O
before _ _ O
the _ _ O
exception _ _ O
must _ _ O
have _ _ O
executed _ _ O
2 _ _ O
. _ _ O
No _ _ O
instructions _ _ O
after _ _ O
the _ _ O
exception _ _ O
must _ _ O
execute _ _ O
● _ _ O
Architectural _ _ O
state _ _ O
: _ _ O
the _ _ O
state _ _ O
visible _ _ O
to _ _ O
the _ _ O
ISA _ _ O
( _ _ O
i.e. _ _ O
software _ _ O
) _ _ O
o _ _ O
State _ _ O
in _ _ O
architectural _ _ O
registers _ _ O
( _ _ O
For _ _ O
MIPS _ _ O
: _ _ O
t0 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t2 _ _ O
, _ _ O
… _ _ O
) _ _ O
o _ _ O
State _ _ O
in _ _ O
data _ _ O
memory _ _ O
● _ _ O
Architectural _ _ O
state _ _ O
at _ _ O
point _ _ O
of _ _ O
exception _ _ O
must _ _ O
reflect _ _ O
above _ _ O
rules _ _ O
27 _ _ O

Precise _ _ O
Exceptions _ _ O
in _ _ O
In-order _ _ O
Processors _ _ O
is _ _ O
Easy _ _ O
I-Mem _ _ O
Ins _ _ O
. _ _ O
Decoder _ _ O
● _ _ O
Exceptions _ _ O
are _ _ O
typically _ _ O
detected _ _ O
at _ _ O
the _ _ O
EX _ _ O
stage _ _ O
o _ _ O
Stage _ _ O
where _ _ O
all _ _ O
arithmetic _ _ O
happens _ _ O
as _ _ O
well _ _ O
as _ _ O
address _ _ O
calculations _ _ O
● _ _ O
On _ _ O
exception _ _ O
, _ _ O
flush _ _ O
EX _ _ O
and _ _ O
all _ _ O
previous _ _ O
stages _ _ O
( _ _ O
ID _ _ O
and _ _ O
IF _ _ O
) _ _ O
o _ _ O
Since _ _ O
in-order _ _ O
, _ _ O
guarantees _ _ O
instructions _ _ O
following _ _ O
EX _ _ O
do _ _ O
not _ _ O
writeback _ _ O
o _ _ O
Only _ _ O
state _ _ O
leading _ _ O
up _ _ O
to _ _ O
instruction _ _ O
at _ _ O
EX _ _ O
will _ _ O
be _ _ O
written _ _ O
to _ _ O
reg _ _ O
/ _ _ O
mem _ _ O
Register _ _ O
File _ _ O
ALU _ _ O
D-Mem _ _ O
ALU _ _ O
28 _ _ O

Precise _ _ O
Exceptions _ _ O
in _ _ O
Out-of-order _ _ O
Processors _ _ O
is _ _ O
Hard _ _ O
[ _ _ O
Decoded _ _ O
] _ _ O
li _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
li _ _ O
t1 _ _ O
, _ _ O
1 _ _ O
div _ _ O
t2 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t0 _ _ O
li _ _ O
t0 _ _ O
, _ _ O
3 _ _ O
Register _ _ O
Renamer _ _ O
Instruction _ _ O
Queue _ _ O
● _ _ O
Suppose _ _ O
div _ _ O
t2 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t0 _ _ O
and _ _ O
li _ _ O
t0 _ _ O
, _ _ O
3 _ _ O
issue _ _ O
out-of-order _ _ O
as _ _ O
below _ _ O
o _ _ O
div _ _ O
p2 _ _ O
, _ _ O
p1 _ _ O
, _ _ O
p0 _ _ O
triggers _ _ O
a _ _ O
divide-by-zero _ _ O
exception _ _ O
( _ _ O
p0 _ _ O
= _ _ O
0 _ _ O
) _ _ O
o _ _ O
But _ _ O
at _ _ O
point _ _ O
of _ _ O
exception _ _ O
, _ _ O
t0 _ _ O
appears _ _ O
to _ _ O
be _ _ O
3 _ _ O
due _ _ O
to _ _ O
li _ _ O
p3 _ _ O
, _ _ O
3 _ _ O
! _ _ O
▪ _ _ O
At _ _ O
that _ _ O
point _ _ O
, _ _ O
t0 _ _ O
is _ _ O
mapped _ _ O
to _ _ O
p3 _ _ O
in _ _ O
the _ _ O
RAT _ _ O
( _ _ O
not _ _ O
p0 _ _ O
) _ _ O
[ _ _ O
Dispatched _ _ O
] _ _ O
li _ _ O
p0 _ _ O
, _ _ O
0 _ _ O
li _ _ O
p1 _ _ O
, _ _ O
1 _ _ O
div _ _ O
p2 _ _ O
, _ _ O
p1 _ _ O
, _ _ O
p0 _ _ O
li _ _ O
p3 _ _ O
, _ _ O
3 _ _ O
Instruction _ _ O
Scheduler _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
Int _ _ O
ALU _ _ O
1 _ _ O
Int _ _ O
ALU _ _ O
2 _ _ O
[ _ _ O
Issued _ _ O
] _ _ O
li _ _ O
p0 _ _ O
, _ _ O
0 _ _ O
li _ _ O
p1 _ _ O
, _ _ O
1 _ _ O
li _ _ O
p3 _ _ O
, _ _ O
3 _ _ O
div _ _ O
p2 _ _ O
, _ _ O
p1 _ _ O
, _ _ O
p0 _ _ O
Divide-by-zero _ _ O
Exception _ _ O
! _ _ O
Float _ _ O
ALU _ _ O
29 _ _ O

Precise _ _ O
Exceptions _ _ O
in _ _ O
Out-of-order _ _ O
Processors _ _ O
is _ _ O
Hard _ _ O
● _ _ O
This _ _ O
is _ _ O
the _ _ O
challenge _ _ O
with _ _ O
out-of-order _ _ O
processors _ _ O
o _ _ O
Instructions _ _ O
execute _ _ O
and _ _ O
complete _ _ O
out-of-order _ _ O
o _ _ O
For _ _ O
precise _ _ O
exceptions _ _ O
, _ _ O
instructions _ _ O
must _ _ O
appear _ _ O
to _ _ O
complete _ _ O
in-order _ _ O
● _ _ O
Solution _ _ O
: _ _ O
update _ _ O
architectural _ _ O
state _ _ O
in-order _ _ O
o _ _ O
When _ _ O
instructions _ _ O
execute _ _ O
, _ _ O
have _ _ O
them _ _ O
only _ _ O
update _ _ O
“ _ _ O
internal _ _ O
” _ _ O
state _ _ O
▪ _ _ O
Physical _ _ O
registers _ _ O
▪ _ _ O
Store _ _ O
queue _ _ O
( _ _ O
MEM _ _ O
queues _ _ O
up _ _ O
stores _ _ O
instead _ _ O
of _ _ O
performing _ _ O
them _ _ O
) _ _ O
o _ _ O
Internal _ _ O
state _ _ O
is _ _ O
transferred _ _ O
to _ _ O
visible _ _ O
state _ _ O
during _ _ O
in-order _ _ O
commit _ _ O
▪ _ _ O
Physical _ _ O
registers _ _ O
are _ _ O
copied _ _ O
to _ _ O
architectural _ _ O
registers _ _ O
▪ _ _ O
Store _ _ O
queue _ _ O
entries _ _ O
are _ _ O
written _ _ O
to _ _ O
memory _ _ O
30 _ _ O

In-order _ _ O
Commit _ _ O
[ _ _ O
Decoded _ _ O
] _ _ O
li _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
li _ _ O
t1 _ _ O
, _ _ O
1 _ _ O
div _ _ O
t2 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t0 _ _ O
li _ _ O
t0 _ _ O
, _ _ O
3 _ _ O
Register _ _ O
Renamer _ _ O
Physical _ _ O
Register _ _ O
File _ _ O
Retirement _ _ O
Register _ _ O
File _ _ O
t0 _ _ O
s0 _ _ O
a0 _ _ O
t1 _ _ O
s1 _ _ O
a1 _ _ O
t2 _ _ O
s2 _ _ O
a2 _ _ O
… _ _ O
… _ _ O
… _ _ O
Instruction _ _ O
Queue _ _ O
instructions _ _ O
dest _ _ O
done _ _ O
? _ _ O
li _ _ O
p0 _ _ O
, _ _ O
0 _ _ O
t0 _ _ O
Y _ _ O
li _ _ O
p1 _ _ O
, _ _ O
1 _ _ O
t1 _ _ O
Y _ _ O
div _ _ O
p2 _ _ O
, _ _ O
p1 _ _ O
, _ _ O
p0 _ _ O
t2 _ _ O
N _ _ O
li _ _ O
p3 _ _ O
, _ _ O
3 _ _ O
t0 _ _ O
Y _ _ O
Architectural _ _ O
Registers _ _ O
commit _ _ O
in _ _ O
order _ _ O
Instruction _ _ O
Decoder _ _ O
● _ _ O
Decoded _ _ O
instructions _ _ O
are _ _ O
stored _ _ O
to _ _ O
i-queue _ _ O
in-order _ _ O
● _ _ O
Instructions _ _ O
execute _ _ O
out-of-order _ _ O
( _ _ O
updating _ _ O
done _ _ O
? _ _ O
field _ _ O
) _ _ O
● _ _ O
Done _ _ O
instructions _ _ O
commit _ _ O
in-order _ _ O
to _ _ O
Retirement _ _ O
Register _ _ O
File _ _ O
( _ _ O
RRF _ _ O
) _ _ O
Instruction _ _ O
Scheduler _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
Int _ _ O
ALU _ _ O
1 _ _ O
Int _ _ O
ALU _ _ O
2 _ _ O
Float _ _ O
ALU _ _ O
31 _ _ O

In-order _ _ O
Commit _ _ O
Example _ _ O
: _ _ O
Cycle _ _ O
1 _ _ O
[ _ _ O
Decoded _ _ O
] _ _ O
li _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
li _ _ O
t1 _ _ O
, _ _ O
1 _ _ O
div _ _ O
t2 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t0 _ _ O
li _ _ O
t0 _ _ O
, _ _ O
3 _ _ O
Register _ _ O
Renamer _ _ O
Physical _ _ O
Register _ _ O
File _ _ O
Retirement _ _ O
Register _ _ O
File _ _ O
t0 _ _ O
s0 _ _ O
a0 _ _ O
t1 _ _ O
s1 _ _ O
a1 _ _ O
t2 _ _ O
s2 _ _ O
a2 _ _ O
… _ _ O
… _ _ O
… _ _ O
Instruction _ _ O
Queue _ _ O
instructions _ _ O
dest _ _ O
done _ _ O
? _ _ O
li _ _ O
p0 _ _ O
, _ _ O
0 _ _ O
t0 _ _ O
Y _ _ O
li _ _ O
p1 _ _ O
, _ _ O
1 _ _ O
t1 _ _ O
Y _ _ O
div _ _ O
p2 _ _ O
, _ _ O
p1 _ _ O
, _ _ O
p0 _ _ O
t2 _ _ O
N _ _ O
li _ _ O
p3 _ _ O
, _ _ O
3 _ _ O
t0 _ _ O
Y _ _ O
Architectural _ _ O
Registers _ _ O
commit _ _ O
in _ _ O
order _ _ O
Instruction _ _ O
Decoder _ _ O
● _ _ O
At _ _ O
this _ _ O
point _ _ O
, _ _ O
all _ _ O
li _ _ O
instructions _ _ O
have _ _ O
completed _ _ O
but _ _ O
not _ _ O
the _ _ O
div _ _ O
● _ _ O
li _ _ O
p0 _ _ O
, _ _ O
0 _ _ O
and _ _ O
li _ _ O
p1 _ _ O
, _ _ O
1 _ _ O
can _ _ O
commit _ _ O
on _ _ O
the _ _ O
next _ _ O
cycle _ _ O
o _ _ O
But _ _ O
not _ _ O
li _ _ O
p3 _ _ O
, _ _ O
3 _ _ O
since _ _ O
we _ _ O
have _ _ O
in-order _ _ O
commit _ _ O
! _ _ O
Instruction _ _ O
Scheduler _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
Int _ _ O
ALU _ _ O
1 _ _ O
Int _ _ O
ALU _ _ O
2 _ _ O
Float _ _ O
ALU _ _ O
32 _ _ O

In-order _ _ O
Commit _ _ O
Example _ _ O
: _ _ O
Cycle _ _ O
2 _ _ O
[ _ _ O
Decoded _ _ O
] _ _ O
li _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
li _ _ O
t1 _ _ O
, _ _ O
1 _ _ O
div _ _ O
t2 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t0 _ _ O
li _ _ O
t0 _ _ O
, _ _ O
3 _ _ O
Register _ _ O
Renamer _ _ O
Physical _ _ O
Register _ _ O
File _ _ O
Retirement _ _ O
Register _ _ O
File _ _ O
t0 _ _ O
s0 _ _ O
a0 _ _ O
t1 _ _ O
s1 _ _ O
a1 _ _ O
t2 _ _ O
s2 _ _ O
a2 _ _ O
… _ _ O
… _ _ O
… _ _ O
Instruction _ _ O
Queue _ _ O
instructions _ _ O
dest _ _ O
done _ _ O
? _ _ O
div _ _ O
p2 _ _ O
, _ _ O
p1 _ _ O
, _ _ O
p0 _ _ O
t2 _ _ O
Y _ _ O
li _ _ O
p3 _ _ O
, _ _ O
3 _ _ O
t0 _ _ O
Y _ _ O
… _ _ O
… _ _ O
Architectural _ _ O
Registers _ _ O
commit _ _ O
in _ _ O
order _ _ O
Instruction _ _ O
Decoder _ _ O
● _ _ O
li _ _ O
p0 _ _ O
, _ _ O
0 _ _ O
and _ _ O
li _ _ O
p1 _ _ O
, _ _ O
1 _ _ O
have _ _ O
committed _ _ O
updating _ _ O
t0 _ _ O
and _ _ O
t1 _ _ O
● _ _ O
div _ _ O
p2 _ _ O
, _ _ O
p1 _ _ O
, _ _ O
p0 _ _ O
has _ _ O
completed _ _ O
execution _ _ O
and _ _ O
is _ _ O
finally _ _ O
ready _ _ O
to _ _ O
commit _ _ O
o _ _ O
On _ _ O
completion _ _ O
, _ _ O
div _ _ O
has _ _ O
set _ _ O
an _ _ O
“ _ _ O
exception _ _ O
bit _ _ O
” _ _ O
in _ _ O
i-queue _ _ O
( _ _ O
not _ _ O
shown _ _ O
here _ _ O
) _ _ O
Instruction _ _ O
Scheduler _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
Int _ _ O
ALU _ _ O
1 _ _ O
Int _ _ O
ALU _ _ O
2 _ _ O
Float _ _ O
ALU _ _ O
33 _ _ O

In-order _ _ O
Commit _ _ O
Example _ _ O
: _ _ O
Cycle _ _ O
3 _ _ O
[ _ _ O
Decoded _ _ O
] _ _ O
li _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
li _ _ O
t1 _ _ O
, _ _ O
1 _ _ O
div _ _ O
t2 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t0 _ _ O
li _ _ O
t0 _ _ O
, _ _ O
3 _ _ O
Register _ _ O
Renamer _ _ O
Physical _ _ O
Register _ _ O
File _ _ O
Retirement _ _ O
Register _ _ O
File _ _ O
t0 _ _ O
s0 _ _ O
a0 _ _ O
t1 _ _ O
s1 _ _ O
a1 _ _ O
t2 _ _ O
s2 _ _ O
a2 _ _ O
… _ _ O
… _ _ O
… _ _ O
Instruction _ _ O
Queue _ _ O
instructions _ _ O
dest _ _ O
done _ _ O
? _ _ O
div _ _ O
p2 _ _ O
, _ _ O
p1 _ _ O
, _ _ O
p0 _ _ O
t2 _ _ O
Y _ _ O
li _ _ O
p3 _ _ O
, _ _ O
3 _ _ O
t0 _ _ O
Y _ _ O
… _ _ O
… _ _ O
Architectural _ _ O
Registers _ _ O
Instruction _ _ O
Scheduler _ _ O
Exception _ _ O
! _ _ O
Flush _ _ O
! _ _ O
Instruction _ _ O
Decoder _ _ O
● _ _ O
An _ _ O
exception _ _ O
is _ _ O
raised _ _ O
for _ _ O
div _ _ O
p2 _ _ O
, _ _ O
p1 _ _ O
, _ _ O
p0 _ _ O
when _ _ O
it _ _ O
tries _ _ O
to _ _ O
commit _ _ O
o _ _ O
Instructions _ _ O
following _ _ O
div _ _ O
are _ _ O
flushed _ _ O
, _ _ O
without _ _ O
modifying _ _ O
RRF _ _ O
● _ _ O
Retirement _ _ O
Register _ _ O
File _ _ O
contains _ _ O
a _ _ O
precise _ _ O
architectural _ _ O
state _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
Int _ _ O
ALU _ _ O
1 _ _ O
Int _ _ O
ALU _ _ O
2 _ _ O
Float _ _ O
ALU _ _ O
34 _ _ O

In-order _ _ O
Commit _ _ O
also _ _ O
solves _ _ O
branch _ _ O
misprediction _ _ O
[ _ _ O
Decoded _ _ O
] _ _ O
li _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
li _ _ O
t1 _ _ O
, _ _ O
1 _ _ O
div _ _ O
t2 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t0 _ _ O
li _ _ O
t0 _ _ O
, _ _ O
3 _ _ O
Register _ _ O
Renamer _ _ O
Physical _ _ O
Register _ _ O
File _ _ O
Retirement _ _ O
Register _ _ O
File _ _ O
t0 _ _ O
s0 _ _ O
a0 _ _ O
t1 _ _ O
s1 _ _ O
a1 _ _ O
t2 _ _ O
s2 _ _ O
a2 _ _ O
… _ _ O
… _ _ O
… _ _ O
Instruction _ _ O
Queue _ _ O
instructions _ _ O
dest _ _ O
done _ _ O
? _ _ O
li _ _ O
p0 _ _ O
, _ _ O
0 _ _ O
t0 _ _ O
Y _ _ O
li _ _ O
p1 _ _ O
, _ _ O
1 _ _ O
t1 _ _ O
Y _ _ O
beq _ _ O
p0 _ _ O
, _ _ O
p1 _ _ O
, _ _ O
… _ _ O
t2 _ _ O
N _ _ O
li _ _ O
p3 _ _ O
, _ _ O
3 _ _ O
t0 _ _ O
Y _ _ O
Architectural _ _ O
Registers _ _ O
Instruction _ _ O
Scheduler _ _ O
Flush _ _ O
! _ _ O
Instruction _ _ O
Decoder _ _ O
● _ _ O
What _ _ O
if _ _ O
processor _ _ O
finds _ _ O
out _ _ O
it _ _ O
mispredicted _ _ O
a _ _ O
branch _ _ O
? _ _ O
o _ _ O
Just _ _ O
flush _ _ O
instructions _ _ O
below _ _ O
it _ _ O
after _ _ O
the _ _ O
branch _ _ O
executes _ _ O
! _ _ O
o _ _ O
Also _ _ O
restore _ _ O
an _ _ O
RAT _ _ O
snapshot _ _ O
that _ _ O
was _ _ O
taken _ _ O
at _ _ O
point _ _ O
of _ _ O
branch _ _ O
. _ _ O
Mispredict _ _ O
! _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
Int _ _ O
ALU _ _ O
1 _ _ O
Int _ _ O
ALU _ _ O
2 _ _ O
Float _ _ O
ALU _ _ O
35 _ _ O

In-order _ _ O
Commit _ _ O
also _ _ O
solves _ _ O
physical _ _ O
register _ _ O
recycling _ _ O
Instruction _ _ O
Decoder _ _ O
● _ _ O
When _ _ O
can _ _ O
the _ _ O
processor _ _ O
recycle _ _ O
physical _ _ O
registers _ _ O
? _ _ O
o _ _ O
The _ _ O
prev _ _ O
column _ _ O
records _ _ O
previous _ _ O
physical _ _ O
register _ _ O
mapped _ _ O
to _ _ O
dest _ _ O
. _ _ O
o _ _ O
When _ _ O
li _ _ O
p3 _ _ O
, _ _ O
3 _ _ O
commits _ _ O
, _ _ O
p0 _ _ O
previously _ _ O
mapped _ _ O
to _ _ O
t0 _ _ O
can _ _ O
be _ _ O
recycled _ _ O
[ _ _ O
Decoded _ _ O
] _ _ O
li _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
li _ _ O
t1 _ _ O
, _ _ O
1 _ _ O
div _ _ O
t2 _ _ O
, _ _ O
t1 _ _ O
, _ _ O
t0 _ _ O
li _ _ O
t0 _ _ O
, _ _ O
3 _ _ O
Register _ _ O
Renamer _ _ O
Physical _ _ O
Register _ _ O
File _ _ O
Retirement _ _ O
Register _ _ O
File _ _ O
t0 _ _ O
s0 _ _ O
a0 _ _ O
t1 _ _ O
s1 _ _ O
a1 _ _ O
t2 _ _ O
s2 _ _ O
a2 _ _ O
… _ _ O
… _ _ O
… _ _ O
Instruction _ _ O
Queue _ _ O
instructions _ _ O
dest _ _ O
prev _ _ O
li _ _ O
p0 _ _ O
, _ _ O
0 _ _ O
t0 _ _ O
li _ _ O
p1 _ _ O
, _ _ O
1 _ _ O
t1 _ _ O
beq _ _ O
p0 _ _ O
, _ _ O
p1 _ _ O
, _ _ O
… _ _ O
t2 _ _ O
li _ _ O
p3 _ _ O
, _ _ O
3 _ _ O
t0 _ _ O
p0 _ _ O
Architectural _ _ O
Registers _ _ O
Instruction _ _ O
Scheduler _ _ O
Recycle _ _ O
p0 _ _ O
on _ _ O
commit _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
Int _ _ O
ALU _ _ O
1 _ _ O
Int _ _ O
ALU _ _ O
2 _ _ O
Float _ _ O
ALU _ _ O
36 _ _ O

Load _ _ O
/ _ _ O
Store _ _ O
Queue _ _ O
37 _ _ O

How _ _ O
about _ _ O
data _ _ O
dependencies _ _ O
through _ _ O
memory _ _ O
? _ _ O
● _ _ O
RAW _ _ O
, _ _ O
WAR _ _ O
, _ _ O
and _ _ O
WAW _ _ O
dependencies _ _ O
happen _ _ O
through _ _ O
memory _ _ O
as _ _ O
well _ _ O
o _ _ O
Clearly _ _ O
, _ _ O
the _ _ O
below _ _ O
code _ _ O
has _ _ O
no _ _ O
data _ _ O
dependencies _ _ O
through _ _ O
registers _ _ O
sw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
4 _ _ O
( _ _ O
$s0 _ _ O
) _ _ O
/ _ _ O
/ _ _ O
stores _ _ O
to _ _ O
0xdeadbeef _ _ O
lw _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
8 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
/ _ _ O
/ _ _ O
loads _ _ O
from _ _ O
0xdeadbeef _ _ O
o _ _ O
But _ _ O
there _ _ O
is _ _ O
a _ _ O
RAW _ _ O
dependency _ _ O
through _ _ O
the _ _ O
location _ _ O
0xdeadbeef _ _ O
● _ _ O
Question _ _ O
: _ _ O
how _ _ O
does _ _ O
processor _ _ O
enforce _ _ O
RAW _ _ O
dependencies _ _ O
? _ _ O
● _ _ O
Question _ _ O
: _ _ O
how _ _ O
does _ _ O
processor _ _ O
deal _ _ O
with _ _ O
WAR _ _ O
and _ _ O
WAW _ _ O
dependencies _ _ O
? _ _ O
● _ _ O
Answer _ _ O
: _ _ O
through _ _ O
memory _ _ O
renaming _ _ O
using _ _ O
a _ _ O
load _ _ O
/ _ _ O
store _ _ O
queue _ _ O
o _ _ O
Just _ _ O
like _ _ O
registers _ _ O
, _ _ O
a _ _ O
new _ _ O
queue _ _ O
entry _ _ O
created _ _ O
for _ _ O
every _ _ O
store _ _ O
instruction _ _ O
→ _ _ O
All _ _ O
WAR _ _ O
and _ _ O
WAW _ _ O
memory _ _ O
dependencies _ _ O
are _ _ O
removed _ _ O
o _ _ O
Loads _ _ O
fetch _ _ O
data _ _ O
from _ _ O
most _ _ O
recent _ _ O
queue _ _ O
entry _ _ O
with _ _ O
same _ _ O
address _ _ O
→ _ _ O
All _ _ O
RAW _ _ O
memory _ _ O
dependencies _ _ O
are _ _ O
enforced _ _ O
38 _ _ O

Every _ _ O
store _ _ O
gets _ _ O
a _ _ O
new _ _ O
store _ _ O
queue _ _ O
entry _ _ O
Instruction _ _ O
Decoder _ _ O
● _ _ O
Loads _ _ O
/ _ _ O
stores _ _ O
are _ _ O
inserted _ _ O
into _ _ O
load _ _ O
/ _ _ O
store _ _ O
queue _ _ O
as _ _ O
well _ _ O
instruction _ _ O
queue _ _ O
o _ _ O
Age _ _ O
denotes _ _ O
age _ _ O
of _ _ O
memory _ _ O
operation _ _ O
( _ _ O
incremented _ _ O
at _ _ O
every _ _ O
mem _ _ O
op _ _ O
) _ _ O
o _ _ O
Address _ _ O
and _ _ O
value _ _ O
of _ _ O
mem _ _ O
op _ _ O
is _ _ O
unknown _ _ O
until _ _ O
mem _ _ O
op _ _ O
is _ _ O
complete _ _ O
Store _ _ O
Queue _ _ O
[ _ _ O
Decoded _ _ O
] _ _ O
addr _ _ O
value _ _ O
sw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s0 _ _ O
) _ _ O
age _ _ O
0 _ _ O
( _ _ O
$s0 _ _ O
) _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
sw _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
1 _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
lw _ _ O
$ _ _ O
t2 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s2 _ _ O
) _ _ O
2 _ _ O
… _ _ O
… _ _ O
… _ _ O
Register _ _ O
Renamer _ _ O
Instruction _ _ O
Queue _ _ O
Physical _ _ O
Register _ _ O
File _ _ O
Load _ _ O
Queue _ _ O
age _ _ O
addr _ _ O
done _ _ O
? _ _ O
3 _ _ O
0 _ _ O
( _ _ O
$s2 _ _ O
) _ _ O
? _ _ O
? _ _ O
? _ _ O
N _ _ O
… _ _ O
… _ _ O
… _ _ O
Renamed _ _ O
Memory _ _ O
Instruction _ _ O
Scheduler _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
Int _ _ O
ALU _ _ O
1 _ _ O
Int _ _ O
ALU _ _ O
2 _ _ O
Float _ _ O
ALU _ _ O
39 _ _ O

Scenario _ _ O
1 _ _ O
: _ _ O
WAW _ _ O
reordering _ _ O
of _ _ O
two _ _ O
stores _ _ O
Instruction _ _ O
Decoder _ _ O
● _ _ O
Let _ _ O
’s _ _ O
say _ _ O
sw _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
becomes _ _ O
ready _ _ O
first _ _ O
in _ _ O
the _ _ O
i-queue _ _ O
and _ _ O
executes _ _ O
o _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
is _ _ O
resolved _ _ O
to _ _ O
0xdeadbeef _ _ O
and _ _ O
$ _ _ O
t1 _ _ O
is _ _ O
resolved _ _ O
to _ _ O
1 _ _ O
Store _ _ O
Queue _ _ O
[ _ _ O
Decoded _ _ O
] _ _ O
addr _ _ O
value _ _ O
sw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s0 _ _ O
) _ _ O
age _ _ O
0 _ _ O
( _ _ O
$s0 _ _ O
) _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
sw _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
1 _ _ O
0xdeadbeef _ _ O
1 _ _ O
lw _ _ O
$ _ _ O
t2 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s2 _ _ O
) _ _ O
2 _ _ O
… _ _ O
… _ _ O
… _ _ O
Register _ _ O
Renamer _ _ O
Instruction _ _ O
Queue _ _ O
Physical _ _ O
Register _ _ O
File _ _ O
Load _ _ O
Queue _ _ O
age _ _ O
addr _ _ O
done _ _ O
? _ _ O
3 _ _ O
0 _ _ O
( _ _ O
$s2 _ _ O
) _ _ O
? _ _ O
? _ _ O
? _ _ O
N _ _ O
… _ _ O
… _ _ O
… _ _ O
Renamed _ _ O
Memory _ _ O
Instruction _ _ O
Scheduler _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
Int _ _ O
ALU _ _ O
1 _ _ O
Int _ _ O
ALU _ _ O
2 _ _ O
Float _ _ O
ALU _ _ O
40 _ _ O

Scenario _ _ O
1 _ _ O
: _ _ O
WAW _ _ O
reordering _ _ O
of _ _ O
two _ _ O
stores _ _ O
Instruction _ _ O
Decoder _ _ O
● _ _ O
Next _ _ O
, _ _ O
sw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s0 _ _ O
) _ _ O
becomes _ _ O
ready _ _ O
in _ _ O
the _ _ O
i-queue _ _ O
and _ _ O
executes _ _ O
o _ _ O
0 _ _ O
( _ _ O
$s0 _ _ O
) _ _ O
is _ _ O
also _ _ O
resolved _ _ O
to _ _ O
0xdeadbeef _ _ O
and _ _ O
$ _ _ O
t0 _ _ O
is _ _ O
resolved _ _ O
to _ _ O
0 _ _ O
o _ _ O
So _ _ O
, _ _ O
we _ _ O
have _ _ O
effectively _ _ O
reordered _ _ O
execution _ _ O
of _ _ O
a _ _ O
WAW _ _ O
dependency _ _ O
Store _ _ O
Queue _ _ O
[ _ _ O
Decoded _ _ O
] _ _ O
addr _ _ O
value _ _ O
sw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s0 _ _ O
) _ _ O
age _ _ O
0xdeadbeef _ _ O
0 _ _ O
sw _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
1 _ _ O
0xdeadbeef _ _ O
1 _ _ O
lw _ _ O
$ _ _ O
t2 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s2 _ _ O
) _ _ O
2 _ _ O
… _ _ O
… _ _ O
… _ _ O
Register _ _ O
Renamer _ _ O
Instruction _ _ O
Queue _ _ O
Physical _ _ O
Register _ _ O
File _ _ O
Load _ _ O
Queue _ _ O
age _ _ O
addr _ _ O
done _ _ O
? _ _ O
3 _ _ O
0 _ _ O
( _ _ O
$s2 _ _ O
) _ _ O
? _ _ O
? _ _ O
? _ _ O
N _ _ O
… _ _ O
… _ _ O
… _ _ O
Renamed _ _ O
Memory _ _ O
Instruction _ _ O
Scheduler _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
Int _ _ O
ALU _ _ O
1 _ _ O
Int _ _ O
ALU _ _ O
2 _ _ O
Float _ _ O
ALU _ _ O
41 _ _ O

Scenario _ _ O
1 _ _ O
: _ _ O
WAW _ _ O
reordering _ _ O
of _ _ O
two _ _ O
stores _ _ O
Instruction _ _ O
Decoder _ _ O
● _ _ O
Finally _ _ O
, _ _ O
lw _ _ O
$ _ _ O
t2 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s2 _ _ O
) _ _ O
becomes _ _ O
ready _ _ O
in _ _ O
the _ _ O
i-queue _ _ O
and _ _ O
executes _ _ O
o _ _ O
0 _ _ O
( _ _ O
$s2 _ _ O
) _ _ O
also _ _ O
resolves _ _ O
to _ _ O
0xdeadbeef _ _ O
meaning _ _ O
a _ _ O
RAW _ _ O
dependence _ _ O
o _ _ O
Load _ _ O
Unit _ _ O
searches _ _ O
Store _ _ O
Queue _ _ O
for _ _ O
most _ _ O
recent _ _ O
store _ _ O
matching _ _ O
address _ _ O
Store _ _ O
Queue _ _ O
[ _ _ O
Decoded _ _ O
] _ _ O
addr _ _ O
value _ _ O
sw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s0 _ _ O
) _ _ O
age _ _ O
0xdeadbeef _ _ O
0 _ _ O
sw _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
1 _ _ O
0xdeadbeef _ _ O
1 _ _ O
lw _ _ O
$ _ _ O
t2 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s2 _ _ O
) _ _ O
2 _ _ O
… _ _ O
… _ _ O
… _ _ O
Register _ _ O
Renamer _ _ O
Instruction _ _ O
Queue _ _ O
Physical _ _ O
Register _ _ O
File _ _ O
Load _ _ O
Queue _ _ O
age _ _ O
addr _ _ O
done _ _ O
? _ _ O
3 _ _ O
0xdeadbeef _ _ O
Y _ _ O
… _ _ O
… _ _ O
… _ _ O
$ _ _ O
t2 _ _ O
= _ _ O
1 _ _ O
addr _ _ O
= _ _ O
= _ _ O
0xdeadbeef _ _ O
& _ _ O
& _ _ O
age _ _ O
< _ _ O
3 _ _ O
? _ _ O
Instruction _ _ O
Scheduler _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
Int _ _ O
ALU _ _ O
1 _ _ O
Int _ _ O
ALU _ _ O
2 _ _ O
Float _ _ O
ALU _ _ O
42 _ _ O

Scenario _ _ O
2 _ _ O
: _ _ O
Flush _ _ O
due _ _ O
to _ _ O
RAW _ _ O
violation _ _ O
Instruction _ _ O
Decoder _ _ O
● _ _ O
In _ _ O
this _ _ O
scenario _ _ O
, _ _ O
lw _ _ O
$ _ _ O
t2 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s2 _ _ O
) _ _ O
becomes _ _ O
ready _ _ O
first _ _ O
and _ _ O
executes _ _ O
o _ _ O
Load _ _ O
Unit _ _ O
searches _ _ O
store _ _ O
queue _ _ O
but _ _ O
does _ _ O
not _ _ O
find _ _ O
matching _ _ O
entry _ _ O
o _ _ O
So _ _ O
, _ _ O
it _ _ O
simply _ _ O
fetches _ _ O
value _ _ O
for _ _ O
$ _ _ O
t2 _ _ O
from _ _ O
memory _ _ O
Store _ _ O
Queue _ _ O
[ _ _ O
Decoded _ _ O
] _ _ O
addr _ _ O
value _ _ O
sw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s0 _ _ O
) _ _ O
age _ _ O
0 _ _ O
( _ _ O
$s0 _ _ O
) _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
sw _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
1 _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
lw _ _ O
$ _ _ O
t2 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s2 _ _ O
) _ _ O
2 _ _ O
… _ _ O
… _ _ O
… _ _ O
Register _ _ O
Renamer _ _ O
Instruction _ _ O
Queue _ _ O
Physical _ _ O
Register _ _ O
File _ _ O
Load _ _ O
Queue _ _ O
age _ _ O
addr _ _ O
done _ _ O
? _ _ O
3 _ _ O
0xdeadbeef _ _ O
Y _ _ O
… _ _ O
… _ _ O
… _ _ O
addr _ _ O
= _ _ O
= _ _ O
0xdeadbeef _ _ O
& _ _ O
& _ _ O
age _ _ O
< _ _ O
3 _ _ O
? _ _ O
Instruction _ _ O
Scheduler _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
Int _ _ O
ALU _ _ O
1 _ _ O
Int _ _ O
ALU _ _ O
2 _ _ O
Float _ _ O
ALU _ _ O
43 _ _ O

Scenario _ _ O
2 _ _ O
: _ _ O
Flush _ _ O
due _ _ O
to _ _ O
RAW _ _ O
violation _ _ O
Instruction _ _ O
Decoder _ _ O
● _ _ O
Next _ _ O
, _ _ O
sw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s0 _ _ O
) _ _ O
becomes _ _ O
ready _ _ O
in _ _ O
the _ _ O
i-queue _ _ O
and _ _ O
executes _ _ O
o _ _ O
Store _ _ O
Unit _ _ O
searches _ _ O
Load _ _ O
Queue _ _ O
to _ _ O
see _ _ O
if _ _ O
there _ _ O
were _ _ O
RAW _ _ O
violations _ _ O
o _ _ O
And _ _ O
, _ _ O
yes _ _ O
, _ _ O
there _ _ O
is _ _ O
a _ _ O
Load _ _ O
that _ _ O
performed _ _ O
earlier _ _ O
than _ _ O
it _ _ O
should _ _ O
have _ _ O
! _ _ O
Store _ _ O
Queue _ _ O
[ _ _ O
Decoded _ _ O
] _ _ O
addr _ _ O
value _ _ O
sw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s0 _ _ O
) _ _ O
age _ _ O
0xdeadbeef _ _ O
0 _ _ O
sw _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
1 _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
lw _ _ O
$ _ _ O
t2 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s2 _ _ O
) _ _ O
2 _ _ O
… _ _ O
… _ _ O
… _ _ O
Register _ _ O
Renamer _ _ O
Physical _ _ O
Register _ _ O
File _ _ O
Instruction _ _ O
Queue _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
Instruction _ _ O
Scheduler _ _ O
Load _ _ O
Queue _ _ O
age _ _ O
addr _ _ O
done _ _ O
? _ _ O
addr _ _ O
= _ _ O
= _ _ O
0xdeadbeef _ _ O
3 _ _ O
0xdeadbeef _ _ O
Y _ _ O
& _ _ O
& _ _ O
age _ _ O
> _ _ O
1 _ _ O
… _ _ O
… _ _ O
… _ _ O
& _ _ O
& _ _ O
done _ _ O
? _ _ O
Int _ _ O
ALU _ _ O
1 _ _ O
Int _ _ O
ALU _ _ O
2 _ _ O
Float _ _ O
ALU _ _ O
44 _ _ O

Scenario _ _ O
2 _ _ O
: _ _ O
Flush _ _ O
due _ _ O
to _ _ O
RAW _ _ O
violation _ _ O
Store _ _ O
Queue _ _ O
[ _ _ O
Decoded _ _ O
] _ _ O
addr _ _ O
value _ _ O
sw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s0 _ _ O
) _ _ O
age _ _ O
0xdeadbeef _ _ O
0 _ _ O
sw _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
1 _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
lw _ _ O
$ _ _ O
t2 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s2 _ _ O
) _ _ O
2 _ _ O
… _ _ O
… _ _ O
… _ _ O
Register _ _ O
Renamer _ _ O
Instruction _ _ O
Queue _ _ O
Physical _ _ O
Register _ _ O
File _ _ O
Load _ _ O
Queue _ _ O
age _ _ O
addr _ _ O
done _ _ O
? _ _ O
3 _ _ O
0xdeadbeef _ _ O
Y _ _ O
… _ _ O
… _ _ O
… _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
Instruction _ _ O
Scheduler _ _ O
Flush _ _ O
! _ _ O
Instruction _ _ O
Decoder _ _ O
● _ _ O
Flush _ _ O
lw _ _ O
$ _ _ O
t2 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s2 _ _ O
) _ _ O
and _ _ O
all _ _ O
instructions _ _ O
that _ _ O
follow _ _ O
it _ _ O
in _ _ O
i-queue _ _ O
o _ _ O
All _ _ O
following _ _ O
execution _ _ O
has _ _ O
been _ _ O
polluted _ _ O
by _ _ O
incorrect _ _ O
value _ _ O
of _ _ O
$ _ _ O
t2 _ _ O
Int _ _ O
ALU _ _ O
1 _ _ O
Int _ _ O
ALU _ _ O
2 _ _ O
Float _ _ O
ALU _ _ O
45 _ _ O

Precise _ _ O
exceptions _ _ O
through _ _ O
in-order _ _ O
commit _ _ O
Instruction _ _ O
Decoder _ _ O
● _ _ O
Values _ _ O
in _ _ O
Store _ _ O
Queue _ _ O
are _ _ O
committed _ _ O
in-order _ _ O
o _ _ O
When _ _ O
store _ _ O
instruction _ _ O
reaches _ _ O
head _ _ O
of _ _ O
i-queue _ _ O
, _ _ O
value _ _ O
stored _ _ O
to _ _ O
memory _ _ O
o _ _ O
Guarantees _ _ O
precise _ _ O
exceptions _ _ O
Store _ _ O
Queue _ _ O
[ _ _ O
Decoded _ _ O
] _ _ O
addr _ _ O
value _ _ O
sw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s0 _ _ O
) _ _ O
age _ _ O
0xdeadbeef _ _ O
0 _ _ O
sw _ _ O
$ _ _ O
t1 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s1 _ _ O
) _ _ O
1 _ _ O
0xdeadbeef _ _ O
1 _ _ O
lw _ _ O
$ _ _ O
t2 _ _ O
, _ _ O
0 _ _ O
( _ _ O
$s2 _ _ O
) _ _ O
2 _ _ O
… _ _ O
… _ _ O
… _ _ O
Register _ _ O
Renamer _ _ O
Instruction _ _ O
Queue _ _ O
Physical _ _ O
Register _ _ O
File _ _ O
Load _ _ O
Queue _ _ O
age _ _ O
addr _ _ O
done _ _ O
? _ _ O
3 _ _ O
0xdeadbeef _ _ O
Y _ _ O
… _ _ O
… _ _ O
… _ _ O
Committed _ _ O
In-order _ _ O
Instruction _ _ O
Scheduler _ _ O
Load _ _ O
/ _ _ O
Store _ _ O
Int _ _ O
ALU _ _ O
1 _ _ O
Int _ _ O
ALU _ _ O
2 _ _ O
Float _ _ O
ALU _ _ O
46 _ _ O

Real _ _ O
Life _ _ O
Superscalars _ _ O
47 _ _ O

The _ _ O
ARM _ _ O
Cortex-A8 _ _ O
architecture _ _ O
● _ _ O
The _ _ O
ARM _ _ O
Cortex-A8 _ _ O
is _ _ O
an _ _ O
in-order _ _ O
superscalar _ _ O
processor _ _ O
o _ _ O
Notice _ _ O
the _ _ O
use _ _ O
of _ _ O
the _ _ O
architectural _ _ O
register _ _ O
file _ _ O
FIGURE _ _ O
4.75 _ _ O
The _ _ O
A8 _ _ O
pipeline _ _ O
. _ _ O
The _ _ O
first _ _ O
three _ _ O
stages _ _ O
fetch _ _ O
instructions _ _ O
into _ _ O
a _ _ O
12-entry _ _ O
instruction _ _ O
fetch _ _ O
buffer _ _ O
. _ _ O
The _ _ O
Address _ _ O
Generation _ _ O
Unit _ _ O
( _ _ O
AGU _ _ O
) _ _ O
uses _ _ O
a _ _ O
Branch _ _ O
Target _ _ O
Buffer _ _ O
( _ _ O
BTB _ _ O
) _ _ O
, _ _ O
Global _ _ O
History _ _ O
Buffer _ _ O
( _ _ O
GHB _ _ O
) _ _ O
, _ _ O
and _ _ O
a _ _ O
Return _ _ O
Stack _ _ O
( _ _ O
RS _ _ O
) _ _ O
to _ _ O
predict _ _ O
branches _ _ O
to _ _ O
try _ _ O
to _ _ O
keep _ _ O
the _ _ O
fetch _ _ O
queue _ _ O
full _ _ O
. _ _ O
Instruction _ _ O
decode _ _ O
is _ _ O
five _ _ O
stages _ _ O
and _ _ O
instruction _ _ O
execution _ _ O
is _ _ O
six _ _ O
stages _ _ O
. _ _ O
48 _ _ O

The _ _ O
AMD _ _ O
Opteron _ _ O
X4 _ _ O
Microarchitecture _ _ O
● _ _ O
The _ _ O
AMD _ _ O
Opteron _ _ O
is _ _ O
an _ _ O
out-of-order _ _ O
superscalar _ _ O
processor _ _ O
o _ _ O
Commit _ _ O
unit _ _ O
oversees _ _ O
retiring _ _ O
instructions _ _ O
from _ _ O
operation _ _ O
queue _ _ O
Instruction _ _ O
Fetch _ _ O
and _ _ O
Decode _ _ O
Register _ _ O
read _ _ O
and _ _ O
Dispatch _ _ O
Execute _ _ O
Mem _ _ O
Write _ _ O
Back _ _ O
49 _ _ O

The _ _ O
Intel _ _ O
Core _ _ O
i7 _ _ O
architecture _ _ O
● _ _ O
The _ _ O
Intel _ _ O
Core _ _ O
i7 _ _ O
is _ _ O
another _ _ O
out-of-order _ _ O
superscalar _ _ O
processor _ _ O
FIGURE _ _ O
4.77 _ _ O
The _ _ O
Core _ _ O
i7 _ _ O
pipeline _ _ O
with _ _ O
memory _ _ O
components _ _ O
. _ _ O
The _ _ O
total _ _ O
pipeline _ _ O
depth _ _ O
is _ _ O
14 _ _ O
stages _ _ O
, _ _ O
with _ _ O
branch _ _ O
mispredictions _ _ O
costing _ _ O
17 _ _ O
clock _ _ O
cycles _ _ O
. _ _ O
This _ _ O
design _ _ O
can _ _ O
buffer _ _ O
48 _ _ O
loads _ _ O
and _ _ O
32 _ _ O
stores _ _ O
. _ _ O
It _ _ O
is _ _ O
a _ _ O
4-wide _ _ O
processor _ _ O
but _ _ O
has _ _ O
6 _ _ O
execution _ _ O
units _ _ O
of _ _ O
different _ _ O
types _ _ O
to _ _ O
reduce _ _ O
structural _ _ O
hazards _ _ O
. _ _ O
50 _ _ O

Intel _ _ O
Core _ _ O
i7 _ _ O
Performance _ _ O
● _ _ O
Ideal _ _ O
CPI _ _ O
= _ _ O
0.25 _ _ O
since _ _ O
this _ _ O
is _ _ O
a _ _ O
4-wide _ _ O
processor _ _ O
51 _ _ O

Intel _ _ O
Core _ _ O
i7 _ _ O
Impact _ _ O
of _ _ O
Branch _ _ O
Misprediction _ _ O
● _ _ O
Due _ _ O
to _ _ O
deep _ _ O
pipeline _ _ O
, _ _ O
tiny _ _ O
misprediction _ _ O
can _ _ O
have _ _ O
outsized _ _ O
impact _ _ O
52 _ _ O

Recap _ _ O
: _ _ O
VLIWs _ _ O
vs _ _ O
SuperScalars _ _ O
53 _ _ O

Ability _ _ O
to _ _ O
deal _ _ O
with _ _ O
hazards _ _ O
● _ _ O
Hazards _ _ O
prevent _ _ O
the _ _ O
full _ _ O
exploitation _ _ O
of _ _ O
ILP _ _ O
( _ _ O
Instruction _ _ O
Level _ _ O
Parallelism _ _ O
) _ _ O
● _ _ O
Which _ _ O
processor _ _ O
type _ _ O
is _ _ O
better _ _ O
at _ _ O
dealing _ _ O
with _ _ O
various _ _ O
hazards _ _ O
? _ _ O
VLIW _ _ O
Out-of-order _ _ O
SuperScalar _ _ O
Structural _ _ O
Hazards _ _ O
Data _ _ O
Hazards _ _ O
( _ _ O
Registers _ _ O
) _ _ O
Data _ _ O
Hazards _ _ O
( _ _ O
Memory _ _ O
) _ _ O
Control _ _ O
Hazards _ _ O
Instruction _ _ O
Window _ _ O
54 _ _ O

Ability _ _ O
to _ _ O
operate _ _ O
energy _ _ O
efficiently _ _ O
● _ _ O
We _ _ O
learned _ _ O
that _ _ O
performance _ _ O
and _ _ O
power _ _ O
are _ _ O
two _ _ O
sides _ _ O
of _ _ O
the _ _ O
same _ _ O
coin _ _ O
. _ _ O
● _ _ O
Which _ _ O
processor _ _ O
type _ _ O
has _ _ O
less _ _ O
power-hungry _ _ O
control _ _ O
structures _ _ O
? _ _ O
VLIW _ _ O
Out-of-order _ _ O
SuperScalar _ _ O
Big _ _ O
Register _ _ O
File _ _ O
Register _ _ O
Alias _ _ O
Table _ _ O
Instruction _ _ O
Queue _ _ O
Data _ _ O
Forwarding _ _ O
Wires _ _ O
55 _ _ O



