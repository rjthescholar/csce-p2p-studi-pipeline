unlabeled|cs1541|lec3.2_cache_design
-DOCSTART- -X- -X- O

Cache _ _ O
Design _ _ O
CS _ _ O
1541 _ _ O
Wonsun _ _ O
Ahn _ _ O

Oracle _ _ O
Cache _ _ O
● _ _ O
CPU _ _ O
Cycles _ _ O
= _ _ O
CPU _ _ O
Compute _ _ O
Cycles _ _ O
+ _ _ O
Memory _ _ O
Stall _ _ O
Cycles _ _ O
● _ _ O
Oracle _ _ O
cache _ _ O
: _ _ O
a _ _ O
cache _ _ O
that _ _ O
never _ _ O
misses _ _ O
o _ _ O
In _ _ O
effect _ _ O
, _ _ O
Memory _ _ O
Stall _ _ O
Cycles _ _ O
= _ _ O
= _ _ O
0 _ _ O
o _ _ O
Impossible _ _ O
, _ _ O
since _ _ O
even _ _ O
with _ _ O
infinite _ _ O
capacity _ _ O
, _ _ O
there _ _ O
are _ _ O
still _ _ O
cold _ _ O
misses _ _ O
o _ _ O
But _ _ O
useful _ _ O
to _ _ O
set _ _ O
bounds _ _ O
on _ _ O
performance _ _ O
● _ _ O
Real _ _ O
caches _ _ O
may _ _ O
approach _ _ O
performance _ _ O
of _ _ O
oracle _ _ O
caches _ _ O
but _ _ O
ca _ _ O
n’t _ _ O
exceed _ _ O
● _ _ O
What _ _ O
metric _ _ O
can _ _ O
we _ _ O
use _ _ O
to _ _ O
compare _ _ O
and _ _ O
evaluate _ _ O
real _ _ O
cache _ _ O
designs _ _ O
? _ _ O
o _ _ O
AMAT _ _ O
( _ _ O
Average _ _ O
Memory _ _ O
Access _ _ O
Time _ _ O
) _ _ O
2 _ _ O

AMAT _ _ O
( _ _ O
Average _ _ O
Memory _ _ O
Access _ _ O
Time _ _ O
) _ _ O
● _ _ O
AMAT _ _ O
( _ _ O
Average _ _ O
Memory _ _ O
Access _ _ O
Time _ _ O
) _ _ O
is _ _ O
defined _ _ O
as _ _ O
follows _ _ O
: _ _ O
o _ _ O
AMAT _ _ O
= _ _ O
hit _ _ O
time _ _ O
+ _ _ O
( _ _ O
miss _ _ O
rate _ _ O
× _ _ O
miss _ _ O
penalty _ _ O
) _ _ O
o _ _ O
Hit _ _ O
time _ _ O
: _ _ O
time _ _ O
to _ _ O
get _ _ O
the _ _ O
data _ _ O
from _ _ O
cache _ _ O
when _ _ O
we _ _ O
hit _ _ O
o _ _ O
Miss _ _ O
rate _ _ O
: _ _ O
what _ _ O
percentage _ _ O
of _ _ O
cache _ _ O
accesses _ _ O
we _ _ O
miss _ _ O
o _ _ O
Miss _ _ O
penalty _ _ O
: _ _ O
time _ _ O
to _ _ O
get _ _ O
the _ _ O
data _ _ O
from _ _ O
lower _ _ O
memory _ _ O
when _ _ O
we _ _ O
miss _ _ O
o _ _ O
Should _ _ O
n’t _ _ O
it _ _ O
be _ _ O
hit _ _ O
rate _ _ O
× _ _ O
hit _ _ O
time _ _ O
? _ _ O
▪ _ _ O
Hit _ _ O
time _ _ O
is _ _ O
incurred _ _ O
regardless _ _ O
of _ _ O
hit _ _ O
or _ _ O
miss _ _ O
▪ _ _ O
It _ _ O
is _ _ O
more _ _ O
aptly _ _ O
called _ _ O
access _ _ O
time _ _ O
( _ _ O
the _ _ O
time _ _ O
to _ _ O
search _ _ O
for _ _ O
the _ _ O
data _ _ O
) _ _ O
● _ _ O
Hit _ _ O
time _ _ O
, _ _ O
miss _ _ O
rate _ _ O
, _ _ O
miss _ _ O
penalty _ _ O
are _ _ O
the _ _ O
3 _ _ O
components _ _ O
of _ _ O
a _ _ O
cache _ _ O
design _ _ O
o _ _ O
When _ _ O
evaluating _ _ O
a _ _ O
cache _ _ O
design _ _ O
, _ _ O
we _ _ O
need _ _ O
to _ _ O
consider _ _ O
all _ _ O
3 _ _ O
o _ _ O
Cache _ _ O
designs _ _ O
trade-off _ _ O
one _ _ O
for _ _ O
the _ _ O
other _ _ O
▪ _ _ O
E.g. _ _ O
a _ _ O
large _ _ O
cache _ _ O
trade-offs _ _ O
longer _ _ O
hit _ _ O
time _ _ O
for _ _ O
smaller _ _ O
miss _ _ O
rate _ _ O
▪ _ _ O
Whether _ _ O
trade-off _ _ O
is _ _ O
beneficial _ _ O
depends _ _ O
on _ _ O
the _ _ O
resulting _ _ O
AMAT _ _ O
3 _ _ O

Cache _ _ O
Design _ _ O
Parameter _ _ O
1 _ _ O
: _ _ O
Number _ _ O
of _ _ O
Levels _ _ O
4 _ _ O

AMAT _ _ O
for _ _ O
Multi-level _ _ O
Caches _ _ O
● _ _ O
For _ _ O
a _ _ O
single-level _ _ O
cache _ _ O
( _ _ O
L1 _ _ O
cache _ _ O
) _ _ O
: _ _ O
o _ _ O
AMAT _ _ O
( _ _ O
L1 _ _ O
) _ _ O
= _ _ O
L1 _ _ O
hit _ _ O
time _ _ O
+ _ _ O
( _ _ O
L1 _ _ O
miss _ _ O
rate _ _ O
× _ _ O
DRAM _ _ O
access _ _ O
time _ _ O
) _ _ O
Miss _ _ O
! _ _ O
Hit _ _ O
! _ _ O
L1 _ _ O
Cache _ _ O
Hit _ _ O
! _ _ O
DRAM _ _ O
Memory _ _ O
L1 _ _ O
hit _ _ O
time _ _ O
L1 _ _ O
miss _ _ O
rate _ _ O
× _ _ O
DRAM _ _ O
access _ _ O
time _ _ O
● _ _ O
For _ _ O
a _ _ O
multi-level _ _ O
cache _ _ O
( _ _ O
L1 _ _ O
, _ _ O
L2 _ _ O
caches _ _ O
) _ _ O
: _ _ O
o _ _ O
AMAT _ _ O
( _ _ O
L2 _ _ O
) _ _ O
= _ _ O
L1 _ _ O
hit _ _ O
time _ _ O
+ _ _ O
( _ _ O
L1 _ _ O
miss _ _ O
rate _ _ O
× _ _ O
L1 _ _ O
miss _ _ O
penalty _ _ O
) _ _ O
o _ _ O
L1 _ _ O
miss _ _ O
penalty _ _ O
= _ _ O
L2 _ _ O
hit _ _ O
time _ _ O
+ _ _ O
( _ _ O
L2 _ _ O
miss _ _ O
rate _ _ O
× _ _ O
DRAM _ _ O
access _ _ O
time _ _ O
) _ _ O
o _ _ O
AMAT _ _ O
( _ _ O
L2 _ _ O
) _ _ O
= _ _ O
L1 _ _ O
hit _ _ O
time _ _ O
+ _ _ O
L1 _ _ O
miss _ _ O
rate _ _ O
× _ _ O
L2 _ _ O
hit _ _ O
time _ _ O
+ _ _ O
L1 _ _ O
miss _ _ O
rate _ _ O
× _ _ O
L2 _ _ O
miss _ _ O
rate _ _ O
× _ _ O
DRAM _ _ O
access _ _ O
time _ _ O
Miss _ _ O
! _ _ O
Miss _ _ O
! _ _ O
Hit _ _ O
! _ _ O
L1 _ _ O
Cache _ _ O
L1 _ _ O
hit _ _ O
time _ _ O
Miss _ _ O
! _ _ O
L2 _ _ O
Cache _ _ O
L1 _ _ O
miss _ _ O
rate _ _ O
× _ _ O
L2 _ _ O
hit _ _ O
time _ _ O
Hit _ _ O
! _ _ O
Hit _ _ O
! _ _ O
DRAM _ _ O
Memory _ _ O
L1 _ _ O
miss _ _ O
rate _ _ O
× _ _ O
L2 _ _ O
miss _ _ O
rate _ _ O
× _ _ O
DRAM _ _ O
access _ _ O
time _ _ O
5 _ _ O

AMAT _ _ O
for _ _ O
Multi-level _ _ O
Caches _ _ O
● _ _ O
For _ _ O
L2 _ _ O
Cache _ _ O
to _ _ O
be _ _ O
worth _ _ O
it _ _ O
, _ _ O
AMAT _ _ O
( _ _ O
L1 _ _ O
) _ _ O
> _ _ O
AMAT _ _ O
( _ _ O
L2 _ _ O
) _ _ O
needs _ _ O
to _ _ O
be _ _ O
true _ _ O
. _ _ O
L1 _ _ O
Cache _ _ O
DRAM _ _ O
Memory _ _ O
L1 _ _ O
hit _ _ O
time _ _ O
L1 _ _ O
miss _ _ O
rate _ _ O
× _ _ O
DRAM _ _ O
access _ _ O
time _ _ O
> _ _ O
? _ _ O
L1 _ _ O
Cache _ _ O
L1 _ _ O
hit _ _ O
time _ _ O
L2 _ _ O
Cache _ _ O
L1 _ _ O
miss _ _ O
rate _ _ O
× _ _ O
L2 _ _ O
hit _ _ O
time _ _ O
DRAM _ _ O
Memory _ _ O
L1 _ _ O
miss _ _ O
rate _ _ O
× _ _ O
L2 _ _ O
miss _ _ O
rate _ _ O
× _ _ O
DRAM _ _ O
access _ _ O
time _ _ O
● _ _ O
AMAT _ _ O
( _ _ O
L1 _ _ O
) _ _ O
– _ _ O
AMAT _ _ O
( _ _ O
L2 _ _ O
) _ _ O
= _ _ O
( _ _ O
L1 _ _ O
miss _ _ O
rate _ _ O
– _ _ O
L1 _ _ O
miss _ _ O
rate _ _ O
× _ _ O
L2 _ _ O
miss _ _ O
rate _ _ O
) _ _ O
× _ _ O
DRAM _ _ O
access _ _ O
time _ _ O
– _ _ O
L1 _ _ O
miss _ _ O
rate _ _ O
× _ _ O
L2 _ _ O
hit _ _ O
time _ _ O
= _ _ O
L1 _ _ O
miss _ _ O
rate _ _ O
× _ _ O
( _ _ O
( _ _ O
1 _ _ O
– _ _ O
L2 _ _ O
miss _ _ O
rate _ _ O
) _ _ O
× _ _ O
DRAM _ _ O
access _ _ O
time _ _ O
– _ _ O
L2 _ _ O
hit _ _ O
time _ _ O
) _ _ O
> _ _ O
0 _ _ O
→ _ _ O
( _ _ O
1 _ _ O
– _ _ O
L2 _ _ O
miss _ _ O
rate _ _ O
) _ _ O
× _ _ O
DRAM _ _ O
access _ _ O
time _ _ O
> _ _ O
L2 _ _ O
hit _ _ O
time _ _ O
→ _ _ O
Benefit _ _ O
from _ _ O
reduced _ _ O
DRAM _ _ O
accesses _ _ O
> _ _ O
Penalty _ _ O
from _ _ O
L2 _ _ O
accesses _ _ O
6 _ _ O

AMAT _ _ O
for _ _ O
Multi-level _ _ O
Caches _ _ O
● _ _ O
( _ _ O
1 _ _ O
– _ _ O
L2 _ _ O
miss _ _ O
rate _ _ O
) _ _ O
× _ _ O
DRAM _ _ O
access _ _ O
time _ _ O
> _ _ O
L2 _ _ O
hit _ _ O
time _ _ O
o _ _ O
Let _ _ O
’s _ _ O
assume _ _ O
L2 _ _ O
miss _ _ O
rate _ _ O
= _ _ O
0.9 _ _ O
and _ _ O
DRAM _ _ O
access _ _ O
time _ _ O
= _ _ O
100 _ _ O
cycles _ _ O
: _ _ O
( _ _ O
1 _ _ O
− _ _ O
0.9 _ _ O
) _ _ O
× _ _ O
100 _ _ O
> _ _ O
L2 _ _ O
hit _ _ O
time _ _ O
L2 _ _ O
hit _ _ O
time _ _ O
< _ _ O
10 _ _ O
o _ _ O
If _ _ O
L2 _ _ O
hit _ _ O
time _ _ O
can _ _ O
be _ _ O
kept _ _ O
below _ _ O
10 _ _ O
cycles _ _ O
, _ _ O
worth _ _ O
it _ _ O
to _ _ O
install _ _ O
L2 _ _ O
cache _ _ O
● _ _ O
So _ _ O
, _ _ O
should _ _ O
we _ _ O
install _ _ O
the _ _ O
L2 _ _ O
cache _ _ O
, _ _ O
or _ _ O
not _ _ O
? _ _ O
That _ _ O
depends _ _ O
on _ _ O
the _ _ O
program _ _ O
! _ _ O
o _ _ O
Locality _ _ O
in _ _ O
program _ _ O
determines _ _ O
cache _ _ O
capacity _ _ O
required _ _ O
for _ _ O
0.9 _ _ O
miss _ _ O
rate _ _ O
o _ _ O
If _ _ O
we _ _ O
can _ _ O
design _ _ O
a _ _ O
cache _ _ O
with _ _ O
hit _ _ O
time _ _ O
< _ _ O
10 _ _ O
for _ _ O
that _ _ O
capacity _ _ O
, _ _ O
go _ _ O
for _ _ O
it _ _ O
● _ _ O
Again _ _ O
, _ _ O
shows _ _ O
design _ _ O
decisions _ _ O
are _ _ O
heavily _ _ O
impacted _ _ O
by _ _ O
needs _ _ O
of _ _ O
software _ _ O
7 _ _ O

Cache _ _ O
Design _ _ O
Parameter _ _ O
2 _ _ O
: _ _ O
Cache _ _ O
Size _ _ O
8 _ _ O

Impact _ _ O
of _ _ O
Cache _ _ O
Size _ _ O
( _ _ O
a.k.a _ _ O
. _ _ O
Capacity _ _ O
) _ _ O
on _ _ O
AMAT _ _ O
● _ _ O
AMAT _ _ O
= _ _ O
hit _ _ O
time _ _ O
+ _ _ O
( _ _ O
miss _ _ O
rate _ _ O
× _ _ O
miss _ _ O
penalty _ _ O
) _ _ O
● _ _ O
Larger _ _ O
caches _ _ O
are _ _ O
good _ _ O
for _ _ O
miss _ _ O
rates _ _ O
o _ _ O
More _ _ O
capacity _ _ O
means _ _ O
you _ _ O
can _ _ O
keep _ _ O
around _ _ O
cache _ _ O
blocks _ _ O
for _ _ O
longer _ _ O
o _ _ O
Means _ _ O
you _ _ O
can _ _ O
leverage _ _ O
more _ _ O
of _ _ O
the _ _ O
pre-existing _ _ O
temporal _ _ O
locality _ _ O
o _ _ O
If _ _ O
entire _ _ O
working _ _ O
set _ _ O
can _ _ O
fit _ _ O
into _ _ O
the _ _ O
cache _ _ O
, _ _ O
no _ _ O
capacity _ _ O
misses _ _ O
! _ _ O
● _ _ O
But _ _ O
larger _ _ O
caches _ _ O
are _ _ O
bad _ _ O
for _ _ O
hit _ _ O
times _ _ O
o _ _ O
Longer _ _ O
wires _ _ O
and _ _ O
larger _ _ O
decoders _ _ O
mean _ _ O
longer _ _ O
access _ _ O
time _ _ O
● _ _ O
Exactly _ _ O
why _ _ O
there _ _ O
are _ _ O
multiple _ _ O
levels _ _ O
of _ _ O
caches _ _ O
o _ _ O
Frequently _ _ O
accessed _ _ O
data _ _ O
where _ _ O
hit _ _ O
time _ _ O
is _ _ O
important _ _ O
stays _ _ O
in _ _ O
L1 _ _ O
cache _ _ O
o _ _ O
Rarely _ _ O
accessed _ _ O
data _ _ O
which _ _ O
is _ _ O
part _ _ O
of _ _ O
a _ _ O
larger _ _ O
working _ _ O
set _ _ O
stays _ _ O
in _ _ O
L3 _ _ O
9 _ _ O

What _ _ O
cache _ _ O
size _ _ O
( _ _ O
s _ _ O
) _ _ O
should _ _ O
I _ _ O
choose _ _ O
? _ _ O
● _ _ O
How _ _ O
should _ _ O
each _ _ O
cache _ _ O
level _ _ O
be _ _ O
sized _ _ O
? _ _ O
● _ _ O
That _ _ O
depends _ _ O
on _ _ O
the _ _ O
application _ _ O
o _ _ O
Working _ _ O
set _ _ O
sizes _ _ O
of _ _ O
the _ _ O
application _ _ O
at _ _ O
various _ _ O
levels _ _ O
. _ _ O
E.g. _ _ O
: _ _ O
▪ _ _ O
Small _ _ O
set _ _ O
of _ _ O
data _ _ O
accessed _ _ O
very _ _ O
frequently _ _ O
( _ _ O
typically _ _ O
stack _ _ O
variables _ _ O
) _ _ O
▪ _ _ O
Medium _ _ O
set _ _ O
of _ _ O
data _ _ O
accessed _ _ O
often _ _ O
( _ _ O
currently _ _ O
accessed _ _ O
data _ _ O
structure _ _ O
) _ _ O
▪ _ _ O
Large _ _ O
set _ _ O
of _ _ O
data _ _ O
accessed _ _ O
rarely _ _ O
( _ _ O
rest _ _ O
of _ _ O
program _ _ O
data _ _ O
) _ _ O
o _ _ O
Ideally _ _ O
, _ _ O
cache _ _ O
levels _ _ O
and _ _ O
sizes _ _ O
would _ _ O
reflect _ _ O
working _ _ O
set _ _ O
sizes _ _ O
. _ _ O
● _ _ O
Simulate _ _ O
multiple _ _ O
cache _ _ O
levels _ _ O
and _ _ O
sizes _ _ O
and _ _ O
choose _ _ O
one _ _ O
with _ _ O
lowest _ _ O
AMAT _ _ O
o _ _ O
Simulate _ _ O
on _ _ O
the _ _ O
applications _ _ O
that _ _ O
you _ _ O
care _ _ O
about _ _ O
o _ _ O
In _ _ O
the _ _ O
end _ _ O
, _ _ O
it _ _ O
must _ _ O
be _ _ O
a _ _ O
compromise _ _ O
( _ _ O
giving _ _ O
best _ _ O
average _ _ O
AMAT _ _ O
) _ _ O
10 _ _ O

Cache _ _ O
Design _ _ O
Parameter _ _ O
3 _ _ O
: _ _ O
Cache _ _ O
Block _ _ O
Size _ _ O
11 _ _ O

Impact _ _ O
of _ _ O
Cache _ _ O
Block _ _ O
Size _ _ O
on _ _ O
AMAT _ _ O
● _ _ O
AMAT _ _ O
= _ _ O
hit _ _ O
time _ _ O
+ _ _ O
( _ _ O
miss _ _ O
rate _ _ O
× _ _ O
miss _ _ O
penalty _ _ O
) _ _ O
● _ _ O
Cache _ _ O
block _ _ O
( _ _ O
a.k.a _ _ O
. _ _ O
cache _ _ O
line _ _ O
) _ _ O
o _ _ O
Unit _ _ O
of _ _ O
transfer _ _ O
for _ _ O
cache _ _ O
data _ _ O
( _ _ O
typically _ _ O
32 _ _ O
or _ _ O
64 _ _ O
bytes _ _ O
) _ _ O
o _ _ O
If _ _ O
program _ _ O
accesses _ _ O
any _ _ O
byte _ _ O
in _ _ O
cache _ _ O
block _ _ O
, _ _ O
entire _ _ O
block _ _ O
is _ _ O
brought _ _ O
in _ _ O
o _ _ O
Each _ _ O
level _ _ O
of _ _ O
a _ _ O
multi-level _ _ O
cache _ _ O
can _ _ O
have _ _ O
a _ _ O
different _ _ O
cache _ _ O
block _ _ O
size _ _ O
● _ _ O
Impact _ _ O
of _ _ O
larger _ _ O
cache _ _ O
block _ _ O
size _ _ O
on _ _ O
miss _ _ O
rate _ _ O
o _ _ O
Maybe _ _ O
smaller _ _ O
miss _ _ O
rate _ _ O
due _ _ O
to _ _ O
better _ _ O
leveraging _ _ O
of _ _ O
spatial _ _ O
locality _ _ O
o _ _ O
Maybe _ _ O
bigger _ _ O
miss _ _ O
rate _ _ O
due _ _ O
to _ _ O
worse _ _ O
leveraging _ _ O
of _ _ O
temporal _ _ O
locality _ _ O
( _ _ O
Bringing _ _ O
in _ _ O
more _ _ O
data _ _ O
at _ _ O
a _ _ O
time _ _ O
may _ _ O
push _ _ O
out _ _ O
other _ _ O
useful _ _ O
data _ _ O
) _ _ O
● _ _ O
Impact _ _ O
of _ _ O
larger _ _ O
cache _ _ O
block _ _ O
size _ _ O
on _ _ O
miss _ _ O
penalty _ _ O
o _ _ O
With _ _ O
a _ _ O
limited _ _ O
bus _ _ O
width _ _ O
, _ _ O
may _ _ O
take _ _ O
multiple _ _ O
transfers _ _ O
for _ _ O
a _ _ O
large _ _ O
block _ _ O
o _ _ O
E.g. _ _ O
DDR _ _ O
4 _ _ O
DRAM _ _ O
bus _ _ O
width _ _ O
is _ _ O
8 _ _ O
bytes _ _ O
, _ _ O
so _ _ O
8 _ _ O
transfers _ _ O
for _ _ O
64-byte _ _ O
block _ _ O
o _ _ O
Could _ _ O
lead _ _ O
to _ _ O
increase _ _ O
in _ _ O
miss _ _ O
penalty _ _ O
12 _ _ O

Cache _ _ O
Block _ _ O
Size _ _ O
and _ _ O
Miss _ _ O
Penalty _ _ O
● _ _ O
On _ _ O
a _ _ O
miss _ _ O
, _ _ O
the _ _ O
data _ _ O
must _ _ O
come _ _ O
from _ _ O
lower _ _ O
memory _ _ O
● _ _ O
Besides _ _ O
memory _ _ O
access _ _ O
time _ _ O
, _ _ O
there _ _ O
’s _ _ O
transfer _ _ O
time _ _ O
● _ _ O
What _ _ O
things _ _ O
impact _ _ O
how _ _ O
long _ _ O
that _ _ O
takes _ _ O
? _ _ O
o _ _ O
The _ _ O
size _ _ O
of _ _ O
the _ _ O
cache _ _ O
block _ _ O
( _ _ O
words _ _ O
/ _ _ O
block _ _ O
) _ _ O
o _ _ O
The _ _ O
width _ _ O
of _ _ O
the _ _ O
memory _ _ O
bus _ _ O
( _ _ O
words _ _ O
/ _ _ O
cycle _ _ O
) _ _ O
o _ _ O
The _ _ O
speed _ _ O
of _ _ O
the _ _ O
memory _ _ O
bus _ _ O
( _ _ O
cycles _ _ O
/ _ _ O
second _ _ O
) _ _ O
● _ _ O
So _ _ O
the _ _ O
transfer _ _ O
time _ _ O
will _ _ O
be _ _ O
: _ _ O
seconds _ _ O
𝟏 _ _ O
words _ _ O
= _ _ O
× _ _ O
cycles _ _ O
words _ _ O
block _ _ O
block _ _ O
× _ _ O
second _ _ O
cycle _ _ O
block _ _ O
size _ _ O
bus _ _ O
speed _ _ O
Cache _ _ O
Memory _ _ O
bus _ _ O
width _ _ O
13 _ _ O

What _ _ O
cache _ _ O
block _ _ O
size _ _ O
should _ _ O
I _ _ O
choose _ _ O
? _ _ O
● _ _ O
Again _ _ O
, _ _ O
that _ _ O
depends _ _ O
on _ _ O
the _ _ O
application _ _ O
o _ _ O
How _ _ O
much _ _ O
spatial _ _ O
and _ _ O
temporal _ _ O
locality _ _ O
the _ _ O
application _ _ O
has _ _ O
● _ _ O
Simulate _ _ O
multiple _ _ O
cache _ _ O
block _ _ O
sizes _ _ O
and _ _ O
choose _ _ O
one _ _ O
with _ _ O
lowest _ _ O
AMAT _ _ O
o _ _ O
Simulate _ _ O
on _ _ O
benchmarks _ _ O
that _ _ O
you _ _ O
care _ _ O
about _ _ O
and _ _ O
choose _ _ O
best _ _ O
average _ _ O
o _ _ O
You _ _ O
may _ _ O
have _ _ O
to _ _ O
simulate _ _ O
different _ _ O
combinations _ _ O
for _ _ O
multi-level _ _ O
caches _ _ O
14 _ _ O

Cache _ _ O
Design _ _ O
Parameter _ _ O
4 _ _ O
: _ _ O
Cache _ _ O
Associativity _ _ O
15 _ _ O

Mapping _ _ O
blocks _ _ O
from _ _ O
memory _ _ O
to _ _ O
caches _ _ O
● _ _ O
Cache _ _ O
size _ _ O
is _ _ O
much _ _ O
smaller _ _ O
compared _ _ O
to _ _ O
the _ _ O
entire _ _ O
memory _ _ O
space _ _ O
o _ _ O
Must _ _ O
map _ _ O
all _ _ O
the _ _ O
blocks _ _ O
in _ _ O
memory _ _ O
to _ _ O
limited _ _ O
CPU _ _ O
cache _ _ O
● _ _ O
Does _ _ O
this _ _ O
sound _ _ O
familiar _ _ O
? _ _ O
Remember _ _ O
branch _ _ O
prediction _ _ O
? _ _ O
o _ _ O
Had _ _ O
similar _ _ O
problem _ _ O
of _ _ O
mapping _ _ O
PCs _ _ O
to _ _ O
a _ _ O
limited _ _ O
BHT _ _ O
o _ _ O
What _ _ O
did _ _ O
we _ _ O
do _ _ O
then _ _ O
? _ _ O
▪ _ _ O
We _ _ O
hashed _ _ O
PC _ _ O
to _ _ O
an _ _ O
entry _ _ O
in _ _ O
the _ _ O
BHT _ _ O
▪ _ _ O
On _ _ O
a _ _ O
hash _ _ O
conflict _ _ O
, _ _ O
we _ _ O
replaced _ _ O
old _ _ O
entry _ _ O
with _ _ O
more _ _ O
recent _ _ O
one _ _ O
● _ _ O
We _ _ O
will _ _ O
use _ _ O
a _ _ O
similar _ _ O
idea _ _ O
with _ _ O
caches _ _ O
o _ _ O
Hash _ _ O
memory _ _ O
addresses _ _ O
to _ _ O
entries _ _ O
in _ _ O
cache _ _ O
o _ _ O
On _ _ O
a _ _ O
conflict _ _ O
: _ _ O
▪ _ _ O
Replace _ _ O
old _ _ O
cache _ _ O
block _ _ O
with _ _ O
more _ _ O
recent _ _ O
one _ _ O
▪ _ _ O
Or _ _ O
, _ _ O
chain _ _ O
multiple _ _ O
cache _ _ O
blocks _ _ O
on _ _ O
to _ _ O
same _ _ O
hash _ _ O
entry _ _ O
16 _ _ O

Impact _ _ O
of _ _ O
Cache _ _ O
Associativity _ _ O
on _ _ O
AMAT _ _ O
● _ _ O
Depending _ _ O
on _ _ O
hash _ _ O
function _ _ O
and _ _ O
chaining _ _ O
, _ _ O
a _ _ O
cache _ _ O
is _ _ O
either _ _ O
: _ _ O
o _ _ O
Direct-mapped _ _ O
( _ _ O
no _ _ O
chaining _ _ O
allowed _ _ O
) _ _ O
o _ _ O
Set-associative _ _ O
( _ _ O
some _ _ O
chaining _ _ O
allowed _ _ O
) _ _ O
o _ _ O
Fully-associative _ _ O
( _ _ O
limitless _ _ O
chaining _ _ O
allowed _ _ O
) _ _ O
● _ _ O
Impact _ _ O
of _ _ O
more _ _ O
associativity _ _ O
on _ _ O
miss _ _ O
rate _ _ O
o _ _ O
Smaller _ _ O
miss _ _ O
rate _ _ O
due _ _ O
to _ _ O
less _ _ O
misses _ _ O
due _ _ O
to _ _ O
hash _ _ O
conflicts _ _ O
o _ _ O
Misses _ _ O
due _ _ O
to _ _ O
hash _ _ O
conflicts _ _ O
are _ _ O
called _ _ O
conflict _ _ O
misses _ _ O
▪ _ _ O
A _ _ O
third _ _ O
category _ _ O
of _ _ O
misses _ _ O
besides _ _ O
cold _ _ O
and _ _ O
capacity _ _ O
misses _ _ O
● _ _ O
Impact _ _ O
of _ _ O
more _ _ O
associativity _ _ O
on _ _ O
hit _ _ O
time _ _ O
o _ _ O
Longer _ _ O
hit _ _ O
time _ _ O
due _ _ O
to _ _ O
need _ _ O
to _ _ O
search _ _ O
through _ _ O
long _ _ O
chain _ _ O
17 _ _ O

Direct-mapped _ _ O
Caches _ _ O
18 _ _ O

Assumptions _ _ O
● _ _ O
Let _ _ O
’s _ _ O
assume _ _ O
for _ _ O
the _ _ O
sake _ _ O
of _ _ O
concise _ _ O
explanations _ _ O
o _ _ O
8-bit _ _ O
memory _ _ O
addresses _ _ O
o _ _ O
4-byte _ _ O
( _ _ O
one _ _ O
word _ _ O
) _ _ O
cache _ _ O
block _ _ O
sizes _ _ O
● _ _ O
Of _ _ O
course _ _ O
these _ _ O
are _ _ O
not _ _ O
typical _ _ O
values _ _ O
. _ _ O
Typical _ _ O
values _ _ O
are _ _ O
: _ _ O
o _ _ O
32-bit _ _ O
or _ _ O
64-bit _ _ O
memory _ _ O
addresses _ _ O
( _ _ O
32-bit _ _ O
or _ _ O
64-bit _ _ O
CPU _ _ O
) _ _ O
o _ _ O
32-byte _ _ O
or _ _ O
64-byte _ _ O
cache _ _ O
blocks _ _ O
sizes _ _ O
( _ _ O
for _ _ O
spatial _ _ O
locality _ _ O
) _ _ O
o _ _ O
But _ _ O
too _ _ O
many _ _ O
bits _ _ O
in _ _ O
addresses _ _ O
are _ _ O
going _ _ O
to _ _ O
give _ _ O
you _ _ O
a _ _ O
headache _ _ O
● _ _ O
According _ _ O
to _ _ O
our _ _ O
assumption _ _ O
, _ _ O
here _ _ O
’s _ _ O
a _ _ O
breakdown _ _ O
of _ _ O
address _ _ O
bits _ _ O
Upper _ _ O
6 _ _ O
bits _ _ O
: _ _ O
Offset _ _ O
of _ _ O
cache _ _ O
block _ _ O
within _ _ O
main _ _ O
memory _ _ O
Lower _ _ O
2 _ _ O
bits _ _ O
: _ _ O
Byte _ _ O
offset _ _ O
within _ _ O
4-byte _ _ O
cache _ _ O
block _ _ O
o _ _ O
When _ _ O
I _ _ O
refer _ _ O
to _ _ O
addresses _ _ O
, _ _ O
I _ _ O
will _ _ O
sometimes _ _ O
omit _ _ O
the _ _ O
lower _ _ O
2 _ _ O
bits _ _ O
( _ _ O
When _ _ O
we _ _ O
talk _ _ O
about _ _ O
cache _ _ O
block _ _ O
transfer _ _ O
, _ _ O
that _ _ O
part _ _ O
is _ _ O
irrelevant _ _ O
) _ _ O
19 _ _ O

Direct-mapped _ _ O
Cache _ _ O
Hash _ _ O
Function _ _ O
● _ _ O
Each _ _ O
memory _ _ O
address _ _ O
maps _ _ O
to _ _ O
one _ _ O
cache _ _ O
block _ _ O
● _ _ O
No _ _ O
chaining _ _ O
allowed _ _ O
so _ _ O
no _ _ O
need _ _ O
to _ _ O
search _ _ O
● _ _ O
Implementing _ _ O
this _ _ O
is _ _ O
relatively _ _ O
simple _ _ O
Hash _ _ O
function _ _ O
: _ _ O
For _ _ O
this _ _ O
8-entry _ _ O
cache _ _ O
, _ _ O
to _ _ O
find _ _ O
cache _ _ O
block _ _ O
index _ _ O
, _ _ O
take _ _ O
the _ _ O
lowest _ _ O
3 _ _ O
cache _ _ O
block _ _ O
offset _ _ O
bits _ _ O
in _ _ O
address _ _ O
. _ _ O
But _ _ O
if _ _ O
our _ _ O
program _ _ O
accesses _ _ O
001000 _ _ O
, _ _ O
then _ _ O
000000 _ _ O
, _ _ O
how _ _ O
do _ _ O
we _ _ O
tell _ _ O
them _ _ O
apart _ _ O
? _ _ O
Tags _ _ O
! _ _ O
Cache _ _ O
000 _ _ O
001 _ _ O
010 _ _ O
011 _ _ O
100 _ _ O
101 _ _ O
110 _ _ O
111 _ _ O
Memory _ _ O
000000 _ _ O
000001 _ _ O
000010 _ _ O
000011 _ _ O
000100 _ _ O
000101 _ _ O
000110 _ _ O
000111 _ _ O
001000 _ _ O
001001 _ _ O
001010 _ _ O
001011 _ _ O
001100 _ _ O
001101 _ _ O
001110 _ _ O
001111 _ _ O
20 _ _ O

Tags _ _ O
help _ _ O
differentiate _ _ O
between _ _ O
conflicting _ _ O
blocks _ _ O
Tag _ _ O
: _ _ O
part _ _ O
of _ _ O
address _ _ O
excluding _ _ O
cache _ _ O
block _ _ O
index _ _ O
● _ _ O
On _ _ O
allocation _ _ O
of _ _ O
001000 _ _ O
: _ _ O
tag _ _ O
= _ _ O
001 _ _ O
Tag _ _ O
000 _ _ O
001 _ _ O
010 _ _ O
011 _ _ O
100 _ _ O
101 _ _ O
110 _ _ O
111 _ _ O
001 _ _ O
Cache _ _ O
Data _ _ O
Memory _ _ O
000000 _ _ O
000001 _ _ O
000010 _ _ O
000011 _ _ O
000100 _ _ O
000101 _ _ O
000110 _ _ O
000111 _ _ O
001000 _ _ O
001001 _ _ O
001010 _ _ O
001011 _ _ O
001100 _ _ O
001101 _ _ O
001110 _ _ O
001111 _ _ O
21 _ _ O

Tags _ _ O
help _ _ O
differentiate _ _ O
between _ _ O
conflicting _ _ O
blocks _ _ O
Tag _ _ O
: _ _ O
part _ _ O
of _ _ O
address _ _ O
excluding _ _ O
cache _ _ O
block _ _ O
index _ _ O
● _ _ O
On _ _ O
allocation _ _ O
of _ _ O
001000 _ _ O
: _ _ O
tag _ _ O
= _ _ O
001 _ _ O
● _ _ O
On _ _ O
allocation _ _ O
of _ _ O
000000 _ _ O
: _ _ O
tag _ _ O
= _ _ O
000 _ _ O
Tag _ _ O
000 _ _ O
001 _ _ O
010 _ _ O
011 _ _ O
100 _ _ O
101 _ _ O
110 _ _ O
111 _ _ O
000 _ _ O
Cache _ _ O
Data _ _ O
Memory _ _ O
000000 _ _ O
000001 _ _ O
000010 _ _ O
000011 _ _ O
000100 _ _ O
000101 _ _ O
000110 _ _ O
000111 _ _ O
001000 _ _ O
001001 _ _ O
001010 _ _ O
001011 _ _ O
001100 _ _ O
001101 _ _ O
001110 _ _ O
001111 _ _ O
22 _ _ O

Valid _ _ O
bit _ _ O
indicates _ _ O
that _ _ O
block _ _ O
contains _ _ O
valid _ _ O
data _ _ O
Valid _ _ O
bit _ _ O
: _ _ O
indicates _ _ O
that _ _ O
the _ _ O
block _ _ O
is _ _ O
valid _ _ O
● _ _ O
Set _ _ O
to _ _ O
0 _ _ O
initially _ _ O
when _ _ O
cache _ _ O
block _ _ O
is _ _ O
empty _ _ O
● _ _ O
Set _ _ O
to _ _ O
1 _ _ O
when _ _ O
a _ _ O
cache _ _ O
block _ _ O
is _ _ O
allocated _ _ O
V _ _ O
Tag _ _ O
000 _ _ O
1 _ _ O
000 _ _ O
Cache _ _ O
Data _ _ O
001 _ _ O
0 _ _ O
010 _ _ O
0 _ _ O
011 _ _ O
0 _ _ O
100 _ _ O
0 _ _ O
101 _ _ O
0 _ _ O
110 _ _ O
0 _ _ O
111 _ _ O
0 _ _ O
● _ _ O
Cache _ _ O
hit _ _ O
: _ _ O
V _ _ O
= _ _ O
= _ _ O
1 _ _ O
& _ _ O
& _ _ O
CacheBlock.Tag _ _ O
= _ _ O
= _ _ O
MemoryBlock.Tag _ _ O
Memory _ _ O
000000 _ _ O
000001 _ _ O
000010 _ _ O
000011 _ _ O
000100 _ _ O
000101 _ _ O
000110 _ _ O
000111 _ _ O
001000 _ _ O
001001 _ _ O
001010 _ _ O
001011 _ _ O
001100 _ _ O
001101 _ _ O
001110 _ _ O
001111 _ _ O
23 _ _ O

Quiz _ _ O
: _ _ O
Address _ _ O
Bits _ _ O
Breakdown _ _ O
● _ _ O
Now _ _ O
with _ _ O
the _ _ O
following _ _ O
parameters _ _ O
: _ _ O
o _ _ O
8-bit _ _ O
memory _ _ O
addresses _ _ O
o _ _ O
4-byte _ _ O
cache _ _ O
block _ _ O
sizes _ _ O
o _ _ O
8-block _ _ O
cache _ _ O
● _ _ O
How _ _ O
would _ _ O
we _ _ O
breakdown _ _ O
the _ _ O
memory _ _ O
address _ _ O
bits _ _ O
? _ _ O
Tag _ _ O
Block _ _ O
index _ _ O
Offset _ _ O
within _ _ O
cache _ _ O
block _ _ O
o _ _ O
First _ _ O
, _ _ O
the _ _ O
correct _ _ O
cache _ _ O
block _ _ O
is _ _ O
accessed _ _ O
using _ _ O
the _ _ O
block _ _ O
index _ _ O
o _ _ O
Then _ _ O
, _ _ O
the _ _ O
tag _ _ O
is _ _ O
compared _ _ O
to _ _ O
the _ _ O
cache _ _ O
block _ _ O
tag _ _ O
o _ _ O
If _ _ O
matched _ _ O
, _ _ O
offset _ _ O
is _ _ O
used _ _ O
to _ _ O
access _ _ O
specific _ _ O
byte _ _ O
within _ _ O
block _ _ O
24 _ _ O

Example _ _ O
: _ _ O
A _ _ O
Direct-mapped _ _ O
Cache _ _ O
● _ _ O
When _ _ O
the _ _ O
program _ _ O
first _ _ O
starts _ _ O
, _ _ O
we _ _ O
set _ _ O
all _ _ O
the _ _ O
valid _ _ O
bits _ _ O
to _ _ O
0 _ _ O
. _ _ O
o _ _ O
Signals _ _ O
all _ _ O
cache _ _ O
lines _ _ O
are _ _ O
empty _ _ O
V _ _ O
Tag _ _ O
Data _ _ O
● _ _ O
Now _ _ O
let _ _ O
's _ _ O
try _ _ O
a _ _ O
sequence _ _ O
of _ _ O
reads _ _ O
... _ _ O
000 _ _ O
0 _ _ O
1 _ _ O
000 _ _ O
something _ _ O
010 _ _ O
do _ _ O
these _ _ O
hit _ _ O
or _ _ O
miss _ _ O
? _ _ O
How _ _ O
do _ _ O
the _ _ O
001 _ _ O
0 _ _ O
cache _ _ O
contents _ _ O
change _ _ O
? _ _ O
000000 _ _ O
miss _ _ O
100101 _ _ O
miss _ _ O
100100 _ _ O
miss _ _ O
100101 _ _ O
hit _ _ O
010000 _ _ O
miss _ _ O
000000 _ _ O
miss _ _ O
Cold _ _ O
misses _ _ O
Cold _ _ O
miss _ _ O
Capacity _ _ O
miss _ _ O
? _ _ O
010 _ _ O
0 _ _ O
011 _ _ O
0 _ _ O
100 _ _ O
0 _ _ O
1 _ _ O
100 _ _ O
something _ _ O
101 _ _ O
1 _ _ O
0 _ _ O
100 _ _ O
something _ _ O
110 _ _ O
0 _ _ O
111 _ _ O
0 _ _ O
25 _ _ O

Conflict _ _ O
Misses _ _ O
● _ _ O
What _ _ O
should _ _ O
we _ _ O
call _ _ O
2nd _ _ O
miss _ _ O
on _ _ O
000000 _ _ O
? _ _ O
o _ _ O
Awkward _ _ O
to _ _ O
call _ _ O
it _ _ O
a _ _ O
capacity _ _ O
miss _ _ O
( _ _ O
It _ _ O
’s _ _ O
not _ _ O
like _ _ O
capacity _ _ O
was _ _ O
lacking _ _ O
) _ _ O
000 _ _ O
o _ _ O
Let _ _ O
’s _ _ O
call _ _ O
it _ _ O
a _ _ O
conflict _ _ O
miss _ _ O
V _ _ O
Tag _ _ O
Data _ _ O
0 _ _ O
1 _ _ O
000 _ _ O
010 _ _ O
something _ _ O
001 _ _ O
0 _ _ O
010 _ _ O
0 _ _ O
011 _ _ O
0 _ _ O
100 _ _ O
0 _ _ O
1 _ _ O
100 _ _ O
something _ _ O
101 _ _ O
1 _ _ O
0 _ _ O
100 _ _ O
something _ _ O
110 _ _ O
0 _ _ O
111 _ _ O
0 _ _ O
000000 _ _ O
miss _ _ O
100101 _ _ O
miss _ _ O
100100 _ _ O
miss _ _ O
100101 _ _ O
hit _ _ O
010000 _ _ O
miss _ _ O
000000 _ _ O
miss _ _ O
Cold _ _ O
misses _ _ O
Cold _ _ O
miss _ _ O
Capacitymiss _ _ O
! _ _ O
Conflict _ _ O
miss _ _ O
? _ _ O
26 _ _ O

Types _ _ O
of _ _ O
Cache _ _ O
Misses _ _ O
( _ _ O
Revised _ _ O
) _ _ O
● _ _ O
Besides _ _ O
cold _ _ O
misses _ _ O
and _ _ O
capacity _ _ O
misses _ _ O
, _ _ O
there _ _ O
are _ _ O
conflict _ _ O
misses _ _ O
● _ _ O
Cold _ _ O
miss _ _ O
( _ _ O
a.k.a _ _ O
. _ _ O
compulsory _ _ O
miss _ _ O
) _ _ O
o _ _ O
Miss _ _ O
suffered _ _ O
when _ _ O
data _ _ O
is _ _ O
accessed _ _ O
for _ _ O
the _ _ O
first _ _ O
time _ _ O
by _ _ O
program _ _ O
● _ _ O
Capacity _ _ O
miss _ _ O
o _ _ O
Miss _ _ O
on _ _ O
a _ _ O
repeat _ _ O
access _ _ O
suffered _ _ O
due _ _ O
to _ _ O
a _ _ O
lack _ _ O
of _ _ O
capacity _ _ O
o _ _ O
When _ _ O
the _ _ O
program _ _ O
's _ _ O
working _ _ O
set _ _ O
is _ _ O
larger _ _ O
than _ _ O
can _ _ O
fit _ _ O
in _ _ O
the _ _ O
cache _ _ O
● _ _ O
Conflict _ _ O
miss _ _ O
o _ _ O
Miss _ _ O
on _ _ O
a _ _ O
repeat _ _ O
access _ _ O
suffered _ _ O
due _ _ O
to _ _ O
a _ _ O
lack _ _ O
of _ _ O
associativity _ _ O
o _ _ O
Associativity _ _ O
: _ _ O
degree _ _ O
of _ _ O
freedom _ _ O
in _ _ O
associating _ _ O
cache _ _ O
block _ _ O
with _ _ O
an _ _ O
index _ _ O
o _ _ O
Direct _ _ O
mapped _ _ O
caches _ _ O
have _ _ O
no _ _ O
associativity _ _ O
▪ _ _ O
Since _ _ O
cache _ _ O
blocks _ _ O
are _ _ O
directly _ _ O
mapped _ _ O
to _ _ O
a _ _ O
particular _ _ O
block _ _ O
index _ _ O
27 _ _ O

Associative _ _ O
caches _ _ O
28 _ _ O

Flexible _ _ O
block _ _ O
placement _ _ O
● _ _ O
Direct-mapped _ _ O
caches _ _ O
can _ _ O
have _ _ O
lots _ _ O
of _ _ O
conflicts _ _ O
o _ _ O
Multiple _ _ O
memory _ _ O
locations _ _ O
" _ _ O
fight _ _ O
" _ _ O
for _ _ O
the _ _ O
same _ _ O
cache _ _ O
line _ _ O
● _ _ O
Suppose _ _ O
we _ _ O
had _ _ O
a _ _ O
4-block _ _ O
direct-mapped _ _ O
cache _ _ O
V _ _ O
Tag _ _ O
Data _ _ O
o _ _ O
As _ _ O
before _ _ O
, _ _ O
4-byte _ _ O
per _ _ O
cache _ _ O
block _ _ O
00 _ _ O
0 _ _ O
0000 _ _ O
1 _ _ O
0001 _ _ O
0011 _ _ O
0010 _ _ O
o _ _ O
Memory _ _ O
addresses _ _ O
are _ _ O
8 _ _ O
bits _ _ O
. _ _ O
01 _ _ O
0 _ _ O
● _ _ O
The _ _ O
following _ _ O
locations _ _ O
are _ _ O
accessed _ _ O
in _ _ O
a _ _ O
loop _ _ O
: _ _ O
10 _ _ O
0 _ _ O
o _ _ O
0 _ _ O
, _ _ O
16 _ _ O
, _ _ O
32 _ _ O
, _ _ O
48 _ _ O
, _ _ O
0 _ _ O
, _ _ O
16 _ _ O
, _ _ O
32 _ _ O
, _ _ O
48 _ _ O
... _ _ O
11 _ _ O
0 _ _ O
o _ _ O
or _ _ O
000000 _ _ O
, _ _ O
000100 _ _ O
, _ _ O
001000 _ _ O
, _ _ O
001100 _ _ O
, _ _ O
… _ _ O
● _ _ O
What _ _ O
would _ _ O
happen _ _ O
? _ _ O
o _ _ O
They _ _ O
will _ _ O
all _ _ O
land _ _ O
on _ _ O
the _ _ O
same _ _ O
block _ _ O
index _ _ O
, _ _ O
and _ _ O
all _ _ O
conflict _ _ O
miss _ _ O
! _ _ O
o _ _ O
Those _ _ O
other _ _ O
3 _ _ O
blocks _ _ O
are _ _ O
not _ _ O
even _ _ O
getting _ _ O
used _ _ O
! _ _ O
o _ _ O
What _ _ O
if _ _ O
we _ _ O
used _ _ O
the _ _ O
space _ _ O
to _ _ O
chain _ _ O
conflicting _ _ O
blocks _ _ O
? _ _ O
29 _ _ O

Full _ _ O
associativity _ _ O
● _ _ O
Let _ _ O
's _ _ O
make _ _ O
our _ _ O
4-block _ _ O
cache _ _ O
4-way _ _ O
set-associative _ _ O
. _ _ O
V _ _ O
Tag _ _ O
1 _ _ O
0 _ _ O
000000 _ _ O
D _ _ O
V _ _ O
Tag _ _ O
* _ _ O
0 _ _ O
1 _ _ O
001100 _ _ O
0 _ _ O
D _ _ O
V _ _ O
Tag _ _ O
* _ _ O
48 _ _ O
1 _ _ O
0 _ _ O
000100 _ _ O
D _ _ O
V _ _ O
Tag _ _ O
* _ _ O
16 _ _ O
0 _ _ O
1 _ _ O
001000 _ _ O
D _ _ O
* _ _ O
32 _ _ O
● _ _ O
What _ _ O
's _ _ O
the _ _ O
difference _ _ O
? _ _ O
o _ _ O
Now _ _ O
a _ _ O
hashed _ _ O
location _ _ O
can _ _ O
be _ _ O
associated _ _ O
with _ _ O
any _ _ O
of _ _ O
the _ _ O
4 _ _ O
blocks _ _ O
o _ _ O
Analogous _ _ O
to _ _ O
having _ _ O
a _ _ O
hash _ _ O
conflict _ _ O
chain _ _ O
4-entries _ _ O
long _ _ O
o _ _ O
The _ _ O
4 _ _ O
cache _ _ O
blocks _ _ O
are _ _ O
said _ _ O
to _ _ O
be _ _ O
part _ _ O
of _ _ O
a _ _ O
cache _ _ O
set _ _ O
o _ _ O
When _ _ O
set _ _ O
size _ _ O
= _ _ O
= _ _ O
cache _ _ O
size _ _ O
, _ _ O
it _ _ O
is _ _ O
said _ _ O
to _ _ O
be _ _ O
fully _ _ O
associative _ _ O
● _ _ O
Let _ _ O
's _ _ O
do _ _ O
that _ _ O
sequence _ _ O
of _ _ O
reads _ _ O
again _ _ O
: _ _ O
0 _ _ O
, _ _ O
16 _ _ O
, _ _ O
32 _ _ O
, _ _ O
48 _ _ O
, _ _ O
0 _ _ O
, _ _ O
16 _ _ O
, _ _ O
32 _ _ O
, _ _ O
48 _ _ O
... _ _ O
● _ _ O
Notice _ _ O
tag _ _ O
is _ _ O
now _ _ O
bigger _ _ O
, _ _ O
since _ _ O
there _ _ O
are _ _ O
no _ _ O
block _ _ O
index _ _ O
bits _ _ O
o _ _ O
Or _ _ O
set _ _ O
index _ _ O
bits _ _ O
in _ _ O
this _ _ O
context _ _ O
( _ _ O
just _ _ O
one _ _ O
set _ _ O
, _ _ O
so _ _ O
none _ _ O
needed _ _ O
) _ _ O
● _ _ O
Now _ _ O
cache _ _ O
holds _ _ O
the _ _ O
entire _ _ O
working _ _ O
set _ _ O
: _ _ O
no _ _ O
more _ _ O
misses _ _ O
! _ _ O
30 _ _ O

Example _ _ O
: _ _ O
A _ _ O
2-way _ _ O
Set-Associative _ _ O
Cache _ _ O
● _ _ O
16-block _ _ O
2-way _ _ O
set-associative _ _ O
cache _ _ O
● _ _ O
Let _ _ O
’s _ _ O
try _ _ O
the _ _ O
same _ _ O
stream _ _ O
of _ _ O
accesses _ _ O
as _ _ O
direct-mapped _ _ O
cache _ _ O
● _ _ O
Yay _ _ O
! _ _ O
2nd _ _ O
access _ _ O
to _ _ O
000000 _ _ O
is _ _ O
no _ _ O
longer _ _ O
a _ _ O
conflict _ _ O
miss _ _ O
! _ _ O
000000 _ _ O
miss _ _ O
100101 _ _ O
miss _ _ O
100100 _ _ O
miss _ _ O
100101 _ _ O
hit _ _ O
010000 _ _ O
miss _ _ O
000000 _ _ O
hit _ _ O
Set _ _ O
V _ _ O
Tag _ _ O
Data _ _ O
V _ _ O
Tag _ _ O
Data _ _ O
000 _ _ O
0 _ _ O
1 _ _ O
000 _ _ O
something _ _ O
0 _ _ O
1 _ _ O
010 _ _ O
something _ _ O
001 _ _ O
0 _ _ O
0 _ _ O
010 _ _ O
0 _ _ O
0 _ _ O
011 _ _ O
0 _ _ O
0 _ _ O
100 _ _ O
0 _ _ O
1 _ _ O
100 _ _ O
something _ _ O
0 _ _ O
101 _ _ O
1 _ _ O
0 _ _ O
100 _ _ O
something _ _ O
0 _ _ O
110 _ _ O
0 _ _ O
0 _ _ O
111 _ _ O
0 _ _ O
0 _ _ O
31 _ _ O

Address _ _ O
Bits _ _ O
Breakdown _ _ O
● _ _ O
A _ _ O
fully _ _ O
associative _ _ O
cache _ _ O
( _ _ O
does _ _ O
n’t _ _ O
matter _ _ O
how _ _ O
many _ _ O
blocks _ _ O
) _ _ O
: _ _ O
Tag _ _ O
● _ _ O
With _ _ O
16-block _ _ O
4-way _ _ O
set-associative _ _ O
cache _ _ O
: _ _ O
Tag _ _ O
Set _ _ O
index _ _ O
Offset _ _ O
within _ _ O
cache _ _ O
block _ _ O
Offset _ _ O
o _ _ O
16 _ _ O
/ _ _ O
4 _ _ O
= _ _ O
4 _ _ O
sets _ _ O
in _ _ O
cache _ _ O
. _ _ O
So _ _ O
, _ _ O
2 _ _ O
bits _ _ O
required _ _ O
for _ _ O
set _ _ O
index _ _ O
. _ _ O
● _ _ O
With _ _ O
64-block _ _ O
8-way _ _ O
set-associative _ _ O
cache _ _ O
: _ _ O
Tag _ _ O
Set _ _ O
index _ _ O
Offset _ _ O
o _ _ O
64 _ _ O
/ _ _ O
8 _ _ O
= _ _ O
8 _ _ O
sets _ _ O
in _ _ O
cache _ _ O
. _ _ O
So _ _ O
, _ _ O
3 _ _ O
bits _ _ O
required _ _ O
for _ _ O
set _ _ O
index _ _ O
. _ _ O
32 _ _ O

Want _ _ O
More _ _ O
Examples _ _ O
? _ _ O
● _ _ O
Try _ _ O
out _ _ O
the _ _ O
Cache _ _ O
Visualizer _ _ O
on _ _ O
the _ _ O
course _ _ O
github _ _ O
: _ _ O
o _ _ O
https _ _ O
: _ _ O
/ _ _ O
/ _ _ O
github.com _ _ O
/ _ _ O
wonsunahn _ _ O
/ _ _ O
CS1541_Spring2022 _ _ O
/ _ _ O
tree _ _ O
/ _ _ O
main _ _ O
/ _ _ O
re _ _ O
sources _ _ O
/ _ _ O
cache_demo _ _ O
o _ _ O
Courtesy _ _ O
of _ _ O
Jarrett _ _ O
Billingsley _ _ O
● _ _ O
Visualizes _ _ O
cache _ _ O
organization _ _ O
for _ _ O
various _ _ O
parameters _ _ O
o _ _ O
Cache _ _ O
block _ _ O
size _ _ O
o _ _ O
Number _ _ O
of _ _ O
blocks _ _ O
in _ _ O
cache _ _ O
( _ _ O
capacity _ _ O
) _ _ O
o _ _ O
Cache _ _ O
associativity _ _ O
33 _ _ O

Associativity _ _ O
is _ _ O
Costly _ _ O
● _ _ O
Associativity _ _ O
requires _ _ O
complex _ _ O
circuitry _ _ O
and _ _ O
may _ _ O
increase _ _ O
hit _ _ O
time _ _ O
● _ _ O
Full _ _ O
associativity _ _ O
is _ _ O
only _ _ O
used _ _ O
for _ _ O
very _ _ O
small _ _ O
caches _ _ O
o _ _ O
And _ _ O
where _ _ O
a _ _ O
cache _ _ O
miss _ _ O
is _ _ O
extremely _ _ O
costly _ _ O
● _ _ O
Usually _ _ O
caches _ _ O
are _ _ O
2- _ _ O
, _ _ O
4- _ _ O
, _ _ O
or _ _ O
maybe _ _ O
8- _ _ O
way _ _ O
set-associative _ _ O
Bottom _ _ O
bit _ _ O
selects _ _ O
set _ _ O
( _ _ O
row _ _ O
) _ _ O
V _ _ O
Tag _ _ O
D _ _ O
V _ _ O
1 _ _ O
10010 _ _ O
-2 _ _ O
0 _ _ O
V _ _ O
Tag _ _ O
D _ _ O
1 _ _ O
01010 _ _ O
64 _ _ O
000110 _ _ O
? _ _ O
00011 _ _ O
Address _ _ O
Remaining _ _ O
tag _ _ O
bits _ _ O
Share _ _ O
comparators _ _ O
across _ _ O
all _ _ O
rows _ _ O
Tag _ _ O
D _ _ O
V _ _ O
Tag _ _ O
D _ _ O
1 _ _ O
11111 _ _ O
9999 _ _ O
= _ _ O
= _ _ O
OR _ _ O
34 _ _ O

Access _ _ O
/ _ _ O
cycle _ _ O
time _ _ O
as _ _ O
a _ _ O
function _ _ O
of _ _ O
associativity _ _ O
Thoziyoor _ _ O
, _ _ O
Shyamkumar _ _ O
& _ _ O
Muralimanohar _ _ O
, _ _ O
Naveen _ _ O
& _ _ O
Ahn _ _ O
, _ _ O
Jung _ _ O
Ho _ _ O
& _ _ O
Jouppi _ _ O
, _ _ O
Norman _ _ O
. _ _ O
( _ _ O
2008 _ _ O
) _ _ O
. _ _ O
CACTI _ _ O
5.1 _ _ O
. _ _ O
35 _ _ O

Cache _ _ O
Design _ _ O
Parameter _ _ O
5 _ _ O
: _ _ O
Cache _ _ O
Replacement _ _ O
Policy _ _ O
36 _ _ O

Cache _ _ O
Replacement _ _ O
● _ _ O
If _ _ O
we _ _ O
have _ _ O
a _ _ O
cache _ _ O
miss _ _ O
and _ _ O
no _ _ O
empty _ _ O
blocks _ _ O
, _ _ O
what _ _ O
then _ _ O
? _ _ O
V _ _ O
Tag _ _ O
1 _ _ O
0 _ _ O
000000 _ _ O
D _ _ O
V _ _ O
Tag _ _ O
* _ _ O
0 _ _ O
1 _ _ O
001100 _ _ O
0 _ _ O
D _ _ O
V _ _ O
Tag _ _ O
* _ _ O
48 _ _ O
000001 _ _ O
1 _ _ O
0 _ _ O
000100 _ _ O
D _ _ O
V _ _ O
Tag _ _ O
* _ _ O
4 _ _ O
* _ _ O
16 _ _ O
0 _ _ O
1 _ _ O
001000 _ _ O
D _ _ O
* _ _ O
32 _ _ O
● _ _ O
Let _ _ O
's _ _ O
read _ _ O
memory _ _ O
address _ _ O
4 _ _ O
( _ _ O
00000100 _ _ O
) _ _ O
. _ _ O
o _ _ O
Uh _ _ O
oh _ _ O
. _ _ O
That _ _ O
's _ _ O
a _ _ O
miss _ _ O
. _ _ O
Where _ _ O
do _ _ O
we _ _ O
put _ _ O
it _ _ O
? _ _ O
● _ _ O
With _ _ O
associative _ _ O
caches _ _ O
, _ _ O
you _ _ O
must _ _ O
have _ _ O
a _ _ O
replacement _ _ O
scheme _ _ O
. _ _ O
o _ _ O
Which _ _ O
block _ _ O
to _ _ O
evict _ _ O
( _ _ O
kick _ _ O
out _ _ O
) _ _ O
when _ _ O
you _ _ O
're _ _ O
out _ _ O
of _ _ O
empty _ _ O
slots _ _ O
? _ _ O
● _ _ O
The _ _ O
simplest _ _ O
replacement _ _ O
scheme _ _ O
is _ _ O
random _ _ O
. _ _ O
o _ _ O
Just _ _ O
pick _ _ O
one _ _ O
. _ _ O
Does _ _ O
n't _ _ O
matter _ _ O
which _ _ O
. _ _ O
● _ _ O
What _ _ O
would _ _ O
make _ _ O
more _ _ O
sense _ _ O
? _ _ O
o _ _ O
How _ _ O
about _ _ O
taking _ _ O
temporal _ _ O
locality _ _ O
into _ _ O
account _ _ O
? _ _ O
37 _ _ O

LRU _ _ O
( _ _ O
Least-Recently-Used _ _ O
) _ _ O
Replacement _ _ O
● _ _ O
When _ _ O
you _ _ O
need _ _ O
to _ _ O
evict _ _ O
a _ _ O
block _ _ O
, _ _ O
kick _ _ O
out _ _ O
the _ _ O
oldest _ _ O
one _ _ O
. _ _ O
V _ _ O
Tag _ _ O
000001 _ _ O
1 _ _ O
0 _ _ O
000000 _ _ O
D _ _ O
V _ _ O
* _ _ O
4 _ _ O
* _ _ O
0 _ _ O
1 _ _ O
001100 _ _ O
0 _ _ O
4 _ _ O
reads _ _ O
old _ _ O
Tag _ _ O
D _ _ O
V _ _ O
* _ _ O
48 _ _ O
1 _ _ O
0 _ _ O
000100 _ _ O
1 _ _ O
read _ _ O
old _ _ O
Tag _ _ O
D _ _ O
V _ _ O
* _ _ O
16 _ _ O
0 _ _ O
1 _ _ O
001000 _ _ O
3 _ _ O
reads _ _ O
old _ _ O
Tag _ _ O
D _ _ O
* _ _ O
32 _ _ O
2 _ _ O
reads _ _ O
old _ _ O
● _ _ O
Our _ _ O
read _ _ O
history _ _ O
looked _ _ O
like _ _ O
0 _ _ O
, _ _ O
16 _ _ O
, _ _ O
32 _ _ O
, _ _ O
48 _ _ O
. _ _ O
How _ _ O
old _ _ O
are _ _ O
the _ _ O
blocks _ _ O
? _ _ O
● _ _ O
Now _ _ O
we _ _ O
want _ _ O
to _ _ O
read _ _ O
address _ _ O
4 _ _ O
. _ _ O
Which _ _ O
block _ _ O
should _ _ O
we _ _ O
replace _ _ O
? _ _ O
● _ _ O
But _ _ O
now _ _ O
we _ _ O
must _ _ O
maintain _ _ O
the _ _ O
age _ _ O
of _ _ O
the _ _ O
blocks _ _ O
o _ _ O
Easy _ _ O
to _ _ O
say _ _ O
. _ _ O
How _ _ O
do _ _ O
we _ _ O
keep _ _ O
track _ _ O
of _ _ O
this _ _ O
in _ _ O
hardware _ _ O
? _ _ O
● _ _ O
Have _ _ O
a _ _ O
saturating _ _ O
counter _ _ O
for _ _ O
each _ _ O
cache _ _ O
block _ _ O
indicating _ _ O
age _ _ O
o _ _ O
When _ _ O
accessing _ _ O
a _ _ O
set _ _ O
, _ _ O
increment _ _ O
counter _ _ O
for _ _ O
each _ _ O
block _ _ O
in _ _ O
set _ _ O
o _ _ O
On _ _ O
a _ _ O
cache _ _ O
hit _ _ O
, _ _ O
reset _ _ O
counter _ _ O
to _ _ O
0 _ _ O
( _ _ O
most _ _ O
recently _ _ O
used _ _ O
) _ _ O
38 _ _ O

Impact _ _ O
of _ _ O
LRU _ _ O
on _ _ O
AMAT _ _ O
● _ _ O
AMAT _ _ O
= _ _ O
hit _ _ O
time _ _ O
+ _ _ O
( _ _ O
miss _ _ O
rate _ _ O
× _ _ O
miss _ _ O
penalty _ _ O
) _ _ O
● _ _ O
Impact _ _ O
of _ _ O
LRU _ _ O
on _ _ O
miss _ _ O
rate _ _ O
o _ _ O
Smaller _ _ O
miss _ _ O
rate _ _ O
due _ _ O
to _ _ O
better _ _ O
leveraging _ _ O
of _ _ O
temporal _ _ O
locality _ _ O
( _ _ O
Recently _ _ O
used _ _ O
cache _ _ O
lines _ _ O
more _ _ O
likely _ _ O
to _ _ O
be _ _ O
used _ _ O
again _ _ O
) _ _ O
● _ _ O
Saturating _ _ O
counter _ _ O
for _ _ O
LRU _ _ O
uses _ _ O
bits _ _ O
and _ _ O
adds _ _ O
to _ _ O
amount _ _ O
of _ _ O
metadata _ _ O
o _ _ O
Cache _ _ O
tag _ _ O
, _ _ O
the _ _ O
valid _ _ O
bit _ _ O
, _ _ O
the _ _ O
saturating _ _ O
counter _ _ O
are _ _ O
all _ _ O
metadata _ _ O
o _ _ O
Every _ _ O
bit _ _ O
you _ _ O
spend _ _ O
on _ _ O
metadata _ _ O
is _ _ O
a _ _ O
bit _ _ O
you _ _ O
do _ _ O
n’t _ _ O
spend _ _ O
on _ _ O
real _ _ O
data _ _ O
o _ _ O
Spending _ _ O
many _ _ O
bits _ _ O
on _ _ O
counter _ _ O
may _ _ O
reduce _ _ O
capacity _ _ O
for _ _ O
real _ _ O
data _ _ O
o _ _ O
This _ _ O
may _ _ O
lead _ _ O
to _ _ O
a _ _ O
larger _ _ O
miss _ _ O
rate _ _ O
, _ _ O
if _ _ O
LRU _ _ O
is _ _ O
not _ _ O
very _ _ O
effective _ _ O
39 _ _ O



