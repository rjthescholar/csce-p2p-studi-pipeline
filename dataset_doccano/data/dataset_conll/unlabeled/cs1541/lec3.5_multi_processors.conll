unlabeled|cs1541|lec3.5_multi_processors
-DOCSTART- -X- -X- O

Multiprocessors _ _ O
and _ _ O
Caching _ _ O
CS _ _ O
1541 _ _ O
Wonsun _ _ O
Ahn _ _ O

Two _ _ O
ways _ _ O
to _ _ O
use _ _ O
multiple _ _ O
processors _ _ O
● _ _ O
Distributed _ _ O
( _ _ O
Memory _ _ O
) _ _ O
System _ _ O
o _ _ O
Processors _ _ O
do _ _ O
not _ _ O
share _ _ O
memory _ _ O
( _ _ O
and _ _ O
by _ _ O
extension _ _ O
data _ _ O
) _ _ O
o _ _ O
Processors _ _ O
exchange _ _ O
data _ _ O
through _ _ O
network _ _ O
messages _ _ O
o _ _ O
Programming _ _ O
standards _ _ O
: _ _ O
▪ _ _ O
Message _ _ O
Passing _ _ O
Interface _ _ O
( _ _ O
MPI _ _ O
) _ _ O
– _ _ O
C _ _ O
/ _ _ O
C++ _ _ O
API _ _ O
for _ _ O
exchanging _ _ O
messages _ _ O
▪ _ _ O
Ajax _ _ O
( _ _ O
Asynchronous _ _ O
JavaScript _ _ O
and _ _ O
XML _ _ O
) _ _ O
– _ _ O
API _ _ O
for _ _ O
web _ _ O
apps _ _ O
o _ _ O
Data _ _ O
exchange _ _ O
protocols _ _ O
: _ _ O
TCP _ _ O
/ _ _ O
IP _ _ O
, _ _ O
UDP _ _ O
/ _ _ O
IP _ _ O
, _ _ O
JSON _ _ O
, _ _ O
XML _ _ O
… _ _ O
● _ _ O
Shared _ _ O
Memory _ _ O
System _ _ O
( _ _ O
a.k.a _ _ O
. _ _ O
Multiprocessor _ _ O
System _ _ O
) _ _ O
o _ _ O
Processors _ _ O
share _ _ O
memory _ _ O
( _ _ O
and _ _ O
by _ _ O
extension _ _ O
data _ _ O
) _ _ O
o _ _ O
Programming _ _ O
standards _ _ O
: _ _ O
▪ _ _ O
Pthreads _ _ O
( _ _ O
POSIX _ _ O
threads _ _ O
) _ _ O
, _ _ O
Java _ _ O
threads _ _ O
– _ _ O
APIs _ _ O
for _ _ O
threading _ _ O
▪ _ _ O
OpenMP _ _ O
– _ _ O
Compiler _ _ O
# _ _ O
pragma _ _ O
directives _ _ O
for _ _ O
parallelization _ _ O
o _ _ O
Cache _ _ O
coherence _ _ O
protocol _ _ O
: _ _ O
protocol _ _ O
for _ _ O
exchanging _ _ O
data _ _ O
among _ _ O
caches _ _ O
→ _ _ O
Just _ _ O
like _ _ O
Ethernet _ _ O
, _ _ O
caches _ _ O
are _ _ O
part _ _ O
of _ _ O
a _ _ O
larger _ _ O
network _ _ O
of _ _ O
caches _ _ O
2 _ _ O

Shared _ _ O
Data _ _ O
Review _ _ O
● _ _ O
What _ _ O
bad _ _ O
thing _ _ O
can _ _ O
happen _ _ O
when _ _ O
you _ _ O
have _ _ O
shared _ _ O
data _ _ O
? _ _ O
● _ _ O
Dataraces _ _ O
! _ _ O
o _ _ O
You _ _ O
should _ _ O
have _ _ O
learned _ _ O
it _ _ O
in _ _ O
CS _ _ O
449 _ _ O
. _ _ O
o _ _ O
But _ _ O
if _ _ O
you _ _ O
did _ _ O
n’t _ _ O
, _ _ O
do _ _ O
n’t _ _ O
worry _ _ O
I _ _ O
’ll _ _ O
go _ _ O
over _ _ O
it _ _ O
. _ _ O
3 _ _ O

Review _ _ O
: _ _ O
Datarace _ _ O
Example _ _ O
int _ _ O
shared _ _ O
= _ _ O
0 _ _ O
; _ _ O
void _ _ O
* _ _ O
add _ _ O
( _ _ O
void _ _ O
* _ _ O
unused _ _ O
) _ _ O
{ _ _ O
for _ _ O
( _ _ O
int _ _ O
i=0 _ _ O
; _ _ O
i _ _ O
< _ _ O
1000000 _ _ O
; _ _ O
i++ _ _ O
) _ _ O
{ _ _ O
shared++ _ _ O
; _ _ O
} _ _ O
return _ _ O
NULL _ _ O
; _ _ O
} _ _ O
bash-4.2 _ _ O
$ _ _ O
. _ _ O
/ _ _ O
datarace _ _ O
int _ _ O
main _ _ O
( _ _ O
) _ _ O
{ _ _ O
pthread_t _ _ O
t _ _ O
; _ _ O
shared=1085894 _ _ O
/ _ _ O
/ _ _ O
Child _ _ O
thread _ _ O
starts _ _ O
running _ _ O
add _ _ O
bash-4.2 _ _ O
$ _ _ O
. _ _ O
/ _ _ O
datarace _ _ O
pthread_create _ _ O
( _ _ O
& _ _ O
t _ _ O
, _ _ O
NULL _ _ O
, _ _ O
add _ _ O
, _ _ O
NULL _ _ O
) _ _ O
; _ _ O
shared=1101173 _ _ O
/ _ _ O
/ _ _ O
Main _ _ O
thread _ _ O
starts _ _ O
running _ _ O
add _ _ O
bash-4.2 _ _ O
$ _ _ O
. _ _ O
/ _ _ O
datarace _ _ O
add _ _ O
( _ _ O
NULL _ _ O
) _ _ O
; _ _ O
/ _ _ O
/ _ _ O
Wait _ _ O
until _ _ O
child _ _ O
thread _ _ O
completes _ _ O
shared=1065494 _ _ O
pthread_join _ _ O
( _ _ O
t _ _ O
, _ _ O
NULL _ _ O
) _ _ O
; _ _ O
printf _ _ O
( _ _ O
"shared=%d\n _ _ O
" _ _ O
, _ _ O
shared _ _ O
) _ _ O
; _ _ O
return _ _ O
0 _ _ O
; _ _ O
} _ _ O
Q _ _ O
) _ _ O
What _ _ O
do _ _ O
you _ _ O
expect _ _ O
from _ _ O
running _ _ O
this _ _ O
? _ _ O
Maybe _ _ O
shared=2000000 _ _ O
? _ _ O
A _ _ O
) _ _ O
Nondeterministic _ _ O
result _ _ O
! _ _ O
Due _ _ O
to _ _ O
datarace _ _ O
on _ _ O
shared _ _ O
. _ _ O
4 _ _ O

Review _ _ O
: _ _ O
Datarace _ _ O
Example _ _ O
● _ _ O
When _ _ O
two _ _ O
threads _ _ O
do _ _ O
shared++ _ _ O
; _ _ O
initially _ _ O
shared _ _ O
= _ _ O
1 _ _ O
shared _ _ O
1 _ _ O
shared++ _ _ O
Thread _ _ O
1 _ _ O
• _ _ O
You _ _ O
may _ _ O
think _ _ O
shared _ _ O
becomes _ _ O
3 _ _ O
. _ _ O
( _ _ O
shared++ _ _ O
on _ _ O
each _ _ O
thread _ _ O
) _ _ O
• _ _ O
But _ _ O
that _ _ O
’s _ _ O
not _ _ O
the _ _ O
only _ _ O
possibility _ _ O
! _ _ O
• _ _ O
I _ _ O
’ll _ _ O
show _ _ O
you _ _ O
shared _ _ O
becoming _ _ O
2 _ _ O
. _ _ O
shared++ _ _ O
Thread _ _ O
2 _ _ O
5 _ _ O

Review _ _ O
: _ _ O
Datarace _ _ O
Example _ _ O
● _ _ O
When _ _ O
two _ _ O
threads _ _ O
do _ _ O
shared++ _ _ O
; _ _ O
initially _ _ O
shared _ _ O
= _ _ O
1 _ _ O
R1 _ _ O
shared _ _ O
R1 _ _ O
0 _ _ O
1 _ _ O
0 _ _ O
R1 _ _ O
= _ _ O
shared _ _ O
R1 _ _ O
= _ _ O
R1 _ _ O
+ _ _ O
1 _ _ O
shared _ _ O
= _ _ O
R1 _ _ O
Thread _ _ O
1 _ _ O
R1 _ _ O
= _ _ O
shared _ _ O
R1 _ _ O
= _ _ O
R1 _ _ O
+ _ _ O
1 _ _ O
shared _ _ O
= _ _ O
R1 _ _ O
Thread _ _ O
2 _ _ O
6 _ _ O

Review _ _ O
: _ _ O
Datarace _ _ O
Example _ _ O
● _ _ O
When _ _ O
two _ _ O
threads _ _ O
do _ _ O
shared++ _ _ O
; _ _ O
initially _ _ O
shared _ _ O
= _ _ O
1 _ _ O
R1 _ _ O
shared _ _ O
R1 _ _ O
1 _ _ O
1 _ _ O
0 _ _ O
① _ _ O
R1 _ _ O
= _ _ O
shared _ _ O
R1 _ _ O
= _ _ O
R1 _ _ O
+ _ _ O
1 _ _ O
shared _ _ O
= _ _ O
R1 _ _ O
Thread _ _ O
1 _ _ O
R1 _ _ O
= _ _ O
shared _ _ O
R1 _ _ O
= _ _ O
R1 _ _ O
+ _ _ O
1 _ _ O
shared _ _ O
= _ _ O
R1 _ _ O
Thread _ _ O
2 _ _ O
7 _ _ O

Review _ _ O
: _ _ O
Datarace _ _ O
Example _ _ O
● _ _ O
When _ _ O
two _ _ O
threads _ _ O
do _ _ O
shared++ _ _ O
; _ _ O
initially _ _ O
shared _ _ O
= _ _ O
1 _ _ O
R1 _ _ O
shared _ _ O
R1 _ _ O
1 _ _ O
1 _ _ O
1 _ _ O
R1 _ _ O
= _ _ O
shared② _ _ O
R1 _ _ O
= _ _ O
R1 _ _ O
+ _ _ O
1 _ _ O
shared _ _ O
= _ _ O
R1 _ _ O
① _ _ O
R1 _ _ O
= _ _ O
shared _ _ O
R1 _ _ O
= _ _ O
R1 _ _ O
+ _ _ O
1 _ _ O
shared _ _ O
= _ _ O
R1 _ _ O
Thread _ _ O
1 _ _ O
Thread _ _ O
2 _ _ O
8 _ _ O

Review _ _ O
: _ _ O
Datarace _ _ O
Example _ _ O
● _ _ O
When _ _ O
two _ _ O
threads _ _ O
do _ _ O
shared++ _ _ O
; _ _ O
initially _ _ O
shared _ _ O
= _ _ O
1 _ _ O
R1 _ _ O
shared _ _ O
R1 _ _ O
2 _ _ O
1 _ _ O
1 _ _ O
R1 _ _ O
= _ _ O
shared② _ _ O
R1 _ _ O
= _ _ O
R1 _ _ O
+ _ _ O
1 _ _ O
shared _ _ O
= _ _ O
R1 _ _ O
① _ _ O
R1 _ _ O
= _ _ O
shared _ _ O
③ _ _ O
R1 _ _ O
= _ _ O
R1 _ _ O
+ _ _ O
1 _ _ O
shared _ _ O
= _ _ O
R1 _ _ O
Thread _ _ O
1 _ _ O
Thread _ _ O
2 _ _ O
9 _ _ O

Review _ _ O
: _ _ O
Datarace _ _ O
Example _ _ O
● _ _ O
When _ _ O
two _ _ O
threads _ _ O
do _ _ O
shared++ _ _ O
; _ _ O
initially _ _ O
shared _ _ O
= _ _ O
1 _ _ O
R1 _ _ O
shared _ _ O
R1 _ _ O
2 _ _ O
1 _ _ O
2 _ _ O
R1 _ _ O
= _ _ O
shared② _ _ O
R1 _ _ O
= _ _ O
R1 _ _ O
+ _ _ O
1④ _ _ O
shared _ _ O
= _ _ O
R1 _ _ O
① _ _ O
R1 _ _ O
= _ _ O
shared _ _ O
③ _ _ O
R1 _ _ O
= _ _ O
R1 _ _ O
+ _ _ O
1 _ _ O
shared _ _ O
= _ _ O
R1 _ _ O
Thread _ _ O
1 _ _ O
Thread _ _ O
2 _ _ O
10 _ _ O

Review _ _ O
: _ _ O
Datarace _ _ O
Example _ _ O
● _ _ O
When _ _ O
two _ _ O
threads _ _ O
do _ _ O
shared++ _ _ O
; _ _ O
initially _ _ O
shared _ _ O
= _ _ O
1 _ _ O
R1 _ _ O
shared _ _ O
R1 _ _ O
2 _ _ O
2 _ _ O
2 _ _ O
R1 _ _ O
= _ _ O
shared② _ _ O
R1 _ _ O
= _ _ O
R1 _ _ O
+ _ _ O
1④ _ _ O
shared _ _ O
= _ _ O
R1 _ _ O
① _ _ O
R1 _ _ O
= _ _ O
shared _ _ O
③ _ _ O
R1 _ _ O
= _ _ O
R1 _ _ O
+ _ _ O
1 _ _ O
⑤ _ _ O
shared _ _ O
= _ _ O
R1 _ _ O
Thread _ _ O
1 _ _ O
Thread _ _ O
2 _ _ O
11 _ _ O

Review _ _ O
: _ _ O
Datarace _ _ O
Example _ _ O
• _ _ O
Why _ _ O
did _ _ O
this _ _ O
occur _ _ O
in _ _ O
the _ _ O
first _ _ O
place _ _ O
? _ _ O
• _ _ O
Because _ _ O
data _ _ O
was _ _ O
replicated _ _ O
to _ _ O
CPU _ _ O
registers _ _ O
and _ _ O
each _ _ O
worked _ _ O
on _ _ O
its _ _ O
own _ _ O
copy _ _ O
! _ _ O
● _ _ O
When _ _ O
two _ _ O
threads _ _ O
do _ _ O
shared++ _ _ O
; _ _ O
initially _ _ O
shared _ _ O
= _ _ O
1 _ _ O
R1 _ _ O
shared _ _ O
R1 _ _ O
2 _ _ O
2 _ _ O
2 _ _ O
① _ _ O
R1 _ _ O
= _ _ O
shared _ _ O
③ _ _ O
R1 _ _ O
= _ _ O
R1 _ _ O
+ _ _ O
1 _ _ O
⑤ _ _ O
shared _ _ O
= _ _ O
R1 _ _ O
Thread _ _ O
1 _ _ O
R1 _ _ O
= _ _ O
shared② _ _ O
R1 _ _ O
= _ _ O
R1 _ _ O
+ _ _ O
1④ _ _ O
shared _ _ O
= _ _ O
R1⑥ _ _ O
• _ _ O
End _ _ O
result _ _ O
is _ _ O
2 _ _ O
instead _ _ O
of _ _ O
3 _ _ O
! _ _ O
• _ _ O
Only _ _ O
on _ _ O
simultaneous _ _ O
access _ _ O
( _ _ O
with _ _ O
this _ _ O
type _ _ O
of _ _ O
interleaving _ _ O
) _ _ O
Thread _ _ O
2 _ _ O
12 _ _ O

Review _ _ O
: _ _ O
Datarace _ _ O
Example _ _ O
pthread_mutex_t _ _ O
lock _ _ O
; _ _ O
int _ _ O
shared _ _ O
= _ _ O
0 _ _ O
; _ _ O
void _ _ O
* _ _ O
add _ _ O
( _ _ O
void _ _ O
* _ _ O
unused _ _ O
) _ _ O
{ _ _ O
for _ _ O
( _ _ O
int _ _ O
i=0 _ _ O
; _ _ O
i _ _ O
< _ _ O
1000000 _ _ O
; _ _ O
i++ _ _ O
) _ _ O
{ _ _ O
pthread_mutex_lock _ _ O
( _ _ O
& _ _ O
lock _ _ O
) _ _ O
; _ _ O
shared++ _ _ O
; _ _ O
pthread_mutex_unlock _ _ O
( _ _ O
& _ _ O
lock _ _ O
) _ _ O
; _ _ O
} _ _ O
return _ _ O
NULL _ _ O
; _ _ O
} _ _ O
int _ _ O
main _ _ O
( _ _ O
) _ _ O
{ _ _ O
… _ _ O
} _ _ O
bash-4.2 _ _ O
$ _ _ O
. _ _ O
/ _ _ O
datarace _ _ O
shared=2000000 _ _ O
bash-4.2 _ _ O
$ _ _ O
. _ _ O
/ _ _ O
datarace _ _ O
shared=2000000 _ _ O
bash-4.2 _ _ O
$ _ _ O
. _ _ O
/ _ _ O
datarace _ _ O
shared=2000000 _ _ O
• _ _ O
Data _ _ O
race _ _ O
is _ _ O
fixed _ _ O
! _ _ O
Now _ _ O
shared _ _ O
is _ _ O
always _ _ O
2000000 _ _ O
. _ _ O
• _ _ O
Problem _ _ O
solved _ _ O
? _ _ O
No _ _ O
! _ _ O
CPU _ _ O
registers _ _ O
is _ _ O
not _ _ O
the _ _ O
only _ _ O
place _ _ O
replication _ _ O
happens _ _ O
! _ _ O
13 _ _ O

Caching _ _ O
also _ _ O
does _ _ O
replication _ _ O
! _ _ O
● _ _ O
What _ _ O
happens _ _ O
if _ _ O
caches _ _ O
sit _ _ O
in _ _ O
between _ _ O
processors _ _ O
and _ _ O
memory _ _ O
? _ _ O
L1 _ _ O
$ _ _ O
L1 _ _ O
$ _ _ O
L1 _ _ O
$ _ _ O
L1 _ _ O
$ _ _ O
Private _ _ O
L1 _ _ O
$ _ _ O
L2 _ _ O
$ _ _ O
L2 _ _ O
$ _ _ O
L2 _ _ O
$ _ _ O
L2 _ _ O
$ _ _ O
Private _ _ O
L2 _ _ O
$ _ _ O
Bank _ _ O
0 _ _ O
Bank _ _ O
1 _ _ O
Bank _ _ O
2 _ _ O
Bank _ _ O
3 _ _ O
Shared _ _ O
L3 _ _ O
$ _ _ O
* _ _ O
All _ _ O
caches _ _ O
are _ _ O
write-back _ _ O
shared _ _ O
0 _ _ O
14 _ _ O

Caching _ _ O
also _ _ O
does _ _ O
replication _ _ O
! _ _ O
● _ _ O
Let _ _ O
’s _ _ O
say _ _ O
CPU _ _ O
0 _ _ O
first _ _ O
fetches _ _ O
shared _ _ O
for _ _ O
incrementing _ _ O
shared _ _ O
0 _ _ O
L1 _ _ O
$ _ _ O
L1 _ _ O
$ _ _ O
L1 _ _ O
$ _ _ O
L1 _ _ O
$ _ _ O
Private _ _ O
L1 _ _ O
$ _ _ O
shared _ _ O
0 _ _ O
L2 _ _ O
$ _ _ O
L2 _ _ O
$ _ _ O
L2 _ _ O
$ _ _ O
L2 _ _ O
$ _ _ O
Private _ _ O
L2 _ _ O
$ _ _ O
shared _ _ O
0 _ _ O
Bank _ _ O
0 _ _ O
Bank _ _ O
1 _ _ O
Bank _ _ O
2 _ _ O
Bank _ _ O
3 _ _ O
Shared _ _ O
L3 _ _ O
$ _ _ O
* _ _ O
All _ _ O
caches _ _ O
are _ _ O
write-back _ _ O
shared _ _ O
0 _ _ O
15 _ _ O

Caching _ _ O
also _ _ O
does _ _ O
replication _ _ O
! _ _ O
● _ _ O
Then _ _ O
CPU _ _ O
0 _ _ O
increments _ _ O
shared _ _ O
100 _ _ O
times _ _ O
to _ _ O
100 _ _ O
shared _ _ O
100 _ _ O
L1 _ _ O
$ _ _ O
L1 _ _ O
$ _ _ O
L1 _ _ O
$ _ _ O
L1 _ _ O
$ _ _ O
Private _ _ O
L1 _ _ O
$ _ _ O
shared _ _ O
0 _ _ O
L2 _ _ O
$ _ _ O
L2 _ _ O
$ _ _ O
L2 _ _ O
$ _ _ O
L2 _ _ O
$ _ _ O
Private _ _ O
L2 _ _ O
$ _ _ O
shared _ _ O
0 _ _ O
Bank _ _ O
0 _ _ O
Bank _ _ O
1 _ _ O
Bank _ _ O
2 _ _ O
Bank _ _ O
3 _ _ O
Shared _ _ O
L3 _ _ O
$ _ _ O
* _ _ O
All _ _ O
caches _ _ O
are _ _ O
write-back _ _ O
shared _ _ O
0 _ _ O
16 _ _ O

Caching _ _ O
also _ _ O
does _ _ O
replication _ _ O
! _ _ O
● _ _ O
Then _ _ O
CPU _ _ O
2 _ _ O
gets _ _ O
hold _ _ O
of _ _ O
the _ _ O
mutex _ _ O
and _ _ O
fetches _ _ O
shared _ _ O
from _ _ O
L3 _ _ O
shared _ _ O
100 _ _ O
L1 _ _ O
$ _ _ O
L1 _ _ O
$ _ _ O
shared _ _ O
L1 _ _ O
$ _ _ O
0 _ _ O
L1 _ _ O
$ _ _ O
Private _ _ O
L1 _ _ O
$ _ _ O
shared _ _ O
0 _ _ O
L2 _ _ O
$ _ _ O
L2 _ _ O
$ _ _ O
shared _ _ O
L2 _ _ O
$ _ _ O
0 _ _ O
L2 _ _ O
$ _ _ O
Private _ _ O
L2 _ _ O
$ _ _ O
shared _ _ O
0 _ _ O
Bank _ _ O
0 _ _ O
Bank _ _ O
1 _ _ O
Bank _ _ O
2 _ _ O
Bank _ _ O
3 _ _ O
Shared _ _ O
L3 _ _ O
$ _ _ O
* _ _ O
All _ _ O
caches _ _ O
are _ _ O
write-back _ _ O
shared _ _ O
0 _ _ O
17 _ _ O

Caching _ _ O
also _ _ O
does _ _ O
replication _ _ O
! _ _ O
● _ _ O
Then _ _ O
CPU _ _ O
2 _ _ O
increments _ _ O
shared _ _ O
10 _ _ O
times _ _ O
to _ _ O
10 _ _ O
shared _ _ O
100 _ _ O
L1 _ _ O
$ _ _ O
L1 _ _ O
$ _ _ O
shared _ _ O
L1 _ _ O
$ _ _ O
10 _ _ O
L1 _ _ O
$ _ _ O
Private _ _ O
L1 _ _ O
$ _ _ O
shared _ _ O
0 _ _ O
L2 _ _ O
$ _ _ O
L2 _ _ O
$ _ _ O
shared _ _ O
L2 _ _ O
$ _ _ O
0 _ _ O
L2 _ _ O
$ _ _ O
Private _ _ O
L2 _ _ O
$ _ _ O
shared _ _ O
0 _ _ O
Bank _ _ O
0 _ _ O
Bank _ _ O
1 _ _ O
Bank _ _ O
2 _ _ O
Bank _ _ O
3 _ _ O
Shared _ _ O
L3 _ _ O
$ _ _ O
* _ _ O
All _ _ O
caches _ _ O
are _ _ O
write-back _ _ O
shared _ _ O
0 _ _ O
18 _ _ O

Caching _ _ O
also _ _ O
does _ _ O
replication _ _ O
! _ _ O
● _ _ O
Clearly _ _ O
this _ _ O
is _ _ O
wrong _ _ O
. _ _ O
L1 _ _ O
caches _ _ O
of _ _ O
CPU _ _ O
0 _ _ O
and _ _ O
CPU _ _ O
2 _ _ O
are _ _ O
incoherent _ _ O
. _ _ O
shared _ _ O
100 _ _ O
L1 _ _ O
$ _ _ O
L1 _ _ O
$ _ _ O
shared _ _ O
L1 _ _ O
$ _ _ O
10 _ _ O
L1 _ _ O
$ _ _ O
Private _ _ O
L1 _ _ O
$ _ _ O
shared _ _ O
0 _ _ O
L2 _ _ O
$ _ _ O
L2 _ _ O
$ _ _ O
shared _ _ O
L2 _ _ O
$ _ _ O
0 _ _ O
L2 _ _ O
$ _ _ O
Private _ _ O
L2 _ _ O
$ _ _ O
shared _ _ O
0 _ _ O
Bank _ _ O
0 _ _ O
Bank _ _ O
1 _ _ O
Bank _ _ O
2 _ _ O
Bank _ _ O
3 _ _ O
Shared _ _ O
L3 _ _ O
$ _ _ O
* _ _ O
All _ _ O
caches _ _ O
are _ _ O
write-back _ _ O
shared _ _ O
0 _ _ O
19 _ _ O

Cache _ _ O
Incoherence _ _ O
: _ _ O
Problem _ _ O
with _ _ O
Private _ _ O
Caches _ _ O
● _ _ O
This _ _ O
problem _ _ O
does _ _ O
not _ _ O
occur _ _ O
with _ _ O
a _ _ O
shared _ _ O
cache _ _ O
. _ _ O
o _ _ O
All _ _ O
processors _ _ O
share _ _ O
and _ _ O
work _ _ O
on _ _ O
a _ _ O
single _ _ O
copy _ _ O
of _ _ O
data _ _ O
. _ _ O
shared _ _ O
0 _ _ O
Bank _ _ O
0 _ _ O
Bank _ _ O
1 _ _ O
Bank _ _ O
2 _ _ O
Bank _ _ O
3 _ _ O
Shared _ _ O
L3 _ _ O
$ _ _ O
o _ _ O
The _ _ O
problem _ _ O
exists _ _ O
only _ _ O
with _ _ O
private _ _ O
caches _ _ O
. _ _ O
● _ _ O
The _ _ O
problem _ _ O
exists _ _ O
for _ _ O
private _ _ O
caches _ _ O
. _ _ O
o _ _ O
Private _ _ O
copy _ _ O
is _ _ O
at _ _ O
times _ _ O
inconsistent _ _ O
with _ _ O
lower _ _ O
memory _ _ O
. _ _ O
o _ _ O
Incoherence _ _ O
occurs _ _ O
when _ _ O
private _ _ O
copies _ _ O
differ _ _ O
from _ _ O
each _ _ O
other _ _ O
. _ _ O
→ _ _ O
Means _ _ O
processors _ _ O
return _ _ O
different _ _ O
values _ _ O
for _ _ O
same _ _ O
location _ _ O
! _ _ O
20 _ _ O

Cache _ _ O
Coherence _ _ O
21 _ _ O

Cache _ _ O
Coherence _ _ O
● _ _ O
Cache _ _ O
coherence _ _ O
( _ _ O
loosely _ _ O
defined _ _ O
) _ _ O
: _ _ O
o _ _ O
All _ _ O
processors _ _ O
of _ _ O
system _ _ O
should _ _ O
see _ _ O
the _ _ O
same _ _ O
view _ _ O
of _ _ O
memory _ _ O
o _ _ O
Copies _ _ O
of _ _ O
values _ _ O
cached _ _ O
by _ _ O
processors _ _ O
should _ _ O
adhere _ _ O
to _ _ O
this _ _ O
rule _ _ O
● _ _ O
Each _ _ O
ISA _ _ O
has _ _ O
a _ _ O
different _ _ O
definition _ _ O
of _ _ O
what _ _ O
that _ _ O
“ _ _ O
view _ _ O
” _ _ O
means _ _ O
o _ _ O
Memory _ _ O
consistency _ _ O
model _ _ O
: _ _ O
definition _ _ O
of _ _ O
what _ _ O
that _ _ O
“ _ _ O
view _ _ O
” _ _ O
is _ _ O
● _ _ O
All _ _ O
models _ _ O
agree _ _ O
on _ _ O
one _ _ O
thing _ _ O
: _ _ O
o _ _ O
That _ _ O
a _ _ O
change _ _ O
in _ _ O
value _ _ O
should _ _ O
reflect _ _ O
on _ _ O
all _ _ O
copies _ _ O
( _ _ O
eventually _ _ O
) _ _ O
22 _ _ O

How _ _ O
Memory _ _ O
Consistent _ _ O
Model _ _ O
affects _ _ O
correctness _ _ O
● _ _ O
Initially _ _ O
, _ _ O
data _ _ O
= _ _ O
= _ _ O
0 _ _ O
, _ _ O
flag _ _ O
= _ _ O
= _ _ O
false _ _ O
. _ _ O
Producer _ _ O
Thread _ _ O
Consumer _ _ O
Thread _ _ O
data _ _ O
= _ _ O
= _ _ O
42 _ _ O
; _ _ O
while _ _ O
( _ _ O
flag _ _ O
= _ _ O
= _ _ O
false _ _ O
) _ _ O
{ _ _ O
/ _ _ O
* _ _ O
wait _ _ O
* _ _ O
/ _ _ O
} _ _ O
flag _ _ O
= _ _ O
true _ _ O
; _ _ O
System.out.println _ _ O
( _ _ O
“data= _ _ O
“ _ _ O
+ _ _ O
data _ _ O
) _ _ O
; _ _ O
Q _ _ O
) _ _ O
What _ _ O
do _ _ O
you _ _ O
expect _ _ O
the _ _ O
value _ _ O
of _ _ O
data _ _ O
will _ _ O
be _ _ O
when _ _ O
it _ _ O
gets _ _ O
printed _ _ O
? _ _ O
A _ _ O
) _ _ O
Most _ _ O
people _ _ O
will _ _ O
say _ _ O
42 _ _ O
because _ _ O
that _ _ O
is _ _ O
the _ _ O
logical _ _ O
ordering _ _ O
. _ _ O
But _ _ O
is _ _ O
it _ _ O
? _ _ O
Not _ _ O
always _ _ O
. _ _ O
There _ _ O
are _ _ O
situations _ _ O
where _ _ O
data _ _ O
is _ _ O
still _ _ O
0 _ _ O
! _ _ O
23 _ _ O

Scenario _ _ O
1 _ _ O
: _ _ O
Stores _ _ O
arrive _ _ O
out-of-order _ _ O
● _ _ O
Initially _ _ O
, _ _ O
data _ _ O
= _ _ O
= _ _ O
0 _ _ O
, _ _ O
flag _ _ O
= _ _ O
= _ _ O
false _ _ O
. _ _ O
Producer _ _ O
Thread _ _ O
Consumer _ _ O
Thread _ _ O
data _ _ O
= _ _ O
= _ _ O
42 _ _ O
; _ _ O
while _ _ O
( _ _ O
flag _ _ O
= _ _ O
= _ _ O
false _ _ O
) _ _ O
{ _ _ O
/ _ _ O
* _ _ O
wait _ _ O
* _ _ O
/ _ _ O
} _ _ O
flag _ _ O
= _ _ O
true _ _ O
; _ _ O
System.out.println _ _ O
( _ _ O
“data= _ _ O
“ _ _ O
+ _ _ O
data _ _ O
) _ _ O
; _ _ O
CPU _ _ O
0 _ _ O
CPU _ _ O
1 _ _ O
L1 _ _ O
$ _ _ O
L1 _ _ O
$ _ _ O
data _ _ O
0 _ _ O
flag _ _ O
data _ _ O
false _ _ O
0 _ _ O
flag _ _ O
false _ _ O
Let _ _ O
’s _ _ O
assume _ _ O
initially _ _ O
both _ _ O
data _ _ O
and _ _ O
flag _ _ O
are _ _ O
cached _ _ O
in _ _ O
each _ _ O
CPU _ _ O
’s _ _ O
L1 _ _ O
caches _ _ O
. _ _ O
24 _ _ O

Scenario _ _ O
1 _ _ O
: _ _ O
Stores _ _ O
arrive _ _ O
out-of-order _ _ O
● _ _ O
Initially _ _ O
, _ _ O
data _ _ O
= _ _ O
= _ _ O
0 _ _ O
, _ _ O
flag _ _ O
= _ _ O
= _ _ O
false _ _ O
. _ _ O
Producer _ _ O
Thread _ _ O
Consumer _ _ O
Thread _ _ O
data _ _ O
= _ _ O
= _ _ O
42 _ _ O
; _ _ O
while _ _ O
( _ _ O
flag _ _ O
= _ _ O
= _ _ O
false _ _ O
) _ _ O
{ _ _ O
/ _ _ O
* _ _ O
wait _ _ O
* _ _ O
/ _ _ O
} _ _ O
flag _ _ O
= _ _ O
true _ _ O
; _ _ O
System.out.println _ _ O
( _ _ O
“data= _ _ O
“ _ _ O
+ _ _ O
data _ _ O
) _ _ O
; _ _ O
CPU _ _ O
0 _ _ O
CPU _ _ O
1 _ _ O
L1 _ _ O
$ _ _ O
L1 _ _ O
$ _ _ O
data _ _ O
42 _ _ O
flag _ _ O
data _ _ O
true _ _ O
0 _ _ O
flag _ _ O
false _ _ O
CPU _ _ O
0 _ _ O
updates _ _ O
both _ _ O
data _ _ O
and _ _ O
flag _ _ O
to _ _ O
42 _ _ O
and _ _ O
true _ _ O
. _ _ O
25 _ _ O

Scenario _ _ O
1 _ _ O
: _ _ O
Stores _ _ O
arrive _ _ O
out-of-order _ _ O
● _ _ O
Initially _ _ O
, _ _ O
data _ _ O
= _ _ O
= _ _ O
0 _ _ O
, _ _ O
flag _ _ O
= _ _ O
= _ _ O
false _ _ O
. _ _ O
Producer _ _ O
Thread _ _ O
Consumer _ _ O
Thread _ _ O
data _ _ O
= _ _ O
= _ _ O
42 _ _ O
; _ _ O
while _ _ O
( _ _ O
flag _ _ O
= _ _ O
= _ _ O
false _ _ O
) _ _ O
{ _ _ O
/ _ _ O
* _ _ O
wait _ _ O
* _ _ O
/ _ _ O
} _ _ O
flag _ _ O
= _ _ O
true _ _ O
; _ _ O
System.out.println _ _ O
( _ _ O
“data= _ _ O
“ _ _ O
+ _ _ O
data _ _ O
) _ _ O
; _ _ O
CPU _ _ O
0 _ _ O
CPU _ _ O
1 _ _ O
L1 _ _ O
$ _ _ O
L1 _ _ O
$ _ _ O
data _ _ O
42 _ _ O
flag _ _ O
data _ _ O
true _ _ O
0 _ _ O
flag _ _ O
false _ _ O
Now _ _ O
the _ _ O
cached _ _ O
values _ _ O
in _ _ O
CPU _ _ O
1 _ _ O
are _ _ O
stale _ _ O
and _ _ O
need _ _ O
to _ _ O
be _ _ O
invalidated _ _ O
. _ _ O
Invalidation _ _ O
: _ _ O
act _ _ O
of _ _ O
marking _ _ O
a _ _ O
cache _ _ O
block _ _ O
with _ _ O
stale _ _ O
data _ _ O
invalid _ _ O
. _ _ O
26 _ _ O

Scenario _ _ O
1 _ _ O
: _ _ O
Stores _ _ O
arrive _ _ O
out-of-order _ _ O
● _ _ O
Initially _ _ O
, _ _ O
data _ _ O
= _ _ O
= _ _ O
0 _ _ O
, _ _ O
flag _ _ O
= _ _ O
= _ _ O
false _ _ O
. _ _ O
Producer _ _ O
Thread _ _ O
Consumer _ _ O
Thread _ _ O
data _ _ O
= _ _ O
= _ _ O
42 _ _ O
; _ _ O
while _ _ O
( _ _ O
flag _ _ O
= _ _ O
= _ _ O
false _ _ O
) _ _ O
{ _ _ O
/ _ _ O
* _ _ O
wait _ _ O
* _ _ O
/ _ _ O
} _ _ O
flag _ _ O
= _ _ O
true _ _ O
; _ _ O
System.out.println _ _ O
( _ _ O
“data= _ _ O
“ _ _ O
+ _ _ O
data _ _ O
) _ _ O
; _ _ O
CPU _ _ O
0 _ _ O
data _ _ O
42 _ _ O
L1 _ _ O
$ _ _ O
CPU _ _ O
1 _ _ O
Invalidate _ _ O
for _ _ O
flag _ _ O
flag _ _ O
true _ _ O
Invalidate _ _ O
for _ _ O
data _ _ O
data _ _ O
0 _ _ O
L1 _ _ O
$ _ _ O
flag _ _ O
false _ _ O
The _ _ O
invalidate _ _ O
messages _ _ O
travel _ _ O
through _ _ O
a _ _ O
network _ _ O
and _ _ O
may _ _ O
arrive _ _ O
out-of-order _ _ O
. _ _ O
Let _ _ O
’s _ _ O
say _ _ O
invalidate _ _ O
for _ _ O
flag _ _ O
arrives _ _ O
first _ _ O
to _ _ O
CPU _ _ O
1 _ _ O
and _ _ O
marks _ _ O
flag _ _ O
invalid _ _ O
. _ _ O
27 _ _ O

Scenario _ _ O
1 _ _ O
: _ _ O
Stores _ _ O
arrive _ _ O
out-of-order _ _ O
● _ _ O
Initially _ _ O
, _ _ O
data _ _ O
= _ _ O
= _ _ O
0 _ _ O
, _ _ O
flag _ _ O
= _ _ O
= _ _ O
false _ _ O
. _ _ O
Producer _ _ O
Thread _ _ O
Consumer _ _ O
Thread _ _ O
data _ _ O
= _ _ O
= _ _ O
42 _ _ O
; _ _ O
while _ _ O
( _ _ O
flag _ _ O
= _ _ O
= _ _ O
false _ _ O
) _ _ O
{ _ _ O
/ _ _ O
* _ _ O
wait _ _ O
* _ _ O
/ _ _ O
} _ _ O
flag _ _ O
= _ _ O
true _ _ O
; _ _ O
System.out.println _ _ O
( _ _ O
“data= _ _ O
“ _ _ O
+ _ _ O
data _ _ O
) _ _ O
; _ _ O
CPU _ _ O
0 _ _ O
data _ _ O
42 _ _ O
L1 _ _ O
$ _ _ O
CPU _ _ O
1 _ _ O
Fetch _ _ O
for _ _ O
flag _ _ O
flag _ _ O
true _ _ O
Invalidate _ _ O
for _ _ O
data _ _ O
data _ _ O
0 _ _ O
L1 _ _ O
$ _ _ O
flag _ _ O
true _ _ O
CPU _ _ O
1 _ _ O
fetches _ _ O
updated _ _ O
flag _ _ O
from _ _ O
CPU _ _ O
0 _ _ O
when _ _ O
comparing _ _ O
flag _ _ O
= _ _ O
= _ _ O
false _ _ O
. _ _ O
Invalidate _ _ O
for _ _ O
data _ _ O
is _ _ O
still _ _ O
traveling _ _ O
through _ _ O
the _ _ O
network _ _ O
. _ _ O
28 _ _ O

Scenario _ _ O
1 _ _ O
: _ _ O
Stores _ _ O
arrive _ _ O
out-of-order _ _ O
● _ _ O
Initially _ _ O
, _ _ O
data _ _ O
= _ _ O
= _ _ O
0 _ _ O
, _ _ O
flag _ _ O
= _ _ O
= _ _ O
false _ _ O
. _ _ O
Producer _ _ O
Thread _ _ O
Consumer _ _ O
Thread _ _ O
data _ _ O
= _ _ O
= _ _ O
42 _ _ O
; _ _ O
while _ _ O
( _ _ O
flag _ _ O
= _ _ O
= _ _ O
false _ _ O
) _ _ O
{ _ _ O
/ _ _ O
* _ _ O
wait _ _ O
* _ _ O
/ _ _ O
} _ _ O
flag _ _ O
= _ _ O
true _ _ O
; _ _ O
System.out.println _ _ O
( _ _ O
“data= _ _ O
“ _ _ O
+ _ _ O
data _ _ O
) _ _ O
; _ _ O
CPU _ _ O
0 _ _ O
data _ _ O
42 _ _ O
L1 _ _ O
$ _ _ O
CPU _ _ O
1 _ _ O
Fetch _ _ O
for _ _ O
flag _ _ O
flag _ _ O
Invalidate _ _ O
for _ _ O
data _ _ O
true _ _ O
data _ _ O
0 _ _ O
L1 _ _ O
$ _ _ O
flag _ _ O
true _ _ O
Since _ _ O
flag _ _ O
is _ _ O
true _ _ O
, _ _ O
CPU _ _ O
1 _ _ O
breaks _ _ O
out _ _ O
of _ _ O
while _ _ O
loop _ _ O
and _ _ O
prints _ _ O
data _ _ O
. _ _ O
data=0 _ _ O
gets _ _ O
printed _ _ O
! _ _ O
29 _ _ O

Scenario _ _ O
2 _ _ O
: _ _ O
Loads _ _ O
perform _ _ O
out-of-order _ _ O
● _ _ O
Initially _ _ O
, _ _ O
data _ _ O
= _ _ O
= _ _ O
0 _ _ O
, _ _ O
flag _ _ O
= _ _ O
= _ _ O
false _ _ O
. _ _ O
Producer _ _ O
Thread _ _ O
Consumer _ _ O
Thread _ _ O
data _ _ O
= _ _ O
= _ _ O
42 _ _ O
; _ _ O
while _ _ O
( _ _ O
flag _ _ O
= _ _ O
= _ _ O
false _ _ O
) _ _ O
{ _ _ O
/ _ _ O
* _ _ O
wait _ _ O
* _ _ O
/ _ _ O
} _ _ O
flag _ _ O
= _ _ O
true _ _ O
; _ _ O
System.out.println _ _ O
( _ _ O
“data= _ _ O
“ _ _ O
+ _ _ O
data _ _ O
) _ _ O
; _ _ O
CPU _ _ O
0 _ _ O
CPU _ _ O
1 _ _ O
L1 _ _ O
$ _ _ O
L1 _ _ O
$ _ _ O
data _ _ O
0 _ _ O
flag _ _ O
data _ _ O
false _ _ O
0 _ _ O
Let _ _ O
’s _ _ O
assume _ _ O
now _ _ O
flag _ _ O
is _ _ O
not _ _ O
cached _ _ O
in _ _ O
CPU _ _ O
1 _ _ O
. _ _ O
CPU _ _ O
1 _ _ O
suffers _ _ O
a _ _ O
cache _ _ O
miss _ _ O
on _ _ O
flag _ _ O
when _ _ O
it _ _ O
compares _ _ O
flag _ _ O
= _ _ O
= _ _ O
false _ _ O
. _ _ O
30 _ _ O

Scenario _ _ O
2 _ _ O
: _ _ O
Loads _ _ O
perform _ _ O
out-of-order _ _ O
● _ _ O
Initially _ _ O
, _ _ O
data _ _ O
= _ _ O
= _ _ O
0 _ _ O
, _ _ O
flag _ _ O
= _ _ O
= _ _ O
false _ _ O
. _ _ O
Producer _ _ O
Thread _ _ O
Consumer _ _ O
Thread _ _ O
data _ _ O
= _ _ O
= _ _ O
42 _ _ O
; _ _ O
while _ _ O
( _ _ O
flag _ _ O
= _ _ O
= _ _ O
false _ _ O
) _ _ O
{ _ _ O
/ _ _ O
* _ _ O
wait _ _ O
* _ _ O
/ _ _ O
} _ _ O
flag _ _ O
= _ _ O
true _ _ O
; _ _ O
System.out.println _ _ O
( _ _ O
“data= _ _ O
“ _ _ O
+ _ _ O
data _ _ O
) _ _ O
; _ _ O
CPU _ _ O
0 _ _ O
CPU _ _ O
1 _ _ O
Instruction _ _ O
Queue _ _ O
lw _ _ O
r1 _ _ O
, _ _ O
flag _ _ O
( _ _ O
miss _ _ O
) _ _ O
data _ _ O
0 _ _ O
L1 _ _ O
$ _ _ O
flag _ _ O
data _ _ O
false _ _ O
0 _ _ O
L1 _ _ O
$ _ _ O
beq _ _ O
r1 _ _ O
, _ _ O
$ _ _ O
zero _ _ O
, _ _ O
_ _ _ O
loop _ _ O
lw _ _ O
r2 _ _ O
, _ _ O
data _ _ O
( _ _ O
hit _ _ O
) _ _ O
call _ _ O
println _ _ O
on _ _ O
r2 _ _ O
Instead _ _ O
of _ _ O
stalling _ _ O
, _ _ O
CPU _ _ O
1 _ _ O
predicts _ _ O
the _ _ O
branch _ _ O
not _ _ O
taken _ _ O
and _ _ O
issues _ _ O
lw _ _ O
r2 _ _ O
, _ _ O
data _ _ O
. _ _ O
Now _ _ O
, _ _ O
r2 _ _ O
= _ _ O
= _ _ O
0 _ _ O
. _ _ O
( _ _ O
Unless _ _ O
pipeline _ _ O
flushes _ _ O
due _ _ O
to _ _ O
branch _ _ O
misprediction _ _ O
. _ _ O
) _ _ O
31 _ _ O

Scenario _ _ O
2 _ _ O
: _ _ O
Loads _ _ O
perform _ _ O
out-of-order _ _ O
● _ _ O
Initially _ _ O
, _ _ O
data _ _ O
= _ _ O
= _ _ O
0 _ _ O
, _ _ O
flag _ _ O
= _ _ O
= _ _ O
false _ _ O
. _ _ O
Producer _ _ O
Thread _ _ O
Consumer _ _ O
Thread _ _ O
data _ _ O
= _ _ O
= _ _ O
42 _ _ O
; _ _ O
while _ _ O
( _ _ O
flag _ _ O
= _ _ O
= _ _ O
false _ _ O
) _ _ O
{ _ _ O
/ _ _ O
* _ _ O
wait _ _ O
* _ _ O
/ _ _ O
} _ _ O
flag _ _ O
= _ _ O
true _ _ O
; _ _ O
System.out.println _ _ O
( _ _ O
“data= _ _ O
“ _ _ O
+ _ _ O
data _ _ O
) _ _ O
; _ _ O
CPU _ _ O
0 _ _ O
CPU _ _ O
1 _ _ O
Instruction _ _ O
Queue _ _ O
lw _ _ O
r1 _ _ O
, _ _ O
flag _ _ O
( _ _ O
miss _ _ O
) _ _ O
data _ _ O
42 _ _ O
L1 _ _ O
$ _ _ O
flag _ _ O
true _ _ O
Fetch _ _ O
for _ _ O
flag _ _ O
data _ _ O
0 _ _ O
L1 _ _ O
$ _ _ O
beq _ _ O
r1 _ _ O
, _ _ O
$ _ _ O
zero _ _ O
, _ _ O
_ _ _ O
loop _ _ O
flag _ _ O
lw _ _ O
r2 _ _ O
, _ _ O
data _ _ O
( _ _ O
hit _ _ O
) _ _ O
true _ _ O
call _ _ O
println _ _ O
on _ _ O
r2 _ _ O
Now _ _ O
let _ _ O
’s _ _ O
say _ _ O
CPU _ _ O
0 _ _ O
updates _ _ O
data _ _ O
and _ _ O
flag _ _ O
before _ _ O
the _ _ O
fetch _ _ O
for _ _ O
flag _ _ O
arrives _ _ O
. _ _ O
Now _ _ O
, _ _ O
lw _ _ O
r1 _ _ O
, _ _ O
flag _ _ O
completes _ _ O
, _ _ O
allowing _ _ O
beq _ _ O
r1 _ _ O
, _ _ O
$ _ _ O
zero _ _ O
, _ _ O
_ _ _ O
loop _ _ O
to _ _ O
issue _ _ O
( _ _ O
with _ _ O
r1 _ _ O
= _ _ O
= _ _ O
true _ _ O
) _ _ O
32 _ _ O

Scenario _ _ O
2 _ _ O
: _ _ O
Loads _ _ O
perform _ _ O
out-of-order _ _ O
● _ _ O
Initially _ _ O
, _ _ O
data _ _ O
= _ _ O
= _ _ O
0 _ _ O
, _ _ O
flag _ _ O
= _ _ O
= _ _ O
false _ _ O
. _ _ O
Producer _ _ O
Thread _ _ O
Consumer _ _ O
Thread _ _ O
data _ _ O
= _ _ O
= _ _ O
42 _ _ O
; _ _ O
while _ _ O
( _ _ O
flag _ _ O
= _ _ O
= _ _ O
false _ _ O
) _ _ O
{ _ _ O
/ _ _ O
* _ _ O
wait _ _ O
* _ _ O
/ _ _ O
} _ _ O
flag _ _ O
= _ _ O
true _ _ O
; _ _ O
System.out.println _ _ O
( _ _ O
“data= _ _ O
“ _ _ O
+ _ _ O
data _ _ O
) _ _ O
; _ _ O
CPU _ _ O
0 _ _ O
CPU _ _ O
1 _ _ O
Instruction _ _ O
Queue _ _ O
lw _ _ O
r1 _ _ O
, _ _ O
flag _ _ O
( _ _ O
miss _ _ O
) _ _ O
data _ _ O
42 _ _ O
L1 _ _ O
$ _ _ O
flag _ _ O
Fetch _ _ O
for _ _ O
flag _ _ O
true _ _ O
data _ _ O
0 _ _ O
L1 _ _ O
$ _ _ O
beq _ _ O
r1 _ _ O
, _ _ O
$ _ _ O
zero _ _ O
, _ _ O
_ _ _ O
loop _ _ O
flag _ _ O
lw _ _ O
r2 _ _ O
, _ _ O
data _ _ O
( _ _ O
hit _ _ O
) _ _ O
true _ _ O
call _ _ O
println _ _ O
on _ _ O
r2 _ _ O
Since _ _ O
r1 _ _ O
= _ _ O
= _ _ O
true _ _ O
, _ _ O
that _ _ O
validates _ _ O
the _ _ O
not-taken _ _ O
prediction _ _ O
for _ _ O
the _ _ O
branch _ _ O
. _ _ O
Since _ _ O
r1 _ _ O
= _ _ O
= _ _ O
0 _ _ O
, _ _ O
the _ _ O
println _ _ O
outputs _ _ O
data=0 _ _ O
! _ _ O
33 _ _ O

Memory _ _ O
Consistency _ _ O
Models _ _ O
are _ _ O
often _ _ O
very _ _ O
lax _ _ O
● _ _ O
Initially _ _ O
, _ _ O
data _ _ O
= _ _ O
= _ _ O
0 _ _ O
, _ _ O
flag _ _ O
= _ _ O
= _ _ O
false _ _ O
. _ _ O
Producer _ _ O
Thread _ _ O
Consumer _ _ O
Thread _ _ O
data _ _ O
= _ _ O
= _ _ O
42 _ _ O
; _ _ O
while _ _ O
( _ _ O
flag _ _ O
= _ _ O
= _ _ O
false _ _ O
) _ _ O
{ _ _ O
/ _ _ O
* _ _ O
wait _ _ O
* _ _ O
/ _ _ O
} _ _ O
flag _ _ O
= _ _ O
true _ _ O
; _ _ O
System.out.println _ _ O
( _ _ O
“data= _ _ O
“ _ _ O
+ _ _ O
data _ _ O
) _ _ O
; _ _ O
• _ _ O
A _ _ O
memory _ _ O
consistency _ _ O
model _ _ O
where _ _ O
above _ _ O
ordering _ _ O
is _ _ O
guaranteed _ _ O
is _ _ O
called _ _ O
, _ _ O
Sequential _ _ O
Consistency _ _ O
( _ _ O
SC _ _ O
) _ _ O
: _ _ O
Instructions _ _ O
appear _ _ O
to _ _ O
execute _ _ O
sequentially _ _ O
. _ _ O
• _ _ O
Real _ _ O
models _ _ O
allow _ _ O
many _ _ O
other _ _ O
orderings _ _ O
to _ _ O
allow _ _ O
optimizations _ _ O
: _ _ O
• _ _ O
Write _ _ O
buffers _ _ O
that _ _ O
allow _ _ O
multiple _ _ O
stores _ _ O
to _ _ O
be _ _ O
pending _ _ O
and _ _ O
perform _ _ O
out-of-order _ _ O
• _ _ O
Instruction _ _ O
queues _ _ O
that _ _ O
allow _ _ O
loads _ _ O
and _ _ O
other _ _ O
instructions _ _ O
to _ _ O
perform _ _ O
out-of-order _ _ O
• _ _ O
Compiler _ _ O
optimizations _ _ O
to _ _ O
reschedule _ _ O
stores _ _ O
and _ _ O
loads _ _ O
out-of-order _ _ O
• _ _ O
Intel _ _ O
, _ _ O
ARM _ _ O
, _ _ O
Java _ _ O
Virtual _ _ O
Machine _ _ O
all _ _ O
have _ _ O
relaxed _ _ O
memory _ _ O
consistency _ _ O
models _ _ O
• _ _ O
Moral _ _ O
: _ _ O
never _ _ O
do _ _ O
custom _ _ O
synchronization _ _ O
unless _ _ O
you _ _ O
know _ _ O
what _ _ O
you _ _ O
are _ _ O
doing _ _ O
! _ _ O
34 _ _ O

Memory _ _ O
Consistency _ _ O
Models _ _ O
are _ _ O
often _ _ O
very _ _ O
lax _ _ O
● _ _ O
Initially _ _ O
, _ _ O
data _ _ O
= _ _ O
= _ _ O
0 _ _ O
, _ _ O
flag _ _ O
= _ _ O
= _ _ O
false _ _ O
. _ _ O
Producer _ _ O
Thread _ _ O
Consumer _ _ O
Thread _ _ O
data _ _ O
= _ _ O
= _ _ O
42 _ _ O
; _ _ O
while _ _ O
( _ _ O
flag _ _ O
= _ _ O
= _ _ O
false _ _ O
) _ _ O
{ _ _ O
/ _ _ O
* _ _ O
wait _ _ O
* _ _ O
/ _ _ O
} _ _ O
flag _ _ O
= _ _ O
true _ _ O
; _ _ O
System.out.println _ _ O
( _ _ O
“data= _ _ O
“ _ _ O
+ _ _ O
data _ _ O
) _ _ O
; _ _ O
• _ _ O
Regardless _ _ O
of _ _ O
memory _ _ O
consistency _ _ O
model _ _ O
, _ _ O
they _ _ O
all _ _ O
agree _ _ O
on _ _ O
one _ _ O
thing _ _ O
: _ _ O
that _ _ O
values _ _ O
of _ _ O
data _ _ O
and _ _ O
flag _ _ O
must _ _ O
be _ _ O
made _ _ O
coherent _ _ O
eventually _ _ O
. _ _ O
• _ _ O
They _ _ O
only _ _ O
disagree _ _ O
on _ _ O
when _ _ O
that _ _ O
eventually _ _ O
is _ _ O
. _ _ O
• _ _ O
This _ _ O
property _ _ O
is _ _ O
called _ _ O
cache _ _ O
coherence _ _ O
. _ _ O
35 _ _ O

Implementing _ _ O
Cache _ _ O
Coherence _ _ O
● _ _ O
How _ _ O
to _ _ O
guarantee _ _ O
changes _ _ O
in _ _ O
value _ _ O
are _ _ O
propagated _ _ O
to _ _ O
all _ _ O
caches _ _ O
? _ _ O
● _ _ O
Cache _ _ O
coherence _ _ O
protocol _ _ O
: _ _ O
A _ _ O
protocol _ _ O
, _ _ O
or _ _ O
set _ _ O
of _ _ O
rules _ _ O
, _ _ O
that _ _ O
all _ _ O
caches _ _ O
must _ _ O
follow _ _ O
to _ _ O
ensure _ _ O
coherence _ _ O
between _ _ O
caches _ _ O
o _ _ O
MSI _ _ O
( _ _ O
Modified-Shared-Invalid _ _ O
) _ _ O
o _ _ O
MESI _ _ O
( _ _ O
Modified-Exclusive-Shared-Invalid _ _ O
) _ _ O
o _ _ O
… _ _ O
often _ _ O
named _ _ O
after _ _ O
the _ _ O
states _ _ O
in _ _ O
cache _ _ O
controller _ _ O
FSM _ _ O
● _ _ O
Three _ _ O
states _ _ O
of _ _ O
MSI _ _ O
protocol _ _ O
( _ _ O
maintained _ _ O
for _ _ O
each _ _ O
block _ _ O
) _ _ O
: _ _ O
o _ _ O
Modified _ _ O
: _ _ O
Dirty _ _ O
. _ _ O
Only _ _ O
this _ _ O
cache _ _ O
has _ _ O
copy _ _ O
. _ _ O
o _ _ O
Shared _ _ O
: _ _ O
Clean _ _ O
. _ _ O
Other _ _ O
caches _ _ O
may _ _ O
have _ _ O
copy _ _ O
. _ _ O
o _ _ O
Invalid _ _ O
: _ _ O
Block _ _ O
contains _ _ O
no _ _ O
data _ _ O
. _ _ O
36 _ _ O

MSI _ _ O
Snoopy _ _ O
Cache _ _ O
Coherence _ _ O
Protocol _ _ O
Processor _ _ O
Snoop _ _ O
tag _ _ O
Cache _ _ O
tag _ _ O
and _ _ O
data _ _ O
Processor _ _ O
Snoop _ _ O
tag _ _ O
Cache _ _ O
tag _ _ O
and _ _ O
data _ _ O
Processor _ _ O
Snoop _ _ O
tag _ _ O
Cache _ _ O
tag _ _ O
and _ _ O
data _ _ O
Single _ _ O
bus _ _ O
Memory _ _ O
I _ _ O
/ _ _ O
O _ _ O
● _ _ O
Each _ _ O
processor _ _ O
monitors _ _ O
( _ _ O
snoops _ _ O
) _ _ O
the _ _ O
activity _ _ O
on _ _ O
the _ _ O
bus _ _ O
oIn _ _ O
much _ _ O
the _ _ O
same _ _ O
way _ _ O
as _ _ O
how _ _ O
nodes _ _ O
snoop _ _ O
the _ _ O
Ethernet _ _ O
● _ _ O
Cache _ _ O
state _ _ O
changes _ _ O
in _ _ O
response _ _ O
to _ _ O
both _ _ O
: _ _ O
oRead _ _ O
/ _ _ O
writes _ _ O
from _ _ O
the _ _ O
local _ _ O
processor _ _ O
oRead _ _ O
misses _ _ O
/ _ _ O
write _ _ O
misses _ _ O
from _ _ O
remote _ _ O
processors _ _ O
it _ _ O
snoops _ _ O
37 _ _ O

MSI _ _ O
: _ _ O
Example _ _ O
• _ _ O
All _ _ O
bus _ _ O
activity _ _ O
is _ _ O
show _ _ O
in _ _ O
blue _ _ O
. _ _ O
Cache _ _ O
changes _ _ O
block _ _ O
state _ _ O
in _ _ O
response _ _ O
. _ _ O
• _ _ O
Bus _ _ O
activity _ _ O
is _ _ O
generated _ _ O
only _ _ O
for _ _ O
cache _ _ O
misses _ _ O
, _ _ O
or _ _ O
for _ _ O
invalidates _ _ O
• _ _ O
Other _ _ O
caches _ _ O
must _ _ O
maintain _ _ O
coherence _ _ O
by _ _ O
monitoring _ _ O
that _ _ O
bus _ _ O
activity _ _ O
Event _ _ O
In _ _ O
P1 _ _ O
’s _ _ O
cache _ _ O
L _ _ O
= _ _ O
invalid _ _ O
P1 _ _ O
writes _ _ O
10 _ _ O
to _ _ O
A _ _ O
( _ _ O
write _ _ O
miss _ _ O
) _ _ O
P1 _ _ O
reads _ _ O
A _ _ O
( _ _ O
read _ _ O
hit _ _ O
) _ _ O
P2 _ _ O
reads _ _ O
A _ _ O
( _ _ O
read _ _ O
miss _ _ O
) _ _ O
P2 _ _ O
writes _ _ O
20 _ _ O
to _ _ O
A _ _ O
( _ _ O
write _ _ O
hit _ _ O
) _ _ O
P2 _ _ O
writes _ _ O
40 _ _ O
to _ _ O
A _ _ O
( _ _ O
write _ _ O
hit _ _ O
) _ _ O
P1 _ _ O
write _ _ O
50 _ _ O
to _ _ O
A _ _ O
( _ _ O
write _ _ O
miss _ _ O
) _ _ O
In _ _ O
P2 _ _ O
’s _ _ O
cache _ _ O
L _ _ O
= _ _ O
invalid _ _ O
Read _ _ O
Exclusive _ _ O
A _ _ O
( _ _ O
from _ _ O
write _ _ O
in _ _ O
P1 _ _ O
) _ _ O
L _ _ O
 _ _ O
A _ _ O
= _ _ O
10 _ _ O
( _ _ O
modified _ _ O
) _ _ O
L _ _ O
= _ _ O
invalid _ _ O
L _ _ O
 _ _ O
A _ _ O
= _ _ O
10 _ _ O
( _ _ O
modified _ _ O
) _ _ O
L _ _ O
= _ _ O
invalid _ _ O
Read _ _ O
A _ _ O
( _ _ O
from _ _ O
read _ _ O
in _ _ O
P2 _ _ O
) _ _ O
L _ _ O
 _ _ O
A _ _ O
= _ _ O
10 _ _ O
( _ _ O
shared _ _ O
) _ _ O
L _ _ O
 _ _ O
A _ _ O
= _ _ O
10 _ _ O
( _ _ O
shared _ _ O
) _ _ O
Invalidate _ _ O
A _ _ O
( _ _ O
from _ _ O
write _ _ O
in _ _ O
P2 _ _ O
) _ _ O
L _ _ O
= _ _ O
invalid _ _ O
L _ _ O
 _ _ O
A _ _ O
= _ _ O
20 _ _ O
( _ _ O
modified _ _ O
) _ _ O
L _ _ O
= _ _ O
invalid _ _ O
L _ _ O
 _ _ O
A _ _ O
= _ _ O
40 _ _ O
( _ _ O
modified _ _ O
) _ _ O
Read _ _ O
Exclusive _ _ O
A _ _ O
( _ _ O
from _ _ O
write _ _ O
in _ _ O
P1 _ _ O
) _ _ O
L _ _ O
 _ _ O
A _ _ O
= _ _ O
50 _ _ O
( _ _ O
modified _ _ O
) _ _ O
L _ _ O
= _ _ O
invalid _ _ O
38 _ _ O

Cache _ _ O
Controller _ _ O
FSM _ _ O
for _ _ O
MSI _ _ O
Protocol _ _ O
● _ _ O
Processor _ _ O
activity _ _ O
in _ _ O
red _ _ O
, _ _ O
Bus _ _ O
activity _ _ O
in _ _ O
blue _ _ O
Read _ _ O
Write _ _ O
Read _ _ O
BusRead _ _ O
BusRead _ _ O
Modified _ _ O
Shared _ _ O
Write _ _ O
BusReadX _ _ O
BusReadX _ _ O
BusInvalidate _ _ O
Write _ _ O
• _ _ O
• _ _ O
Read _ _ O
• _ _ O
Invalid _ _ O
BusRead _ _ O
: _ _ O
Read _ _ O
request _ _ O
is _ _ O
snooped _ _ O
BusReadX _ _ O
: _ _ O
Read _ _ O
exclusive _ _ O
request _ _ O
is _ _ O
snooped _ _ O
• _ _ O
Sent _ _ O
by _ _ O
a _ _ O
processor _ _ O
on _ _ O
a _ _ O
write _ _ O
miss _ _ O
• _ _ O
Since _ _ O
line _ _ O
will _ _ O
be _ _ O
modified _ _ O
, _ _ O
need _ _ O
to _ _ O
invalidate _ _ O
BusInvalidate _ _ O
: _ _ O
Invalidate _ _ O
request _ _ O
is _ _ O
snooped _ _ O
• _ _ O
Sent _ _ O
on _ _ O
a _ _ O
write _ _ O
hit _ _ O
on _ _ O
shared _ _ O
cache _ _ O
line _ _ O
• _ _ O
To _ _ O
invalidate _ _ O
all _ _ O
other _ _ O
shared _ _ O
lines _ _ O
in _ _ O
system _ _ O
BusRead _ _ O
BusReadX _ _ O
BusInvalidate _ _ O
39 _ _ O

TLB _ _ O
Coherence _ _ O
40 _ _ O

How _ _ O
about _ _ O
TLBs _ _ O
? _ _ O
● _ _ O
We _ _ O
said _ _ O
TLBs _ _ O
are _ _ O
also _ _ O
a _ _ O
type _ _ O
of _ _ O
cache _ _ O
that _ _ O
caches _ _ O
PTEs _ _ O
. _ _ O
o _ _ O
So _ _ O
what _ _ O
happens _ _ O
if _ _ O
a _ _ O
processor _ _ O
changes _ _ O
a _ _ O
PTE _ _ O
? _ _ O
o _ _ O
How _ _ O
does _ _ O
that _ _ O
change _ _ O
get _ _ O
propagated _ _ O
to _ _ O
other _ _ O
processor _ _ O
TLBs _ _ O
? _ _ O
● _ _ O
Unfortunately _ _ O
, _ _ O
there _ _ O
is _ _ O
no _ _ O
hardware _ _ O
coherence _ _ O
for _ _ O
TLBs _ _ O
. _ _ O
 _ _ O
● _ _ O
That _ _ O
means _ _ O
software _ _ O
( _ _ O
the _ _ O
OS _ _ O
) _ _ O
must _ _ O
handle _ _ O
the _ _ O
coherence _ _ O
o _ _ O
Which _ _ O
is _ _ O
of _ _ O
course _ _ O
much _ _ O
much _ _ O
slower _ _ O
41 _ _ O

TLB _ _ O
shootdown _ _ O
● _ _ O
In _ _ O
order _ _ O
to _ _ O
update _ _ O
a _ _ O
PTE _ _ O
( _ _ O
page _ _ O
table _ _ O
entry _ _ O
) _ _ O
o _ _ O
Initiator _ _ O
OS _ _ O
must _ _ O
first _ _ O
flush _ _ O
its _ _ O
own _ _ O
TLB _ _ O
o _ _ O
Send _ _ O
IPIs _ _ O
( _ _ O
Inter-processor _ _ O
interrupts _ _ O
) _ _ O
to _ _ O
other _ _ O
processors _ _ O
▪ _ _ O
To _ _ O
flush _ _ O
the _ _ O
TLBs _ _ O
for _ _ O
all _ _ O
other _ _ O
processors _ _ O
too _ _ O
o _ _ O
Source _ _ O
of _ _ O
significant _ _ O
performance _ _ O
overhead _ _ O
* _ _ O
Courtesy _ _ O
of _ _ O
Nadav _ _ O
Amit _ _ O
et _ _ O
al _ _ O
. _ _ O
at _ _ O
VMWare _ _ O
42 _ _ O



