unlabeled|cs1550|lec10
-DOCSTART- -X- -X- O

Introduction _ _ O
to _ _ O
Operating _ _ O
Systems _ _ O
CS _ _ O
/ _ _ O
COE _ _ O
1550 _ _ O
Spring _ _ O
2022 _ _ O
Sherif _ _ O
Khattab _ _ O
ksm73@pitt.edu _ _ O
( _ _ O
Some _ _ O
slides _ _ O
are _ _ O
from _ _ O
Silberschatz _ _ O
, _ _ O
Galvin _ _ O
and _ _ O
Gagne _ _ O
© _ _ O
2013 _ _ O
) _ _ O

Announcements _ _ O
• _ _ O
Upcoming _ _ O
deadlines _ _ O
: _ _ O
• _ _ O
Project _ _ O
1 _ _ O
: _ _ O
due _ _ O
on _ _ O
2 _ _ O
/ _ _ O
18 _ _ O
• _ _ O
Homework _ _ O
5 _ _ O
: _ _ O
due _ _ O
2 _ _ O
/ _ _ O
21 _ _ O
• _ _ O
Lab _ _ O
2 _ _ O
: _ _ O
due _ _ O
on _ _ O
2 _ _ O
/ _ _ O
28 _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O

Previous _ _ O
lecture _ _ O
… _ _ O
• _ _ O
Dining _ _ O
philosophers _ _ O
• _ _ O
Deadlock _ _ O
prevention _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O

Muddiest _ _ O
Points _ _ O
• _ _ O
Checked _ _ O
on _ _ O
Tophat _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O

Questions _ _ O
of _ _ O
the _ _ O
Day _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O

Banker _ _ O
’s _ _ O
Algorithm _ _ O
We _ _ O
can _ _ O
use _ _ O
the _ _ O
same _ _ O
algorithm _ _ O
for _ _ O
both _ _ O
detecting _ _ O
and _ _ O
avoiding _ _ O
deadlocks _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O

Deadlock _ _ O
detection _ _ O
algorithm _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
Avail _ _ O
2 _ _ O
3 _ _ O
0 _ _ O
1 _ _ O
Hold _ _ O
Process _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
1 _ _ O
0 _ _ O
3 _ _ O
0 _ _ O
0 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
1 _ _ O
1 _ _ O
3 _ _ O
0 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
4 _ _ O
2 _ _ O
2 _ _ O
3 _ _ O
0 _ _ O
Want _ _ O
Process _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
1 _ _ O
3 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
2 _ _ O
2 _ _ O
2 _ _ O
0 _ _ O
0 _ _ O
3 _ _ O
3 _ _ O
5 _ _ O
3 _ _ O
1 _ _ O
4 _ _ O
0 _ _ O
4 _ _ O
1 _ _ O
1 _ _ O
current=avail _ _ O
; _ _ O
for _ _ O
( _ _ O
j _ _ O
= _ _ O
0 _ _ O
; _ _ O
j _ _ O
< _ _ O
N _ _ O
; _ _ O
j++ _ _ O
) _ _ O
{ _ _ O
for _ _ O
( _ _ O
k=0 _ _ O
; _ _ O
k _ _ O
< _ _ O
N _ _ O
; _ _ O
k++ _ _ O
) _ _ O
{ _ _ O
if _ _ O
( _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
) _ _ O
continue _ _ O
; _ _ O
if _ _ O
( _ _ O
want _ _ O
[ _ _ O
k _ _ O
] _ _ O
< _ _ O
= _ _ O
current _ _ O
) _ _ O
{ _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
= _ _ O
1 _ _ O
; _ _ O
current _ _ O
+ _ _ O
= _ _ O
hold _ _ O
[ _ _ O
k _ _ O
] _ _ O
; _ _ O
break _ _ O
; _ _ O
} _ _ O
} _ _ O
if _ _ O
( _ _ O
k==N _ _ O
) _ _ O
{ _ _ O
printf _ _ O
“ _ _ O
Deadlock _ _ O
! _ _ O
\n _ _ O
” _ _ O
; _ _ O
/ _ _ O
/ _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
==0 _ _ O
means _ _ O
process _ _ O
is _ _ O
in _ _ O
/ _ _ O
/ _ _ O
the _ _ O
deadlock _ _ O
break _ _ O
; _ _ O
} _ _ O
} _ _ O
Note _ _ O
: _ _ O
want _ _ O
[ _ _ O
j _ _ O
] _ _ O
, _ _ O
hold _ _ O
[ _ _ O
j _ _ O
] _ _ O
, _ _ O
current _ _ O
, _ _ O
avail _ _ O
are _ _ O
arrays _ _ O
! _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O

Deadlock _ _ O
detection _ _ O
algorithm _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
current _ _ O
2 _ _ O
3 _ _ O
0 _ _ O
1 _ _ O
Hold _ _ O
Process _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
1 _ _ O
0 _ _ O
3 _ _ O
0 _ _ O
0 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
1 _ _ O
1 _ _ O
3 _ _ O
0 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
4 _ _ O
2 _ _ O
2 _ _ O
3 _ _ O
0 _ _ O
Want _ _ O
Process _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
1 _ _ O
3 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
2 _ _ O
2 _ _ O
2 _ _ O
0 _ _ O
0 _ _ O
3 _ _ O
3 _ _ O
5 _ _ O
3 _ _ O
1 _ _ O
4 _ _ O
0 _ _ O
4 _ _ O
1 _ _ O
1 _ _ O
current=avail _ _ O
; _ _ O
for _ _ O
( _ _ O
j _ _ O
= _ _ O
0 _ _ O
; _ _ O
j _ _ O
< _ _ O
N _ _ O
; _ _ O
j++ _ _ O
) _ _ O
{ _ _ O
for _ _ O
( _ _ O
k=0 _ _ O
; _ _ O
k _ _ O
< _ _ O
N _ _ O
; _ _ O
k++ _ _ O
) _ _ O
{ _ _ O
if _ _ O
( _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
) _ _ O
continue _ _ O
; _ _ O
if _ _ O
( _ _ O
want _ _ O
[ _ _ O
k _ _ O
] _ _ O
< _ _ O
= _ _ O
current _ _ O
) _ _ O
{ _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
= _ _ O
1 _ _ O
; _ _ O
current _ _ O
+ _ _ O
= _ _ O
hold _ _ O
[ _ _ O
k _ _ O
] _ _ O
; _ _ O
break _ _ O
; _ _ O
} _ _ O
} _ _ O
if _ _ O
( _ _ O
k==N _ _ O
) _ _ O
{ _ _ O
printf _ _ O
“ _ _ O
Deadlock _ _ O
! _ _ O
\n _ _ O
” _ _ O
; _ _ O
/ _ _ O
/ _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
==0 _ _ O
means _ _ O
process _ _ O
is _ _ O
in _ _ O
/ _ _ O
/ _ _ O
the _ _ O
deadlock _ _ O
break _ _ O
; _ _ O
} _ _ O
} _ _ O
Note _ _ O
: _ _ O
want _ _ O
[ _ _ O
j _ _ O
] _ _ O
, _ _ O
hold _ _ O
[ _ _ O
j _ _ O
] _ _ O
, _ _ O
current _ _ O
, _ _ O
avail _ _ O
are _ _ O
arrays _ _ O
! _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O

Deadlock _ _ O
detection _ _ O
algorithm _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
current _ _ O
2 _ _ O
3 _ _ O
0 _ _ O
1 _ _ O
Hold _ _ O
Process _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
1 _ _ O
0 _ _ O
3 _ _ O
0 _ _ O
0 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
1 _ _ O
1 _ _ O
3 _ _ O
0 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
4 _ _ O
2 _ _ O
2 _ _ O
3 _ _ O
0 _ _ O
Want _ _ O
Process _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
1 _ _ O
3 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
2 _ _ O
2 _ _ O
2 _ _ O
0 _ _ O
0 _ _ O
3 _ _ O
3 _ _ O
5 _ _ O
3 _ _ O
1 _ _ O
4 _ _ O
0 _ _ O
4 _ _ O
1 _ _ O
1 _ _ O
current=avail _ _ O
; _ _ O
for _ _ O
( _ _ O
j _ _ O
= _ _ O
0 _ _ O
; _ _ O
j _ _ O
< _ _ O
N _ _ O
; _ _ O
j++ _ _ O
) _ _ O
{ _ _ O
for _ _ O
( _ _ O
k=0 _ _ O
; _ _ O
k _ _ O
< _ _ O
N _ _ O
; _ _ O
k++ _ _ O
) _ _ O
{ _ _ O
if _ _ O
( _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
) _ _ O
continue _ _ O
; _ _ O
if _ _ O
( _ _ O
want _ _ O
[ _ _ O
k _ _ O
] _ _ O
< _ _ O
= _ _ O
current _ _ O
) _ _ O
{ _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
= _ _ O
1 _ _ O
; _ _ O
current _ _ O
+ _ _ O
= _ _ O
hold _ _ O
[ _ _ O
k _ _ O
] _ _ O
; _ _ O
break _ _ O
; _ _ O
} _ _ O
} _ _ O
if _ _ O
( _ _ O
k==N _ _ O
) _ _ O
{ _ _ O
printf _ _ O
“ _ _ O
Deadlock _ _ O
! _ _ O
\n _ _ O
” _ _ O
; _ _ O
/ _ _ O
/ _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
==0 _ _ O
means _ _ O
process _ _ O
is _ _ O
in _ _ O
/ _ _ O
/ _ _ O
the _ _ O
deadlock _ _ O
break _ _ O
; _ _ O
} _ _ O
} _ _ O
Note _ _ O
: _ _ O
want _ _ O
[ _ _ O
j _ _ O
] _ _ O
, _ _ O
hold _ _ O
[ _ _ O
j _ _ O
] _ _ O
, _ _ O
current _ _ O
, _ _ O
avail _ _ O
are _ _ O
arrays _ _ O
! _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O

Deadlock _ _ O
detection _ _ O
algorithm _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
current _ _ O
3 _ _ O
3 _ _ O
1 _ _ O
2 _ _ O
Hold _ _ O
Process _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
1 _ _ O
0 _ _ O
3 _ _ O
0 _ _ O
0 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
1 _ _ O
1 _ _ O
3 _ _ O
0 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
4 _ _ O
2 _ _ O
2 _ _ O
3 _ _ O
0 _ _ O
Want _ _ O
Process _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
1 _ _ O
3 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
2 _ _ O
2 _ _ O
2 _ _ O
0 _ _ O
0 _ _ O
3 _ _ O
3 _ _ O
5 _ _ O
3 _ _ O
1 _ _ O
4 _ _ O
0 _ _ O
4 _ _ O
1 _ _ O
1 _ _ O
current=avail _ _ O
; _ _ O
for _ _ O
( _ _ O
j _ _ O
= _ _ O
0 _ _ O
; _ _ O
j _ _ O
< _ _ O
N _ _ O
; _ _ O
j++ _ _ O
) _ _ O
{ _ _ O
for _ _ O
( _ _ O
k=0 _ _ O
; _ _ O
k _ _ O
< _ _ O
N _ _ O
; _ _ O
k++ _ _ O
) _ _ O
{ _ _ O
if _ _ O
( _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
) _ _ O
continue _ _ O
; _ _ O
if _ _ O
( _ _ O
want _ _ O
[ _ _ O
k _ _ O
] _ _ O
< _ _ O
= _ _ O
current _ _ O
) _ _ O
{ _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
= _ _ O
1 _ _ O
; _ _ O
current _ _ O
+ _ _ O
= _ _ O
hold _ _ O
[ _ _ O
k _ _ O
] _ _ O
; _ _ O
break _ _ O
; _ _ O
} _ _ O
} _ _ O
if _ _ O
( _ _ O
k==N _ _ O
) _ _ O
{ _ _ O
printf _ _ O
“ _ _ O
Deadlock _ _ O
! _ _ O
\n _ _ O
” _ _ O
; _ _ O
/ _ _ O
/ _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
==0 _ _ O
means _ _ O
process _ _ O
is _ _ O
in _ _ O
/ _ _ O
/ _ _ O
the _ _ O
deadlock _ _ O
break _ _ O
; _ _ O
} _ _ O
} _ _ O
Note _ _ O
: _ _ O
want _ _ O
[ _ _ O
j _ _ O
] _ _ O
, _ _ O
hold _ _ O
[ _ _ O
j _ _ O
] _ _ O
, _ _ O
current _ _ O
, _ _ O
avail _ _ O
are _ _ O
arrays _ _ O
! _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O

Deadlock _ _ O
detection _ _ O
algorithm _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
current _ _ O
3 _ _ O
3 _ _ O
1 _ _ O
2 _ _ O
Hold _ _ O
Process _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
1 _ _ O
0 _ _ O
3 _ _ O
0 _ _ O
0 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
1 _ _ O
1 _ _ O
3 _ _ O
0 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
4 _ _ O
2 _ _ O
2 _ _ O
3 _ _ O
0 _ _ O
Want _ _ O
Process _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
1 _ _ O
3 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
2 _ _ O
2 _ _ O
2 _ _ O
0 _ _ O
0 _ _ O
3 _ _ O
3 _ _ O
5 _ _ O
3 _ _ O
1 _ _ O
4 _ _ O
0 _ _ O
4 _ _ O
1 _ _ O
1 _ _ O
current=avail _ _ O
; _ _ O
for _ _ O
( _ _ O
j _ _ O
= _ _ O
0 _ _ O
; _ _ O
j _ _ O
< _ _ O
N _ _ O
; _ _ O
j++ _ _ O
) _ _ O
{ _ _ O
for _ _ O
( _ _ O
k=0 _ _ O
; _ _ O
k _ _ O
< _ _ O
N _ _ O
; _ _ O
k++ _ _ O
) _ _ O
{ _ _ O
if _ _ O
( _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
) _ _ O
continue _ _ O
; _ _ O
if _ _ O
( _ _ O
want _ _ O
[ _ _ O
k _ _ O
] _ _ O
< _ _ O
= _ _ O
current _ _ O
) _ _ O
{ _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
= _ _ O
1 _ _ O
; _ _ O
current _ _ O
+ _ _ O
= _ _ O
hold _ _ O
[ _ _ O
k _ _ O
] _ _ O
; _ _ O
break _ _ O
; _ _ O
} _ _ O
} _ _ O
if _ _ O
( _ _ O
k==N _ _ O
) _ _ O
{ _ _ O
printf _ _ O
“ _ _ O
Deadlock _ _ O
! _ _ O
\n _ _ O
” _ _ O
; _ _ O
/ _ _ O
/ _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
==0 _ _ O
means _ _ O
process _ _ O
is _ _ O
in _ _ O
/ _ _ O
/ _ _ O
the _ _ O
deadlock _ _ O
break _ _ O
; _ _ O
} _ _ O
} _ _ O
Note _ _ O
: _ _ O
want _ _ O
[ _ _ O
j _ _ O
] _ _ O
, _ _ O
hold _ _ O
[ _ _ O
j _ _ O
] _ _ O
, _ _ O
current _ _ O
, _ _ O
avail _ _ O
are _ _ O
arrays _ _ O
! _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O

Deadlock _ _ O
detection _ _ O
algorithm _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
current _ _ O
3 _ _ O
3 _ _ O
1 _ _ O
2 _ _ O
Hold _ _ O
Process _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
1 _ _ O
0 _ _ O
3 _ _ O
0 _ _ O
0 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
1 _ _ O
1 _ _ O
3 _ _ O
0 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
4 _ _ O
2 _ _ O
2 _ _ O
3 _ _ O
0 _ _ O
Want _ _ O
Process _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
1 _ _ O
3 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
2 _ _ O
2 _ _ O
2 _ _ O
0 _ _ O
0 _ _ O
3 _ _ O
3 _ _ O
5 _ _ O
3 _ _ O
1 _ _ O
4 _ _ O
0 _ _ O
4 _ _ O
1 _ _ O
1 _ _ O
current=avail _ _ O
; _ _ O
for _ _ O
( _ _ O
j _ _ O
= _ _ O
0 _ _ O
; _ _ O
j _ _ O
< _ _ O
N _ _ O
; _ _ O
j++ _ _ O
) _ _ O
{ _ _ O
for _ _ O
( _ _ O
k=0 _ _ O
; _ _ O
k _ _ O
< _ _ O
N _ _ O
; _ _ O
k++ _ _ O
) _ _ O
{ _ _ O
if _ _ O
( _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
) _ _ O
continue _ _ O
; _ _ O
if _ _ O
( _ _ O
want _ _ O
[ _ _ O
k _ _ O
] _ _ O
< _ _ O
= _ _ O
current _ _ O
) _ _ O
{ _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
= _ _ O
1 _ _ O
; _ _ O
current _ _ O
+ _ _ O
= _ _ O
hold _ _ O
[ _ _ O
k _ _ O
] _ _ O
; _ _ O
break _ _ O
; _ _ O
} _ _ O
} _ _ O
if _ _ O
( _ _ O
k==N _ _ O
) _ _ O
{ _ _ O
printf _ _ O
“ _ _ O
Deadlock _ _ O
! _ _ O
\n _ _ O
” _ _ O
; _ _ O
/ _ _ O
/ _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
==0 _ _ O
means _ _ O
process _ _ O
is _ _ O
in _ _ O
/ _ _ O
/ _ _ O
the _ _ O
deadlock _ _ O
break _ _ O
; _ _ O
} _ _ O
} _ _ O
Note _ _ O
: _ _ O
want _ _ O
[ _ _ O
j _ _ O
] _ _ O
, _ _ O
hold _ _ O
[ _ _ O
j _ _ O
] _ _ O
, _ _ O
current _ _ O
, _ _ O
avail _ _ O
are _ _ O
arrays _ _ O
! _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O

Deadlock _ _ O
detection _ _ O
algorithm _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
current _ _ O
3 _ _ O
3 _ _ O
1 _ _ O
2 _ _ O
Hold _ _ O
Process _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
1 _ _ O
0 _ _ O
3 _ _ O
0 _ _ O
0 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
1 _ _ O
1 _ _ O
3 _ _ O
0 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
4 _ _ O
2 _ _ O
2 _ _ O
3 _ _ O
0 _ _ O
Want _ _ O
Process _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
1 _ _ O
3 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
2 _ _ O
2 _ _ O
2 _ _ O
0 _ _ O
0 _ _ O
3 _ _ O
3 _ _ O
5 _ _ O
3 _ _ O
1 _ _ O
4 _ _ O
0 _ _ O
4 _ _ O
1 _ _ O
1 _ _ O
current=avail _ _ O
; _ _ O
for _ _ O
( _ _ O
j _ _ O
= _ _ O
0 _ _ O
; _ _ O
j _ _ O
< _ _ O
N _ _ O
; _ _ O
j++ _ _ O
) _ _ O
{ _ _ O
for _ _ O
( _ _ O
k=0 _ _ O
; _ _ O
k _ _ O
< _ _ O
N _ _ O
; _ _ O
k++ _ _ O
) _ _ O
{ _ _ O
if _ _ O
( _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
) _ _ O
continue _ _ O
; _ _ O
if _ _ O
( _ _ O
want _ _ O
[ _ _ O
k _ _ O
] _ _ O
< _ _ O
= _ _ O
current _ _ O
) _ _ O
{ _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
= _ _ O
1 _ _ O
; _ _ O
current _ _ O
+ _ _ O
= _ _ O
hold _ _ O
[ _ _ O
k _ _ O
] _ _ O
; _ _ O
break _ _ O
; _ _ O
} _ _ O
} _ _ O
if _ _ O
( _ _ O
k==N _ _ O
) _ _ O
{ _ _ O
printf _ _ O
“ _ _ O
Deadlock _ _ O
! _ _ O
\n _ _ O
” _ _ O
; _ _ O
/ _ _ O
/ _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
==0 _ _ O
means _ _ O
process _ _ O
is _ _ O
in _ _ O
/ _ _ O
/ _ _ O
the _ _ O
deadlock _ _ O
break _ _ O
; _ _ O
} _ _ O
} _ _ O
Note _ _ O
: _ _ O
want _ _ O
[ _ _ O
j _ _ O
] _ _ O
, _ _ O
hold _ _ O
[ _ _ O
j _ _ O
] _ _ O
, _ _ O
current _ _ O
, _ _ O
avail _ _ O
are _ _ O
arrays _ _ O
! _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O

Deadlock _ _ O
detection _ _ O
algorithm _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
current _ _ O
3 _ _ O
6 _ _ O
1 _ _ O
2 _ _ O
Hold _ _ O
Process _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
1 _ _ O
0 _ _ O
3 _ _ O
0 _ _ O
0 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
1 _ _ O
1 _ _ O
3 _ _ O
0 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
4 _ _ O
2 _ _ O
2 _ _ O
3 _ _ O
0 _ _ O
Want _ _ O
Process _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
1 _ _ O
3 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
2 _ _ O
2 _ _ O
2 _ _ O
0 _ _ O
0 _ _ O
3 _ _ O
3 _ _ O
5 _ _ O
3 _ _ O
1 _ _ O
4 _ _ O
0 _ _ O
4 _ _ O
1 _ _ O
1 _ _ O
current=avail _ _ O
; _ _ O
for _ _ O
( _ _ O
j _ _ O
= _ _ O
0 _ _ O
; _ _ O
j _ _ O
< _ _ O
N _ _ O
; _ _ O
j++ _ _ O
) _ _ O
{ _ _ O
for _ _ O
( _ _ O
k=0 _ _ O
; _ _ O
k _ _ O
< _ _ O
N _ _ O
; _ _ O
k++ _ _ O
) _ _ O
{ _ _ O
if _ _ O
( _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
) _ _ O
continue _ _ O
; _ _ O
if _ _ O
( _ _ O
want _ _ O
[ _ _ O
k _ _ O
] _ _ O
< _ _ O
= _ _ O
current _ _ O
) _ _ O
{ _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
= _ _ O
1 _ _ O
; _ _ O
current _ _ O
+ _ _ O
= _ _ O
hold _ _ O
[ _ _ O
k _ _ O
] _ _ O
; _ _ O
break _ _ O
; _ _ O
} _ _ O
} _ _ O
if _ _ O
( _ _ O
k==N _ _ O
) _ _ O
{ _ _ O
printf _ _ O
“ _ _ O
Deadlock _ _ O
! _ _ O
\n _ _ O
” _ _ O
; _ _ O
/ _ _ O
/ _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
==0 _ _ O
means _ _ O
process _ _ O
is _ _ O
in _ _ O
/ _ _ O
/ _ _ O
the _ _ O
deadlock _ _ O
break _ _ O
; _ _ O
} _ _ O
} _ _ O
Note _ _ O
: _ _ O
want _ _ O
[ _ _ O
j _ _ O
] _ _ O
, _ _ O
hold _ _ O
[ _ _ O
j _ _ O
] _ _ O
, _ _ O
current _ _ O
, _ _ O
avail _ _ O
are _ _ O
arrays _ _ O
! _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O

Deadlock _ _ O
detection _ _ O
algorithm _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
current _ _ O
3 _ _ O
6 _ _ O
1 _ _ O
2 _ _ O
Hold _ _ O
Process _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
1 _ _ O
0 _ _ O
3 _ _ O
0 _ _ O
0 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
1 _ _ O
1 _ _ O
3 _ _ O
0 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
4 _ _ O
2 _ _ O
2 _ _ O
3 _ _ O
0 _ _ O
Want _ _ O
Process _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
1 _ _ O
3 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
2 _ _ O
2 _ _ O
2 _ _ O
0 _ _ O
0 _ _ O
3 _ _ O
3 _ _ O
5 _ _ O
3 _ _ O
1 _ _ O
4 _ _ O
0 _ _ O
4 _ _ O
1 _ _ O
1 _ _ O
current=avail _ _ O
; _ _ O
for _ _ O
( _ _ O
j _ _ O
= _ _ O
0 _ _ O
; _ _ O
j _ _ O
< _ _ O
N _ _ O
; _ _ O
j++ _ _ O
) _ _ O
{ _ _ O
for _ _ O
( _ _ O
k=0 _ _ O
; _ _ O
k _ _ O
< _ _ O
N _ _ O
; _ _ O
k++ _ _ O
) _ _ O
{ _ _ O
if _ _ O
( _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
) _ _ O
continue _ _ O
; _ _ O
if _ _ O
( _ _ O
want _ _ O
[ _ _ O
k _ _ O
] _ _ O
< _ _ O
= _ _ O
current _ _ O
) _ _ O
{ _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
= _ _ O
1 _ _ O
; _ _ O
current _ _ O
+ _ _ O
= _ _ O
hold _ _ O
[ _ _ O
k _ _ O
] _ _ O
; _ _ O
break _ _ O
; _ _ O
} _ _ O
} _ _ O
if _ _ O
( _ _ O
k==N _ _ O
) _ _ O
{ _ _ O
printf _ _ O
“ _ _ O
Deadlock _ _ O
! _ _ O
\n _ _ O
” _ _ O
; _ _ O
/ _ _ O
/ _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
==0 _ _ O
means _ _ O
process _ _ O
is _ _ O
in _ _ O
/ _ _ O
/ _ _ O
the _ _ O
deadlock _ _ O
break _ _ O
; _ _ O
} _ _ O
} _ _ O
Note _ _ O
: _ _ O
want _ _ O
[ _ _ O
j _ _ O
] _ _ O
, _ _ O
hold _ _ O
[ _ _ O
j _ _ O
] _ _ O
, _ _ O
current _ _ O
, _ _ O
avail _ _ O
are _ _ O
arrays _ _ O
! _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O

Deadlock _ _ O
detection _ _ O
algorithm _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
current _ _ O
5 _ _ O
8 _ _ O
4 _ _ O
2 _ _ O
Hold _ _ O
Process _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
1 _ _ O
0 _ _ O
3 _ _ O
0 _ _ O
0 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
1 _ _ O
1 _ _ O
3 _ _ O
0 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
4 _ _ O
2 _ _ O
2 _ _ O
3 _ _ O
0 _ _ O
Want _ _ O
Process _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
1 _ _ O
3 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
2 _ _ O
2 _ _ O
2 _ _ O
0 _ _ O
0 _ _ O
3 _ _ O
3 _ _ O
5 _ _ O
3 _ _ O
1 _ _ O
4 _ _ O
0 _ _ O
4 _ _ O
1 _ _ O
1 _ _ O
current=avail _ _ O
; _ _ O
for _ _ O
( _ _ O
j _ _ O
= _ _ O
0 _ _ O
; _ _ O
j _ _ O
< _ _ O
N _ _ O
; _ _ O
j++ _ _ O
) _ _ O
{ _ _ O
for _ _ O
( _ _ O
k=0 _ _ O
; _ _ O
k _ _ O
< _ _ O
N _ _ O
; _ _ O
k++ _ _ O
) _ _ O
{ _ _ O
if _ _ O
( _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
) _ _ O
continue _ _ O
; _ _ O
if _ _ O
( _ _ O
want _ _ O
[ _ _ O
k _ _ O
] _ _ O
< _ _ O
= _ _ O
current _ _ O
) _ _ O
{ _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
= _ _ O
1 _ _ O
; _ _ O
current _ _ O
+ _ _ O
= _ _ O
hold _ _ O
[ _ _ O
k _ _ O
] _ _ O
; _ _ O
break _ _ O
; _ _ O
} _ _ O
} _ _ O
if _ _ O
( _ _ O
k==N _ _ O
) _ _ O
{ _ _ O
printf _ _ O
“ _ _ O
Deadlock _ _ O
! _ _ O
\n _ _ O
” _ _ O
; _ _ O
/ _ _ O
/ _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
==0 _ _ O
means _ _ O
process _ _ O
is _ _ O
in _ _ O
/ _ _ O
/ _ _ O
the _ _ O
deadlock _ _ O
break _ _ O
; _ _ O
} _ _ O
} _ _ O
Note _ _ O
: _ _ O
want _ _ O
[ _ _ O
j _ _ O
] _ _ O
, _ _ O
hold _ _ O
[ _ _ O
j _ _ O
] _ _ O
, _ _ O
current _ _ O
, _ _ O
avail _ _ O
are _ _ O
arrays _ _ O
! _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O

Deadlock _ _ O
detection _ _ O
algorithm _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
current _ _ O
5 _ _ O
8 _ _ O
4 _ _ O
2 _ _ O
Hold _ _ O
Process _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
1 _ _ O
0 _ _ O
3 _ _ O
0 _ _ O
0 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
1 _ _ O
1 _ _ O
3 _ _ O
0 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
4 _ _ O
2 _ _ O
2 _ _ O
3 _ _ O
0 _ _ O
Want _ _ O
Process _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
1 _ _ O
3 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
2 _ _ O
2 _ _ O
2 _ _ O
0 _ _ O
0 _ _ O
3 _ _ O
3 _ _ O
5 _ _ O
3 _ _ O
1 _ _ O
4 _ _ O
0 _ _ O
4 _ _ O
1 _ _ O
1 _ _ O
current=avail _ _ O
; _ _ O
for _ _ O
( _ _ O
j _ _ O
= _ _ O
0 _ _ O
; _ _ O
j _ _ O
< _ _ O
N _ _ O
; _ _ O
j++ _ _ O
) _ _ O
{ _ _ O
for _ _ O
( _ _ O
k=0 _ _ O
; _ _ O
k _ _ O
< _ _ O
N _ _ O
; _ _ O
k++ _ _ O
) _ _ O
{ _ _ O
if _ _ O
( _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
) _ _ O
continue _ _ O
; _ _ O
if _ _ O
( _ _ O
want _ _ O
[ _ _ O
k _ _ O
] _ _ O
< _ _ O
= _ _ O
current _ _ O
) _ _ O
{ _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
= _ _ O
1 _ _ O
; _ _ O
current _ _ O
+ _ _ O
= _ _ O
hold _ _ O
[ _ _ O
k _ _ O
] _ _ O
; _ _ O
break _ _ O
; _ _ O
} _ _ O
} _ _ O
if _ _ O
( _ _ O
k==N _ _ O
) _ _ O
{ _ _ O
printf _ _ O
“ _ _ O
Deadlock _ _ O
! _ _ O
\n _ _ O
” _ _ O
; _ _ O
/ _ _ O
/ _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
==0 _ _ O
means _ _ O
process _ _ O
is _ _ O
in _ _ O
/ _ _ O
/ _ _ O
the _ _ O
deadlock _ _ O
break _ _ O
; _ _ O
} _ _ O
} _ _ O
Note _ _ O
: _ _ O
want _ _ O
[ _ _ O
j _ _ O
] _ _ O
, _ _ O
hold _ _ O
[ _ _ O
j _ _ O
] _ _ O
, _ _ O
current _ _ O
, _ _ O
avail _ _ O
are _ _ O
arrays _ _ O
! _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O

Deadlock _ _ O
detection _ _ O
algorithm _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
current _ _ O
5 _ _ O
10 _ _ O
5 _ _ O
2 _ _ O
Hold _ _ O
Process _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
1 _ _ O
0 _ _ O
3 _ _ O
0 _ _ O
0 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
1 _ _ O
1 _ _ O
3 _ _ O
0 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
4 _ _ O
2 _ _ O
2 _ _ O
3 _ _ O
0 _ _ O
Want _ _ O
Process _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
1 _ _ O
3 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
2 _ _ O
2 _ _ O
2 _ _ O
0 _ _ O
0 _ _ O
3 _ _ O
3 _ _ O
5 _ _ O
3 _ _ O
1 _ _ O
4 _ _ O
0 _ _ O
4 _ _ O
1 _ _ O
1 _ _ O
current=avail _ _ O
; _ _ O
for _ _ O
( _ _ O
j _ _ O
= _ _ O
0 _ _ O
; _ _ O
j _ _ O
< _ _ O
N _ _ O
; _ _ O
j++ _ _ O
) _ _ O
{ _ _ O
for _ _ O
( _ _ O
k=0 _ _ O
; _ _ O
k _ _ O
< _ _ O
N _ _ O
; _ _ O
k++ _ _ O
) _ _ O
{ _ _ O
if _ _ O
( _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
) _ _ O
continue _ _ O
; _ _ O
if _ _ O
( _ _ O
want _ _ O
[ _ _ O
k _ _ O
] _ _ O
< _ _ O
= _ _ O
current _ _ O
) _ _ O
{ _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
= _ _ O
1 _ _ O
; _ _ O
current _ _ O
+ _ _ O
= _ _ O
hold _ _ O
[ _ _ O
k _ _ O
] _ _ O
; _ _ O
break _ _ O
; _ _ O
} _ _ O
} _ _ O
if _ _ O
( _ _ O
k==N _ _ O
) _ _ O
{ _ _ O
printf _ _ O
“ _ _ O
Deadlock _ _ O
! _ _ O
\n _ _ O
” _ _ O
; _ _ O
/ _ _ O
/ _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
==0 _ _ O
means _ _ O
process _ _ O
is _ _ O
in _ _ O
/ _ _ O
/ _ _ O
the _ _ O
deadlock _ _ O
break _ _ O
; _ _ O
} _ _ O
} _ _ O
Note _ _ O
: _ _ O
want _ _ O
[ _ _ O
j _ _ O
] _ _ O
, _ _ O
hold _ _ O
[ _ _ O
j _ _ O
] _ _ O
, _ _ O
current _ _ O
, _ _ O
avail _ _ O
are _ _ O
arrays _ _ O
! _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O

Deadlock _ _ O
detection _ _ O
algorithm _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
current _ _ O
5 _ _ O
10 _ _ O
5 _ _ O
2 _ _ O
Hold _ _ O
Process _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
1 _ _ O
0 _ _ O
3 _ _ O
0 _ _ O
0 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
1 _ _ O
1 _ _ O
3 _ _ O
0 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
4 _ _ O
2 _ _ O
2 _ _ O
3 _ _ O
0 _ _ O
Want _ _ O
Process _ _ O
A _ _ O
B _ _ O
C _ _ O
D _ _ O
1 _ _ O
3 _ _ O
2 _ _ O
1 _ _ O
0 _ _ O
2 _ _ O
2 _ _ O
2 _ _ O
0 _ _ O
0 _ _ O
3 _ _ O
3 _ _ O
5 _ _ O
3 _ _ O
1 _ _ O
4 _ _ O
0 _ _ O
4 _ _ O
1 _ _ O
1 _ _ O
current=avail _ _ O
; _ _ O
for _ _ O
( _ _ O
j _ _ O
= _ _ O
0 _ _ O
; _ _ O
j _ _ O
< _ _ O
N _ _ O
; _ _ O
j++ _ _ O
) _ _ O
{ _ _ O
for _ _ O
( _ _ O
k=0 _ _ O
; _ _ O
k _ _ O
< _ _ O
N _ _ O
; _ _ O
k++ _ _ O
) _ _ O
{ _ _ O
if _ _ O
( _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
) _ _ O
continue _ _ O
; _ _ O
if _ _ O
( _ _ O
want _ _ O
[ _ _ O
k _ _ O
] _ _ O
< _ _ O
= _ _ O
current _ _ O
) _ _ O
{ _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
= _ _ O
1 _ _ O
; _ _ O
current _ _ O
+ _ _ O
= _ _ O
hold _ _ O
[ _ _ O
k _ _ O
] _ _ O
; _ _ O
break _ _ O
; _ _ O
} _ _ O
} _ _ O
if _ _ O
( _ _ O
k==N _ _ O
) _ _ O
{ _ _ O
printf _ _ O
“ _ _ O
Deadlock _ _ O
! _ _ O
\n _ _ O
” _ _ O
; _ _ O
/ _ _ O
/ _ _ O
finished _ _ O
[ _ _ O
k _ _ O
] _ _ O
==0 _ _ O
means _ _ O
process _ _ O
is _ _ O
in _ _ O
/ _ _ O
/ _ _ O
the _ _ O
deadlock _ _ O
break _ _ O
; _ _ O
} _ _ O
} _ _ O
Note _ _ O
: _ _ O
want _ _ O
[ _ _ O
j _ _ O
] _ _ O
, _ _ O
hold _ _ O
[ _ _ O
j _ _ O
] _ _ O
, _ _ O
current _ _ O
, _ _ O
avail _ _ O
are _ _ O
arrays _ _ O
! _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O

Banker _ _ O
’s _ _ O
Algorithm _ _ O
Insights _ _ O
• _ _ O
It _ _ O
is _ _ O
possible _ _ O
that _ _ O
some _ _ O
event _ _ O
sequences _ _ O
lead _ _ O
a _ _ O
deadlock _ _ O
• _ _ O
What _ _ O
we _ _ O
are _ _ O
looking _ _ O
for _ _ O
is _ _ O
at _ _ O
least _ _ O
one _ _ O
event _ _ O
sequence _ _ O
that _ _ O
can _ _ O
make _ _ O
all _ _ O
processes _ _ O
finish _ _ O
• _ _ O
If _ _ O
such _ _ O
sequence _ _ O
exists _ _ O
, _ _ O
the _ _ O
state _ _ O
is _ _ O
safe _ _ O
• _ _ O
The _ _ O
Banker _ _ O
’s _ _ O
algorithm _ _ O
finds _ _ O
such _ _ O
sequence _ _ O
if _ _ O
it _ _ O
exists _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O

Using _ _ O
the _ _ O
Banker _ _ O
’s _ _ O
Algorithm _ _ O
for _ _ O
Deadlock _ _ O
Avoidance _ _ O
• _ _ O
Call _ _ O
the _ _ O
algorithm _ _ O
on _ _ O
the _ _ O
following _ _ O

Proof _ _ O
sketch _ _ O
for _ _ O
Deadlock _ _ O
Prevention _ _ O
• _ _ O
If _ _ O
resources _ _ O
are _ _ O
ordered _ _ O
and _ _ O
resource _ _ O
requests _ _ O
within _ _ O
each _ _ O
process _ _ O
follow _ _ O
the _ _ O
resource _ _ O
ordering _ _ O
, _ _ O
the _ _ O
resource _ _ O
allocation _ _ O
graph _ _ O
will _ _ O
have _ _ O
no _ _ O
downward _ _ O
arrows _ _ O
. _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O

Problem _ _ O
of _ _ O
the _ _ O
Day _ _ O
: _ _ O
Sleepy _ _ O
Barbers _ _ O
• _ _ O
We _ _ O
have _ _ O
two _ _ O
sets _ _ O
of _ _ O
processes _ _ O
• _ _ O
• _ _ O
Worker _ _ O
processes _ _ O
( _ _ O
e.g. _ _ O
, _ _ O
barbers _ _ O
) _ _ O
Customer _ _ O
processes _ _ O
• _ _ O
Customer _ _ O
processes _ _ O
may _ _ O
arrive _ _ O
at _ _ O
anytime _ _ O
• _ _ O
Worker _ _ O
processes _ _ O
check _ _ O
in _ _ O
when _ _ O
they _ _ O
are _ _ O
not _ _ O
serving _ _ O
any _ _ O
customers _ _ O
• _ _ O
Each _ _ O
worker _ _ O
process _ _ O
must _ _ O
wait _ _ O
until _ _ O
it _ _ O
gets _ _ O
matched _ _ O
with _ _ O
a _ _ O
customer _ _ O
process _ _ O
• _ _ O
Each _ _ O
customer _ _ O
process _ _ O
must _ _ O
wait _ _ O
until _ _ O
it _ _ O
gets _ _ O
matched _ _ O
with _ _ O
a _ _ O
worker _ _ O
process _ _ O
• _ _ O
The _ _ O
customer _ _ O
process _ _ O
can _ _ O
not _ _ O
leave _ _ O
until _ _ O
the _ _ O
matched _ _ O
worker _ _ O
process _ _ O
finishes _ _ O
the _ _ O
work _ _ O
• _ _ O
The _ _ O
worker _ _ O
process _ _ O
can _ _ O
not _ _ O
check _ _ O
in _ _ O
for _ _ O
the _ _ O
next _ _ O
customer _ _ O
until _ _ O
the _ _ O
matched _ _ O
customer _ _ O
process _ _ O
leaves _ _ O
• _ _ O
Many _ _ O
applications _ _ O
in _ _ O
the _ _ O
real-world _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O

Rendezvous _ _ O
Pattern _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O

Solution _ _ O
Using _ _ O
Semaphores _ _ O
: _ _ O
Take _ _ O
1 _ _ O
• _ _ O
One _ _ O
pair _ _ O
of _ _ O
semaphores _ _ O
per _ _ O
rendezvous _ _ O
• _ _ O
RV1a _ _ O
and _ _ O
RV1b _ _ O
• _ _ O
RV2a _ _ O
and _ _ O
RV2b _ _ O
• _ _ O
Notice _ _ O
the _ _ O
flipped _ _ O
order _ _ O
of _ _ O
the _ _ O
down _ _ O
and _ _ O
up _ _ O
calls _ _ O
in _ _ O
the _ _ O
two _ _ O
processes _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O

Solution _ _ O
Using _ _ O
Semaphores _ _ O
: _ _ O
Take _ _ O
1 _ _ O
• _ _ O
This _ _ O
solution _ _ O
does _ _ O
n’t _ _ O
work _ _ O
for _ _ O
multiple _ _ O
workers _ _ O
and _ _ O
multiple _ _ O
customers _ _ O
• _ _ O
A _ _ O
customer _ _ O
can _ _ O
leave _ _ O
before _ _ O
its _ _ O
associated _ _ O
worker _ _ O
finishes _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O



