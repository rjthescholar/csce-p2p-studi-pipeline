unlabeled|cs1550|lec11
-DOCSTART- -X- -X- O

Introduction _ _ O
to _ _ O
Operating _ _ O
Systems _ _ O
CS _ _ O
/ _ _ O
COE _ _ O
1550 _ _ O
Spring _ _ O
2022 _ _ O
Sherif _ _ O
Khattab _ _ O
ksm73@pitt.edu _ _ O
( _ _ O
Some _ _ O
slides _ _ O
are _ _ O
from _ _ O
Silberschatz _ _ O
, _ _ O
Galvin _ _ O
and _ _ O
Gagne _ _ O
© _ _ O
2013 _ _ O
) _ _ O

Announcements _ _ O
• _ _ O
Upcoming _ _ O
deadlines _ _ O
: _ _ O
• _ _ O
Project _ _ O
1 _ _ O
: _ _ O
due _ _ O
on _ _ O
2 _ _ O
/ _ _ O
18 _ _ O
• _ _ O
Homework _ _ O
5 _ _ O
: _ _ O
due _ _ O
2 _ _ O
/ _ _ O
21 _ _ O
• _ _ O
Lab _ _ O
2 _ _ O
: _ _ O
due _ _ O
on _ _ O
2 _ _ O
/ _ _ O
28 _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O

Previous _ _ O
lecture _ _ O
… _ _ O
• _ _ O
Deadlock _ _ O
detection _ _ O
and _ _ O
avoidance _ _ O
using _ _ O
the _ _ O
Banker _ _ O
’s _ _ O
algorithm _ _ O
• _ _ O
Sleepy _ _ O
Barbers _ _ O
problem _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O

Muddiest _ _ O
Points _ _ O
• _ _ O
Checked _ _ O
on _ _ O
Tophat _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O

Sleepy _ _ O
Barbers _ _ O
Solution _ _ O
: _ _ O
Take _ _ O
2 _ _ O
struct _ _ O
mysems _ _ O
{ _ _ O
Semaphore _ _ O
RV1a _ _ O
( _ _ O
0 _ _ O
) _ _ O
, _ _ O
RV1b _ _ O
( _ _ O
0 _ _ O
) _ _ O
, _ _ O
RV2a _ _ O
( _ _ O
0 _ _ O
) _ _ O
, _ _ O
RV2b _ _ O
( _ _ O
0 _ _ O
) _ _ O
; _ _ O
} _ _ O
; _ _ O
SharedBuffer _ _ O
buff _ _ O
; _ _ O
/ _ _ O
/ _ _ O
producers-consumers _ _ O
problem _ _ O
Worker _ _ O
Process _ _ O
Customer _ _ O
Process _ _ O
struct _ _ O
mysems _ _ O
sems _ _ O
= _ _ O
buff.consume _ _ O
( _ _ O
) _ _ O
; _ _ O
struct _ _ O
mysems _ _ O
sems _ _ O
= _ _ O
new _ _ O
struct _ _ O
mysems _ _ O
up _ _ O
( _ _ O
sems.RV1a _ _ O
) _ _ O
; _ _ O
buff.produce _ _ O
( _ _ O
sems _ _ O
) _ _ O
; _ _ O
down _ _ O
( _ _ O
sems.RV1b _ _ O
) _ _ O
; _ _ O
down _ _ O
( _ _ O
sems.RV1a _ _ O
) _ _ O
; _ _ O
/ _ _ O
/ _ _ O
do _ _ O
work _ _ O
up _ _ O
( _ _ O
sems.RV1b _ _ O
) _ _ O
; _ _ O
down _ _ O
( _ _ O
sems.RV2a _ _ O
) _ _ O
; _ _ O
/ _ _ O
/ _ _ O
get _ _ O
work _ _ O
up _ _ O
( _ _ O
sems.RV2b _ _ O
) _ _ O
; _ _ O
up _ _ O
( _ _ O
sems.RV2a _ _ O
) _ _ O
; _ _ O
/ _ _ O
/ _ _ O
check-in _ _ O
for _ _ O
next _ _ O
customer _ _ O
down _ _ O
( _ _ O
sems.RV2b _ _ O
) _ _ O
; _ _ O
/ _ _ O
/ _ _ O
leave _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O

Questions _ _ O
of _ _ O
the _ _ O
Day _ _ O
• _ _ O
How _ _ O
to _ _ O
implement _ _ O
condition _ _ O
variables _ _ O
? _ _ O
• _ _ O
Reflect _ _ O
more _ _ O
on _ _ O
all _ _ O
the _ _ O
solutions _ _ O
/ _ _ O
problems _ _ O
that _ _ O
we _ _ O
have _ _ O
studied _ _ O

User-level _ _ O
implementation _ _ O
of _ _ O
Condition _ _ O
Variables _ _ O
A _ _ O
Lock _ _ O
with _ _ O
two _ _ O
waiting _ _ O
queues _ _ O
struct _ _ O
Lock _ _ O
{ _ _ O
Semaphore _ _ O
mutex _ _ O
( _ _ O
1 _ _ O
) _ _ O
; _ _ O
Semaphore _ _ O
next _ _ O
( _ _ O
0 _ _ O
) _ _ O
; _ _ O
int _ _ O
nextCount _ _ O
= _ _ O
0 _ _ O
; _ _ O
Release _ _ O
( _ _ O
) _ _ O
{ _ _ O
} _ _ O
if _ _ O
( _ _ O
nextCount _ _ O
> _ _ O
0 _ _ O
) _ _ O
{ _ _ O
Acquire _ _ O
( _ _ O
) _ _ O
{ _ _ O
next.up _ _ O
( _ _ O
) _ _ O
; _ _ O
mutex.down _ _ O
( _ _ O
) _ _ O
; _ _ O
nextCount-- _ _ O
; _ _ O
} _ _ O
} _ _ O
else _ _ O
mutex.up _ _ O
( _ _ O
) _ _ O
; _ _ O
} _ _ O

Condition _ _ O
Variable _ _ O
struct _ _ O
ConditionVariable _ _ O
{ _ _ O
Semaphore _ _ O
condSem _ _ O
( _ _ O
0 _ _ O
) _ _ O
; _ _ O
int _ _ O
semCount _ _ O
= _ _ O
0 _ _ O
; _ _ O
Lock _ _ O
* _ _ O
lk _ _ O
; _ _ O
} _ _ O
Wait _ _ O
( _ _ O
) _ _ O
{ _ _ O
if _ _ O
( _ _ O
lk- _ _ O
> _ _ O
nextCount _ _ O
> _ _ O
0 _ _ O
) _ _ O
Signal _ _ O
( _ _ O
) _ _ O
{ _ _ O
lk- _ _ O
> _ _ O
next.up _ _ O
( _ _ O
) _ _ O
; _ _ O
if _ _ O
( _ _ O
semCount _ _ O
> _ _ O
0 _ _ O
) _ _ O
{ _ _ O
lk- _ _ O
> _ _ O
nextCount-- _ _ O
; _ _ O
condSem.up _ _ O
( _ _ O
) _ _ O
lk- _ _ O
> _ _ O
nextCount++ _ _ O
else _ _ O
{ _ _ O
lk- _ _ O
> _ _ O
next.down _ _ O
( _ _ O
) _ _ O
; _ _ O
lk- _ _ O
> _ _ O
mutex.up _ _ O
( _ _ O
) _ _ O
; _ _ O
lk- _ _ O
> _ _ O
nextCount _ _ O
— _ _ O
} _ _ O
semCount++ _ _ O
; _ _ O
condSem.down _ _ O
( _ _ O
) _ _ O
; _ _ O
semCount-- _ _ O
; _ _ O
} _ _ O
} _ _ O
} _ _ O

Lock _ _ O
and _ _ O
Condition _ _ O
Variable _ _ O
Implementation _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O

Implementing _ _ O
locks _ _ O
with _ _ O
semaphores _ _ O
• _ _ O
Use _ _ O
mutex _ _ O
to _ _ O
ensure _ _ O
exclusion _ _ O
within _ _ O
the _ _ O
lock _ _ O
bounds _ _ O
• _ _ O
Use _ _ O
next _ _ O
to _ _ O
give _ _ O
lock _ _ O
to _ _ O
processes _ _ O
with _ _ O
a _ _ O
higher _ _ O
priority _ _ O
( _ _ O
why _ _ O
? _ _ O
) _ _ O
• _ _ O
nextCount _ _ O
indicates _ _ O
whether _ _ O
there _ _ O
are _ _ O
any _ _ O
higher _ _ O
priority _ _ O
waiters _ _ O
class _ _ O
Lock _ _ O
{ _ _ O
Semaphore _ _ O
mutex _ _ O
( _ _ O
1 _ _ O
) _ _ O
; _ _ O
Semaphore _ _ O
next _ _ O
( _ _ O
0 _ _ O
) _ _ O
; _ _ O
int _ _ O
nextCount _ _ O
= _ _ O
0 _ _ O
; _ _ O
} _ _ O
; _ _ O
Lock _ _ O
: _ _ O
: _ _ O
Acquire _ _ O
( _ _ O
) _ _ O
{ _ _ O
mutex.down _ _ O
( _ _ O
) _ _ O
; _ _ O
} _ _ O
Lock _ _ O
: _ _ O
: _ _ O
Release _ _ O
( _ _ O
) _ _ O
{ _ _ O
if _ _ O
( _ _ O
nextCount _ _ O
> _ _ O
0 _ _ O
) _ _ O
next.up _ _ O
( _ _ O
) _ _ O
; _ _ O
else _ _ O
mutex.up _ _ O
( _ _ O
) _ _ O
; _ _ O
} _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O

Implementing _ _ O
condition _ _ O
variables _ _ O
• _ _ O
Are _ _ O
these _ _ O
Hoare _ _ O
or _ _ O
Mesa _ _ O
semantics _ _ O
? _ _ O
• _ _ O
Can _ _ O
there _ _ O
be _ _ O
multiple _ _ O
condition _ _ O
variables _ _ O
for _ _ O
a _ _ O
single _ _ O
Lock _ _ O
? _ _ O
class _ _ O
Condition _ _ O
{ _ _ O
Lock _ _ O
* _ _ O
lock _ _ O
; _ _ O
Semaphore _ _ O
condSem _ _ O
( _ _ O
0 _ _ O
) _ _ O
; _ _ O
int _ _ O
semCount _ _ O
= _ _ O
0 _ _ O
; _ _ O
} _ _ O
; _ _ O
Condition _ _ O
: _ _ O
: _ _ O
Wait _ _ O
( _ _ O
) _ _ O
{ _ _ O
semCount _ _ O
+ _ _ O
= _ _ O
1 _ _ O
; _ _ O
if _ _ O
( _ _ O
lock- _ _ O
> _ _ O
nextCount _ _ O
> _ _ O
0 _ _ O
) _ _ O
lock- _ _ O
> _ _ O
next.up _ _ O
( _ _ O
) _ _ O
; _ _ O
else _ _ O
lock- _ _ O
> _ _ O
mutex.up _ _ O
( _ _ O
) _ _ O
; _ _ O
condSem.down _ _ O
( _ _ O
) _ _ O
; _ _ O
semCount _ _ O
-= _ _ O
1 _ _ O
; _ _ O
} _ _ O
Condition _ _ O
: _ _ O
: _ _ O
Signal _ _ O
( _ _ O
) _ _ O
{ _ _ O
if _ _ O
( _ _ O
semCount _ _ O
> _ _ O
0 _ _ O
) _ _ O
{ _ _ O
lock- _ _ O
> _ _ O
nextCount _ _ O
+ _ _ O
= _ _ O
1 _ _ O
; _ _ O
condSem.up _ _ O
( _ _ O
) _ _ O
; _ _ O
lock- _ _ O
> _ _ O
next.down _ _ O
( _ _ O
) _ _ O
; _ _ O
lock- _ _ O
> _ _ O
nextCount _ _ O
-= _ _ O
1 _ _ O
; _ _ O
} _ _ O
} _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O

Process _ _ O
Synchronization _ _ O
inside _ _ O
Monitors _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O

Condition _ _ O
Variable-based _ _ O
Solutions _ _ O
• _ _ O
Code _ _ O
Walkthrough _ _ O
at _ _ O
: _ _ O
https _ _ O
: _ _ O
/ _ _ O
/ _ _ O
cs1550 _ _ O
- _ _ O
2214.github.io _ _ O
/ _ _ O
cs1550-codehandouts _ _ O
/ _ _ O
ProcessSynchronization _ _ O
/ _ _ O
Slides _ _ O
/ _ _ O
CS _ _ O
/ _ _ O
COE _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O
13 _ _ O

Reflections _ _ O
on _ _ O
semaphore _ _ O
usage _ _ O
• _ _ O
Semaphores _ _ O
can _ _ O
be _ _ O
used _ _ O
as _ _ O
• _ _ O
Resource _ _ O
counters _ _ O
• _ _ O
Waiting _ _ O
spaces _ _ O
• _ _ O
For _ _ O
mutual _ _ O
exclusion _ _ O

Reflections _ _ O
on _ _ O
Condition _ _ O
Variables _ _ O
• _ _ O
Define _ _ O
a _ _ O
class _ _ O
and _ _ O
put _ _ O
all _ _ O
shared _ _ O
variables _ _ O
inside _ _ O
the _ _ O
class _ _ O
• _ _ O
Include _ _ O
a _ _ O
mutex _ _ O
and _ _ O
a _ _ O
condition _ _ O
variable _ _ O
in _ _ O
the _ _ O
class _ _ O
• _ _ O
For _ _ O
each _ _ O
public _ _ O
method _ _ O
of _ _ O
the _ _ O
class _ _ O
• _ _ O
Start _ _ O
by _ _ O
locking _ _ O
the _ _ O
mutex _ _ O
lock _ _ O
• _ _ O
If _ _ O
need _ _ O
to _ _ O
wait _ _ O
, _ _ O
use _ _ O
a _ _ O
while _ _ O
loop _ _ O
and _ _ O
wait _ _ O
on _ _ O
the _ _ O
condition _ _ O
variable _ _ O
• _ _ O
Before _ _ O
broadcasting _ _ O
on _ _ O
the _ _ O
condition _ _ O
variable _ _ O
, _ _ O
make _ _ O
sure _ _ O
to _ _ O
change _ _ O
the _ _ O
waiting _ _ O
condition _ _ O



