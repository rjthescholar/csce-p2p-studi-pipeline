unlabeled|cs1622|lec03
-DOCSTART- -X- -X- O

Lexing _ _ O
and _ _ O
Grammars _ _ O
CS _ _ O
/ _ _ O
COE _ _ O
1622 _ _ O
Jarrett _ _ O
Billingsley _ _ O

Class _ _ O
Announcements _ _ O
● _ _ O
project _ _ O
1 _ _ O
is _ _ O
out _ _ O
if _ _ O
you _ _ O
did _ _ O
n't _ _ O
see _ _ O
the _ _ O
announcement _ _ O
( _ _ O
s _ _ O
) _ _ O
o _ _ O
remember _ _ O
it _ _ O
's _ _ O
due _ _ O
by _ _ O
this _ _ O
Saturday _ _ O
evening _ _ O
o _ _ O
or _ _ O
Sunday _ _ O
for _ _ O
late _ _ O
credit _ _ O
( _ _ O
-10 _ _ O
% _ _ O
) _ _ O
● _ _ O
finally _ _ O
today _ _ O
we _ _ O
're _ _ O
getting _ _ O
into _ _ O
the _ _ O
COMPILER _ _ O
STUFF _ _ O
! _ _ O
● _ _ O
couple _ _ O
new _ _ O
examples _ _ O
in _ _ O
the _ _ O
examples _ _ O
repo _ _ O
for _ _ O
today _ _ O
too _ _ O
! _ _ O
2 _ _ O

Lexing _ _ O
3 _ _ O

What _ _ O
is _ _ O
it _ _ O
? _ _ O
● _ _ O
when _ _ O
a _ _ O
compiler _ _ O
reads _ _ O
the _ _ O
source _ _ O
code _ _ O
, _ _ O
it _ _ O
's _ _ O
just _ _ O
a _ _ O
long _ _ O
string _ _ O
. _ _ O
● _ _ O
lexing _ _ O
( _ _ O
or _ _ O
" _ _ O
scanning _ _ O
" _ _ O
) _ _ O
is _ _ O
the _ _ O
process _ _ O
of _ _ O
splitting _ _ O
that _ _ O
string _ _ O
into _ _ O
small _ _ O
, _ _ O
meaningful _ _ O
pieces _ _ O
in _ _ O
order _ _ O
to _ _ O
simplify _ _ O
the _ _ O
next _ _ O
step _ _ O
, _ _ O
parsing _ _ O
. _ _ O
" _ _ O
3*x _ _ O
+ _ _ O
( _ _ O
y _ _ O
/ _ _ O
1.9 _ _ O
) _ _ O
" _ _ O
the _ _ O
lexer _ _ O
's _ _ O
input _ _ O
is _ _ O
the _ _ O
source _ _ O
code _ _ O
. _ _ O
Lexer _ _ O
IntLit _ _ O
( _ _ O
3 _ _ O
, _ _ O
Dec _ _ O
) _ _ O
, _ _ O
Times _ _ O
, _ _ O
Id _ _ O
( _ _ O
"x _ _ O
" _ _ O
) _ _ O
, _ _ O
Plus _ _ O
, _ _ O
... _ _ O
the _ _ O
lexer _ _ O
's _ _ O
output _ _ O
is _ _ O
a _ _ O
list _ _ O
of _ _ O
tokens _ _ O
. _ _ O
each _ _ O
token _ _ O
is _ _ O
like _ _ O
one _ _ O
" _ _ O
word _ _ O
" _ _ O
in _ _ O
the _ _ O
source _ _ O
language _ _ O
– _ _ O
the _ _ O
smallest _ _ O
unit _ _ O
of _ _ O
meaning _ _ O
. _ _ O
4 _ _ O

Tokens _ _ O
, _ _ O
and _ _ O
… _ _ O
not-tokens _ _ O
● _ _ O
tokens _ _ O
have _ _ O
meaning _ _ O
to _ _ O
the _ _ O
programming _ _ O
language _ _ O
. _ _ O
but _ _ O
not _ _ O
everything _ _ O
you _ _ O
type _ _ O
in _ _ O
the _ _ O
source _ _ O
code _ _ O
is _ _ O
meaningful _ _ O
. _ _ O
if _ _ O
x _ _ O
< _ _ O
10 _ _ O
{ _ _ O
f _ _ O
( _ _ O
) _ _ O
; _ _ O
} _ _ O
if _ _ O
x _ _ O
< _ _ O
10{f _ _ O
( _ _ O
) _ _ O
; _ _ O
} _ _ O
if _ _ O
x _ _ O
< _ _ O
10 _ _ O
{ _ _ O
/ _ _ O
/ _ _ O
call _ _ O
f _ _ O
( _ _ O
) _ _ O
; _ _ O
} _ _ O
all _ _ O
three _ _ O
of _ _ O
these _ _ O
would _ _ O
lex _ _ O
to _ _ O
the _ _ O
same _ _ O
sequence _ _ O
of _ _ O
tokens _ _ O
. _ _ O
but _ _ O
what _ _ O
differs _ _ O
? _ _ O
spacing _ _ O
and _ _ O
indentation _ _ O
– _ _ O
together _ _ O
called _ _ O
whitespace _ _ O
– _ _ O
is _ _ O
meaningless _ _ O
in _ _ O
most _ _ O
modern _ _ O
languages _ _ O
, _ _ O
and _ _ O
the _ _ O
lexer _ _ O
strips _ _ O
it _ _ O
out _ _ O
. _ _ O
comments _ _ O
are _ _ O
another _ _ O
common _ _ O
kind _ _ O
of _ _ O
meaningless _ _ O
text _ _ O
that _ _ O
can _ _ O
be _ _ O
ignored _ _ O
. _ _ O
5 _ _ O

Not-so-whitespace _ _ O
● _ _ O
whitespace _ _ O
ca _ _ O
n't _ _ O
be _ _ O
ignored _ _ O
in _ _ O
all _ _ O
situations _ _ O
, _ _ O
though _ _ O
. _ _ O
" _ _ O
hello _ _ O
, _ _ O
world _ _ O
" _ _ O
" _ _ O
hello _ _ O
, _ _ O
world _ _ O
" _ _ O
these _ _ O
are _ _ O
different _ _ O
strings _ _ O
, _ _ O
right _ _ O
? _ _ O
so _ _ O
we _ _ O
have _ _ O
to _ _ O
remember _ _ O
whether _ _ O
or _ _ O
not _ _ O
we _ _ O
're _ _ O
inside _ _ O
" _ _ O
quotes _ _ O
" _ _ O
. _ _ O
also _ _ O
, _ _ O
fortress _ _ O
and _ _ O
for _ _ O
tress _ _ O
mean _ _ O
different _ _ O
things _ _ O
. _ _ O
Python _ _ O
uses _ _ O
indentation _ _ O
to _ _ O
structure _ _ O
code _ _ O
, _ _ O
instead _ _ O
of _ _ O
{ _ _ O
braces _ _ O
} _ _ O
. _ _ O
if _ _ O
x _ _ O
< _ _ O
10 _ _ O
: _ _ O
f _ _ O
( _ _ O
) _ _ O
print _ _ O
( _ _ O
"done _ _ O
" _ _ O
) _ _ O
the _ _ O
print _ _ O
call _ _ O
is _ _ O
outside _ _ O
of _ _ O
the _ _ O
if _ _ O
. _ _ O
the _ _ O
only _ _ O
thing _ _ O
that _ _ O
indicates _ _ O
that _ _ O
is _ _ O
the _ _ O
indentation _ _ O
. _ _ O
and _ _ O
JavaScript _ _ O
( _ _ O
aka _ _ O
ECMAScript _ _ O
) _ _ O
does _ _ O
weird _ _ O
things _ _ O
with _ _ O
newlines _ _ O
so _ _ O
you _ _ O
can _ _ O
avoid _ _ O
writing _ _ O
semicolons _ _ O
… _ _ O
6 _ _ O

Where _ _ O
are _ _ O
we _ _ O
? _ _ O
● _ _ O
a _ _ O
secondary _ _ O
( _ _ O
but _ _ O
super _ _ O
important _ _ O
) _ _ O
job _ _ O
of _ _ O
the _ _ O
lexer _ _ O
is _ _ O
to _ _ O
produce _ _ O
location _ _ O
info _ _ O
so _ _ O
the _ _ O
compiler _ _ O
can _ _ O
give _ _ O
good _ _ O
error _ _ O
messages _ _ O
. _ _ O
line _ _ O
1 _ _ O
, _ _ O
column _ _ O
1 _ _ O
1 _ _ O
: _ _ O
13 _ _ O
line _ _ O
1 _ _ O
, _ _ O
col _ _ O
4 _ _ O
1 _ _ O
: _ _ O
19 _ _ O
1 _ _ O
: _ _ O
16 _ _ O
if _ _ O
num_cats _ _ O
= _ _ O
= _ _ O
10 _ _ O
{ _ _ O
println _ _ O
( _ _ O
"yay _ _ O
! _ _ O
" _ _ O
) _ _ O
; _ _ O
2 _ _ O
: _ _ O
5 _ _ O
2 _ _ O
: _ _ O
12 _ _ O
2 _ _ O
: _ _ O
13 _ _ O
2 _ _ O
: _ _ O
19 _ _ O
2 _ _ O
: _ _ O
20 _ _ O
the _ _ O
line _ _ O
number _ _ O
is _ _ O
based _ _ O
on _ _ O
how _ _ O
many _ _ O
newlines _ _ O
it _ _ O
's _ _ O
seen _ _ O
. _ _ O
the _ _ O
column _ _ O
number _ _ O
is _ _ O
based _ _ O
on _ _ O
how _ _ O
many _ _ O
characters _ _ O
it _ _ O
's _ _ O
seen _ _ O
since _ _ O
the _ _ O
last _ _ O
newline _ _ O
. _ _ O
this _ _ O
information _ _ O
can _ _ O
be _ _ O
carried _ _ O
forward _ _ O
through _ _ O
the _ _ O
rest _ _ O
of _ _ O
the _ _ O
compilation _ _ O
process _ _ O
for _ _ O
a _ _ O
number _ _ O
of _ _ O
uses _ _ O
. _ _ O
7 _ _ O

Lexing _ _ O
from _ _ O
Intuition _ _ O
8 _ _ O

Getting _ _ O
a _ _ O
feel _ _ O
for _ _ O
it _ _ O
● _ _ O
a _ _ O
lot _ _ O
of _ _ O
problem-solving _ _ O
works _ _ O
by _ _ O
getting _ _ O
a _ _ O
feel _ _ O
for _ _ O
what _ _ O
a _ _ O
solution _ _ O
might _ _ O
look _ _ O
like _ _ O
, _ _ O
then _ _ O
formalizing _ _ O
that _ _ O
intuition _ _ O
into _ _ O
an _ _ O
algorithm _ _ O
. _ _ O
● _ _ O
let _ _ O
's _ _ O
start _ _ O
by _ _ O
looking _ _ O
at _ _ O
what _ _ O
our _ _ O
input _ _ O
language _ _ O
looks _ _ O
like _ _ O
. _ _ O
struct _ _ O
S _ _ O
{ _ _ O
x _ _ O
: _ _ O
int _ _ O
, _ _ O
y _ _ O
: _ _ O
bool _ _ O
, _ _ O
} _ _ O
this _ _ O
is _ _ O
the _ _ O
toy _ _ O
language _ _ O
we _ _ O
'll _ _ O
be _ _ O
using _ _ O
for _ _ O
projects _ _ O
and _ _ O
examples _ _ O
, _ _ O
called _ _ O
Truss _ _ O
. _ _ O
fn _ _ O
main _ _ O
( _ _ O
) _ _ O
{ _ _ O
println_s _ _ O
( _ _ O
"hi _ _ O
! _ _ O
" _ _ O
) _ _ O
; _ _ O
let _ _ O
s _ _ O
= _ _ O
new _ _ O
S _ _ O
( _ _ O
) _ _ O
; _ _ O
s.x _ _ O
= _ _ O
10 _ _ O
; _ _ O
s.y _ _ O
= _ _ O
true _ _ O
; _ _ O
println_i _ _ O
( _ _ O
s.x _ _ O
) _ _ O
; _ _ O
} _ _ O
it _ _ O
has _ _ O
similarities _ _ O
to _ _ O
both _ _ O
Rust _ _ O
and _ _ O
Java _ _ O
, _ _ O
but _ _ O
is _ _ O
a _ _ O
lot _ _ O
simpler _ _ O
in _ _ O
many _ _ O
ways _ _ O
. _ _ O
what _ _ O
are _ _ O
some _ _ O
kinds _ _ O
of _ _ O
tokens _ _ O
you _ _ O
can _ _ O
pick _ _ O
out _ _ O
from _ _ O
this _ _ O
example _ _ O
? _ _ O
9 _ _ O

Common _ _ O
classes _ _ O
of _ _ O
tokens _ _ O
● _ _ O
most _ _ O
languages _ _ O
today _ _ O
use _ _ O
similar _ _ O
rules _ _ O
for _ _ O
their _ _ O
classes _ _ O
of _ _ O
tokens _ _ O
. _ _ O
there _ _ O
are _ _ O
tokens _ _ O
that _ _ O
look _ _ O
like _ _ O
words _ _ O
. _ _ O
struct _ _ O
int _ _ O
return _ _ O
while _ _ O
some _ _ O
have _ _ O
special _ _ O
meaning _ _ O
in _ _ O
the _ _ O
language _ _ O
. _ _ O
these _ _ O
are _ _ O
called _ _ O
keywords _ _ O
. _ _ O
S _ _ O
num_cats _ _ O
println _ _ O
main _ _ O
others _ _ O
are _ _ O
written _ _ O
by _ _ O
the _ _ O
programmer _ _ O
to _ _ O
name _ _ O
things _ _ O
. _ _ O
these _ _ O
are _ _ O
called _ _ O
identifiers _ _ O
. _ _ O
there _ _ O
are _ _ O
often _ _ O
many _ _ O
symbols _ _ O
. _ _ O
and _ _ O
there _ _ O
are _ _ O
literals _ _ O
: _ _ O
a _ _ O
way _ _ O
of _ _ O
embedding _ _ O
constant _ _ O
values _ _ O
directly _ _ O
into _ _ O
your _ _ O
code _ _ O
. _ _ O
+ _ _ O
- _ _ O
* _ _ O
/ _ _ O
= _ _ O
. _ _ O
, _ _ O
; _ _ O
{ _ _ O
} _ _ O
= _ _ O
= _ _ O
& _ _ O
& _ _ O
|| _ _ O
+ _ _ O
= _ _ O
" _ _ O
hello _ _ O
, _ _ O
\nworld _ _ O
! _ _ O
" _ _ O
' _ _ O
c _ _ O
' _ _ O
true _ _ O
0xDEADBEEF _ _ O
1.9e6 _ _ O
345 _ _ O
10 _ _ O

A _ _ O
first _ _ O
attempt _ _ O
● _ _ O
we _ _ O
might _ _ O
come _ _ O
up _ _ O
with _ _ O
some _ _ O
simple _ _ O
rules _ _ O
for _ _ O
these _ _ O
tokens _ _ O
: _ _ O
o _ _ O
identifiers _ _ O
are _ _ O
a _ _ O
sequence _ _ O
of _ _ O
letters _ _ O
, _ _ O
underscores _ _ O
, _ _ O
and _ _ O
digits _ _ O
. _ _ O
▪ _ _ O
e.g. _ _ O
x _ _ O
, _ _ O
x2 _ _ O
, _ _ O
_ _ _ O
lift _ _ O
, _ _ O
THIS_IS_A_TEST _ _ O
, _ _ O
fort _ _ O
, _ _ O
o_o _ _ O
o _ _ O
keywords _ _ O
are _ _ O
a _ _ O
fixed _ _ O
subset _ _ O
of _ _ O
identifiers _ _ O
. _ _ O
▪ _ _ O
e.g. _ _ O
if _ _ O
, _ _ O
else _ _ O
, _ _ O
int _ _ O
, _ _ O
private _ _ O
, _ _ O
for _ _ O
o _ _ O
symbols _ _ O
are _ _ O
a _ _ O
fixed _ _ O
set _ _ O
of _ _ O
sequences _ _ O
of _ _ O
symbol _ _ O
characters _ _ O
. _ _ O
▪ _ _ O
e.g. _ _ O
+ _ _ O
, _ _ O
+ _ _ O
= _ _ O
, _ _ O
= _ _ O
, _ _ O
= _ _ O
= _ _ O
, _ _ O
& _ _ O
, _ _ O
& _ _ O
= _ _ O
, _ _ O
& _ _ O
& _ _ O
● _ _ O
but _ _ O
then _ _ O
we _ _ O
get _ _ O
to _ _ O
the _ _ O
literals _ _ O
, _ _ O
and _ _ O
it _ _ O
gets _ _ O
harder _ _ O
. _ _ O
o _ _ O
here _ _ O
are _ _ O
some _ _ O
floats _ _ O
: _ _ O
1.2 _ _ O
, _ _ O
10e9 _ _ O
, _ _ O
6.28E+23 _ _ O
, _ _ O
4 _ _ O
. _ _ O
, _ _ O
5f _ _ O
o _ _ O
do _ _ O
you _ _ O
think _ _ O
you _ _ O
could _ _ O
come _ _ O
up _ _ O
with _ _ O
a _ _ O
concise _ _ O
rule _ _ O
for _ _ O
that _ _ O
? _ _ O
o _ _ O
and _ _ O
then _ _ O
strings _ _ O
… _ _ O
" _ _ O
hello\nworld _ _ O
" _ _ O
● _ _ O
oh _ _ O
, _ _ O
but _ _ O
it _ _ O
gets _ _ O
worse _ _ O
! _ _ O
11 _ _ O

We _ _ O
keep _ _ O
running _ _ O
into _ _ O
each _ _ O
other _ _ O
● _ _ O
let _ _ O
's _ _ O
look _ _ O
at _ _ O
some _ _ O
awkward _ _ O
situations _ _ O
! _ _ O
abc123 _ _ O
123abc _ _ O
x.y _ _ O
4.y _ _ O
x.5 _ _ O
4.5 _ _ O
1.2.3 _ _ O
abc123 _ _ O
123abc _ _ O
? _ _ O
or _ _ O
123 _ _ O
, _ _ O
abc _ _ O
? _ _ O
or _ _ O
error _ _ O
? _ _ O
x _ _ O
, _ _ O
. _ _ O
, _ _ O
y _ _ O
4 _ _ O
, _ _ O
. _ _ O
, _ _ O
y _ _ O
or _ _ O
4 _ _ O
. _ _ O
, _ _ O
y _ _ O
? _ _ O
x _ _ O
, _ _ O
. _ _ O
, _ _ O
5 _ _ O
or _ _ O
x _ _ O
, _ _ O
.5 _ _ O
? _ _ O
4.5 _ _ O
or _ _ O
4 _ _ O
. _ _ O
, _ _ O
5 _ _ O
or _ _ O
4 _ _ O
, _ _ O
. _ _ O
, _ _ O
5 _ _ O
? _ _ O
or _ _ O
or _ _ O
or _ _ O
or _ _ O
1.2 _ _ O
, _ _ O
. _ _ O
, _ _ O
3 _ _ O
1.2 _ _ O
, _ _ O
.3 _ _ O
1 _ _ O
. _ _ O
, _ _ O
2.3 _ _ O
1 _ _ O
. _ _ O
, _ _ O
2 _ _ O
. _ _ O
, _ _ O
3 _ _ O
1 _ _ O
, _ _ O
. _ _ O
, _ _ O
2 _ _ O
, _ _ O
. _ _ O
, _ _ O
3 _ _ O
12 _ _ O

uHH _ _ O
● _ _ O
even _ _ O
with _ _ O
such _ _ O
a _ _ O
simple _ _ O
set _ _ O
of _ _ O
tokens _ _ O
, _ _ O
we _ _ O
're _ _ O
already _ _ O
running _ _ O
into _ _ O
problems _ _ O
, _ _ O
and _ _ O
it _ _ O
's _ _ O
not _ _ O
entirely _ _ O
clear _ _ O
where _ _ O
we _ _ O
went _ _ O
wrong _ _ O
. _ _ O
● _ _ O
well _ _ O
, _ _ O
let _ _ O
's _ _ O
first _ _ O
learn _ _ O
a _ _ O
bit _ _ O
about _ _ O
grammars _ _ O
, _ _ O
which _ _ O
can _ _ O
give _ _ O
us _ _ O
some _ _ O
tools _ _ O
to _ _ O
talk _ _ O
about _ _ O
these _ _ O
things _ _ O
more _ _ O
rigorously _ _ O
. _ _ O
13 _ _ O

Grammars _ _ O
14 _ _ O

Languages _ _ O
and _ _ O
alphabets _ _ O
● _ _ O
a _ _ O
language _ _ O
is _ _ O
a _ _ O
set _ _ O
of _ _ O
strings _ _ O
. _ _ O
( _ _ O
most _ _ O
useful _ _ O
languages _ _ O
are _ _ O
infinite _ _ O
sets _ _ O
. _ _ O
) _ _ O
● _ _ O
each _ _ O
string _ _ O
is _ _ O
a _ _ O
sequence _ _ O
of _ _ O
symbols _ _ O
chosen _ _ O
from _ _ O
an _ _ O
alphabet _ _ O
. _ _ O
● _ _ O
for _ _ O
example _ _ O
, _ _ O
here _ _ O
's _ _ O
a _ _ O
really _ _ O
dumb _ _ O
language _ _ O
and _ _ O
its _ _ O
alphabet _ _ O
: _ _ O
L _ _ O
= _ _ O
{ _ _ O
" _ _ O
hi _ _ O
" _ _ O
, _ _ O
" _ _ O
bye _ _ O
" _ _ O
} _ _ O
A _ _ O
= _ _ O
{ _ _ O
' _ _ O
a _ _ O
' _ _ O
, _ _ O
' _ _ O
b _ _ O
' _ _ O
, _ _ O
… _ _ O
, _ _ O
' _ _ O
z _ _ O
' _ _ O
} _ _ O
each _ _ O
symbol _ _ O
in _ _ O
the _ _ O
alphabet _ _ O
is _ _ O
called _ _ O
a _ _ O
terminal _ _ O
. _ _ O
if _ _ O
we _ _ O
generate _ _ O
strings _ _ O
from _ _ O
this _ _ O
alphabet _ _ O
, _ _ O
it _ _ O
's _ _ O
kind _ _ O
of _ _ O
obvious _ _ O
whether _ _ O
or _ _ O
not _ _ O
they _ _ O
are _ _ O
in _ _ O
L. _ _ O
" _ _ O
hi _ _ O
" _ _ O
∈ _ _ O
L _ _ O
" _ _ O
hii _ _ O
" _ _ O
∉ _ _ O
L _ _ O
" _ _ O
cat _ _ O
" _ _ O
∉ _ _ O
L _ _ O
… _ _ O
ok _ _ O
, _ _ O
what _ _ O
about _ _ O
a _ _ O
more _ _ O
complicated _ _ O
example _ _ O
? _ _ O
15 _ _ O

Grammars _ _ O
● _ _ O
for _ _ O
more _ _ O
complex _ _ O
or _ _ O
infinite _ _ O
languages _ _ O
, _ _ O
you _ _ O
need _ _ O
a _ _ O
grammar _ _ O
: _ _ O
a _ _ O
set _ _ O
of _ _ O
rules _ _ O
to _ _ O
decide _ _ O
if _ _ O
a _ _ O
string _ _ O
is _ _ O
in _ _ O
the _ _ O
language _ _ O
. _ _ O
L _ _ O
= _ _ O
{ _ _ O
" _ _ O
a _ _ O
" _ _ O
, _ _ O
" _ _ O
aa _ _ O
" _ _ O
, _ _ O
" _ _ O
aaa _ _ O
" _ _ O
, _ _ O
… _ _ O
} _ _ O
A _ _ O
= _ _ O
{ _ _ O
' _ _ O
a _ _ O
' _ _ O
, _ _ O
' _ _ O
b _ _ O
' _ _ O
, _ _ O
… _ _ O
, _ _ O
' _ _ O
z _ _ O
' _ _ O
} _ _ O
what _ _ O
is _ _ O
/ _ _ O
are _ _ O
the _ _ O
rule _ _ O
( _ _ O
s _ _ O
) _ _ O
for _ _ O
this _ _ O
language _ _ O
? _ _ O
" _ _ O
1 _ _ O
or _ _ O
more _ _ O
' _ _ O
a _ _ O
's _ _ O
" _ _ O
okay _ _ O
. _ _ O
but _ _ O
can _ _ O
we _ _ O
write _ _ O
that _ _ O
grammar _ _ O
rule _ _ O
in _ _ O
a _ _ O
more _ _ O
rigorous _ _ O
way _ _ O
? _ _ O
L _ _ O
: _ _ O
' _ _ O
a _ _ O
' _ _ O
+ _ _ O
this _ _ O
is _ _ O
a _ _ O
nonterminal _ _ O
. _ _ O
it _ _ O
is _ _ O
n't _ _ O
part _ _ O
of _ _ O
the _ _ O
alphabet _ _ O
; _ _ O
it _ _ O
stands _ _ O
in _ _ O
for _ _ O
some _ _ O
combination _ _ O
of _ _ O
terminals _ _ O
. _ _ O
this _ _ O
+ _ _ O
says _ _ O
" _ _ O
repeat _ _ O
the _ _ O
previous _ _ O
thing _ _ O
1 _ _ O
or _ _ O
more _ _ O
times _ _ O
. _ _ O
" _ _ O
16 _ _ O

A _ _ O
language _ _ O
for _ _ O
specifying _ _ O
languages _ _ O
● _ _ O
we _ _ O
usually _ _ O
specify _ _ O
the _ _ O
lexical _ _ O
and _ _ O
syntactic _ _ O
form _ _ O
of _ _ O
a _ _ O
language _ _ O
with _ _ O
a _ _ O
metalanguage _ _ O
: _ _ O
a _ _ O
concise _ _ O
way _ _ O
of _ _ O
specifying _ _ O
rules _ _ O
. _ _ O
● _ _ O
there _ _ O
are _ _ O
some _ _ O
common _ _ O
patterns _ _ O
for _ _ O
these _ _ O
rules _ _ O
: _ _ O
L _ _ O
: _ _ O
A _ _ O
B _ _ O
R _ _ O
: _ _ O
A _ _ O
| _ _ O
B _ _ O
X _ _ O
: _ _ O
A _ _ O
* _ _ O
Y _ _ O
: _ _ O
A+ _ _ O
U _ _ O
: _ _ O
A _ _ O
? _ _ O
D _ _ O
: _ _ O
( _ _ O
A _ _ O
B _ _ O
) _ _ O
+ _ _ O
A _ _ O
followed _ _ O
by _ _ O
B. _ _ O
( _ _ O
sequencing _ _ O
) _ _ O
an _ _ O
A _ _ O
or _ _ O
a _ _ O
B. _ _ O
( _ _ O
alternation _ _ O
) _ _ O
zero _ _ O
or _ _ O
more _ _ O
As _ _ O
. _ _ O
( _ _ O
repetition _ _ O
) _ _ O
one _ _ O
or _ _ O
more _ _ O
As _ _ O
. _ _ O
( _ _ O
repetition _ _ O
… _ _ O
again _ _ O
) _ _ O
zero _ _ O
or _ _ O
one _ _ O
A _ _ O
, _ _ O
or _ _ O
" _ _ O
an _ _ O
optional _ _ O
A _ _ O
" _ _ O
. _ _ O
parens _ _ O
can _ _ O
group _ _ O
things _ _ O
together _ _ O
. _ _ O
in _ _ O
these _ _ O
examples _ _ O
, _ _ O
A _ _ O
and _ _ O
B _ _ O
can _ _ O
be _ _ O
terminals _ _ O
( _ _ O
from _ _ O
the _ _ O
alphabet _ _ O
) _ _ O
or _ _ O
nonterminals _ _ O
( _ _ O
names _ _ O
of _ _ O
other _ _ O
rules _ _ O
) _ _ O
. _ _ O
17 _ _ O

Lexing _ _ O
a _ _ O
programming _ _ O
language _ _ O
● _ _ O
the _ _ O
alphabet _ _ O
is _ _ O
the _ _ O
character _ _ O
set _ _ O
that _ _ O
the _ _ O
source _ _ O
code _ _ O
is _ _ O
in _ _ O
. _ _ O
o _ _ O
in _ _ O
our _ _ O
case _ _ O
, _ _ O
that _ _ O
's _ _ O
Unicode _ _ O
! _ _ O
● _ _ O
the _ _ O
language _ _ O
is _ _ O
n't _ _ O
the _ _ O
entire _ _ O
programming _ _ O
language _ _ O
… _ _ O
o _ _ O
instead _ _ O
, _ _ O
it _ _ O
's _ _ O
the _ _ O
tokens _ _ O
we _ _ O
want _ _ O
to _ _ O
produce _ _ O
. _ _ O
● _ _ O
so _ _ O
, _ _ O
we _ _ O
'll _ _ O
write _ _ O
a _ _ O
rule _ _ O
for _ _ O
each _ _ O
kind _ _ O
of _ _ O
token _ _ O
. _ _ O
Symbol _ _ O
: _ _ O
' _ _ O
+ _ _ O
' _ _ O
| _ _ O
' _ _ O
- _ _ O
' _ _ O
| _ _ O
' _ _ O
{ _ _ O
' _ _ O
| _ _ O
' _ _ O
} _ _ O
' _ _ O
| _ _ O
' _ _ O
= _ _ O
' _ _ O
| _ _ O
( _ _ O
' _ _ O
= _ _ O
' _ _ O
' _ _ O
= _ _ O
' _ _ O
) _ _ O
' _ _ O
quoted _ _ O
' _ _ O
things _ _ O
are _ _ O
terminals _ _ O
, _ _ O
picked _ _ O
from _ _ O
the _ _ O
alphabet _ _ O
. _ _ O
Keyword _ _ O
: _ _ O
( _ _ O
' _ _ O
i _ _ O
' _ _ O
' _ _ O
f _ _ O
' _ _ O
) _ _ O
| _ _ O
( _ _ O
' _ _ O
e _ _ O
' _ _ O
' _ _ O
l _ _ O
' _ _ O
's _ _ O
' _ _ O
' _ _ O
e _ _ O
' _ _ O
) _ _ O
| _ _ O
... _ _ O
that _ _ O
's _ _ O
ugly _ _ O
, _ _ O
but _ _ O
we _ _ O
can _ _ O
make _ _ O
our _ _ O
metalanguage _ _ O
look _ _ O
any _ _ O
way _ _ O
we _ _ O
like _ _ O
. _ _ O
Keyword _ _ O
: _ _ O
" _ _ O
if _ _ O
" _ _ O
| _ _ O
" _ _ O
else _ _ O
" _ _ O
| _ _ O
" _ _ O
fn _ _ O
" _ _ O
| _ _ O
" _ _ O
return _ _ O
" _ _ O
that _ _ O
's _ _ O
better _ _ O
! _ _ O
18 _ _ O

Getting _ _ O
more _ _ O
complex _ _ O
● _ _ O
rules _ _ O
can _ _ O
refer _ _ O
to _ _ O
other _ _ O
rules _ _ O
. _ _ O
like _ _ O
here _ _ O
: _ _ O
I _ _ O
d _ _ O
: _ _ O
IdStart _ _ O
IdCont _ _ O
* _ _ O
IdStart _ _ O
: _ _ O
Alphabetic _ _ O
| _ _ O
' _ _ O
_ _ _ O
' _ _ O
| _ _ O
' _ _ O
$ _ _ O
' _ _ O
IdCont _ _ O
: _ _ O
IdStart _ _ O
| _ _ O
Digit _ _ O
Digit _ _ O
: _ _ O
' _ _ O
0 _ _ O
' _ _ O
| _ _ O
' _ _ O
1 _ _ O
' _ _ O
| _ _ O
' _ _ O
2 _ _ O
' _ _ O
| _ _ O
' _ _ O
3 _ _ O
' _ _ O
| _ _ O
' _ _ O
4 _ _ O
' _ _ O
| _ _ O
' _ _ O
5 _ _ O
' _ _ O
| _ _ O
' _ _ O
6 _ _ O
' _ _ O
| _ _ O
' _ _ O
7 _ _ O
' _ _ O
| _ _ O
' _ _ O
8 _ _ O
' _ _ O
| _ _ O
' _ _ O
9 _ _ O
' _ _ O
Alphabetic _ _ O
: _ _ O
( _ _ O
a _ _ O
whole _ _ O
bunch _ _ O
of _ _ O
characters _ _ O
) _ _ O
so _ _ O
, _ _ O
an _ _ O
identifier _ _ O
starts _ _ O
with _ _ O
a _ _ O
letter _ _ O
or _ _ O
underscore _ _ O
or _ _ O
dollar _ _ O
sign _ _ O
; _ _ O
and _ _ O
that _ _ O
is _ _ O
followed _ _ O
by _ _ O
zero _ _ O
or _ _ O
more _ _ O
of _ _ O
those _ _ O
, _ _ O
plus _ _ O
digits _ _ O
. _ _ O
neat _ _ O
. _ _ O
and _ _ O
we _ _ O
could _ _ O
keep _ _ O
going _ _ O
for _ _ O
all _ _ O
the _ _ O
tokens _ _ O
! _ _ O
19 _ _ O

Literals _ _ O
! _ _ O
● _ _ O
numeric _ _ O
and _ _ O
string _ _ O
literals _ _ O
can _ _ O
get _ _ O
pretty _ _ O
complicated _ _ O
, _ _ O
but _ _ O
let _ _ O
’s _ _ O
keep _ _ O
them _ _ O
simple _ _ O
for _ _ O
now _ _ O
: _ _ O
IntLit _ _ O
: _ _ O
Digit+ _ _ O
StrLit _ _ O
: _ _ O
' _ _ O
" _ _ O
' _ _ O
StrChar _ _ O
* _ _ O
' _ _ O
" _ _ O
' _ _ O
StrChar _ _ O
: _ _ O
< _ _ O
any _ _ O
character _ _ O
except _ _ O
' _ _ O
" _ _ O
' _ _ O
> _ _ O
integer _ _ O
literals _ _ O
are _ _ O
sequences _ _ O
of _ _ O
digits _ _ O
, _ _ O
and _ _ O
string _ _ O
literals _ _ O
are _ _ O
sequences _ _ O
of _ _ O
characters _ _ O
surrounded _ _ O
by _ _ O
double _ _ O
quotes _ _ O
. _ _ O
also _ _ O
it _ _ O
’s _ _ O
fine _ _ O
to _ _ O
be _ _ O
a _ _ O
bit _ _ O
hand-wavey _ _ O
like _ _ O
in _ _ O
StrChar _ _ O
, _ _ O
as _ _ O
long _ _ O
as _ _ O
the _ _ O
intent _ _ O
is _ _ O
clear _ _ O
. _ _ O
but _ _ O
: _ _ O
what _ _ O
if _ _ O
the _ _ O
input _ _ O
contains _ _ O
the _ _ O
number _ _ O
100000000000000000000 _ _ O
? _ _ O
is _ _ O
n’t _ _ O
it _ _ O
too _ _ O
big _ _ O
… _ _ O
? _ _ O
defining _ _ O
the _ _ O
valid _ _ O
ranges _ _ O
of _ _ O
numbers _ _ O
within _ _ O
the _ _ O
metalanguage _ _ O
is _ _ O
n’t _ _ O
possible _ _ O
. _ _ O
so _ _ O
we _ _ O
could _ _ O
define _ _ O
that _ _ O
as _ _ O
an _ _ O
additional _ _ O
rule _ _ O
. _ _ O
20 _ _ O

Uh _ _ O
oh _ _ O
, _ _ O
whitespace _ _ O
. _ _ O
● _ _ O
whitespace _ _ O
is _ _ O
n't _ _ O
a _ _ O
token _ _ O
, _ _ O
but _ _ O
we _ _ O
do _ _ O
have _ _ O
to _ _ O
deal _ _ O
with _ _ O
it _ _ O
somehow _ _ O
. _ _ O
● _ _ O
we _ _ O
can _ _ O
write _ _ O
rules _ _ O
for _ _ O
it _ _ O
, _ _ O
like _ _ O
a _ _ O
real _ _ O
token _ _ O
: _ _ O
Whitespace _ _ O
: _ _ O
' _ _ O
' _ _ O
| _ _ O
' _ _ O
\t _ _ O
' _ _ O
| _ _ O
' _ _ O
\n _ _ O
' _ _ O
| _ _ O
Comment _ _ O
Comment _ _ O
: _ _ O
" _ _ O
/ _ _ O
/ _ _ O
" _ _ O
CommentChar _ _ O
* _ _ O
CommentEnd _ _ O
CommentChar _ _ O
: _ _ O
< _ _ O
any _ _ O
character _ _ O
except _ _ O
' _ _ O
\n _ _ O
' _ _ O
or _ _ O
Eof _ _ O
> _ _ O
CommentEnd _ _ O
: _ _ O
( _ _ O
' _ _ O
\n _ _ O
' _ _ O
| _ _ O
Eof _ _ O
) _ _ O
non-consuming _ _ O
woah _ _ O
what _ _ O
the _ _ O
heck _ _ O
is _ _ O
that _ _ O
this _ _ O
is _ _ O
a _ _ O
lookahead _ _ O
: _ _ O
it _ _ O
checks _ _ O
if _ _ O
the _ _ O
next _ _ O
character _ _ O
is _ _ O
a _ _ O
newline _ _ O
or _ _ O
EOF _ _ O
, _ _ O
but _ _ O
it _ _ O
does _ _ O
not _ _ O
make _ _ O
it _ _ O
part _ _ O
of _ _ O
the _ _ O
Comment _ _ O
. _ _ O
it _ _ O
feels _ _ O
a _ _ O
little _ _ O
kludgey _ _ O
, _ _ O
but _ _ O
sometimes _ _ O
lookaheads _ _ O
are _ _ O
just _ _ O
what _ _ O
you _ _ O
need _ _ O
. _ _ O
just _ _ O
… _ _ O
do _ _ O
n’t _ _ O
use _ _ O
them _ _ O
too _ _ O
much _ _ O
. _ _ O
21 _ _ O

Wrapping _ _ O
it _ _ O
up _ _ O
and _ _ O
putting _ _ O
a _ _ O
bow _ _ O
on _ _ O
top _ _ O
● _ _ O
once _ _ O
we _ _ O
have _ _ O
a _ _ O
rule _ _ O
for _ _ O
each _ _ O
kind _ _ O
of _ _ O
token _ _ O
, _ _ O
we _ _ O
can _ _ O
do _ _ O
this _ _ O
: _ _ O
Token _ _ O
: _ _ O
Symbol _ _ O
| _ _ O
Keyword _ _ O
| _ _ O
I _ _ O
d _ _ O
| _ _ O
IntLit _ _ O
| _ _ O
StrLit _ _ O
Program _ _ O
: _ _ O
( _ _ O
Whitespace _ _ O
? _ _ O
Token _ _ O
) _ _ O
* _ _ O
Whitespace _ _ O
? _ _ O
Eof _ _ O
here _ _ O
, _ _ O
Program _ _ O
is _ _ O
a _ _ O
special _ _ O
rule _ _ O
: _ _ O
it _ _ O
's _ _ O
our _ _ O
top-level _ _ O
or _ _ O
start _ _ O
rule _ _ O
. _ _ O
if _ _ O
we _ _ O
want _ _ O
to _ _ O
translate _ _ O
this _ _ O
grammar _ _ O
into _ _ O
code _ _ O
that _ _ O
lexes _ _ O
, _ _ O
it _ _ O
's _ _ O
where _ _ O
we _ _ O
start _ _ O
– _ _ O
it _ _ O
's _ _ O
the _ _ O
outermost _ _ O
loop _ _ O
. _ _ O
but _ _ O
wait _ _ O
. _ _ O
if _ _ O
we _ _ O
spent _ _ O
all _ _ O
this _ _ O
time _ _ O
writing _ _ O
the _ _ O
lexical _ _ O
rules _ _ O
in _ _ O
a _ _ O
formalized _ _ O
, _ _ O
rigorous _ _ O
way _ _ O
… _ _ O
could _ _ O
n't _ _ O
we _ _ O
just _ _ O
have _ _ O
a _ _ O
program _ _ O
compile _ _ O
the _ _ O
grammar _ _ O
itself _ _ O
into _ _ O
a _ _ O
lexer _ _ O
? _ _ O
22 _ _ O

COMPILER _ _ O
COMPILERS _ _ O
🤯 _ _ O
● _ _ O
yes _ _ O
, _ _ O
this _ _ O
is _ _ O
A _ _ O
Thing _ _ O
. _ _ O
● _ _ O
there _ _ O
are _ _ O
many _ _ O
tools _ _ O
which _ _ O
will _ _ O
take _ _ O
some _ _ O
kind _ _ O
of _ _ O
metalanguage _ _ O
as _ _ O
the _ _ O
input _ _ O
, _ _ O
and _ _ O
produce _ _ O
a _ _ O
lexer _ _ O
program _ _ O
as _ _ O
an _ _ O
output _ _ O
. _ _ O
o _ _ O
( _ _ O
or _ _ O
a _ _ O
parser _ _ O
, _ _ O
but _ _ O
we _ _ O
have _ _ O
n't _ _ O
gotten _ _ O
to _ _ O
those _ _ O
yet _ _ O
) _ _ O
● _ _ O
however _ _ O
… _ _ O
o _ _ O
most _ _ O
are _ _ O
tightly _ _ O
tied _ _ O
to _ _ O
the _ _ O
language _ _ O
whose _ _ O
code _ _ O
they _ _ O
output _ _ O
. _ _ O
o _ _ O
they _ _ O
're _ _ O
really _ _ O
complex _ _ O
, _ _ O
to _ _ O
be _ _ O
as _ _ O
flexible _ _ O
as _ _ O
possible _ _ O
. _ _ O
o _ _ O
… _ _ O
but _ _ O
, _ _ O
it _ _ O
can _ _ O
be _ _ O
awkward _ _ O
to _ _ O
fit _ _ O
your _ _ O
grammars _ _ O
into _ _ O
their _ _ O
rules _ _ O
. _ _ O
o _ _ O
they _ _ O
can _ _ O
give _ _ O
really _ _ O
confusing _ _ O
/ _ _ O
terrible _ _ O
error _ _ O
messages _ _ O
on _ _ O
invalid _ _ O
lexer _ _ O
input _ _ O
. _ _ O
● _ _ O
and _ _ O
honestly _ _ O
, _ _ O
writing _ _ O
your _ _ O
own _ _ O
lexer _ _ O
is _ _ O
not _ _ O
that _ _ O
complicated _ _ O
. _ _ O
o _ _ O
and _ _ O
, _ _ O
yanno _ _ O
, _ _ O
it _ _ O
's _ _ O
a _ _ O
compilers _ _ O
course _ _ O
, _ _ O
so _ _ O
you _ _ O
have _ _ O
to _ _ O
do _ _ O
it _ _ O
. _ _ O
(: _ _ O
23 _ _ O

Dealing _ _ O
with _ _ O
Ambiguity _ _ O
24 _ _ O

Dealing _ _ O
with _ _ O
ambiguity _ _ O
● _ _ O
ambiguity _ _ O
is _ _ O
when _ _ O
you _ _ O
have _ _ O
> _ _ O
1 _ _ O
possible _ _ O
" _ _ O
correct _ _ O
" _ _ O
tokenizations _ _ O
. _ _ O
● _ _ O
consider _ _ O
these _ _ O
snippets _ _ O
of _ _ O
Java _ _ O
. _ _ O
if _ _ O
( _ _ O
x _ _ O
= _ _ O
= _ _ O
3 _ _ O
) _ _ O
is _ _ O
this _ _ O
[ _ _ O
= _ _ O
= _ _ O
] _ _ O
or _ _ O
[= _ _ O
, _ _ O
=] _ _ O
? _ _ O
3.4 _ _ O
is _ _ O
this _ _ O
[ _ _ O
3.4 _ _ O
] _ _ O
or _ _ O
[ _ _ O
3 _ _ O
. _ _ O
, _ _ O
4 _ _ O
] _ _ O
? _ _ O
abc123 _ _ O
123abc _ _ O
is _ _ O
this _ _ O
[ _ _ O
abc123 _ _ O
] _ _ O
or _ _ O
[ _ _ O
abc _ _ O
, _ _ O
123 _ _ O
] _ _ O
or _ _ O
[ _ _ O
ab _ _ O
, _ _ O
c123 _ _ O
] _ _ O
or _ _ O
… _ _ O
? _ _ O
why _ _ O
do _ _ O
we _ _ O
think _ _ O
this _ _ O
is _ _ O
an _ _ O
error _ _ O
when _ _ O
the _ _ O
above _ _ O
is _ _ O
not _ _ O
? _ _ O
on _ _ O
this _ _ O
line _ _ O
, _ _ O
> _ _ O
> _ _ O
is _ _ O
a _ _ O
right _ _ O
shift _ _ O
… _ _ O
int _ _ O
y _ _ O
= _ _ O
x _ _ O
> _ _ O
> _ _ O
3 _ _ O
; _ _ O
List _ _ O
< _ _ O
List _ _ O
< _ _ O
String _ _ O
> _ _ O
> _ _ O
l _ _ O
; _ _ O
but _ _ O
here _ _ O
, _ _ O
it _ _ O
's _ _ O
two _ _ O
right _ _ O
angle _ _ O
brackets _ _ O
? _ _ O
there _ _ O
are _ _ O
three _ _ O
ways _ _ O
I _ _ O
can _ _ O
think _ _ O
of _ _ O
to _ _ O
resolve _ _ O
ambiguity _ _ O
. _ _ O
25 _ _ O

Approach _ _ O
1 _ _ O
: _ _ O
Maximal _ _ O
Munch _ _ O
● _ _ O
maximal _ _ O
munch _ _ O
is _ _ O
a _ _ O
strategy _ _ O
that _ _ O
says _ _ O
: _ _ O
always _ _ O
try _ _ O
to _ _ O
make _ _ O
the _ _ O
biggest _ _ O
token _ _ O
possible _ _ O
, _ _ O
going _ _ O
left-to-right _ _ O
. _ _ O
if _ _ O
( _ _ O
x _ _ O
= _ _ O
= _ _ O
3 _ _ O
) _ _ O
this _ _ O
is _ _ O
[ _ _ O
= _ _ O
=] _ _ O
. _ _ O
3.4 _ _ O
this _ _ O
is _ _ O
[ _ _ O
3.4 _ _ O
] _ _ O
. _ _ O
abc123 _ _ O
123abc _ _ O
this _ _ O
is _ _ O
[ _ _ O
abc123 _ _ O
] _ _ O
. _ _ O
this _ _ O
is _ _ O
an _ _ O
error _ _ O
because _ _ O
we _ _ O
start _ _ O
lexing _ _ O
a _ _ O
number _ _ O
, _ _ O
and _ _ O
then _ _ O
hit _ _ O
a _ _ O
non-numerical _ _ O
character _ _ O
. _ _ O
although _ _ O
, _ _ O
it _ _ O
does _ _ O
n't _ _ O
have _ _ O
to _ _ O
be _ _ O
; _ _ O
we _ _ O
could _ _ O
say _ _ O
" _ _ O
3x _ _ O
" _ _ O
is _ _ O
another _ _ O
way _ _ O
of _ _ O
writing _ _ O
" _ _ O
3 _ _ O
* _ _ O
x _ _ O
" _ _ O
, _ _ O
could _ _ O
n't _ _ O
we _ _ O
? _ _ O
int _ _ O
y _ _ O
= _ _ O
x _ _ O
> _ _ O
> _ _ O
3 _ _ O
; _ _ O
List _ _ O
< _ _ O
List _ _ O
< _ _ O
String _ _ O
> _ _ O
> _ _ O
l _ _ O
; _ _ O
but _ _ O
this _ _ O
still _ _ O
presents _ _ O
an _ _ O
issue _ _ O
… _ _ O
26 _ _ O

Approach _ _ O
2 _ _ O
: _ _ O
Deal _ _ O
with _ _ O
it _ _ O
later _ _ O
! _ _ O
● _ _ O
we _ _ O
can _ _ O
have _ _ O
the _ _ O
parser _ _ O
( _ _ O
the _ _ O
next _ _ O
step _ _ O
) _ _ O
disambiguate _ _ O
things _ _ O
that _ _ O
would _ _ O
be _ _ O
impossible _ _ O
to _ _ O
detect _ _ O
in _ _ O
the _ _ O
lexer _ _ O
. _ _ O
lexers _ _ O
are _ _ O
usually _ _ O
specified _ _ O
as _ _ O
regular _ _ O
languages _ _ O
, _ _ O
which _ _ O
can _ _ O
not _ _ O
detect _ _ O
arbitrarily _ _ O
nested _ _ O
brackets _ _ O
. _ _ O
List _ _ O
< _ _ O
List _ _ O
< _ _ O
String _ _ O
> _ _ O
> _ _ O
l _ _ O
; _ _ O
the _ _ O
lexer _ _ O
can _ _ O
not _ _ O
know _ _ O
that _ _ O
> _ _ O
> _ _ O
is _ _ O
a _ _ O
pair _ _ O
of _ _ O
closing _ _ O
brackets _ _ O
without _ _ O
knowing _ _ O
that _ _ O
there _ _ O
are _ _ O
two _ _ O
unpaired _ _ O
open _ _ O
brackets _ _ O
. _ _ O
so _ _ O
, _ _ O
we _ _ O
have _ _ O
the _ _ O
parser _ _ O
say _ _ O
" _ _ O
oh _ _ O
, _ _ O
I _ _ O
currently _ _ O
have _ _ O
two _ _ O
open _ _ O
brackets _ _ O
; _ _ O
this _ _ O
> _ _ O
> _ _ O
must _ _ O
be _ _ O
a _ _ O
pair _ _ O
of _ _ O
closing _ _ O
brackets _ _ O
and _ _ O
not _ _ O
a _ _ O
right-shift _ _ O
. _ _ O
" _ _ O
but _ _ O
why _ _ O
bother _ _ O
making _ _ O
things _ _ O
harder _ _ O
for _ _ O
ourselves _ _ O
? _ _ O
27 _ _ O

Approach _ _ O
3 _ _ O
: _ _ O
" _ _ O
Doctor _ _ O
, _ _ O
it _ _ O
hurts _ _ O
when _ _ O
I _ _ O
do _ _ O
this _ _ O
" _ _ O
● _ _ O
we _ _ O
could _ _ O
just _ _ O
define _ _ O
our _ _ O
rules _ _ O
so _ _ O
they _ _ O
're _ _ O
unambiguous _ _ O
. _ _ O
List _ _ O
! _ _ O
( _ _ O
List _ _ O
! _ _ O
( _ _ O
String _ _ O
) _ _ O
) _ _ O
l _ _ O
; _ _ O
in _ _ O
the _ _ O
D _ _ O
language _ _ O
, _ _ O
templates _ _ O
( _ _ O
generics _ _ O
) _ _ O
use _ _ O
parens _ _ O
instead _ _ O
. _ _ O
the _ _ O
parser _ _ O
then _ _ O
knows _ _ O
! _ _ O
( _ _ O
is _ _ O
a _ _ O
" _ _ O
template _ _ O
open _ _ O
paren _ _ O
" _ _ O
. _ _ O
l _ _ O
: _ _ O
: _ _ O
List _ _ O
List _ _ O
String _ _ O
m _ _ O
: _ _ O
: _ _ O
List _ _ O
( _ _ O
List _ _ O
String _ _ O
) _ _ O
in _ _ O
Haskell _ _ O
, _ _ O
generics _ _ O
do _ _ O
n't _ _ O
require _ _ O
any _ _ O
symbols _ _ O
, _ _ O
but _ _ O
can _ _ O
use _ _ O
parens _ _ O
. _ _ O
x _ _ O
shr _ _ O
3 _ _ O
or _ _ O
, _ _ O
we _ _ O
could _ _ O
redefine _ _ O
right _ _ O
shift _ _ O
to _ _ O
use _ _ O
some _ _ O
spelling _ _ O
other _ _ O
than _ _ O
> _ _ O
> _ _ O
. _ _ O
28 _ _ O

Really _ _ O
bad _ _ O
cases _ _ O
of _ _ O
ambiguity _ _ O
● _ _ O
if _ _ O
you _ _ O
are _ _ O
n't _ _ O
careful _ _ O
, _ _ O
you _ _ O
can _ _ O
end _ _ O
up _ _ O
with _ _ O
nasty _ _ O
situations _ _ O
. _ _ O
Lexer _ _ O
Parser _ _ O
Semantic _ _ O
Analyzer _ _ O
C _ _ O
and _ _ O
C++ _ _ O
have _ _ O
this _ _ O
situation _ _ O
, _ _ O
where _ _ O
you _ _ O
can _ _ O
not _ _ O
correctly _ _ O
lex _ _ O
the _ _ O
source _ _ O
code _ _ O
until _ _ O
you _ _ O
've _ _ O
done _ _ O
( _ _ O
some _ _ O
) _ _ O
semantic _ _ O
analysis _ _ O
. _ _ O
this _ _ O
sucks _ _ O
! _ _ O
it _ _ O
makes _ _ O
the _ _ O
compiler _ _ O
slower _ _ O
, _ _ O
harder _ _ O
to _ _ O
write _ _ O
, _ _ O
and _ _ O
harder _ _ O
to _ _ O
reason _ _ O
about _ _ O
. _ _ O
fortunately _ _ O
, _ _ O
we _ _ O
have _ _ O
the _ _ O
hindsight _ _ O
of _ _ O
decades _ _ O
of _ _ O
language _ _ O
design _ _ O
and _ _ O
can _ _ O
avoid _ _ O
this _ _ O
stuff _ _ O
:) _ _ O
29 _ _ O

The _ _ O
examples _ _ O
● _ _ O
first _ _ O
, _ _ O
there _ _ O
’s _ _ O
an _ _ O
example _ _ O
showing _ _ O
how _ _ O
Rust _ _ O
’s _ _ O
match _ _ O
statement _ _ O
works _ _ O
, _ _ O
called _ _ O
rust_match _ _ O
. _ _ O
● _ _ O
there _ _ O
's _ _ O
a _ _ O
small _ _ O
example _ _ O
, _ _ O
lexing_toy _ _ O
, _ _ O
that _ _ O
shows _ _ O
how _ _ O
simple _ _ O
it _ _ O
can _ _ O
be _ _ O
to _ _ O
make _ _ O
a _ _ O
lexer _ _ O
. _ _ O
o _ _ O
it _ _ O
only _ _ O
has _ _ O
a _ _ O
few _ _ O
kinds _ _ O
of _ _ O
tokens _ _ O
, _ _ O
and _ _ O
is _ _ O
written _ _ O
in _ _ O
a _ _ O
different _ _ O
style _ _ O
from _ _ O
the _ _ O
project _ _ O
, _ _ O
cause _ _ O
I _ _ O
do _ _ O
n’t _ _ O
wanna _ _ O
give _ _ O
too _ _ O
much _ _ O
away _ _ O
(: _ _ O
o _ _ O
but _ _ O
it _ _ O
shows _ _ O
the _ _ O
general _ _ O
“ _ _ O
shape _ _ O
” _ _ O
of _ _ O
a _ _ O
lexing _ _ O
algorithm _ _ O
. _ _ O
30 _ _ O



