unlabeled|cs1622|lec06
-DOCSTART- -X- -X- O

Bottom-up _ _ O
Parsing _ _ O
CS _ _ O
/ _ _ O
COE _ _ O
1622 _ _ O
Jarrett _ _ O
Billingsley _ _ O

Class _ _ O
Announcements _ _ O
● _ _ O
today _ _ O
we _ _ O
're _ _ O
finishing _ _ O
parsing _ _ O
! _ _ O
! _ _ O
yaaay _ _ O
o _ _ O
so _ _ O
after _ _ O
today _ _ O
you _ _ O
’ll _ _ O
have _ _ O
everything _ _ O
you _ _ O
need _ _ O
for _ _ O
project _ _ O
2 _ _ O
! _ _ O
! _ _ O
! _ _ O
! _ _ O
! _ _ O
! _ _ O
● _ _ O
bottom-up _ _ O
parsing _ _ O
is _ _ O
( _ _ O
imo _ _ O
) _ _ O
best _ _ O
used _ _ O
for _ _ O
parsing _ _ O
expressions _ _ O
, _ _ O
so _ _ O
we _ _ O
should _ _ O
start _ _ O
by _ _ O
talking _ _ O
about _ _ O
… _ _ O
2 _ _ O

Operators _ _ O
3 _ _ O

Evaluating _ _ O
( _ _ O
and _ _ O
producing _ _ O
) _ _ O
trees _ _ O
● _ _ O
we _ _ O
saw _ _ O
before _ _ O
that _ _ O
given _ _ O
an _ _ O
AST _ _ O
, _ _ O
we _ _ O
could _ _ O
evaluate _ _ O
it _ _ O
: _ _ O
* _ _ O
5 _ _ O
I _ _ O
think _ _ O
you _ _ O
would _ _ O
agree _ _ O
that _ _ O
the _ _ O
order _ _ O
of _ _ O
operations _ _ O
here _ _ O
is _ _ O
to _ _ O
do _ _ O
the _ _ O
addition _ _ O
, _ _ O
then _ _ O
the _ _ O
multiplication _ _ O
. _ _ O
+ _ _ O
2 _ _ O
3 _ _ O
but _ _ O
we _ _ O
're _ _ O
talking _ _ O
about _ _ O
parsing _ _ O
now _ _ O
. _ _ O
what _ _ O
source _ _ O
code _ _ O
would _ _ O
I _ _ O
write _ _ O
to _ _ O
produce _ _ O
this _ _ O
AST _ _ O
? _ _ O
5 _ _ O
* _ _ O
( _ _ O
2 _ _ O
+ _ _ O
3 _ _ O
) _ _ O
+ _ _ O
why _ _ O
did _ _ O
we _ _ O
have _ _ O
to _ _ O
put _ _ O
parentheses _ _ O
there _ _ O
? _ _ O
because _ _ O
of _ _ O
the _ _ O
order _ _ O
of _ _ O
operations _ _ O
: _ _ O
without _ _ O
them _ _ O
, _ _ O
5 _ _ O
* _ _ O
2 _ _ O
+ _ _ O
3 _ _ O
would _ _ O
parse _ _ O
as _ _ O
: _ _ O
* _ _ O
5 _ _ O
3 _ _ O
2 _ _ O
4 _ _ O

PEMDAS _ _ O
, _ _ O
BODMAS _ _ O
, _ _ O
BIDMAS _ _ O
… _ _ O
● _ _ O
officially _ _ O
, _ _ O
the _ _ O
order _ _ O
of _ _ O
operations _ _ O
used _ _ O
by _ _ O
mathematicians _ _ O
is _ _ O
: _ _ O
1 _ _ O
. _ _ O
parentheses _ _ O
/ _ _ O
brackets _ _ O
2 _ _ O
. _ _ O
exponentiation _ _ O
/ _ _ O
roots _ _ O
3 _ _ O
. _ _ O
multiplication _ _ O
/ _ _ O
division _ _ O
4 _ _ O
. _ _ O
addition _ _ O
/ _ _ O
subtraction _ _ O
● _ _ O
the _ _ O
order _ _ O
of _ _ O
the _ _ O
letters _ _ O
in _ _ O
the _ _ O
acronym _ _ O
( _ _ O
MD _ _ O
vs. _ _ O
DM _ _ O
) _ _ O
does _ _ O
not _ _ O
say _ _ O
that _ _ O
e.g. _ _ O
multiplication _ _ O
happens _ _ O
before _ _ O
division _ _ O
. _ _ O
● _ _ O
when _ _ O
writing _ _ O
math _ _ O
horizontally _ _ O
like _ _ O
27 _ _ O
/ _ _ O
3 _ _ O
/ _ _ O
9 _ _ O
, _ _ O
there _ _ O
's _ _ O
a _ _ O
problem _ _ O
: _ _ O
o _ _ O
even _ _ O
among _ _ O
mathematicians _ _ O
, _ _ O
there _ _ O
is _ _ O
no _ _ O
consensus _ _ O
on _ _ O
what _ _ O
order _ _ O
horizontal _ _ O
division _ _ O
should _ _ O
be _ _ O
done _ _ O
! _ _ O
● _ _ O
in _ _ O
programming _ _ O
languages _ _ O
, _ _ O
all _ _ O
math _ _ O
is _ _ O
written _ _ O
horizontally _ _ O
… _ _ O
o _ _ O
and _ _ O
you _ _ O
have _ _ O
e.g. _ _ O
% _ _ O
, _ _ O
& _ _ O
& _ _ O
, _ _ O
|| _ _ O
, _ _ O
& _ _ O
, _ _ O
| _ _ O
, _ _ O
^ _ _ O
, _ _ O
! _ _ O
, _ _ O
~ _ _ O
, _ _ O
< _ _ O
, _ _ O
> _ _ O
, _ _ O
< _ _ O
= _ _ O
, _ _ O
> _ _ O
= _ _ O
, _ _ O
= _ _ O
= _ _ O
, _ _ O
! _ _ O
= _ _ O
, _ _ O
… _ _ O
● _ _ O
so _ _ O
we _ _ O
need _ _ O
a _ _ O
more _ _ O
rigorous _ _ O
way _ _ O
of _ _ O
dealing _ _ O
with _ _ O
this _ _ O
. _ _ O
5 _ _ O

Operator _ _ O
Precedence _ _ O
● _ _ O
here _ _ O
's _ _ O
a _ _ O
more _ _ O
formalized _ _ O
, _ _ O
algorithmically-checkable _ _ O
method _ _ O
: _ _ O
o _ _ O
you _ _ O
rank _ _ O
the _ _ O
operators _ _ O
by _ _ O
giving _ _ O
each _ _ O
a _ _ O
number _ _ O
, _ _ O
its _ _ O
precedence _ _ O
o _ _ O
that _ _ O
precedence _ _ O
decides _ _ O
the _ _ O
order _ _ O
of _ _ O
evaluation _ _ O
● _ _ O
another _ _ O
way _ _ O
of _ _ O
thinking _ _ O
of _ _ O
it _ _ O
is _ _ O
: _ _ O
if _ _ O
you _ _ O
wrote _ _ O
the _ _ O
expression _ _ O
without _ _ O
parentheses _ _ O
, _ _ O
the _ _ O
precedence _ _ O
tells _ _ O
you _ _ O
where _ _ O
they _ _ O
should _ _ O
go _ _ O
: _ _ O
Operator _ _ O
Prec _ _ O
a _ _ O
+ _ _ O
b _ _ O
* _ _ O
c _ _ O
a _ _ O
+ _ _ O
( _ _ O
b _ _ O
* _ _ O
c _ _ O
) _ _ O
* _ _ O
* _ _ O
1st _ _ O
a _ _ O
* _ _ O
* _ _ O
b _ _ O
* _ _ O
c _ _ O
( _ _ O
a _ _ O
* _ _ O
* _ _ O
b _ _ O
) _ _ O
* _ _ O
c _ _ O
* _ _ O
/ _ _ O
% _ _ O
2nd _ _ O
+ _ _ O
- _ _ O
3rd _ _ O
but _ _ O
this _ _ O
still _ _ O
is _ _ O
n't _ _ O
enough _ _ O
information _ _ O
to _ _ O
disambiguate _ _ O
when _ _ O
operators _ _ O
of _ _ O
the _ _ O
same _ _ O
precedence _ _ O
appear _ _ O
next _ _ O
to _ _ O
each _ _ O
other _ _ O
: _ _ O
27 _ _ O
/ _ _ O
3 _ _ O
/ _ _ O
9 _ _ O
( _ _ O
27 _ _ O
/ _ _ O
3 _ _ O
) _ _ O
/ _ _ O
9 _ _ O
or _ _ O
27 _ _ O
/ _ _ O
( _ _ O
3 _ _ O
/ _ _ O
9 _ _ O
) _ _ O
? _ _ O
6 _ _ O

Operator _ _ O
Associativity _ _ O
● _ _ O
in _ _ O
a _ _ O
precedence _ _ O
tie _ _ O
, _ _ O
an _ _ O
operator _ _ O
's _ _ O
associativity _ _ O
breaks _ _ O
the _ _ O
tie _ _ O
. _ _ O
left-associative _ _ O
operators _ _ O
( _ _ O
e.g. _ _ O
+ _ _ O
, _ _ O
- _ _ O
, _ _ O
* _ _ O
, _ _ O
/ _ _ O
, _ _ O
% _ _ O
) _ _ O
evaluate _ _ O
things _ _ O
left-to-right _ _ O
. _ _ O
and _ _ O
right-associative _ _ O
operators _ _ O
( _ _ O
e.g. _ _ O
* _ _ O
* _ _ O
, _ _ O
=) _ _ O
evaluate _ _ O
things _ _ O
right-to-left _ _ O
. _ _ O
27 _ _ O
/ _ _ O
3 _ _ O
/ _ _ O
9 _ _ O
2 _ _ O
* _ _ O
* _ _ O
3 _ _ O
* _ _ O
* _ _ O
4 _ _ O
( _ _ O
27 _ _ O
/ _ _ O
3 _ _ O
) _ _ O
/ _ _ O
9 _ _ O
2 _ _ O
* _ _ O
* _ _ O
( _ _ O
3 _ _ O
* _ _ O
* _ _ O
4 _ _ O
) _ _ O
in _ _ O
other _ _ O
words _ _ O
, _ _ O
associativity _ _ O
says _ _ O
which _ _ O
way _ _ O
the _ _ O
tree _ _ O
branches _ _ O
. _ _ O
/ _ _ O
/ _ _ O
27 _ _ O
* _ _ O
* _ _ O
9 _ _ O
3 _ _ O
2 _ _ O
* _ _ O
* _ _ O
3 _ _ O
4 _ _ O
7 _ _ O

More _ _ O
about _ _ O
associativity _ _ O
● _ _ O
to _ _ O
be _ _ O
clear _ _ O
: _ _ O
associativity _ _ O
only _ _ O
applies _ _ O
when _ _ O
you _ _ O
have _ _ O
adjacent _ _ O
operators _ _ O
of _ _ O
the _ _ O
same _ _ O
precedence _ _ O
. _ _ O
o _ _ O
a _ _ O
* _ _ O
* _ _ O
b _ _ O
+ _ _ O
c _ _ O
parses _ _ O
as _ _ O
( _ _ O
a _ _ O
* _ _ O
* _ _ O
b _ _ O
) _ _ O
+ _ _ O
c _ _ O
, _ _ O
because _ _ O
exponentiation _ _ O
's _ _ O
precedence _ _ O
ranks _ _ O
higher _ _ O
than _ _ O
addition _ _ O
's _ _ O
. _ _ O
● _ _ O
it _ _ O
's _ _ O
also _ _ O
possible _ _ O
for _ _ O
operators _ _ O
to _ _ O
be _ _ O
non-associative _ _ O
. _ _ O
o _ _ O
that _ _ O
means _ _ O
it _ _ O
's _ _ O
an _ _ O
error _ _ O
for _ _ O
them _ _ O
to _ _ O
be _ _ O
adjacent _ _ O
. _ _ O
● _ _ O
for _ _ O
example _ _ O
, _ _ O
what _ _ O
does _ _ O
x _ _ O
< _ _ O
y _ _ O
< _ _ O
z _ _ O
mean _ _ O
? _ _ O
o _ _ O
in _ _ O
Java _ _ O
, _ _ O
you _ _ O
get _ _ O
a _ _ O
type _ _ O
error _ _ O
. _ _ O
o _ _ O
in _ _ O
Python _ _ O
, _ _ O
it _ _ O
's _ _ O
parsed _ _ O
as _ _ O
( _ _ O
x _ _ O
< _ _ O
y _ _ O
) _ _ O
& _ _ O
& _ _ O
( _ _ O
y _ _ O
< _ _ O
z _ _ O
) _ _ O
. _ _ O
o _ _ O
in _ _ O
the _ _ O
language _ _ O
we _ _ O
're _ _ O
designing _ _ O
, _ _ O
we _ _ O
could _ _ O
say _ _ O
that _ _ O
comparisons _ _ O
are _ _ O
non-associative _ _ O
, _ _ O
and _ _ O
block _ _ O
this _ _ O
potentially-confusing _ _ O
code _ _ O
as _ _ O
a _ _ O
parsing _ _ O
error _ _ O
instead _ _ O
. _ _ O
8 _ _ O

Unary _ _ O
and _ _ O
postfix _ _ O
operators _ _ O
● _ _ O
operators _ _ O
that _ _ O
take _ _ O
two _ _ O
operands _ _ O
are _ _ O
called _ _ O
binary _ _ O
. _ _ O
but _ _ O
many _ _ O
( _ _ O
especially _ _ O
in _ _ O
C-style _ _ O
languages _ _ O
) _ _ O
are _ _ O
unary _ _ O
and _ _ O
operate _ _ O
on _ _ O
one _ _ O
value _ _ O
. _ _ O
o _ _ O
-x _ _ O
, _ _ O
~x _ _ O
, _ _ O
! _ _ O
x _ _ O
, _ _ O
& _ _ O
x _ _ O
, _ _ O
* _ _ O
x _ _ O
, _ _ O
+ _ _ O
+ _ _ O
x _ _ O
, _ _ O
--x _ _ O
, _ _ O
( _ _ O
int _ _ O
) _ _ O
x _ _ O
o _ _ O
these _ _ O
are _ _ O
given _ _ O
a _ _ O
precedence _ _ O
higher _ _ O
than _ _ O
any _ _ O
binary _ _ O
operator _ _ O
. _ _ O
▪ _ _ O
this _ _ O
matches _ _ O
our _ _ O
intuition _ _ O
: _ _ O
-3 _ _ O
+ _ _ O
5 _ _ O
should _ _ O
give _ _ O
2 _ _ O
, _ _ O
not _ _ O
-8 _ _ O
. _ _ O
o _ _ O
these _ _ O
are _ _ O
all _ _ O
right-associative _ _ O
, _ _ O
but _ _ O
it _ _ O
does _ _ O
n't _ _ O
come _ _ O
up _ _ O
much _ _ O
. _ _ O
▪ _ _ O
-~x _ _ O
would _ _ O
bitwise-complement _ _ O
x _ _ O
first _ _ O
, _ _ O
then _ _ O
negate _ _ O
that _ _ O
. _ _ O
● _ _ O
finally _ _ O
there _ _ O
are _ _ O
postfix _ _ O
operators _ _ O
which _ _ O
come _ _ O
after _ _ O
their _ _ O
operand _ _ O
. _ _ O
o _ _ O
x++ _ _ O
, _ _ O
x-- _ _ O
, _ _ O
a _ _ O
[ _ _ O
i _ _ O
] _ _ O
, _ _ O
obj.field _ _ O
, _ _ O
f _ _ O
( _ _ O
x _ _ O
) _ _ O
o _ _ O
and _ _ O
these _ _ O
have _ _ O
the _ _ O
highest _ _ O
precedence _ _ O
of _ _ O
all _ _ O
! _ _ O
▪ _ _ O
-f _ _ O
( _ _ O
x _ _ O
) _ _ O
calls _ _ O
the _ _ O
function _ _ O
first _ _ O
, _ _ O
then _ _ O
negates _ _ O
the _ _ O
return _ _ O
value _ _ O
. _ _ O
o _ _ O
these _ _ O
are _ _ O
all _ _ O
left-associative _ _ O
, _ _ O
and _ _ O
that _ _ O
's _ _ O
pretty _ _ O
common _ _ O
to _ _ O
see _ _ O
. _ _ O
▪ _ _ O
f _ _ O
( _ _ O
x _ _ O
) _ _ O
[ _ _ O
i _ _ O
] _ _ O
.field _ _ O
calls _ _ O
f _ _ O
first _ _ O
, _ _ O
then _ _ O
indexes _ _ O
the _ _ O
returned _ _ O
array _ _ O
, _ _ O
then _ _ O
accesses _ _ O
the _ _ O
field _ _ O
from _ _ O
the _ _ O
array _ _ O
value _ _ O
. _ _ O
9 _ _ O

Summarizing _ _ O
operators _ _ O
● _ _ O
a _ _ O
language _ _ O
's _ _ O
specification _ _ O
will _ _ O
typically _ _ O
have _ _ O
all _ _ O
the _ _ O
operators _ _ O
, _ _ O
their _ _ O
precedences _ _ O
, _ _ O
and _ _ O
their _ _ O
associativities _ _ O
listed _ _ O
in _ _ O
a _ _ O
table _ _ O
: _ _ O
Operator _ _ O
Prec _ _ O
Assoc _ _ O
f _ _ O
( _ _ O
) _ _ O
a _ _ O
[ _ _ O
i _ _ O
] _ _ O
o.f _ _ O
1 _ _ O
L _ _ O
! _ _ O
x _ _ O
-x _ _ O
* _ _ O
x _ _ O
& _ _ O
x _ _ O
+ _ _ O
+ _ _ O
x _ _ O
--x _ _ O
2 _ _ O
R _ _ O
* _ _ O
/ _ _ O
% _ _ O
3 _ _ O
L _ _ O
+ _ _ O
- _ _ O
4 _ _ O
L _ _ O
< _ _ O
< _ _ O
= _ _ O
> _ _ O
> _ _ O
= _ _ O
5 _ _ O
L _ _ O
= _ _ O
= _ _ O
! _ _ O
= _ _ O
6 _ _ O
L _ _ O
& _ _ O
& _ _ O
7 _ _ O
L _ _ O
|| _ _ O
8 _ _ O
L _ _ O
= _ _ O
9 _ _ O
R _ _ O
this _ _ O
is _ _ O
a _ _ O
pretty _ _ O
typical _ _ O
arrangement _ _ O
for _ _ O
a _ _ O
C-style _ _ O
language _ _ O
( _ _ O
excluding _ _ O
bitwise _ _ O
operators _ _ O
, _ _ O
casts _ _ O
, _ _ O
reflexive _ _ O
assignments _ _ O
, _ _ O
and _ _ O
some _ _ O
other _ _ O
obscure _ _ O
operators _ _ O
) _ _ O
but _ _ O
where _ _ O
are _ _ O
parentheses _ _ O
? _ _ O
well _ _ O
, _ _ O
they _ _ O
're _ _ O
not _ _ O
operators _ _ O
. _ _ O
parentheses _ _ O
only _ _ O
control _ _ O
the _ _ O
order _ _ O
of _ _ O
evaluation _ _ O
and _ _ O
the _ _ O
way _ _ O
the _ _ O
AST _ _ O
is _ _ O
built _ _ O
; _ _ O
they _ _ O
do _ _ O
n't _ _ O
do _ _ O
anything _ _ O
otherwise _ _ O
. _ _ O
10 _ _ O

Building _ _ O
a _ _ O
grammar _ _ O
for _ _ O
expressions _ _ O
11 _ _ O

A _ _ O
grammar _ _ O
from _ _ O
the _ _ O
bottom _ _ O
up _ _ O
● _ _ O
rather _ _ O
than _ _ O
starting _ _ O
with _ _ O
the _ _ O
" _ _ O
overall _ _ O
" _ _ O
structure _ _ O
of _ _ O
an _ _ O
expression _ _ O
… _ _ O
o _ _ O
let _ _ O
's _ _ O
start _ _ O
with _ _ O
the _ _ O
most _ _ O
basic _ _ O
parts _ _ O
and _ _ O
gradually _ _ O
combine _ _ O
them _ _ O
. _ _ O
● _ _ O
a _ _ O
primary _ _ O
expression _ _ O
is _ _ O
the _ _ O
most _ _ O
basic _ _ O
kind _ _ O
. _ _ O
literals _ _ O
fall _ _ O
into _ _ O
this _ _ O
category _ _ O
. _ _ O
318 _ _ O
identifiers _ _ O
are _ _ O
another _ _ O
kind _ _ O
: _ _ O
they _ _ O
name _ _ O
single _ _ O
things _ _ O
. _ _ O
" _ _ O
hello _ _ O
" _ _ O
9.5 _ _ O
' _ _ O
x _ _ O
' _ _ O
x _ _ O
main _ _ O
System _ _ O
last _ _ O
, _ _ O
we _ _ O
'll _ _ O
include _ _ O
parenthesized _ _ O
expressions _ _ O
, _ _ O
because _ _ O
they _ _ O
contain _ _ O
whole _ _ O
sub-expressions _ _ O
. _ _ O
so _ _ O
, _ _ O
our _ _ O
grammar _ _ O
is _ _ O
: _ _ O
PrimaryExp _ _ O
: _ _ O
IdExp _ _ O
| _ _ O
IntLitExp _ _ O
| _ _ O
ParenExp _ _ O
IdExp _ _ O
: _ _ O
< _ _ O
identifier _ _ O
token _ _ O
> _ _ O
IntLitExp _ _ O
: _ _ O
< _ _ O
int _ _ O
literal _ _ O
token _ _ O
> _ _ O
( _ _ O
Exp _ _ O
is _ _ O
the _ _ O
top-level _ _ O
expression _ _ O
rule _ _ O
that _ _ O
we _ _ O
're _ _ O
building _ _ O
up _ _ O
to _ _ O
) _ _ O
ParenExp _ _ O
: _ _ O
' _ _ O
( _ _ O
' _ _ O
Exp _ _ O
' _ _ O
) _ _ O
' _ _ O
12 _ _ O

Terms _ _ O
: _ _ O
primaries _ _ O
with _ _ O
decorations _ _ O
● _ _ O
since _ _ O
unary _ _ O
and _ _ O
postfix _ _ O
operators _ _ O
are _ _ O
so _ _ O
closely _ _ O
associated _ _ O
with _ _ O
their _ _ O
operands _ _ O
, _ _ O
we _ _ O
can _ _ O
define _ _ O
a _ _ O
Term _ _ O
rule _ _ O
like _ _ O
this _ _ O
: _ _ O
Term _ _ O
: _ _ O
UnaryOp _ _ O
* _ _ O
PrimaryExp _ _ O
PostfixOp _ _ O
* _ _ O
● _ _ O
that _ _ O
is _ _ O
, _ _ O
0 _ _ O
or _ _ O
more _ _ O
unary _ _ O
operators _ _ O
before _ _ O
a _ _ O
primary _ _ O
" _ _ O
core _ _ O
, _ _ O
" _ _ O
followed _ _ O
by _ _ O
0 _ _ O
or _ _ O
more _ _ O
postfix _ _ O
operators _ _ O
. _ _ O
● _ _ O
UnaryOp _ _ O
and _ _ O
PostfixOp _ _ O
might _ _ O
be _ _ O
defined _ _ O
like _ _ O
: _ _ O
UnaryOp _ _ O
: _ _ O
' _ _ O
- _ _ O
' _ _ O
| _ _ O
' _ _ O
! _ _ O
' _ _ O
PostfixOp _ _ O
: _ _ O
CallOp _ _ O
| _ _ O
FieldOp _ _ O
| _ _ O
IndexOp _ _ O
CallOp _ _ O
: _ _ O
' _ _ O
( _ _ O
' _ _ O
' _ _ O
) _ _ O
' _ _ O
| _ _ O
' _ _ O
( _ _ O
' _ _ O
Exp _ _ O
( _ _ O
' _ _ O
, _ _ O
' _ _ O
Exp _ _ O
) _ _ O
* _ _ O
' _ _ O
) _ _ O
' _ _ O
FieldOp _ _ O
: _ _ O
' _ _ O
. _ _ O
' _ _ O
< _ _ O
identifier _ _ O
token _ _ O
> _ _ O
IndexOp _ _ O
: _ _ O
' _ _ O
[ _ _ O
' _ _ O
Exp _ _ O
' _ _ O
] _ _ O
' _ _ O
● _ _ O
example _ _ O
productions _ _ O
of _ _ O
this _ _ O
grammar _ _ O
are _ _ O
x _ _ O
, _ _ O
-x _ _ O
, _ _ O
f _ _ O
( _ _ O
) _ _ O
, _ _ O
! _ _ O
f _ _ O
( _ _ O
x _ _ O
) _ _ O
.z _ _ O
, _ _ O
! _ _ O
! _ _ O
x _ _ O
13 _ _ O

Expressions _ _ O
: _ _ O
the _ _ O
big _ _ O
picture _ _ O
● _ _ O
really _ _ O
, _ _ O
every _ _ O
expression _ _ O
looks _ _ O
like _ _ O
this _ _ O
: _ _ O
term _ _ O
op _ _ O
term _ _ O
op _ _ O
term _ _ O
op _ _ O
term _ _ O
op _ _ O
term _ _ O
where _ _ O
each _ _ O
op _ _ O
is _ _ O
a _ _ O
binary _ _ O
operator _ _ O
. _ _ O
so _ _ O
, _ _ O
we _ _ O
'll _ _ O
define _ _ O
these _ _ O
rules _ _ O
: _ _ O
Exp _ _ O
: _ _ O
Term _ _ O
( _ _ O
BinaryOp _ _ O
Term _ _ O
) _ _ O
* _ _ O
BinaryOp _ _ O
: _ _ O
' _ _ O
+ _ _ O
' _ _ O
| _ _ O
' _ _ O
- _ _ O
' _ _ O
| _ _ O
' _ _ O
* _ _ O
' _ _ O
| _ _ O
' _ _ O
/ _ _ O
' _ _ O
| _ _ O
' _ _ O
% _ _ O
' _ _ O
|…etc _ _ O
. _ _ O
but _ _ O
what _ _ O
about _ _ O
the _ _ O
associativity _ _ O
and _ _ O
precedence _ _ O
? _ _ O
? _ _ O
well _ _ O
, _ _ O
we _ _ O
just _ _ O
… _ _ O
uh _ _ O
… _ _ O
wo _ _ O
n't _ _ O
encode _ _ O
that _ _ O
into _ _ O
the _ _ O
grammar _ _ O
. _ _ O
14 _ _ O

Wait _ _ O
. _ _ O
What _ _ O
? _ _ O
● _ _ O
it _ _ O
is _ _ O
absolutely _ _ O
possible _ _ O
to _ _ O
encode _ _ O
precedence _ _ O
and _ _ O
associativity _ _ O
into _ _ O
the _ _ O
expression _ _ O
grammar _ _ O
, _ _ O
and _ _ O
then _ _ O
write _ _ O
a _ _ O
fully _ _ O
recursive-descent _ _ O
parser _ _ O
for _ _ O
expressions _ _ O
. _ _ O
( _ _ O
I _ _ O
know _ _ O
, _ _ O
because _ _ O
I _ _ O
've _ _ O
done _ _ O
it _ _ O
. _ _ O
) _ _ O
● _ _ O
but _ _ O
the _ _ O
result _ _ O
is _ _ O
just _ _ O
… _ _ O
well _ _ O
. _ _ O
here _ _ O
's _ _ O
a _ _ O
simple _ _ O
mathematical _ _ O
language _ _ O
: _ _ O
Exp _ _ O
: _ _ O
Add _ _ O
Add _ _ O
: _ _ O
Mul _ _ O
( _ _ O
( _ _ O
' _ _ O
+ _ _ O
' _ _ O
| _ _ O
' _ _ O
- _ _ O
' _ _ O
) _ _ O
Mul _ _ O
) _ _ O
* _ _ O
Mul _ _ O
: _ _ O
Neg _ _ O
( _ _ O
( _ _ O
' _ _ O
* _ _ O
' _ _ O
| _ _ O
' _ _ O
/ _ _ O
' _ _ O
| _ _ O
' _ _ O
% _ _ O
' _ _ O
) _ _ O
Neg _ _ O
) _ _ O
* _ _ O
Neg _ _ O
: _ _ O
Pow _ _ O
| _ _ O
( _ _ O
' _ _ O
- _ _ O
' _ _ O
Neg _ _ O
) _ _ O
Pow _ _ O
: _ _ O
Pri _ _ O
( _ _ O
' _ _ O
* _ _ O
* _ _ O
' _ _ O
Pow _ _ O
) _ _ O
* _ _ O
Pri _ _ O
: _ _ O
I _ _ O
d _ _ O
| _ _ O
IntLit _ _ O
| _ _ O
' _ _ O
( _ _ O
' _ _ O
Exp _ _ O
' _ _ O
) _ _ O
' _ _ O
is _ _ O
it _ _ O
obvious _ _ O
that _ _ O
this _ _ O
accurately _ _ O
captures _ _ O
all _ _ O
expressions _ _ O
? _ _ O
can _ _ O
you _ _ O
identify _ _ O
the _ _ O
associativity _ _ O
and _ _ O
precedence _ _ O
of _ _ O
these _ _ O
operators _ _ O
? _ _ O
what _ _ O
if _ _ O
, _ _ O
like _ _ O
C _ _ O
or _ _ O
C++ _ _ O
, _ _ O
we _ _ O
had _ _ O
15 _ _ O
precedence _ _ O
levels _ _ O
and _ _ O
dozens _ _ O
of _ _ O
operators _ _ O
? _ _ O
how _ _ O
readable _ _ O
would _ _ O
that _ _ O
be _ _ O
? _ _ O
15 _ _ O

So _ _ O
no _ _ O
! _ _ O
We _ _ O
wo _ _ O
n't _ _ O
do _ _ O
it _ _ O
! _ _ O
● _ _ O
because _ _ O
we _ _ O
're _ _ O
defining _ _ O
our _ _ O
language _ _ O
's _ _ O
grammar _ _ O
a _ _ O
bit _ _ O
loosely _ _ O
, _ _ O
it _ _ O
does _ _ O
n't _ _ O
really _ _ O
matter _ _ O
if _ _ O
our _ _ O
grammar _ _ O
is _ _ O
100 _ _ O
% _ _ O
accurate _ _ O
. _ _ O
o _ _ O
instead _ _ O
, _ _ O
the _ _ O
ambiguities _ _ O
in _ _ O
the _ _ O
grammar _ _ O
are _ _ O
resolved _ _ O
by _ _ O
the _ _ O
table _ _ O
of _ _ O
precedence _ _ O
and _ _ O
associativity _ _ O
. _ _ O
● _ _ O
any _ _ O
complex _ _ O
idea _ _ O
can _ _ O
be _ _ O
expressed _ _ O
in _ _ O
multiple _ _ O
different _ _ O
ways _ _ O
. _ _ O
o _ _ O
unless _ _ O
you _ _ O
have _ _ O
some _ _ O
kind _ _ O
of _ _ O
externally-imposed _ _ O
reason _ _ O
to _ _ O
stick _ _ O
with _ _ O
one _ _ O
way _ _ O
of _ _ O
writing _ _ O
something _ _ O
… _ _ O
o _ _ O
it _ _ O
makes _ _ O
sense _ _ O
to _ _ O
use _ _ O
different _ _ O
ways _ _ O
according _ _ O
to _ _ O
their _ _ O
strengths _ _ O
. _ _ O
● _ _ O
so _ _ O
… _ _ O
o _ _ O
how _ _ O
do _ _ O
we _ _ O
write _ _ O
an _ _ O
algorithm _ _ O
to _ _ O
parse _ _ O
this _ _ O
stuff _ _ O
? _ _ O
? _ _ O
16 _ _ O

Bottom-up _ _ O
parsing _ _ O
17 _ _ O

The _ _ O
core _ _ O
of _ _ O
the _ _ O
algorithm _ _ O
● _ _ O
let _ _ O
's _ _ O
assume _ _ O
we _ _ O
only _ _ O
have _ _ O
left-associative _ _ O
binary _ _ O
operators _ _ O
. _ _ O
● _ _ O
so _ _ O
, _ _ O
to _ _ O
parse _ _ O
Term _ _ O
( _ _ O
BinaryOp _ _ O
Term _ _ O
) _ _ O
* _ _ O
, _ _ O
we _ _ O
can _ _ O
write _ _ O
something _ _ O
like _ _ O
: _ _ O
let _ _ O
mut _ _ O
LHS _ _ O
= _ _ O
parse_term _ _ O
( _ _ O
) _ _ O
; _ _ O
while _ _ O
current _ _ O
token _ _ O
is _ _ O
a _ _ O
binary _ _ O
operator _ _ O
{ _ _ O
let _ _ O
op _ _ O
= _ _ O
current _ _ O
token _ _ O
; _ _ O
move _ _ O
to _ _ O
next _ _ O
token _ _ O
; _ _ O
let _ _ O
RHS _ _ O
= _ _ O
parse_term _ _ O
( _ _ O
) _ _ O
; _ _ O
LHS _ _ O
= _ _ O
AstNode _ _ O
: _ _ O
: _ _ O
new _ _ O
( _ _ O
LHS _ _ O
, _ _ O
op _ _ O
, _ _ O
RHS _ _ O
) _ _ O
; _ _ O
} _ _ O
return _ _ O
LHS _ _ O
; _ _ O
● _ _ O
it _ _ O
might _ _ O
seem _ _ O
strange _ _ O
to _ _ O
replace _ _ O
the _ _ O
contents _ _ O
of _ _ O
the _ _ O
LHS _ _ O
variable _ _ O
inside _ _ O
the _ _ O
loop _ _ O
, _ _ O
but _ _ O
this _ _ O
is _ _ O
how _ _ O
it _ _ O
builds _ _ O
up _ _ O
the _ _ O
tree _ _ O
. _ _ O
18 _ _ O

Okay _ _ O
, _ _ O
let _ _ O
's _ _ O
try _ _ O
it _ _ O
( _ _ O
animated _ _ O
) _ _ O
● _ _ O
given _ _ O
this _ _ O
sequence _ _ O
of _ _ O
tokens _ _ O
, _ _ O
let _ _ O
's _ _ O
see _ _ O
what _ _ O
happens _ _ O
: _ _ O
x _ _ O
+ _ _ O
y _ _ O
- _ _ O
z _ _ O
< _ _ O
eof _ _ O
> _ _ O
Token _ _ O
Action _ _ O
x _ _ O
+ _ _ O
y _ _ O
z _ _ O
< _ _ O
eof _ _ O
> _ _ O
LHS _ _ O
= _ _ O
parse _ _ O
term _ _ O
LHS _ _ O
+ _ _ O
stop _ _ O
looping _ _ O
! _ _ O
y _ _ O
( _ _ O
x _ _ O
+ _ _ O
y _ _ O
) _ _ O
op _ _ O
= _ _ O
- _ _ O
, _ _ O
loop _ _ O
! _ _ O
RHS _ _ O
= _ _ O
parse _ _ O
term _ _ O
LHS _ _ O
= _ _ O
( _ _ O
LHS _ _ O
op _ _ O
RHS _ _ O
) _ _ O
RHS _ _ O
x _ _ O
op _ _ O
= _ _ O
+ _ _ O
, _ _ O
loop _ _ O
! _ _ O
RHS _ _ O
= _ _ O
parse _ _ O
term _ _ O
LHS _ _ O
= _ _ O
( _ _ O
LHS _ _ O
op _ _ O
RHS _ _ O
) _ _ O
op _ _ O
- _ _ O
z _ _ O
( _ _ O
( _ _ O
x _ _ O
+ _ _ O
y _ _ O
) _ _ O
- _ _ O
z _ _ O
) _ _ O
19 _ _ O

That _ _ O
's _ _ O
why _ _ O
it _ _ O
's _ _ O
called _ _ O
bottom-up _ _ O
( _ _ O
animated _ _ O
) _ _ O
● _ _ O
this _ _ O
algorithm _ _ O
produces _ _ O
a _ _ O
tree _ _ O
that _ _ O
branches _ _ O
to _ _ O
the _ _ O
left _ _ O
, _ _ O
like _ _ O
this _ _ O
. _ _ O
a _ _ O
+ _ _ O
b _ _ O
+ _ _ O
c _ _ O
+ _ _ O
d _ _ O
+ _ _ O
e _ _ O
but _ _ O
if _ _ O
we _ _ O
allow _ _ O
all _ _ O
the _ _ O
operators _ _ O
, _ _ O
what _ _ O
would _ _ O
be _ _ O
a _ _ O
problem _ _ O
input _ _ O
for _ _ O
this _ _ O
? _ _ O
+ _ _ O
+ _ _ O
+ _ _ O
+ _ _ O
a _ _ O
x _ _ O
+ _ _ O
y _ _ O
* _ _ O
z _ _ O
e _ _ O
* _ _ O
d _ _ O
+ _ _ O
c _ _ O
b _ _ O
and _ _ O
it _ _ O
builds _ _ O
it _ _ O
… _ _ O
bottom _ _ O
up _ _ O
! _ _ O
x _ _ O
z _ _ O
y _ _ O
it _ _ O
was _ _ O
a _ _ O
little _ _ O
too _ _ O
eager _ _ O
to _ _ O
produce _ _ O
( _ _ O
x _ _ O
+ _ _ O
y _ _ O
) _ _ O
, _ _ O
when _ _ O
it _ _ O
did _ _ O
n't _ _ O
know _ _ O
that _ _ O
there _ _ O
was _ _ O
a _ _ O
* _ _ O
coming _ _ O
up _ _ O
. _ _ O
20 _ _ O

Accounting _ _ O
for _ _ O
precedence _ _ O
● _ _ O
we _ _ O
have _ _ O
to _ _ O
tweak _ _ O
our _ _ O
algorithm _ _ O
a _ _ O
bit _ _ O
. _ _ O
let _ _ O
mut _ _ O
LHS _ _ O
= _ _ O
parse_term _ _ O
( _ _ O
) _ _ O
; _ _ O
while _ _ O
current _ _ O
token _ _ O
is _ _ O
a _ _ O
binary _ _ O
operator _ _ O
{ _ _ O
let _ _ O
op _ _ O
= _ _ O
current _ _ O
token _ _ O
; _ _ O
move _ _ O
to _ _ O
next _ _ O
token _ _ O
; _ _ O
at _ _ O
this _ _ O
point _ _ O
, _ _ O
we _ _ O
do _ _ O
n't _ _ O
know _ _ O
if _ _ O
RHS _ _ O
is _ _ O
let _ _ O
RHS _ _ O
= _ _ O
parse_term _ _ O
( _ _ O
) _ _ O
; _ _ O
our _ _ O
second _ _ O
operand _ _ O
, _ _ O
or _ _ O
if _ _ O
it _ _ O
's _ _ O
the _ _ O
next _ _ O
operator _ _ O
's _ _ O
first _ _ O
operand _ _ O
. _ _ O
so _ _ O
, _ _ O
we _ _ O
'll _ _ O
have _ _ O
to _ _ O
check _ _ O
if _ _ O
the _ _ O
current _ _ O
token _ _ O
is _ _ O
a _ _ O
binary _ _ O
operator _ _ O
whose _ _ O
precedence _ _ O
is _ _ O
higher _ _ O
than _ _ O
op _ _ O
's _ _ O
. _ _ O
and _ _ O
if _ _ O
that _ _ O
's _ _ O
the _ _ O
case _ _ O
, _ _ O
we _ _ O
um _ _ O
. _ _ O
uh _ _ O
. _ _ O
wait _ _ O
, _ _ O
what _ _ O
do _ _ O
we _ _ O
do _ _ O
then _ _ O
? _ _ O
LHS _ _ O
= _ _ O
AstNode _ _ O
: _ _ O
: _ _ O
new _ _ O
( _ _ O
LHS _ _ O
, _ _ O
op _ _ O
, _ _ O
RHS _ _ O
) _ _ O
; _ _ O
} _ _ O
21 _ _ O

Implicit _ _ O
parentheses _ _ O
● _ _ O
if _ _ O
you _ _ O
think _ _ O
about _ _ O
what _ _ O
we _ _ O
're _ _ O
doing _ _ O
in _ _ O
a _ _ O
different _ _ O
way _ _ O
… _ _ O
a _ _ O
+ _ _ O
( _ _ O
b _ _ O
* _ _ O
c _ _ O
* _ _ O
d _ _ O
* _ _ O
e _ _ O
) _ _ O
+ _ _ O
f _ _ O
we _ _ O
're _ _ O
sort _ _ O
of _ _ O
inserting _ _ O
parentheses _ _ O
as _ _ O
we _ _ O
go _ _ O
. _ _ O
so _ _ O
when _ _ O
we _ _ O
see _ _ O
the _ _ O
first _ _ O
* _ _ O
, _ _ O
we _ _ O
should _ _ O
say _ _ O
" _ _ O
oh _ _ O
, _ _ O
the _ _ O
left _ _ O
parenthesis _ _ O
goes _ _ O
before _ _ O
b _ _ O
… _ _ O
" _ _ O
… _ _ O
and _ _ O
the _ _ O
right _ _ O
parenthesis _ _ O
goes _ _ O
before _ _ O
the _ _ O
first _ _ O
operator _ _ O
that _ _ O
has _ _ O
a _ _ O
lower _ _ O
precedence _ _ O
than _ _ O
multiplication _ _ O
. _ _ O
" _ _ O
* _ _ O
since _ _ O
we _ _ O
want _ _ O
to _ _ O
put _ _ O
the _ _ O
parsing _ _ O
of _ _ O
+ _ _ O
on _ _ O
hold _ _ O
, _ _ O
the _ _ O
most _ _ O
natural _ _ O
way _ _ O
to _ _ O
parse _ _ O
the _ _ O
multiplications _ _ O
is _ _ O
to _ _ O
recurse _ _ O
. _ _ O
( _ _ O
let _ _ O
's _ _ O
look _ _ O
at _ _ O
the _ _ O
example _ _ O
to _ _ O
see _ _ O
how _ _ O
this _ _ O
is _ _ O
done _ _ O
. _ _ O
) _ _ O
22 _ _ O

How _ _ O
that _ _ O
parses _ _ O
( _ _ O
animated _ _ O
) _ _ O
● _ _ O
Looking _ _ O
at _ _ O
this _ _ O
input _ _ O
again _ _ O
, _ _ O
let _ _ O
's _ _ O
see _ _ O
how _ _ O
the _ _ O
AST _ _ O
is _ _ O
built _ _ O
for _ _ O
it _ _ O
: _ _ O
+ _ _ O
a _ _ O
+ _ _ O
b _ _ O
* _ _ O
c _ _ O
* _ _ O
d _ _ O
* _ _ O
e _ _ O
+ _ _ O
f _ _ O
1 _ _ O
. _ _ O
a _ _ O
is _ _ O
parsed _ _ O
. _ _ O
f _ _ O
+ _ _ O
2 _ _ O
. _ _ O
b _ _ O
is _ _ O
parsed _ _ O
. _ _ O
3 _ _ O
. _ _ O
* _ _ O
is _ _ O
seen _ _ O
, _ _ O
causing _ _ O
us _ _ O
to _ _ O
recurse _ _ O
. _ _ O
+ _ _ O
is _ _ O
put _ _ O
" _ _ O
on _ _ O
hold _ _ O
. _ _ O
" _ _ O
* _ _ O
4 _ _ O
. _ _ O
the _ _ O
subtree _ _ O
of _ _ O
multiplications _ _ O
is _ _ O
parsed _ _ O
. _ _ O
5 _ _ O
. _ _ O
that _ _ O
subtree _ _ O
is _ _ O
returned _ _ O
and _ _ O
becomes _ _ O
+ _ _ O
's _ _ O
RHS _ _ O
. _ _ O
6 _ _ O
. _ _ O
the _ _ O
final _ _ O
+ _ _ O
f _ _ O
is _ _ O
parsed _ _ O
. _ _ O
Right-branching _ _ O
is _ _ O
done _ _ O
by _ _ O
the _ _ O
Recursion _ _ O
; _ _ O
Left-branching _ _ O
is _ _ O
done _ _ O
by _ _ O
the _ _ O
Loop _ _ O
. _ _ O
* _ _ O
* _ _ O
a _ _ O
b _ _ O
e _ _ O
d _ _ O
c _ _ O
23 _ _ O

Finishing _ _ O
up _ _ O
by _ _ O
parsing _ _ O
terms _ _ O
● _ _ O
finally _ _ O
, _ _ O
these _ _ O
are _ _ O
more _ _ O
straightforward _ _ O
. _ _ O
Term _ _ O
: _ _ O
UnaryOp _ _ O
* _ _ O
PrimaryExp _ _ O
PostfixOp _ _ O
* _ _ O
● _ _ O
since _ _ O
the _ _ O
unary _ _ O
operators _ _ O
are _ _ O
Right-associative _ _ O
… _ _ O
o _ _ O
you _ _ O
got _ _ O
it _ _ O
: _ _ O
we _ _ O
have _ _ O
to _ _ O
Recurse _ _ O
to _ _ O
build _ _ O
the _ _ O
AST _ _ O
for _ _ O
those _ _ O
. _ _ O
● _ _ O
after _ _ O
that _ _ O
, _ _ O
primary _ _ O
expressions _ _ O
are _ _ O
straightforward _ _ O
. _ _ O
o _ _ O
parenthesized _ _ O
expressions _ _ O
will _ _ O
work _ _ O
just _ _ O
fine _ _ O
, _ _ O
because _ _ O
' _ _ O
) _ _ O
' _ _ O
is _ _ O
not _ _ O
an _ _ O
operator _ _ O
, _ _ O
and _ _ O
will _ _ O
cause _ _ O
the _ _ O
operator _ _ O
parsing _ _ O
loop _ _ O
to _ _ O
terminate _ _ O
. _ _ O
● _ _ O
and _ _ O
finally _ _ O
, _ _ O
postfix _ _ O
expressions _ _ O
come _ _ O
after _ _ O
the _ _ O
primaries _ _ O
. _ _ O
o _ _ O
the _ _ O
primary _ _ O
has _ _ O
to _ _ O
be _ _ O
passed _ _ O
to _ _ O
the _ _ O
postfix _ _ O
parser _ _ O
, _ _ O
so _ _ O
that _ _ O
it _ _ O
can _ _ O
become _ _ O
the _ _ O
LHS _ _ O
of _ _ O
those _ _ O
postfix _ _ O
operators _ _ O
. _ _ O
o _ _ O
postfix _ _ O
operators _ _ O
are _ _ O
Left-associative _ _ O
, _ _ O
so _ _ O
we _ _ O
can _ _ O
use _ _ O
a _ _ O
Loop _ _ O
. _ _ O
o _ _ O
also _ _ O
, _ _ O
it _ _ O
's _ _ O
not _ _ O
an _ _ O
error _ _ O
to _ _ O
see _ _ O
0 _ _ O
postfix _ _ O
operators _ _ O
. _ _ O
they _ _ O
’re _ _ O
optional _ _ O
! _ _ O
24 _ _ O

What _ _ O
about _ _ O
right-associative _ _ O
binary _ _ O
operators _ _ O
? _ _ O
● _ _ O
right-associativity _ _ O
is _ _ O
another _ _ O
kind _ _ O
of _ _ O
right-branching _ _ O
. _ _ O
o _ _ O
so _ _ O
, _ _ O
we _ _ O
would _ _ O
have _ _ O
to _ _ O
change _ _ O
the _ _ O
recursion _ _ O
condition _ _ O
in _ _ O
the _ _ O
binary _ _ O
operator _ _ O
parsing _ _ O
. _ _ O
● _ _ O
currently _ _ O
we _ _ O
recurse _ _ O
when _ _ O
we _ _ O
see _ _ O
an _ _ O
operator _ _ O
of _ _ O
higher _ _ O
precedence _ _ O
. _ _ O
o _ _ O
we _ _ O
will _ _ O
also _ _ O
recurse _ _ O
when _ _ O
we _ _ O
see _ _ O
a _ _ O
right-associative _ _ O
operator _ _ O
of _ _ O
the _ _ O
same _ _ O
or _ _ O
higher _ _ O
precedence _ _ O
. _ _ O
● _ _ O
this _ _ O
is _ _ O
so _ _ O
if _ _ O
you _ _ O
have _ _ O
multiple _ _ O
right-associative _ _ O
operators _ _ O
in _ _ O
a _ _ O
row _ _ O
of _ _ O
the _ _ O
same _ _ O
precedence _ _ O
, _ _ O
you _ _ O
still _ _ O
get _ _ O
the _ _ O
right-branching _ _ O
structure _ _ O
. _ _ O
● _ _ O
in _ _ O
a _ _ O
* _ _ O
* _ _ O
b _ _ O
* _ _ O
* _ _ O
c _ _ O
… _ _ O
o _ _ O
we _ _ O
see _ _ O
that _ _ O
the _ _ O
second _ _ O
* _ _ O
* _ _ O
has _ _ O
the _ _ O
same _ _ O
precedence _ _ O
as _ _ O
the _ _ O
first _ _ O
o _ _ O
so _ _ O
we _ _ O
recurse _ _ O
, _ _ O
giving _ _ O
us _ _ O
an _ _ O
RHS _ _ O
of _ _ O
b _ _ O
* _ _ O
* _ _ O
c _ _ O
o _ _ O
ultimately _ _ O
giving _ _ O
us _ _ O
a _ _ O
* _ _ O
* _ _ O
( _ _ O
b _ _ O
* _ _ O
* _ _ O
c _ _ O
) _ _ O
25 _ _ O

Things _ _ O
to _ _ O
think _ _ O
about _ _ O
26 _ _ O

Bottom-up _ _ O
parsing _ _ O
without _ _ O
recursion _ _ O
● _ _ O
by _ _ O
using _ _ O
auxiliary _ _ O
stack _ _ O
data _ _ O
structures _ _ O
, _ _ O
we _ _ O
could _ _ O
remove _ _ O
the _ _ O
need _ _ O
for _ _ O
recursion _ _ O
entirely _ _ O
. _ _ O
● _ _ O
did _ _ O
any _ _ O
of _ _ O
you _ _ O
do _ _ O
the _ _ O
expression _ _ O
evaluation _ _ O
assignment _ _ O
in _ _ O
445 _ _ O
? _ _ O
o _ _ O
where _ _ O
you _ _ O
had _ _ O
an _ _ O
operator _ _ O
stack _ _ O
and _ _ O
an _ _ O
operand _ _ O
stack _ _ O
? _ _ O
● _ _ O
if _ _ O
you _ _ O
still _ _ O
have _ _ O
that _ _ O
code _ _ O
, _ _ O
try _ _ O
going _ _ O
back _ _ O
and _ _ O
looking _ _ O
at _ _ O
it _ _ O
. _ _ O
● _ _ O
what _ _ O
if _ _ O
the _ _ O
operand _ _ O
stack _ _ O
held _ _ O
AST _ _ O
nodes _ _ O
, _ _ O
instead _ _ O
of _ _ O
Doubles _ _ O
? _ _ O
o _ _ O
and _ _ O
when _ _ O
you _ _ O
handle _ _ O
names _ _ O
/ _ _ O
operands _ _ O
, _ _ O
you _ _ O
pushed _ _ O
AST _ _ O
nodes _ _ O
? _ _ O
● _ _ O
and _ _ O
in _ _ O
the _ _ O
parts _ _ O
where _ _ O
you _ _ O
pop _ _ O
operators _ _ O
and _ _ O
evaluate _ _ O
… _ _ O
o _ _ O
what _ _ O
if _ _ O
, _ _ O
instead _ _ O
of _ _ O
evaluating _ _ O
, _ _ O
you _ _ O
created _ _ O
/ _ _ O
pushed _ _ O
AST _ _ O
nodes _ _ O
? _ _ O
● _ _ O
that _ _ O
's _ _ O
it _ _ O
, _ _ O
that _ _ O
's _ _ O
a _ _ O
parser _ _ O
, _ _ O
you _ _ O
already _ _ O
made _ _ O
most _ _ O
of _ _ O
an _ _ O
expression _ _ O
parser _ _ O
and _ _ O
you _ _ O
did _ _ O
n't _ _ O
even _ _ O
know _ _ O
it _ _ O
27 _ _ O

Can _ _ O
we _ _ O
parse _ _ O
everything _ _ O
with _ _ O
bottom-up _ _ O
parsing _ _ O
? _ _ O
● _ _ O
Yes _ _ O
! _ _ O
● _ _ O
actually _ _ O
, _ _ O
generalized _ _ O
bottom-up _ _ O
parsing _ _ O
is _ _ O
more _ _ O
powerful _ _ O
than _ _ O
topdown _ _ O
parsing _ _ O
! _ _ O
o _ _ O
there _ _ O
are _ _ O
some _ _ O
grammars _ _ O
that _ _ O
top-down _ _ O
parsers _ _ O
can _ _ O
never _ _ O
parse _ _ O
. _ _ O
● _ _ O
however _ _ O
… _ _ O
o _ _ O
once _ _ O
you _ _ O
move _ _ O
beyond _ _ O
expressions _ _ O
it _ _ O
gets _ _ O
stupidly _ _ O
complex _ _ O
o _ _ O
the _ _ O
complexity _ _ O
is _ _ O
not _ _ O
really _ _ O
justified _ _ O
for _ _ O
programming _ _ O
languages _ _ O
▪ _ _ O
their _ _ O
grammars _ _ O
are _ _ O
typically _ _ O
not _ _ O
that _ _ O
complicated _ _ O
o _ _ O
so _ _ O
it _ _ O
's _ _ O
mostly _ _ O
out _ _ O
of _ _ O
the _ _ O
scope _ _ O
of _ _ O
this _ _ O
course _ _ O
, _ _ O
IMO _ _ O
● _ _ O
for _ _ O
our _ _ O
language _ _ O
, _ _ O
we _ _ O
can _ _ O
parse _ _ O
everything _ _ O
using _ _ O
a _ _ O
hybrid _ _ O
approach _ _ O
: _ _ O
o _ _ O
use _ _ O
recursive _ _ O
descent _ _ O
for _ _ O
the _ _ O
program _ _ O
's _ _ O
broad _ _ O
structure _ _ O
o _ _ O
use _ _ O
bottom-up _ _ O
for _ _ O
expressions _ _ O
28 _ _ O

How _ _ O
does _ _ O
that _ _ O
work _ _ O
though _ _ O
? _ _ O
● _ _ O
well _ _ O
, _ _ O
expressions _ _ O
only _ _ O
appear _ _ O
inside _ _ O
other _ _ O
pieces _ _ O
of _ _ O
code _ _ O
. _ _ O
● _ _ O
so _ _ O
, _ _ O
a _ _ O
grammar _ _ O
might _ _ O
look _ _ O
like _ _ O
this _ _ O
: _ _ O
Program _ _ O
: _ _ O
Function _ _ O
* _ _ O
Function _ _ O
: _ _ O
' _ _ O
fn _ _ O
' _ _ O
I _ _ O
d _ _ O
' _ _ O
( _ _ O
' _ _ O
' _ _ O
) _ _ O
' _ _ O
Block _ _ O
Block _ _ O
: _ _ O
' _ _ O
{ _ _ O
' _ _ O
Stmt _ _ O
* _ _ O
' _ _ O
} _ _ O
' _ _ O
Stmt _ _ O
: _ _ O
IfStmt _ _ O
| _ _ O
ExpStmt _ _ O
| _ _ O
AssignStmt _ _ O
IfStmt _ _ O
: _ _ O
' _ _ O
if _ _ O
' _ _ O
Exp _ _ O
Block _ _ O
( _ _ O
' _ _ O
else _ _ O
' _ _ O
Block _ _ O
) _ _ O
? _ _ O
ExpStmt _ _ O
: _ _ O
Exp _ _ O
' _ _ O
; _ _ O
' _ _ O
AssignStmt _ _ O
: _ _ O
Exp _ _ O
' _ _ O
= _ _ O
' _ _ O
Exp _ _ O
' _ _ O
; _ _ O
' _ _ O
● _ _ O
all _ _ O
of _ _ O
these _ _ O
rules _ _ O
would _ _ O
be _ _ O
parsed _ _ O
with _ _ O
recursive _ _ O
descent _ _ O
… _ _ O
● _ _ O
and _ _ O
whenever _ _ O
we _ _ O
need _ _ O
to _ _ O
parse _ _ O
an _ _ O
Exp _ _ O
, _ _ O
we _ _ O
use _ _ O
bottom-up _ _ O
parsing _ _ O
. _ _ O
29 _ _ O

Syntactic _ _ O
Sugar _ _ O
30 _ _ O

Yummy _ _ O
● _ _ O
each _ _ O
language _ _ O
feature _ _ O
adds _ _ O
complexity _ _ O
in _ _ O
every _ _ O
stage _ _ O
of _ _ O
the _ _ O
compiler _ _ O
: _ _ O
lexing _ _ O
, _ _ O
parsing _ _ O
, _ _ O
semantics _ _ O
, _ _ O
optimization _ _ O
, _ _ O
code _ _ O
generation _ _ O
… _ _ O
● _ _ O
so _ _ O
, _ _ O
one _ _ O
approach _ _ O
to _ _ O
adding _ _ O
features _ _ O
to _ _ O
our _ _ O
languages _ _ O
is _ _ O
by _ _ O
defining _ _ O
them _ _ O
in _ _ O
terms _ _ O
of _ _ O
other _ _ O
, _ _ O
simpler _ _ O
features _ _ O
that _ _ O
already _ _ O
exist _ _ O
. _ _ O
let _ _ O
lhs _ _ O
= _ _ O
self.parse_term _ _ O
( _ _ O
) _ _ O
? _ _ O
; _ _ O
this _ _ O
is _ _ O
syntactic _ _ O
sugar _ _ O
, _ _ O
and _ _ O
it _ _ O
's _ _ O
called _ _ O
that _ _ O
because _ _ O
it _ _ O
usually _ _ O
makes _ _ O
your _ _ O
code _ _ O
easier _ _ O
to _ _ O
write _ _ O
. _ _ O
let _ _ O
lhs _ _ O
= _ _ O
match _ _ O
self.parse_term _ _ O
( _ _ O
) _ _ O
{ _ _ O
Ok _ _ O
( _ _ O
x _ _ O
) _ _ O
= _ _ O
> _ _ O
x _ _ O
, _ _ O
Err _ _ O
( _ _ O
e _ _ O
) _ _ O
= _ _ O
> _ _ O
return _ _ O
Err _ _ O
( _ _ O
e _ _ O
) _ _ O
, _ _ O
} _ _ O
; _ _ O
31 _ _ O

Another _ _ O
example _ _ O
● _ _ O
Java _ _ O
's _ _ O
generic _ _ O
for _ _ O
loop _ _ O
is _ _ O
just _ _ O
sugar _ _ O
for _ _ O
using _ _ O
an _ _ O
iterator _ _ O
. _ _ O
for _ _ O
( _ _ O
int _ _ O
i _ _ O
: _ _ O
someCollection _ _ O
) _ _ O
{ _ _ O
… _ _ O
} _ _ O
● _ _ O
becomes _ _ O
something _ _ O
like _ _ O
: _ _ O
for _ _ O
( _ _ O
Iterator _ _ O
< _ _ O
Integer _ _ O
> _ _ O
iter _ _ O
= _ _ O
someCollection.iterator _ _ O
( _ _ O
) _ _ O
; _ _ O
iter.hasNext _ _ O
( _ _ O
) _ _ O
; _ _ O
) _ _ O
{ _ _ O
int _ _ O
i _ _ O
= _ _ O
iter.next _ _ O
( _ _ O
) _ _ O
.intValue _ _ O
( _ _ O
) _ _ O
; _ _ O
… _ _ O
} _ _ O
32 _ _ O

How _ _ O
is _ _ O
it _ _ O
implemented _ _ O
? _ _ O
● _ _ O
by _ _ O
desugaring _ _ O
: _ _ O
rewriting _ _ O
the _ _ O
AST _ _ O
after _ _ O
parsing _ _ O
. _ _ O
o _ _ O
we _ _ O
saw _ _ O
previously _ _ O
that _ _ O
trees _ _ O
are _ _ O
easy _ _ O
to _ _ O
create _ _ O
and _ _ O
manipulate _ _ O
. _ _ O
● _ _ O
but _ _ O
we _ _ O
have _ _ O
to _ _ O
be _ _ O
a _ _ O
little _ _ O
careful _ _ O
. _ _ O
o _ _ O
up _ _ O
next _ _ O
is _ _ O
semantic _ _ O
analysis _ _ O
, _ _ O
and _ _ O
if _ _ O
we _ _ O
desugar _ _ O
the _ _ O
code _ _ O
before _ _ O
then _ _ O
, _ _ O
it _ _ O
might _ _ O
give _ _ O
really _ _ O
confusing _ _ O
errors _ _ O
about _ _ O
code _ _ O
that _ _ O
the _ _ O
programmer _ _ O
did _ _ O
n't _ _ O
write _ _ O
! _ _ O
● _ _ O
but _ _ O
that _ _ O
's _ _ O
it _ _ O
for _ _ O
parsing _ _ O
! _ _ O
33 _ _ O



