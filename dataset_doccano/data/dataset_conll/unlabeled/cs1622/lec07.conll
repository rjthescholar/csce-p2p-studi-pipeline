unlabeled|cs1622|lec07
-DOCSTART- -X- -X- O

Semantic _ _ O
Analysis _ _ O
CS _ _ O
/ _ _ O
COE _ _ O
1622 _ _ O
Jarrett _ _ O
Billingsley _ _ O

Class _ _ O
Announcements _ _ O
● _ _ O
ö _ _ O
2 _ _ O

Semantics _ _ O
3 _ _ O

What _ _ O
does _ _ O
it _ _ O
all _ _ O
MEAN _ _ O
● _ _ O
semantics _ _ O
means _ _ O
… _ _ O
meaning _ _ O
. _ _ O
● _ _ O
a _ _ O
language _ _ O
's _ _ O
semantics _ _ O
are _ _ O
the _ _ O
rules _ _ O
that _ _ O
make _ _ O
it _ _ O
that _ _ O
language _ _ O
. _ _ O
int _ _ O
x _ _ O
= _ _ O
10 _ _ O
; _ _ O
printf _ _ O
( _ _ O
"x _ _ O
= _ _ O
" _ _ O
+ _ _ O
x _ _ O
) _ _ O
; _ _ O
this _ _ O
code _ _ O
lexes _ _ O
and _ _ O
parses _ _ O
exactly _ _ O
the _ _ O
same _ _ O
in _ _ O
both _ _ O
C _ _ O
and _ _ O
Java _ _ O
. _ _ O
but _ _ O
the _ _ O
semantics _ _ O
differ _ _ O
wildly _ _ O
. _ _ O
in _ _ O
Java _ _ O
, _ _ O
this _ _ O
says _ _ O
: _ _ O
" _ _ O
create _ _ O
a _ _ O
new _ _ O
string _ _ O
object _ _ O
that _ _ O
is _ _ O
the _ _ O
concatenation _ _ O
of _ _ O
" _ _ O
x _ _ O
= _ _ O
" _ _ O
and _ _ O
the _ _ O
result _ _ O
of _ _ O
calling _ _ O
x.toString _ _ O
( _ _ O
) _ _ O
. _ _ O
" _ _ O
in _ _ O
C _ _ O
, _ _ O
this _ _ O
says _ _ O
: _ _ O
" _ _ O
calculate _ _ O
a _ _ O
pointer _ _ O
starting _ _ O
at _ _ O
the _ _ O
address _ _ O
of _ _ O
" _ _ O
x _ _ O
= _ _ O
" _ _ O
and _ _ O
adding _ _ O
the _ _ O
value _ _ O
in _ _ O
x _ _ O
times _ _ O
the _ _ O
size _ _ O
of _ _ O
one _ _ O
char _ _ O
. _ _ O
" _ _ O
the _ _ O
semantics _ _ O
define _ _ O
what _ _ O
each _ _ O
piece _ _ O
of _ _ O
the _ _ O
language _ _ O
does _ _ O
. _ _ O
4 _ _ O

Static _ _ O
vs. _ _ O
Dynamic _ _ O
● _ _ O
you _ _ O
'll _ _ O
see _ _ O
these _ _ O
words _ _ O
used _ _ O
a _ _ O
lot _ _ O
in _ _ O
talking _ _ O
about _ _ O
semantics _ _ O
● _ _ O
if _ _ O
we _ _ O
look _ _ O
at _ _ O
a _ _ O
timeline _ _ O
of _ _ O
the _ _ O
process _ _ O
of _ _ O
compiling _ _ O
and _ _ O
running _ _ O
… _ _ O
execution _ _ O
begins _ _ O
here _ _ O
! _ _ O
compilation _ _ O
, _ _ O
linking _ _ O
, _ _ O
loading _ _ O
… _ _ O
program _ _ O
is _ _ O
running _ _ O
static _ _ O
means _ _ O
something _ _ O
that _ _ O
is _ _ O
done _ _ O
before _ _ O
execution _ _ O
begins _ _ O
, _ _ O
and _ _ O
it _ _ O
's _ _ O
only _ _ O
done _ _ O
once _ _ O
. _ _ O
dynamic _ _ O
means _ _ O
something _ _ O
that _ _ O
is _ _ O
done _ _ O
during _ _ O
execution _ _ O
, _ _ O
possibly _ _ O
over _ _ O
and _ _ O
over _ _ O
. _ _ O
you _ _ O
'll _ _ O
also _ _ O
hear _ _ O
it _ _ O
called _ _ O
" _ _ O
compile-time _ _ O
. _ _ O
" _ _ O
you _ _ O
'll _ _ O
also _ _ O
hear _ _ O
it _ _ O
called _ _ O
" _ _ O
runtime _ _ O
. _ _ O
" _ _ O
( _ _ O
or _ _ O
" _ _ O
link-time _ _ O
" _ _ O
or _ _ O
" _ _ O
load-time _ _ O
" _ _ O
) _ _ O
5 _ _ O

Abstraction _ _ O
● _ _ O
HLLs _ _ O
provide _ _ O
programmers _ _ O
with _ _ O
useful _ _ O
sets _ _ O
of _ _ O
abstractions _ _ O
. _ _ O
● _ _ O
semantics _ _ O
are _ _ O
about _ _ O
enforcing _ _ O
the _ _ O
rules _ _ O
of _ _ O
those _ _ O
abstractions _ _ O
… _ _ O
o _ _ O
even _ _ O
if _ _ O
the _ _ O
target _ _ O
CPU _ _ O
does _ _ O
n't _ _ O
make _ _ O
a _ _ O
distinction _ _ O
! _ _ O
int _ _ O
i _ _ O
= _ _ O
0 _ _ O
; _ _ O
Object _ _ O
o _ _ O
= _ _ O
null _ _ O
; _ _ O
char _ _ O
c _ _ O
= _ _ O
' _ _ O
\0 _ _ O
' _ _ O
; _ _ O
boolean _ _ O
b _ _ O
= _ _ O
false _ _ O
; _ _ O
in _ _ O
this _ _ O
Java _ _ O
, _ _ O
all _ _ O
four _ _ O
lines _ _ O
here _ _ O
will _ _ O
probably _ _ O
compile _ _ O
down _ _ O
to _ _ O
the _ _ O
exact _ _ O
same _ _ O
code _ _ O
, _ _ O
something _ _ O
like _ _ O
: _ _ O
sw _ _ O
$ _ _ O
zero _ _ O
, _ _ O
i _ _ O
the _ _ O
CPU _ _ O
does _ _ O
n't _ _ O
know _ _ O
or _ _ O
care _ _ O
about _ _ O
the _ _ O
difference _ _ O
between _ _ O
these _ _ O
types _ _ O
, _ _ O
but _ _ O
the _ _ O
language _ _ O
does _ _ O
. _ _ O
6 _ _ O

Compile-time _ _ O
and _ _ O
runtime _ _ O
guarantees _ _ O
● _ _ O
the _ _ O
compiler _ _ O
is _ _ O
responsible _ _ O
for _ _ O
enforcing _ _ O
many _ _ O
of _ _ O
the _ _ O
language _ _ O
's _ _ O
rules _ _ O
, _ _ O
but _ _ O
those _ _ O
rules _ _ O
can _ _ O
extend _ _ O
beyond _ _ O
the _ _ O
compiler _ _ O
's _ _ O
reach _ _ O
! _ _ O
int _ _ O
[ _ _ O
] _ _ O
a _ _ O
= _ _ O
new _ _ O
int _ _ O
[ _ _ O
5 _ _ O
] _ _ O
; _ _ O
a _ _ O
[ _ _ O
10 _ _ O
] _ _ O
= _ _ O
0 _ _ O
; _ _ O
/ _ _ O
/ _ _ O
oops _ _ O
a _ _ O
Java _ _ O
compiler _ _ O
might _ _ O
be _ _ O
able _ _ O
to _ _ O
catch _ _ O
this _ _ O
contrived _ _ O
case _ _ O
. _ _ O
but _ _ O
in _ _ O
the _ _ O
general _ _ O
case _ _ O
, _ _ O
this _ _ O
error _ _ O
ca _ _ O
n't _ _ O
be _ _ O
detected _ _ O
until _ _ O
runtime _ _ O
. _ _ O
static _ _ O
checks _ _ O
done _ _ O
by _ _ O
the _ _ O
compiler _ _ O
try _ _ O
to _ _ O
catch _ _ O
as _ _ O
many _ _ O
mistakes _ _ O
as _ _ O
possible _ _ O
… _ _ O
… _ _ O
but _ _ O
they _ _ O
ca _ _ O
n't _ _ O
catch _ _ O
every _ _ O
mistake _ _ O
. _ _ O
doing _ _ O
so _ _ O
would _ _ O
require _ _ O
solving _ _ O
the _ _ O
halting _ _ O
problem _ _ O
. _ _ O
still _ _ O
, _ _ O
doing _ _ O
what _ _ O
static _ _ O
checks _ _ O
we _ _ O
can _ _ O
is _ _ O
better _ _ O
than _ _ O
leaving _ _ O
all _ _ O
the _ _ O
semantic _ _ O
analysis _ _ O
until _ _ O
runtime _ _ O
! _ _ O
7 _ _ O

Semantic _ _ O
analysis _ _ O
can _ _ O
get _ _ O
tricky _ _ O
● _ _ O
in _ _ O
most _ _ O
nontrivial _ _ O
languages _ _ O
, _ _ O
semantic _ _ O
analysis _ _ O
is _ _ O
not _ _ O
just _ _ O
" _ _ O
one _ _ O
step _ _ O
. _ _ O
" _ _ O
o _ _ O
there _ _ O
may _ _ O
be _ _ O
several _ _ O
phases _ _ O
or _ _ O
passes _ _ O
of _ _ O
semantic _ _ O
analysis _ _ O
… _ _ O
o _ _ O
and _ _ O
sometimes _ _ O
, _ _ O
those _ _ O
passes _ _ O
can _ _ O
be _ _ O
run _ _ O
multiple _ _ O
times _ _ O
, _ _ O
or _ _ O
be _ _ O
mutually _ _ O
recursive _ _ O
with _ _ O
one _ _ O
another _ _ O
! _ _ O
● _ _ O
the _ _ O
toy _ _ O
language _ _ O
we _ _ O
're _ _ O
working _ _ O
with _ _ O
wo _ _ O
n't _ _ O
get _ _ O
too _ _ O
scary _ _ O
to _ _ O
analyze _ _ O
… _ _ O
o _ _ O
but _ _ O
it _ _ O
's _ _ O
good _ _ O
to _ _ O
keep _ _ O
in _ _ O
mind _ _ O
that _ _ O
even _ _ O
seemingly-simple _ _ O
features _ _ O
can _ _ O
cause _ _ O
the _ _ O
complexity _ _ O
of _ _ O
semantic _ _ O
analysis _ _ O
to _ _ O
explode _ _ O
. _ _ O
● _ _ O
one _ _ O
of _ _ O
the _ _ O
most _ _ O
powerful _ _ O
tools _ _ O
we _ _ O
have _ _ O
to _ _ O
define _ _ O
the _ _ O
rules _ _ O
and _ _ O
boundaries _ _ O
of _ _ O
a _ _ O
language _ _ O
is _ _ O
… _ _ O
8 _ _ O

Types _ _ O
9 _ _ O

Types _ _ O
and _ _ O
typing _ _ O
● _ _ O
HLLs _ _ O
give _ _ O
us _ _ O
several _ _ O
kinds _ _ O
of _ _ O
values _ _ O
to _ _ O
work _ _ O
with _ _ O
. _ _ O
● _ _ O
we _ _ O
classify _ _ O
these _ _ O
values _ _ O
according _ _ O
to _ _ O
their _ _ O
type _ _ O
. _ _ O
a _ _ O
type _ _ O
is _ _ O
a _ _ O
set _ _ O
of _ _ O
valid _ _ O
values _ _ O
… _ _ O
{ _ _ O
0 _ _ O
, _ _ O
1 _ _ O
, _ _ O
-1 _ _ O
, _ _ O
2 _ _ O
, _ _ O
-2 _ _ O
, _ _ O
... _ _ O
} _ _ O
… _ _ O
along _ _ O
with _ _ O
a _ _ O
set _ _ O
of _ _ O
operations _ _ O
that _ _ O
can _ _ O
be _ _ O
performed _ _ O
on _ _ O
them _ _ O
. _ _ O
{ _ _ O
+ _ _ O
, _ _ O
- _ _ O
, _ _ O
* _ _ O
, _ _ O
/ _ _ O
, _ _ O
% _ _ O
, _ _ O
parse _ _ O
, _ _ O
... _ _ O
} _ _ O
types _ _ O
set _ _ O
the _ _ O
boundaries _ _ O
on _ _ O
what _ _ O
you _ _ O
can _ _ O
and _ _ O
ca _ _ O
n't _ _ O
do _ _ O
within _ _ O
the _ _ O
language _ _ O
. _ _ O
10 _ _ O

You _ _ O
have _ _ O
to _ _ O
listen _ _ O
to _ _ O
the _ _ O
notes _ _ O
they _ _ O
do _ _ O
n't _ _ O
play _ _ O
● _ _ O
down _ _ O
at _ _ O
the _ _ O
CPU _ _ O
level _ _ O
, _ _ O
types _ _ O
do _ _ O
n't _ _ O
really _ _ O
exist _ _ O
. _ _ O
o _ _ O
you _ _ O
can _ _ O
do _ _ O
almost _ _ O
anything _ _ O
with _ _ O
anything _ _ O
! _ _ O
the _ _ O
CPU _ _ O
does _ _ O
n't _ _ O
care _ _ O
! _ _ O
● _ _ O
we _ _ O
say _ _ O
that _ _ O
assembly _ _ O
is _ _ O
untyped _ _ O
. _ _ O
li _ _ O
sw _ _ O
li _ _ O
jr _ _ O
t0 _ _ O
, _ _ O
10 _ _ O
zero _ _ O
, _ _ O
( _ _ O
t0 _ _ O
) _ _ O
t0 _ _ O
, _ _ O
' _ _ O
a _ _ O
' _ _ O
t0 _ _ O
# _ _ O
oh _ _ O
, _ _ O
t0 _ _ O
is _ _ O
an _ _ O
int _ _ O
# _ _ O
wait _ _ O
we _ _ O
're _ _ O
using _ _ O
it _ _ O
as _ _ O
an _ _ O
address _ _ O
? _ _ O
# _ _ O
uhh _ _ O
now _ _ O
it _ _ O
's _ _ O
a _ _ O
character _ _ O
? _ _ O
# _ _ O
and _ _ O
now _ _ O
we _ _ O
're _ _ O
jumping _ _ O
to _ _ O
it _ _ O
? _ _ O
? _ _ O
● _ _ O
in _ _ O
an _ _ O
untyped _ _ O
language _ _ O
, _ _ O
the _ _ O
programmer _ _ O
can _ _ O
do _ _ O
anything _ _ O
. _ _ O
o _ _ O
but _ _ O
is _ _ O
that _ _ O
really _ _ O
a _ _ O
good _ _ O
idea _ _ O
… _ _ O
? _ _ O
11 _ _ O

A _ _ O
vast _ _ O
sea _ _ O
of _ _ O
garbage _ _ O
● _ _ O
a _ _ O
program _ _ O
is _ _ O
any _ _ O
sequence _ _ O
of _ _ O
instructions _ _ O
. _ _ O
● _ _ O
so _ _ O
if _ _ O
we _ _ O
consider _ _ O
all _ _ O
possible _ _ O
sequences _ _ O
of _ _ O
instructions _ _ O
… _ _ O
almost _ _ O
all _ _ O
of _ _ O
them _ _ O
do _ _ O
nothing _ _ O
useful _ _ O
at _ _ O
all _ _ O
. _ _ O
this _ _ O
is _ _ O
Useful _ _ O
Program _ _ O
Island _ _ O
. _ _ O
Type _ _ O
System _ _ O
Town _ _ O
× _ _ O
type _ _ O
systems _ _ O
keep _ _ O
you _ _ O
safely _ _ O
on _ _ O
the _ _ O
island _ _ O
… _ _ O
… _ _ O
at _ _ O
the _ _ O
cost _ _ O
of _ _ O
preventing _ _ O
you _ _ O
from _ _ O
being _ _ O
able _ _ O
to _ _ O
write _ _ O
all _ _ O
useful _ _ O
programs _ _ O
. _ _ O
like _ _ O
this _ _ O
one _ _ O
. _ _ O
but _ _ O
maybe _ _ O
these _ _ O
kinds _ _ O
of _ _ O
programs _ _ O
are _ _ O
too _ _ O
hard _ _ O
for _ _ O
humans _ _ O
to _ _ O
understand _ _ O
anyway _ _ O
, _ _ O
so _ _ O
no _ _ O
big _ _ O
loss _ _ O
? _ _ O
12 _ _ O

The _ _ O
soul _ _ O
of _ _ O
a _ _ O
programming _ _ O
language _ _ O
● _ _ O
the _ _ O
type _ _ O
system _ _ O
affects _ _ O
every _ _ O
operation _ _ O
in _ _ O
the _ _ O
language _ _ O
. _ _ O
● _ _ O
the _ _ O
type _ _ O
system _ _ O
decides _ _ O
… _ _ O
o _ _ O
what _ _ O
kinds _ _ O
of _ _ O
variables _ _ O
can _ _ O
exist _ _ O
o _ _ O
what _ _ O
operators _ _ O
and _ _ O
methods _ _ O
you _ _ O
can _ _ O
use _ _ O
on _ _ O
them _ _ O
o _ _ O
how _ _ O
those _ _ O
operators _ _ O
do _ _ O
their _ _ O
work _ _ O
o _ _ O
how _ _ O
control _ _ O
structures _ _ O
work _ _ O
● _ _ O
the _ _ O
main _ _ O
difference _ _ O
between _ _ O
C _ _ O
and _ _ O
Java _ _ O
is _ _ O
their _ _ O
type _ _ O
systems _ _ O
. _ _ O
o _ _ O
even _ _ O
though _ _ O
their _ _ O
syntax _ _ O
can _ _ O
look _ _ O
superficially _ _ O
similar _ _ O
… _ _ O
o _ _ O
the _ _ O
boundaries _ _ O
drawn _ _ O
by _ _ O
their _ _ O
type _ _ O
systems _ _ O
are _ _ O
completely _ _ O
different _ _ O
. _ _ O
13 _ _ O

Type _ _ O
systems _ _ O
14 _ _ O

Primitive _ _ O
types _ _ O
● _ _ O
every _ _ O
language _ _ O
considers _ _ O
some _ _ O
types _ _ O
to _ _ O
be _ _ O
primitive _ _ O
, _ _ O
or _ _ O
fundamental _ _ O
. _ _ O
they _ _ O
can _ _ O
not _ _ O
be _ _ O
broken _ _ O
into _ _ O
any _ _ O
simpler _ _ O
parts _ _ O
. _ _ O
some _ _ O
, _ _ O
like _ _ O
ints _ _ O
and _ _ O
floats _ _ O
, _ _ O
are _ _ O
lw _ _ O
$ _ _ O
t0 _ _ O
, _ _ O
int_var _ _ O
derived _ _ O
from _ _ O
the _ _ O
CPU _ _ O
's _ _ O
abilities _ _ O
. _ _ O
l.s _ _ O
$ _ _ O
f0 _ _ O
, _ _ O
float_var _ _ O
others _ _ O
, _ _ O
like _ _ O
bools _ _ O
and _ _ O
chars _ _ O
, _ _ O
are _ _ O
simple _ _ O
abstractions _ _ O
on _ _ O
top _ _ O
of _ _ O
those _ _ O
… _ _ O
but _ _ O
they _ _ O
help _ _ O
us _ _ O
encode _ _ O
intent _ _ O
into _ _ O
our _ _ O
programs _ _ O
, _ _ O
and _ _ O
intent _ _ O
helps _ _ O
us _ _ O
better _ _ O
understand _ _ O
our _ _ O
own _ _ O
code _ _ O
( _ _ O
and _ _ O
the _ _ O
code _ _ O
that _ _ O
others _ _ O
write _ _ O
) _ _ O
. _ _ O
int _ _ O
isDone _ _ O
= _ _ O
0 _ _ O
; _ _ O
/ _ _ O
/ _ _ O
? _ _ O
? _ _ O
bool _ _ O
isDone _ _ O
= _ _ O
false _ _ O
; _ _ O
/ _ _ O
/ _ _ O
better _ _ O
. _ _ O
15 _ _ O

Compound _ _ O
types _ _ O
● _ _ O
compound _ _ O
types _ _ O
are _ _ O
composed _ _ O
of _ _ O
two _ _ O
or _ _ O
more _ _ O
primitive _ _ O
types _ _ O
. _ _ O
o _ _ O
you _ _ O
can _ _ O
think _ _ O
of _ _ O
primitive _ _ O
and _ _ O
compound _ _ O
types _ _ O
like _ _ O
atoms _ _ O
and _ _ O
molecules _ _ O
: _ _ O
multiple _ _ O
atoms _ _ O
make _ _ O
up _ _ O
a _ _ O
molecule _ _ O
. _ _ O
struct _ _ O
Point _ _ O
{ _ _ O
x _ _ O
: _ _ O
i32 _ _ O
, _ _ O
structs _ _ O
and _ _ O
classes _ _ O
are _ _ O
common _ _ O
ways _ _ O
to _ _ O
let _ _ O
the _ _ O
y _ _ O
: _ _ O
i32 _ _ O
, _ _ O
programmer _ _ O
define _ _ O
their _ _ O
own _ _ O
compound _ _ O
types _ _ O
. _ _ O
} _ _ O
let _ _ O
p _ _ O
: _ _ O
( _ _ O
i32 _ _ O
, _ _ O
i32 _ _ O
) _ _ O
= _ _ O
( _ _ O
4 _ _ O
, _ _ O
5 _ _ O
) _ _ O
; _ _ O
tuples _ _ O
are _ _ O
a _ _ O
little _ _ O
obscure _ _ O
, _ _ O
but _ _ O
work _ _ O
similarly _ _ O
to _ _ O
structs _ _ O
. _ _ O
let _ _ O
a _ _ O
: _ _ O
[ _ _ O
i32 _ _ O
; _ _ O
3 _ _ O
] _ _ O
= _ _ O
[ _ _ O
1 _ _ O
, _ _ O
2 _ _ O
, _ _ O
3 _ _ O
] _ _ O
; _ _ O
arrays _ _ O
also _ _ O
count _ _ O
, _ _ O
but _ _ O
they _ _ O
're _ _ O
a _ _ O
little _ _ O
more _ _ O
interesting _ _ O
… _ _ O
16 _ _ O

Generic _ _ O
types _ _ O
● _ _ O
a _ _ O
generic _ _ O
type _ _ O
is _ _ O
a _ _ O
special _ _ O
kind _ _ O
of _ _ O
function _ _ O
which _ _ O
takes _ _ O
types _ _ O
as _ _ O
its _ _ O
inputs _ _ O
, _ _ O
and _ _ O
produces _ _ O
a _ _ O
type _ _ O
as _ _ O
its _ _ O
output _ _ O
. _ _ O
o _ _ O
we _ _ O
call _ _ O
that _ _ O
a _ _ O
type _ _ O
constructor _ _ O
. _ _ O
● _ _ O
if _ _ O
that _ _ O
sounds _ _ O
really _ _ O
out _ _ O
there _ _ O
, _ _ O
well _ _ O
, _ _ O
how _ _ O
about _ _ O
ArrayList _ _ O
? _ _ O
o _ _ O
it _ _ O
takes _ _ O
type _ _ O
arguments _ _ O
in _ _ O
angle _ _ O
brackets _ _ O
: _ _ O
ArrayList _ _ O
< _ _ O
Integer _ _ O
> _ _ O
● _ _ O
and _ _ O
if _ _ O
you _ _ O
give _ _ O
it _ _ O
different _ _ O
type _ _ O
arguments _ _ O
, _ _ O
you _ _ O
get _ _ O
a _ _ O
different _ _ O
type _ _ O
. _ _ O
o _ _ O
ArrayList _ _ O
< _ _ O
Integer _ _ O
> _ _ O
is _ _ O
different _ _ O
from _ _ O
ArrayList _ _ O
< _ _ O
Double _ _ O
> _ _ O
. _ _ O
● _ _ O
another _ _ O
example _ _ O
in _ _ O
Java _ _ O
is _ _ O
the _ _ O
square _ _ O
brackets _ _ O
: _ _ O
[ _ _ O
] _ _ O
o _ _ O
you _ _ O
ca _ _ O
n't _ _ O
just _ _ O
have _ _ O
a _ _ O
[ _ _ O
] _ _ O
. _ _ O
it _ _ O
has _ _ O
to _ _ O
be _ _ O
an _ _ O
array _ _ O
of _ _ O
something _ _ O
. _ _ O
● _ _ O
you _ _ O
can _ _ O
put _ _ O
any _ _ O
type _ _ O
before _ _ O
[ _ _ O
] _ _ O
and _ _ O
get _ _ O
a _ _ O
new _ _ O
type _ _ O
, _ _ O
so _ _ O
it _ _ O
's _ _ O
a _ _ O
type _ _ O
constructor _ _ O
. _ _ O
o _ _ O
int _ _ O
[ _ _ O
] _ _ O
is _ _ O
a _ _ O
new _ _ O
type _ _ O
. _ _ O
int _ _ O
[ _ _ O
] _ _ O
[ _ _ O
] _ _ O
is _ _ O
another _ _ O
new _ _ O
type _ _ O
. _ _ O
and _ _ O
so _ _ O
on _ _ O
, _ _ O
forever _ _ O
! _ _ O
17 _ _ O

And _ _ O
further _ _ O
still _ _ O
… _ _ O
● _ _ O
there _ _ O
are _ _ O
even _ _ O
type _ _ O
constructors _ _ O
that _ _ O
can _ _ O
take _ _ O
values _ _ O
as _ _ O
arguments _ _ O
. _ _ O
● _ _ O
there _ _ O
's _ _ O
a _ _ O
very _ _ O
concrete _ _ O
example _ _ O
for _ _ O
that _ _ O
: _ _ O
arrays _ _ O
o _ _ O
see _ _ O
, _ _ O
an _ _ O
array _ _ O
has _ _ O
a _ _ O
length _ _ O
o _ _ O
but _ _ O
… _ _ O
what _ _ O
if _ _ O
that _ _ O
length _ _ O
were _ _ O
part _ _ O
of _ _ O
the _ _ O
type _ _ O
? _ _ O
like _ _ O
int _ _ O
[ _ _ O
10 _ _ O
] _ _ O
? _ _ O
● _ _ O
could _ _ O
you _ _ O
make _ _ O
a _ _ O
language _ _ O
where _ _ O
you _ _ O
could _ _ O
never _ _ O
have _ _ O
an _ _ O
ArrayIndexOutOfBoundsException _ _ O
? _ _ O
o _ _ O
yes _ _ O
! _ _ O
o _ _ O
it _ _ O
's _ _ O
possible _ _ O
to _ _ O
track _ _ O
the _ _ O
length _ _ O
of _ _ O
every _ _ O
array _ _ O
and _ _ O
the _ _ O
range _ _ O
of _ _ O
every _ _ O
integer _ _ O
at _ _ O
compile _ _ O
time _ _ O
, _ _ O
and _ _ O
ensure _ _ O
they _ _ O
ca _ _ O
n't _ _ O
happen _ _ O
. _ _ O
● _ _ O
but _ _ O
there _ _ O
's _ _ O
a _ _ O
big _ _ O
downside _ _ O
to _ _ O
this _ _ O
: _ _ O
o _ _ O
in _ _ O
the _ _ O
general _ _ O
case _ _ O
, _ _ O
these _ _ O
type _ _ O
systems _ _ O
are _ _ O
undecidable _ _ O
( _ _ O
meaning _ _ O
you _ _ O
have _ _ O
to _ _ O
solve _ _ O
the _ _ O
halting _ _ O
problem _ _ O
) _ _ O
. _ _ O
▪ _ _ O
but _ _ O
in _ _ O
some _ _ O
limited _ _ O
cases _ _ O
, _ _ O
it _ _ O
is _ _ O
decidable _ _ O
, _ _ O
and _ _ O
maybe _ _ O
useful _ _ O
? _ _ O
18 _ _ O

Naming _ _ O
19 _ _ O

Hello _ _ O
, _ _ O
my _ _ O
name _ _ O
is _ _ O
… _ _ O
● _ _ O
computers _ _ O
do _ _ O
n't _ _ O
know _ _ O
anything _ _ O
about _ _ O
names _ _ O
, _ _ O
language _ _ O
, _ _ O
or _ _ O
strings _ _ O
… _ _ O
o _ _ O
but _ _ O
humans _ _ O
love _ _ O
words _ _ O
. _ _ O
we _ _ O
ca _ _ O
n't _ _ O
get _ _ O
enough _ _ O
of _ _ O
em _ _ O
. _ _ O
● _ _ O
one _ _ O
of _ _ O
the _ _ O
reasons _ _ O
people _ _ O
very _ _ O
quickly _ _ O
invented _ _ O
assembly _ _ O
language _ _ O
was _ _ O
to _ _ O
be _ _ O
able _ _ O
to _ _ O
name _ _ O
things _ _ O
in _ _ O
their _ _ O
programs _ _ O
, _ _ O
because _ _ O
dealing _ _ O
with _ _ O
addresses _ _ O
is _ _ O
confusing _ _ O
, _ _ O
tedious _ _ O
, _ _ O
and _ _ O
error-prone _ _ O
. _ _ O
o _ _ O
can _ _ O
you _ _ O
imagine _ _ O
having _ _ O
to _ _ O
refer _ _ O
to _ _ O
everything _ _ O
by _ _ O
a _ _ O
number _ _ O
? _ _ O
o _ _ O
and _ _ O
where _ _ O
changing _ _ O
one _ _ O
part _ _ O
of _ _ O
the _ _ O
program _ _ O
changed _ _ O
the _ _ O
numbers _ _ O
of _ _ O
everything _ _ O
after _ _ O
it _ _ O
, _ _ O
and _ _ O
so _ _ O
you _ _ O
had _ _ O
to _ _ O
go _ _ O
back _ _ O
and _ _ O
change _ _ O
all _ _ O
the _ _ O
references _ _ O
to _ _ O
all _ _ O
those _ _ O
numbers _ _ O
… _ _ O
▪ _ _ O
it _ _ O
was _ _ O
not _ _ O
doable _ _ O
. _ _ O
20 _ _ O

Scoping _ _ O
and _ _ O
name _ _ O
resolution _ _ O
● _ _ O
name _ _ O
resolution _ _ O
matches _ _ O
names _ _ O
to _ _ O
the _ _ O
things _ _ O
they _ _ O
refer _ _ O
to _ _ O
. _ _ O
● _ _ O
scoping _ _ O
determines _ _ O
which _ _ O
names _ _ O
are _ _ O
candidates _ _ O
during _ _ O
resolution _ _ O
. _ _ O
void _ _ O
main _ _ O
( _ _ O
) _ _ O
{ _ _ O
int _ _ O
m _ _ O
= _ _ O
5 _ _ O
; _ _ O
f _ _ O
( _ _ O
) _ _ O
; _ _ O
} _ _ O
you _ _ O
know _ _ O
that _ _ O
this _ _ O
is _ _ O
wrong _ _ O
, _ _ O
but _ _ O
not _ _ O
every _ _ O
language _ _ O
works _ _ O
like _ _ O
this _ _ O
! _ _ O
void _ _ O
f _ _ O
( _ _ O
) _ _ O
{ _ _ O
printf _ _ O
( _ _ O
"m _ _ O
= _ _ O
% _ _ O
d\n _ _ O
" _ _ O
, _ _ O
m _ _ O
) _ _ O
; _ _ O
} _ _ O
in _ _ O
some _ _ O
languages _ _ O
, _ _ O
you _ _ O
can _ _ O
access _ _ O
the _ _ O
local _ _ O
variables _ _ O
of _ _ O
any _ _ O
function _ _ O
on _ _ O
the _ _ O
call _ _ O
stack _ _ O
. _ _ O
this _ _ O
used _ _ O
to _ _ O
be _ _ O
somewhat _ _ O
common _ _ O
in _ _ O
older _ _ O
languages _ _ O
, _ _ O
but _ _ O
eventually _ _ O
we _ _ O
realized _ _ O
" _ _ O
wow _ _ O
that _ _ O
's _ _ O
confusing _ _ O
as _ _ O
hell _ _ O
" _ _ O
we _ _ O
've _ _ O
kind _ _ O
of _ _ O
settled _ _ O
on _ _ O
a _ _ O
common _ _ O
set _ _ O
of _ _ O
name _ _ O
resolution _ _ O
rules _ _ O
, _ _ O
but _ _ O
some _ _ O
languages _ _ O
can _ _ O
still _ _ O
surprise _ _ O
you _ _ O
. _ _ O
21 _ _ O

Static _ _ O
vs. _ _ O
dynamic _ _ O
name _ _ O
resolution _ _ O
● _ _ O
some _ _ O
names _ _ O
' _ _ O
referents _ _ O
ca _ _ O
n't _ _ O
be _ _ O
decided _ _ O
until _ _ O
runtime _ _ O
. _ _ O
class _ _ O
A _ _ O
{ _ _ O
String _ _ O
toString _ _ O
( _ _ O
) _ _ O
{ _ _ O
return _ _ O
" _ _ O
A _ _ O
" _ _ O
; _ _ O
} _ _ O
} _ _ O
class _ _ O
B _ _ O
{ _ _ O
String _ _ O
toString _ _ O
( _ _ O
) _ _ O
{ _ _ O
return _ _ O
" _ _ O
B _ _ O
" _ _ O
; _ _ O
} _ _ O
} _ _ O
Object _ _ O
[ _ _ O
] _ _ O
objs _ _ O
= _ _ O
new _ _ O
Object _ _ O
[ _ _ O
] _ _ O
{ _ _ O
new _ _ O
A _ _ O
( _ _ O
) _ _ O
, _ _ O
new _ _ O
B _ _ O
( _ _ O
) _ _ O
} _ _ O
; _ _ O
for _ _ O
( _ _ O
Object _ _ O
o _ _ O
: _ _ O
objs _ _ O
) _ _ O
System.out.println _ _ O
( _ _ O
o.toString _ _ O
( _ _ O
) _ _ O
) _ _ O
; _ _ O
which _ _ O
toString _ _ O
( _ _ O
) _ _ O
does _ _ O
o.toString _ _ O
( _ _ O
) _ _ O
refer _ _ O
to _ _ O
? _ _ O
on _ _ O
the _ _ O
other _ _ O
hand _ _ O
, _ _ O
all _ _ O
the _ _ O
class _ _ O
names _ _ O
, _ _ O
variable _ _ O
names _ _ O
etc _ _ O
. _ _ O
are _ _ O
statically _ _ O
resolved _ _ O
. _ _ O
in _ _ O
some _ _ O
languages _ _ O
, _ _ O
all _ _ O
names _ _ O
are _ _ O
dynamically _ _ O
resolved _ _ O
. _ _ O
22 _ _ O

Round _ _ O
and _ _ O
round _ _ O
● _ _ O
name _ _ O
resolution _ _ O
can _ _ O
create _ _ O
a _ _ O
complex _ _ O
or _ _ O
even _ _ O
cyclical _ _ O
graph _ _ O
of _ _ O
dependencies _ _ O
between _ _ O
the _ _ O
parts _ _ O
of _ _ O
a _ _ O
program _ _ O
. _ _ O
class _ _ O
A _ _ O
{ _ _ O
void _ _ O
print _ _ O
( _ _ O
B _ _ O
b _ _ O
) _ _ O
{ _ _ O
println _ _ O
( _ _ O
b.value _ _ O
( _ _ O
) _ _ O
) _ _ O
; _ _ O
} _ _ O
int _ _ O
value _ _ O
( _ _ O
) _ _ O
{ _ _ O
return _ _ O
10 _ _ O
; _ _ O
} _ _ O
} _ _ O
A _ _ O
depends _ _ O
on _ _ O
B _ _ O
, _ _ O
and _ _ O
B _ _ O
depends _ _ O
on _ _ O
A. _ _ O
class _ _ O
B _ _ O
{ _ _ O
void _ _ O
print _ _ O
( _ _ O
A _ _ O
a _ _ O
) _ _ O
{ _ _ O
println _ _ O
( _ _ O
a.value _ _ O
( _ _ O
) _ _ O
) _ _ O
; _ _ O
} _ _ O
int _ _ O
value _ _ O
( _ _ O
) _ _ O
{ _ _ O
return _ _ O
20 _ _ O
; _ _ O
} _ _ O
} _ _ O
I _ _ O
ca _ _ O
n't _ _ O
check _ _ O
that _ _ O
all _ _ O
of _ _ O
A _ _ O
's _ _ O
code _ _ O
is _ _ O
correct _ _ O
until _ _ O
I _ _ O
check _ _ O
B _ _ O
's _ _ O
… _ _ O
but _ _ O
I _ _ O
ca _ _ O
n't _ _ O
check _ _ O
that _ _ O
B _ _ O
's _ _ O
is _ _ O
correct _ _ O
until _ _ O
I _ _ O
check _ _ O
A _ _ O
's _ _ O
… _ _ O
? _ _ O
? _ _ O
? _ _ O
well _ _ O
. _ _ O
it _ _ O
's _ _ O
possible _ _ O
to _ _ O
do _ _ O
things _ _ O
in _ _ O
phases _ _ O
, _ _ O
like _ _ O
I _ _ O
said _ _ O
before _ _ O
. _ _ O
23 _ _ O

Scoping _ _ O
24 _ _ O

What _ _ O
is _ _ O
it _ _ O
? _ _ O
● _ _ O
the _ _ O
programmer _ _ O
can _ _ O
declare _ _ O
named _ _ O
things _ _ O
like _ _ O
variables _ _ O
, _ _ O
etc _ _ O
. _ _ O
● _ _ O
the _ _ O
scope _ _ O
is _ _ O
where _ _ O
those _ _ O
names _ _ O
can _ _ O
be _ _ O
seen _ _ O
in _ _ O
the _ _ O
program _ _ O
. _ _ O
if _ _ O
( _ _ O
x _ _ O
= _ _ O
= _ _ O
10 _ _ O
) _ _ O
{ _ _ O
int _ _ O
y _ _ O
= _ _ O
20 _ _ O
; _ _ O
printf _ _ O
( _ _ O
"%d _ _ O
" _ _ O
, _ _ O
y _ _ O
) _ _ O
; _ _ O
this _ _ O
is _ _ O
alright _ _ O
! _ _ O
} _ _ O
well _ _ O
, _ _ O
that _ _ O
's _ _ O
how _ _ O
you _ _ O
learned _ _ O
it _ _ O
. _ _ O
not _ _ O
every _ _ O
language _ _ O
has _ _ O
the _ _ O
same _ _ O
rules _ _ O
. _ _ O
printf _ _ O
( _ _ O
"%d _ _ O
" _ _ O
, _ _ O
y _ _ O
) _ _ O
; _ _ O
this _ _ O
is _ _ O
not _ _ O
. _ _ O
# _ _ O
Python _ _ O
if _ _ O
x _ _ O
= _ _ O
= _ _ O
10 _ _ O
: _ _ O
y _ _ O
= _ _ O
20 _ _ O
print _ _ O
( _ _ O
y _ _ O
) _ _ O
# _ _ O
works _ _ O
! _ _ O
print _ _ O
( _ _ O
y _ _ O
) _ _ O
# _ _ O
works _ _ O
! _ _ O
25 _ _ O

Static _ _ O
vs. _ _ O
dynamic _ _ O
● _ _ O
the _ _ O
majority _ _ O
of _ _ O
languages _ _ O
use _ _ O
static _ _ O
scope _ _ O
: _ _ O
the _ _ O
syntactic _ _ O
structure _ _ O
of _ _ O
the _ _ O
language _ _ O
defines _ _ O
where _ _ O
a _ _ O
name _ _ O
can _ _ O
be _ _ O
seen _ _ O
. _ _ O
● _ _ O
Python _ _ O
and _ _ O
many _ _ O
other _ _ O
dynamically-typed _ _ O
languages _ _ O
are _ _ O
instead _ _ O
dynamically _ _ O
scoped _ _ O
: _ _ O
the _ _ O
variable _ _ O
is _ _ O
not _ _ O
looked _ _ O
up _ _ O
until _ _ O
runtime _ _ O
. _ _ O
dynamic _ _ O
scope _ _ O
can _ _ O
lead _ _ O
to _ _ O
really _ _ O
confusing _ _ O
problems _ _ O
; _ _ O
the _ _ O
same _ _ O
piece _ _ O
of _ _ O
code _ _ O
can _ _ O
either _ _ O
work _ _ O
or _ _ O
not _ _ O
work _ _ O
based _ _ O
on _ _ O
what _ _ O
variables _ _ O
are _ _ O
f _ _ O
( _ _ O
) _ _ O
# _ _ O
runtime _ _ O
error _ _ O
! _ _ O
declared _ _ O
around _ _ O
it _ _ O
. _ _ O
g _ _ O
= _ _ O
10 _ _ O
# _ _ O
g _ _ O
is _ _ O
a _ _ O
global _ _ O
f _ _ O
( _ _ O
) _ _ O
# _ _ O
prints _ _ O
10 _ _ O
# _ _ O
Python _ _ O
def _ _ O
f _ _ O
( _ _ O
) _ _ O
: _ _ O
print _ _ O
( _ _ O
g _ _ O
) _ _ O
but _ _ O
I _ _ O
think _ _ O
most _ _ O
dynamic _ _ O
languages _ _ O
do _ _ O
it _ _ O
like _ _ O
this _ _ O
cause _ _ O
it _ _ O
's _ _ O
easy _ _ O
to _ _ O
implement _ _ O
! _ _ O
26 _ _ O

Shadowing _ _ O
● _ _ O
names _ _ O
are _ _ O
n't _ _ O
always _ _ O
unique _ _ O
. _ _ O
● _ _ O
sometimes _ _ O
this _ _ O
is _ _ O
clearly _ _ O
a _ _ O
mistake _ _ O
, _ _ O
but _ _ O
in _ _ O
other _ _ O
cases _ _ O
… _ _ O
class _ _ O
A _ _ O
{ _ _ O
in _ _ O
this _ _ O
case _ _ O
we _ _ O
say _ _ O
that _ _ O
the _ _ O
local _ _ O
int _ _ O
x _ _ O
; _ _ O
variable _ _ O
shadows _ _ O
the _ _ O
member _ _ O
variable _ _ O
. _ _ O
A _ _ O
( _ _ O
int _ _ O
x _ _ O
) _ _ O
{ _ _ O
/ _ _ O
/ _ _ O
which _ _ O
x _ _ O
? _ _ O
x _ _ O
= _ _ O
5 _ _ O
; _ _ O
} _ _ O
this _ _ O
refers _ _ O
to _ _ O
… _ _ O
} _ _ O
x _ _ O
that _ _ O
argument _ _ O
. _ _ O
27 _ _ O

Shadowing _ _ O
is _ _ O
n't _ _ O
always _ _ O
a _ _ O
mistake _ _ O
● _ _ O
sometimes _ _ O
it _ _ O
just _ _ O
makes _ _ O
things _ _ O
more _ _ O
convenient _ _ O
. _ _ O
o _ _ O
if _ _ O
you _ _ O
write _ _ O
a _ _ O
piece _ _ O
of _ _ O
code _ _ O
, _ _ O
and _ _ O
then _ _ O
change _ _ O
the _ _ O
environment _ _ O
around _ _ O
it _ _ O
( _ _ O
like _ _ O
adding _ _ O
a _ _ O
global _ _ O
) _ _ O
, _ _ O
you _ _ O
do _ _ O
n't _ _ O
want _ _ O
it _ _ O
to _ _ O
suddenly _ _ O
change _ _ O
behavior _ _ O
or _ _ O
get _ _ O
new _ _ O
compiler _ _ O
errors _ _ O
! _ _ O
● _ _ O
or _ _ O
in _ _ O
Rust _ _ O
, _ _ O
where _ _ O
variables _ _ O
are _ _ O
immutable _ _ O
by _ _ O
default _ _ O
, _ _ O
this _ _ O
is _ _ O
a _ _ O
common _ _ O
pattern _ _ O
: _ _ O
let _ _ O
ast _ _ O
= _ _ O
parse _ _ O
( _ _ O
lex _ _ O
( _ _ O
input _ _ O
) _ _ O
? _ _ O
) _ _ O
? _ _ O
; _ _ O
let _ _ O
types _ _ O
= _ _ O
typecheck _ _ O
( _ _ O
ast _ _ O
) _ _ O
? _ _ O
; _ _ O
let _ _ O
ast _ _ O
= _ _ O
const_fold _ _ O
( _ _ O
ast _ _ O
, _ _ O
types _ _ O
) _ _ O
? _ _ O
; _ _ O
let _ _ O
ast _ _ O
= _ _ O
inline_calls _ _ O
( _ _ O
ast _ _ O
, _ _ O
types _ _ O
) _ _ O
? _ _ O
; _ _ O
codegen _ _ O
( _ _ O
ast _ _ O
, _ _ O
types _ _ O
) _ _ O
? _ _ O
; _ _ O
● _ _ O
subsequent _ _ O
declarations _ _ O
of _ _ O
ast _ _ O
shadow _ _ O
the _ _ O
previous _ _ O
ones _ _ O
. _ _ O
28 _ _ O

Evaluation _ _ O
and _ _ O
Execution _ _ O
29 _ _ O

Evaluation _ _ O
and _ _ O
Side _ _ O
Effects _ _ O
● _ _ O
evaluation _ _ O
means _ _ O
figuring _ _ O
out _ _ O
the _ _ O
value _ _ O
that _ _ O
an _ _ O
expression _ _ O
has _ _ O
. _ _ O
o _ _ O
it _ _ O
might _ _ O
be _ _ O
trivial _ _ O
, _ _ O
like _ _ O
for _ _ O
literals _ _ O
: _ _ O
10 _ _ O
evaluates _ _ O
to _ _ O
… _ _ O
10 _ _ O
! _ _ O
● _ _ O
but _ _ O
it _ _ O
might _ _ O
require _ _ O
execution _ _ O
of _ _ O
an _ _ O
unknown _ _ O
amount _ _ O
of _ _ O
code _ _ O
… _ _ O
● _ _ O
and _ _ O
in _ _ O
the _ _ O
process _ _ O
, _ _ O
that _ _ O
code _ _ O
may _ _ O
also _ _ O
produce _ _ O
side _ _ O
effects _ _ O
: _ _ O
changes _ _ O
to _ _ O
things _ _ O
outside _ _ O
of _ _ O
the _ _ O
code _ _ O
's _ _ O
local _ _ O
variables _ _ O
, _ _ O
like _ _ O
: _ _ O
o _ _ O
modifying _ _ O
global _ _ O
variables _ _ O
o _ _ O
modifying _ _ O
objects _ _ O
that _ _ O
were _ _ O
passed _ _ O
to _ _ O
it _ _ O
by _ _ O
reference _ _ O
o _ _ O
performing _ _ O
input _ _ O
or _ _ O
output _ _ O
o _ _ O
making _ _ O
your _ _ O
computer _ _ O
explode _ _ O
● _ _ O
side _ _ O
effects _ _ O
make _ _ O
it _ _ O
hard _ _ O
for _ _ O
us _ _ O
to _ _ O
reason _ _ O
about _ _ O
code _ _ O
… _ _ O
o _ _ O
they _ _ O
can _ _ O
cause _ _ O
the _ _ O
same _ _ O
piece _ _ O
of _ _ O
code _ _ O
to _ _ O
do _ _ O
different _ _ O
things _ _ O
depending _ _ O
on _ _ O
how _ _ O
many _ _ O
times _ _ O
you _ _ O
run _ _ O
it _ _ O
. _ _ O
● _ _ O
but _ _ O
without _ _ O
side _ _ O
effects _ _ O
, _ _ O
code _ _ O
ca _ _ O
n't _ _ O
do _ _ O
anything _ _ O
useful _ _ O
! _ _ O
o _ _ O
imagine _ _ O
having _ _ O
no _ _ O
input _ _ O
or _ _ O
output _ _ O
! _ _ O
30 _ _ O

Evaluation _ _ O
Order _ _ O
● _ _ O
here _ _ O
's _ _ O
some _ _ O
Java _ _ O
code _ _ O
: _ _ O
int _ _ O
f _ _ O
( _ _ O
int _ _ O
x _ _ O
) _ _ O
{ _ _ O
println _ _ O
( _ _ O
"got _ _ O
" _ _ O
+ _ _ O
x _ _ O
) _ _ O
; _ _ O
return _ _ O
x _ _ O
; _ _ O
} _ _ O
int _ _ O
add _ _ O
( _ _ O
int _ _ O
a _ _ O
, _ _ O
int _ _ O
b _ _ O
) _ _ O
{ _ _ O
return _ _ O
a _ _ O
+ _ _ O
b _ _ O
; _ _ O
} _ _ O
println _ _ O
( _ _ O
"3 _ _ O
+ _ _ O
5 _ _ O
= _ _ O
" _ _ O
+ _ _ O
add _ _ O
( _ _ O
f _ _ O
( _ _ O
3 _ _ O
) _ _ O
, _ _ O
f _ _ O
( _ _ O
5 _ _ O
) _ _ O
) _ _ O
) _ _ O
; _ _ O
● _ _ O
which _ _ O
one _ _ O
does _ _ O
it _ _ O
print _ _ O
? _ _ O
got _ _ O
3 _ _ O
got _ _ O
5 _ _ O
3 _ _ O
+ _ _ O
5 _ _ O
= _ _ O
8 _ _ O
got _ _ O
5 _ _ O
got _ _ O
3 _ _ O
3 _ _ O
+ _ _ O
5 _ _ O
= _ _ O
8 _ _ O
we _ _ O
have _ _ O
an _ _ O
expectation _ _ O
that _ _ O
code _ _ O
executes _ _ O
left-to-right _ _ O
, _ _ O
so _ _ O
we _ _ O
expect _ _ O
this _ _ O
left _ _ O
one _ _ O
… _ _ O
and _ _ O
this _ _ O
is _ _ O
correct _ _ O
. _ _ O
for _ _ O
Java _ _ O
. _ _ O
evaluation _ _ O
order _ _ O
is _ _ O
defined _ _ O
by _ _ O
a _ _ O
language _ _ O
's _ _ O
semantics _ _ O
, _ _ O
and _ _ O
Java _ _ O
happens _ _ O
to _ _ O
define _ _ O
this _ _ O
order _ _ O
, _ _ O
but _ _ O
not _ _ O
all _ _ O
languages _ _ O
agree _ _ O
! _ _ O
31 _ _ O

Eager _ _ O
vs. _ _ O
Lazy _ _ O
● _ _ O
a _ _ O
less _ _ O
common _ _ O
distinction _ _ O
is _ _ O
eager _ _ O
versus _ _ O
lazy _ _ O
evaluation _ _ O
. _ _ O
int _ _ O
x _ _ O
= _ _ O
someLongComputation _ _ O
( _ _ O
) _ _ O
; _ _ O
System.out.println _ _ O
( _ _ O
"done _ _ O
. _ _ O
" _ _ O
) _ _ O
; _ _ O
System.out.println _ _ O
( _ _ O
"x _ _ O
= _ _ O
" _ _ O
+ _ _ O
x _ _ O
) _ _ O
; _ _ O
● _ _ O
in _ _ O
the _ _ O
above _ _ O
Java _ _ O
code _ _ O
, _ _ O
someLongComputation _ _ O
( _ _ O
) _ _ O
is _ _ O
called _ _ O
, _ _ O
and _ _ O
its _ _ O
return _ _ O
value _ _ O
is _ _ O
assigned _ _ O
into _ _ O
x _ _ O
after _ _ O
it _ _ O
returns _ _ O
. _ _ O
o _ _ O
this _ _ O
is _ _ O
eager _ _ O
evaluation _ _ O
, _ _ O
in _ _ O
which _ _ O
the _ _ O
function _ _ O
call _ _ O
occurs _ _ O
at _ _ O
the _ _ O
point _ _ O
where _ _ O
you _ _ O
write _ _ O
it _ _ O
. _ _ O
● _ _ O
but _ _ O
another _ _ O
way _ _ O
is _ _ O
lazy _ _ O
evaluation _ _ O
, _ _ O
in _ _ O
which _ _ O
the _ _ O
variable _ _ O
declaration _ _ O
does _ _ O
n't _ _ O
call _ _ O
the _ _ O
function _ _ O
, _ _ O
the _ _ O
use _ _ O
of _ _ O
x _ _ O
on _ _ O
the _ _ O
last _ _ O
line _ _ O
does _ _ O
. _ _ O
o _ _ O
that _ _ O
might _ _ O
sound _ _ O
bizarre _ _ O
, _ _ O
but _ _ O
is _ _ O
actually _ _ O
very _ _ O
popular _ _ O
in _ _ O
functional _ _ O
languages _ _ O
, _ _ O
where _ _ O
side-effect-free _ _ O
functions _ _ O
are _ _ O
the _ _ O
norm _ _ O
! _ _ O
● _ _ O
eager _ _ O
evaluation _ _ O
is _ _ O
by _ _ O
far _ _ O
the _ _ O
more _ _ O
popular _ _ O
strategy _ _ O
today _ _ O
, _ _ O
but _ _ O
… _ _ O
32 _ _ O

You _ _ O
never _ _ O
knew _ _ O
you _ _ O
were _ _ O
using _ _ O
it _ _ O
● _ _ O
in _ _ O
this _ _ O
code _ _ O
: _ _ O
if _ _ O
( _ _ O
condOne _ _ O
( _ _ O
) _ _ O
& _ _ O
& _ _ O
condTwo _ _ O
( _ _ O
) _ _ O
) _ _ O
{ _ _ O
println _ _ O
( _ _ O
"woo _ _ O
" _ _ O
) _ _ O
; _ _ O
} _ _ O
● _ _ O
if _ _ O
condOne _ _ O
( _ _ O
) _ _ O
returns _ _ O
false _ _ O
, _ _ O
does _ _ O
condTwo _ _ O
( _ _ O
) _ _ O
ever _ _ O
run _ _ O
? _ _ O
o _ _ O
nope _ _ O
. _ _ O
● _ _ O
this _ _ O
is _ _ O
lazy _ _ O
evaluation _ _ O
. _ _ O
o _ _ O
in _ _ O
all _ _ O
C-style _ _ O
languages _ _ O
, _ _ O
& _ _ O
& _ _ O
and _ _ O
|| _ _ O
lazily _ _ O
evaluate _ _ O
their _ _ O
second _ _ O
operand _ _ O
: _ _ O
they _ _ O
only _ _ O
execute _ _ O
that _ _ O
code _ _ O
if _ _ O
needed _ _ O
. _ _ O
● _ _ O
lazy _ _ O
evaluation _ _ O
can _ _ O
be _ _ O
really _ _ O
useful _ _ O
when _ _ O
using _ _ O
higher-order _ _ O
functions _ _ O
( _ _ O
passing _ _ O
functions _ _ O
to _ _ O
other _ _ O
functions _ _ O
) _ _ O
, _ _ O
too _ _ O
. _ _ O
● _ _ O
so _ _ O
do _ _ O
n't _ _ O
write _ _ O
it _ _ O
off _ _ O
as _ _ O
academic _ _ O
nonsense _ _ O
! _ _ O
33 _ _ O

Languages _ _ O
without _ _ O
Semantic _ _ O
Analysis _ _ O
? _ _ O
34 _ _ O

Who _ _ O
needs _ _ O
semantic _ _ O
analysis _ _ O
anyway _ _ O
● _ _ O
depending _ _ O
on _ _ O
how _ _ O
the _ _ O
language _ _ O
is _ _ O
designed _ _ O
, _ _ O
we _ _ O
may _ _ O
not _ _ O
have _ _ O
to _ _ O
do _ _ O
any _ _ O
semantic _ _ O
analysis _ _ O
in _ _ O
the _ _ O
compiler _ _ O
. _ _ O
def _ _ O
test _ _ O
( _ _ O
) _ _ O
: _ _ O
Python _ _ O
is _ _ O
a _ _ O
dynamically-typed _ _ O
language _ _ O
. _ _ O
x _ _ O
= _ _ O
10 _ _ O
x _ _ O
= _ _ O
" _ _ O
hello _ _ O
" _ _ O
that _ _ O
means _ _ O
the _ _ O
semantic _ _ O
rules _ _ O
of _ _ O
its _ _ O
type _ _ O
system _ _ O
are _ _ O
checked _ _ O
at _ _ O
runtime _ _ O
, _ _ O
as _ _ O
the _ _ O
code _ _ O
executes _ _ O
. _ _ O
x _ _ O
= _ _ O
print _ _ O
x _ _ O
( _ _ O
"hi _ _ O
! _ _ O
" _ _ O
) _ _ O
this _ _ O
is _ _ O
totally _ _ O
valid _ _ O
Python _ _ O
code _ _ O
, _ _ O
but _ _ O
there _ _ O
's _ _ O
no _ _ O
test _ _ O
( _ _ O
) _ _ O
way _ _ O
for _ _ O
the _ _ O
compiler _ _ O
to _ _ O
tell _ _ O
. _ _ O
so _ _ O
, _ _ O
it _ _ O
… _ _ O
does _ _ O
n't _ _ O
. _ _ O
compilers _ _ O
for _ _ O
dynamic _ _ O
languages _ _ O
can _ _ O
be _ _ O
pretty _ _ O
simple _ _ O
: _ _ O
lex _ _ O
, _ _ O
parse _ _ O
, _ _ O
and _ _ O
then _ _ O
… _ _ O
well _ _ O
, _ _ O
right _ _ O
to _ _ O
execution _ _ O
! _ _ O
35 _ _ O

Executing _ _ O
the _ _ O
AST _ _ O
● _ _ O
we _ _ O
saw _ _ O
this _ _ O
already _ _ O
with _ _ O
the _ _ O
ast_math _ _ O
example _ _ O
! _ _ O
o _ _ O
once _ _ O
you _ _ O
build _ _ O
the _ _ O
AST _ _ O
, _ _ O
you _ _ O
just _ _ O
write _ _ O
some _ _ O
recursive _ _ O
methods _ _ O
to _ _ O
visit _ _ O
all _ _ O
the _ _ O
AST _ _ O
nodes _ _ O
in _ _ O
order _ _ O
, _ _ O
evaluating _ _ O
them _ _ O
as _ _ O
you _ _ O
go _ _ O
. _ _ O
o _ _ O
it _ _ O
's _ _ O
not _ _ O
hard _ _ O
to _ _ O
extend _ _ O
this _ _ O
concept _ _ O
to _ _ O
AST _ _ O
nodes _ _ O
for _ _ O
loops _ _ O
, _ _ O
conditionals _ _ O
, _ _ O
function _ _ O
calls _ _ O
etc _ _ O
. _ _ O
● _ _ O
this _ _ O
is _ _ O
an _ _ O
AST _ _ O
interpreter _ _ O
, _ _ O
and _ _ O
is _ _ O
a _ _ O
really _ _ O
quick-and-dirty _ _ O
way _ _ O
to _ _ O
get _ _ O
something _ _ O
running _ _ O
. _ _ O
o _ _ O
from _ _ O
what _ _ O
I _ _ O
understand _ _ O
, _ _ O
Ruby _ _ O
used _ _ O
exactly _ _ O
this _ _ O
execution _ _ O
strategy _ _ O
for _ _ O
over _ _ O
10 _ _ O
years _ _ O
! _ _ O
● _ _ O
but _ _ O
as _ _ O
you _ _ O
might _ _ O
imagine _ _ O
, _ _ O
it _ _ O
is _ _ O
not _ _ O
fast _ _ O
at _ _ O
all _ _ O
. _ _ O
o _ _ O
consider _ _ O
all _ _ O
the _ _ O
interpreter _ _ O
code _ _ O
that _ _ O
needs _ _ O
to _ _ O
run _ _ O
just _ _ O
to _ _ O
, _ _ O
say _ _ O
, _ _ O
add _ _ O
a _ _ O
couple _ _ O
numbers _ _ O
together _ _ O
. _ _ O
● _ _ O
but _ _ O
this _ _ O
topic _ _ O
is _ _ O
better _ _ O
left _ _ O
for _ _ O
after _ _ O
the _ _ O
midterm _ _ O
… _ _ O
36 _ _ O



