unlabeled|cs1622|lec08
-DOCSTART- -X- -X- O

Scoping _ _ O
and _ _ O
Naming _ _ O
CS _ _ O
1622 _ _ O
Jarrett _ _ O
Billingsley _ _ O

Class _ _ O
Announcements _ _ O
● _ _ O
how _ _ O
’s _ _ O
project _ _ O
2 _ _ O
coming _ _ O
along _ _ O
(: _ _ O
2 _ _ O

Symbol _ _ O
Tables _ _ O
and _ _ O
Scope _ _ O
Trees _ _ O
3 _ _ O

Scoping _ _ O
it _ _ O
out _ _ O
● _ _ O
the _ _ O
first _ _ O
phase _ _ O
of _ _ O
semantic _ _ O
analysis _ _ O
is _ _ O
name-checking _ _ O
, _ _ O
which _ _ O
: _ _ O
o _ _ O
matches _ _ O
names _ _ O
to _ _ O
the _ _ O
things _ _ O
they _ _ O
refer _ _ O
to _ _ O
; _ _ O
and _ _ O
o _ _ O
checks _ _ O
for _ _ O
scoping _ _ O
violations _ _ O
. _ _ O
▪ _ _ O
remember _ _ O
that _ _ O
the _ _ O
scope _ _ O
of _ _ O
a _ _ O
name _ _ O
is _ _ O
where _ _ O
it _ _ O
can _ _ O
be _ _ O
seen _ _ O
. _ _ O
● _ _ O
so _ _ O
how _ _ O
do _ _ O
we _ _ O
do _ _ O
this _ _ O
stuff _ _ O
? _ _ O
o _ _ O
well _ _ O
, _ _ O
like _ _ O
many _ _ O
other _ _ O
things _ _ O
we _ _ O
've _ _ O
talked _ _ O
about _ _ O
, _ _ O
it _ _ O
's _ _ O
about _ _ O
formalizing _ _ O
our _ _ O
intuition _ _ O
: _ _ O
taking _ _ O
rules _ _ O
that _ _ O
we _ _ O
kind _ _ O
of _ _ O
know _ _ O
already _ _ O
, _ _ O
and _ _ O
turning _ _ O
them _ _ O
into _ _ O
an _ _ O
algorithm _ _ O
. _ _ O
● _ _ O
we _ _ O
also _ _ O
need _ _ O
a _ _ O
data _ _ O
structure _ _ O
or _ _ O
two _ _ O
… _ _ O
o _ _ O
we _ _ O
need _ _ O
to _ _ O
remember _ _ O
where _ _ O
each _ _ O
name _ _ O
is _ _ O
declared _ _ O
o _ _ O
and _ _ O
we _ _ O
need _ _ O
some _ _ O
mapping _ _ O
from _ _ O
names _ _ O
to _ _ O
referents _ _ O
● _ _ O
so _ _ O
let _ _ O
’s _ _ O
start _ _ O
with _ _ O
… _ _ O
4 _ _ O

Symbol _ _ O
tables _ _ O
● _ _ O
a _ _ O
symbol _ _ O
table _ _ O
maps _ _ O
from _ _ O
names _ _ O
to _ _ O
the _ _ O
" _ _ O
things _ _ O
" _ _ O
they _ _ O
refer _ _ O
to _ _ O
. _ _ O
o _ _ O
symbol _ _ O
means _ _ O
anything _ _ O
that _ _ O
can _ _ O
have _ _ O
a _ _ O
name _ _ O
: _ _ O
variables _ _ O
, _ _ O
functions _ _ O
, _ _ O
classes _ _ O
, _ _ O
modules _ _ O
, _ _ O
packages _ _ O
, _ _ O
interfaces _ _ O
, _ _ O
macros _ _ O
, _ _ O
etc _ _ O
. _ _ O
etc _ _ O
. _ _ O
● _ _ O
as _ _ O
you _ _ O
declare _ _ O
things _ _ O
, _ _ O
they _ _ O
are _ _ O
added _ _ O
to _ _ O
the _ _ O
symbol _ _ O
table _ _ O
. _ _ O
Name _ _ O
Referent _ _ O
class _ _ O
A _ _ O
{ _ _ O
" _ _ O
A _ _ O
" _ _ O
< _ _ O
class _ _ O
A _ _ O
> _ _ O
static _ _ O
int _ _ O
x _ _ O
= _ _ O
5 _ _ O
; _ _ O
static _ _ O
void _ _ O
main _ _ O
( _ _ O
) _ _ O
{ _ _ O
" _ _ O
x _ _ O
" _ _ O
< _ _ O
int _ _ O
x _ _ O
> _ _ O
foo _ _ O
( _ _ O
x _ _ O
) _ _ O
; _ _ O
" _ _ O
main _ _ O
" _ _ O
< _ _ O
void _ _ O
main _ _ O
( _ _ O
) _ _ O
> _ _ O
} _ _ O
" _ _ O
foo _ _ O
" _ _ O
< _ _ O
void _ _ O
foo _ _ O
( _ _ O
) _ _ O
> _ _ O
static _ _ O
void _ _ O
foo _ _ O
( _ _ O
int _ _ O
y _ _ O
) _ _ O
{ _ _ O
S.o.println _ _ O
( _ _ O
y _ _ O
) _ _ O
; _ _ O
" _ _ O
y _ _ O
" _ _ O
< _ _ O
int _ _ O
y _ _ O
> _ _ O
} _ _ O
} _ _ O
but _ _ O
you _ _ O
ca _ _ O
n't _ _ O
see _ _ O
y _ _ O
from _ _ O
main _ _ O
… _ _ O
so _ _ O
should _ _ O
it _ _ O
be _ _ O
in _ _ O
this _ _ O
table _ _ O
? _ _ O
5 _ _ O

Instead _ _ O
of _ _ O
ONE _ _ O
symbol _ _ O
table _ _ O
… _ _ O
● _ _ O
we _ _ O
nest _ _ O
the _ _ O
symbol _ _ O
tables _ _ O
in _ _ O
a _ _ O
tree _ _ O
. _ _ O
there _ _ O
's _ _ O
one _ _ O
for _ _ O
each _ _ O
scope _ _ O
. _ _ O
class _ _ O
A _ _ O
{ _ _ O
static _ _ O
int _ _ O
x _ _ O
= _ _ O
5 _ _ O
; _ _ O
static _ _ O
void _ _ O
main _ _ O
( _ _ O
) _ _ O
{ _ _ O
foo _ _ O
( _ _ O
x _ _ O
) _ _ O
; _ _ O
} _ _ O
static _ _ O
void _ _ O
foo _ _ O
( _ _ O
int _ _ O
y _ _ O
) _ _ O
{ _ _ O
S.o.println _ _ O
( _ _ O
y _ _ O
) _ _ O
; _ _ O
} _ _ O
} _ _ O
this _ _ O
outermost _ _ O
( _ _ O
global _ _ O
) _ _ O
scope _ _ O
is _ _ O
where _ _ O
e.g. _ _ O
System _ _ O
lives _ _ O
. _ _ O
A _ _ O
is _ _ O
inserted _ _ O
there _ _ O
too _ _ O
. _ _ O
the _ _ O
class _ _ O
A _ _ O
gets _ _ O
a _ _ O
scope _ _ O
to _ _ O
hold _ _ O
its _ _ O
members _ _ O
, _ _ O
like _ _ O
its _ _ O
variables _ _ O
and _ _ O
methods _ _ O
. _ _ O
this _ _ O
scope _ _ O
is _ _ O
a _ _ O
child _ _ O
of _ _ O
the _ _ O
global _ _ O
scope _ _ O
. _ _ O
then _ _ O
each _ _ O
method _ _ O
gets _ _ O
its _ _ O
own _ _ O
scope _ _ O
, _ _ O
both _ _ O
of _ _ O
which _ _ O
are _ _ O
children _ _ O
of _ _ O
A _ _ O
's _ _ O
scope _ _ O
. _ _ O
6 _ _ O

The _ _ O
scope _ _ O
tree _ _ O
data _ _ O
structure _ _ O
● _ _ O
it _ _ O
's _ _ O
a _ _ O
tree _ _ O
, _ _ O
where _ _ O
each _ _ O
node _ _ O
is _ _ O
a _ _ O
scope _ _ O
, _ _ O
which _ _ O
has _ _ O
a _ _ O
symbol _ _ O
table _ _ O
. _ _ O
● _ _ O
the _ _ O
symbol _ _ O
tables _ _ O
map _ _ O
from _ _ O
names _ _ O
to _ _ O
the _ _ O
nodes _ _ O
in _ _ O
the _ _ O
AST _ _ O
which _ _ O
define _ _ O
those _ _ O
names _ _ O
. _ _ O
* _ _ O
" _ _ O
The _ _ O
AST _ _ O
" _ _ O
< _ _ O
global _ _ O
scope _ _ O
> _ _ O
" _ _ O
A _ _ O
" _ _ O
" _ _ O
System _ _ O
" _ _ O
A _ _ O
's _ _ O
scope _ _ O
main _ _ O
's _ _ O
scope _ _ O
class _ _ O
A _ _ O
{ _ _ O
static _ _ O
int _ _ O
x _ _ O
= _ _ O
5 _ _ O
; _ _ O
static _ _ O
void _ _ O
main _ _ O
( _ _ O
) _ _ O
{ _ _ O
foo _ _ O
( _ _ O
x _ _ O
) _ _ O
; _ _ O
" _ _ O
x _ _ O
" _ _ O
" _ _ O
main _ _ O
" _ _ O
} _ _ O
" _ _ O
foo _ _ O
" _ _ O
static _ _ O
void _ _ O
foo _ _ O
( _ _ O
int _ _ O
y _ _ O
) _ _ O
{ _ _ O
S.o.println _ _ O
( _ _ O
y _ _ O
) _ _ O
; _ _ O
< _ _ O
empty _ _ O
> _ _ O
} _ _ O
} _ _ O
foo _ _ O
's _ _ O
scope _ _ O
" _ _ O
y _ _ O
" _ _ O
7 _ _ O

Parent _ _ O
scopes _ _ O
● _ _ O
each _ _ O
child _ _ O
scope _ _ O
also _ _ O
needs _ _ O
to _ _ O
know _ _ O
which _ _ O
scope _ _ O
is _ _ O
its _ _ O
parent _ _ O
. _ _ O
o _ _ O
( _ _ O
this _ _ O
is _ _ O
used _ _ O
in _ _ O
the _ _ O
name _ _ O
resolution _ _ O
algorithm _ _ O
. _ _ O
) _ _ O
● _ _ O
that _ _ O
means _ _ O
we _ _ O
've _ _ O
got _ _ O
bidirectional _ _ O
links _ _ O
between _ _ O
the _ _ O
scopes _ _ O
. _ _ O
< _ _ O
global _ _ O
scope _ _ O
> _ _ O
A _ _ O
's _ _ O
scope _ _ O
main _ _ O
's _ _ O
scope _ _ O
foo _ _ O
's _ _ O
scope _ _ O
this _ _ O
is _ _ O
going _ _ O
to _ _ O
have _ _ O
implications _ _ O
for _ _ O
the _ _ O
way _ _ O
we _ _ O
implement _ _ O
this _ _ O
data _ _ O
structure _ _ O
in _ _ O
Rust _ _ O
… _ _ O
but _ _ O
then _ _ O
each _ _ O
scope _ _ O
has _ _ O
a _ _ O
symbol _ _ O
table _ _ O
which _ _ O
somehow _ _ O
points _ _ O
into _ _ O
the _ _ O
AST _ _ O
? _ _ O
how _ _ O
do _ _ O
we _ _ O
deal _ _ O
with _ _ O
that _ _ O
? _ _ O
maybe _ _ O
we _ _ O
could _ _ O
integrate _ _ O
this _ _ O
into _ _ O
the _ _ O
AST _ _ O
? _ _ O
? _ _ O
WELL _ _ O
, _ _ O
NO _ _ O
…… _ _ O
.. _ _ O
8 _ _ O

Syntax _ _ O
, _ _ O
not _ _ O
semantics _ _ O
● _ _ O
since _ _ O
the _ _ O
scopes _ _ O
more _ _ O
or _ _ O
less _ _ O
follow _ _ O
the _ _ O
syntax _ _ O
( _ _ O
{ _ _ O
} _ _ O
≅ _ _ O
scope _ _ O
) _ _ O
… _ _ O
o _ _ O
we _ _ O
might _ _ O
be _ _ O
tempted _ _ O
to _ _ O
jam _ _ O
the _ _ O
scope _ _ O
tree _ _ O
into _ _ O
the _ _ O
AST _ _ O
somehow _ _ O
. _ _ O
o _ _ O
this _ _ O
is _ _ O
a _ _ O
really _ _ O
bad _ _ O
idea _ _ O
. _ _ O
● _ _ O
the _ _ O
AST _ _ O
is _ _ O
an _ _ O
abstract _ _ O
syntax _ _ O
tree _ _ O
, _ _ O
but _ _ O
we _ _ O
're _ _ O
moving _ _ O
beyond _ _ O
syntax _ _ O
. _ _ O
o _ _ O
the _ _ O
relationships _ _ O
established _ _ O
by _ _ O
name _ _ O
resolution _ _ O
can _ _ O
crisscross _ _ O
the _ _ O
whole _ _ O
program _ _ O
and _ _ O
form _ _ O
any _ _ O
shape _ _ O
of _ _ O
graph _ _ O
, _ _ O
including _ _ O
cycles _ _ O
. _ _ O
o _ _ O
and _ _ O
as _ _ O
we _ _ O
get _ _ O
further _ _ O
into _ _ O
semantic _ _ O
analysis _ _ O
– _ _ O
and _ _ O
then _ _ O
into _ _ O
optimization _ _ O
and _ _ O
code _ _ O
generation _ _ O
– _ _ O
the _ _ O
syntax _ _ O
will _ _ O
become _ _ O
less _ _ O
and _ _ O
less _ _ O
relevant _ _ O
. _ _ O
● _ _ O
so _ _ O
, _ _ O
the _ _ O
scope _ _ O
tree _ _ O
data _ _ O
structure _ _ O
should _ _ O
exist _ _ O
in _ _ O
parallel _ _ O
to _ _ O
the _ _ O
AST _ _ O
. _ _ O
o _ _ O
we _ _ O
'll _ _ O
represent _ _ O
the _ _ O
links _ _ O
between _ _ O
the _ _ O
two _ _ O
data _ _ O
structures _ _ O
in _ _ O
an _ _ O
indirect _ _ O
way _ _ O
, _ _ O
as _ _ O
we _ _ O
'll _ _ O
see _ _ O
… _ _ O
9 _ _ O

Name _ _ O
Resolution _ _ O
time _ _ O
check _ _ O
≤ _ _ O
20 _ _ O
10 _ _ O

Declaration _ _ O
vs. _ _ O
use _ _ O
● _ _ O
when _ _ O
we _ _ O
declare _ _ O
classes _ _ O
, _ _ O
variables _ _ O
, _ _ O
functions _ _ O
etc _ _ O
. _ _ O
that _ _ O
makes _ _ O
the _ _ O
name _ _ O
available _ _ O
for _ _ O
use _ _ O
by _ _ O
other _ _ O
pieces _ _ O
of _ _ O
code _ _ O
. _ _ O
o _ _ O
a _ _ O
declaration _ _ O
essentially _ _ O
inserts _ _ O
a _ _ O
name _ _ O
into _ _ O
a _ _ O
symbol _ _ O
table _ _ O
. _ _ O
int _ _ O
x _ _ O
= _ _ O
0 _ _ O
; _ _ O
x _ _ O
= _ _ O
x _ _ O
+ _ _ O
1 _ _ O
; _ _ O
println _ _ O
( _ _ O
x _ _ O
) _ _ O
; _ _ O
x _ _ O
= _ _ O
f _ _ O
( _ _ O
) _ _ O
; _ _ O
return _ _ O
x _ _ O
; _ _ O
this _ _ O
is _ _ O
the _ _ O
declaration _ _ O
of _ _ O
x. _ _ O
it _ _ O
puts _ _ O
x _ _ O
into _ _ O
this _ _ O
scope _ _ O
’s _ _ O
symbol _ _ O
table _ _ O
. _ _ O
all _ _ O
of _ _ O
these _ _ O
other _ _ O
places _ _ O
where _ _ O
we _ _ O
refer _ _ O
to _ _ O
x _ _ O
by _ _ O
name _ _ O
are _ _ O
called _ _ O
uses _ _ O
. _ _ O
for _ _ O
each _ _ O
of _ _ O
these _ _ O
uses _ _ O
, _ _ O
we _ _ O
have _ _ O
to _ _ O
perform _ _ O
name _ _ O
resolution _ _ O
: _ _ O
determining _ _ O
which _ _ O
symbol _ _ O
the _ _ O
use _ _ O
refers _ _ O
to _ _ O
. _ _ O
the _ _ O
scope _ _ O
tree _ _ O
/ _ _ O
symbol _ _ O
tables _ _ O
and _ _ O
the _ _ O
scoping _ _ O
rules _ _ O
are _ _ O
what _ _ O
we _ _ O
'll _ _ O
use _ _ O
to _ _ O
implement _ _ O
name _ _ O
resolution _ _ O
! _ _ O
11 _ _ O

Climbing _ _ O
the _ _ O
tree _ _ O
( _ _ O
animated _ _ O
) _ _ O
● _ _ O
the _ _ O
name _ _ O
resolution _ _ O
algorithm _ _ O
is _ _ O
actually _ _ O
pretty _ _ O
straightforward _ _ O
. _ _ O
< _ _ O
global _ _ O
scope _ _ O
> _ _ O
" _ _ O
A _ _ O
" _ _ O
" _ _ O
System _ _ O
" _ _ O
A _ _ O
's _ _ O
scope _ _ O
" _ _ O
x _ _ O
" _ _ O
" _ _ O
main _ _ O
" _ _ O
" _ _ O
foo _ _ O
" _ _ O
foo _ _ O
's _ _ O
scope _ _ O
3 _ _ O
. _ _ O
go _ _ O
to _ _ O
the _ _ O
parent _ _ O
scope _ _ O
of _ _ O
that _ _ O
one _ _ O
. _ _ O
is _ _ O
System _ _ O
there _ _ O
? _ _ O
yes _ _ O
! _ _ O
name _ _ O
resolved _ _ O
. _ _ O
2 _ _ O
. _ _ O
go _ _ O
to _ _ O
the _ _ O
foo _ _ O
's _ _ O
parent _ _ O
scope _ _ O
. _ _ O
is _ _ O
System _ _ O
there _ _ O
? _ _ O
" _ _ O
y _ _ O
" _ _ O
static _ _ O
void _ _ O
foo _ _ O
( _ _ O
int _ _ O
y _ _ O
) _ _ O
{ _ _ O
System.out.println _ _ O
( _ _ O
y _ _ O
) _ _ O
; _ _ O
} _ _ O
still _ _ O
no _ _ O
? _ _ O
1 _ _ O
. _ _ O
is _ _ O
System _ _ O
declared _ _ O
in _ _ O
foo _ _ O
's _ _ O
scope _ _ O
? _ _ O
this _ _ O
use _ _ O
of _ _ O
System _ _ O
appears _ _ O
in _ _ O
foo _ _ O
's _ _ O
scope _ _ O
. _ _ O
let _ _ O
's _ _ O
start _ _ O
there _ _ O
. _ _ O
no _ _ O
? _ _ O
12 _ _ O

What _ _ O
if _ _ O
it _ _ O
fails _ _ O
? _ _ O
● _ _ O
what _ _ O
if _ _ O
we _ _ O
get _ _ O
up _ _ O
to _ _ O
the _ _ O
global _ _ O
scope _ _ O
and _ _ O
there _ _ O
's _ _ O
no _ _ O
match _ _ O
? _ _ O
o _ _ O
well _ _ O
, _ _ O
that _ _ O
's _ _ O
an _ _ O
error _ _ O
. _ _ O
that _ _ O
's _ _ O
when _ _ O
your _ _ O
compiler _ _ O
says _ _ O
" _ _ O
unresolved _ _ O
symbol _ _ O
" _ _ O
or _ _ O
" _ _ O
undefined _ _ O
name _ _ O
" _ _ O
or _ _ O
whatever _ _ O
. _ _ O
● _ _ O
but _ _ O
it _ _ O
could _ _ O
" _ _ O
fail _ _ O
" _ _ O
in _ _ O
another _ _ O
way _ _ O
: _ _ O
int _ _ O
x _ _ O
= _ _ O
System _ _ O
+ _ _ O
5 _ _ O
; _ _ O
o _ _ O
assuming _ _ O
I _ _ O
did _ _ O
n't _ _ O
declare _ _ O
a _ _ O
variable _ _ O
named _ _ O
System _ _ O
… _ _ O
o _ _ O
this _ _ O
is _ _ O
nonsense _ _ O
. _ _ O
how _ _ O
do _ _ O
you _ _ O
add _ _ O
a _ _ O
class _ _ O
and _ _ O
an _ _ O
integer _ _ O
? _ _ O
● _ _ O
well _ _ O
, _ _ O
do _ _ O
n't _ _ O
worry _ _ O
about _ _ O
it _ _ O
. _ _ O
not _ _ O
at _ _ O
this _ _ O
stage _ _ O
, _ _ O
anyway _ _ O
. _ _ O
o _ _ O
name _ _ O
resolution _ _ O
only _ _ O
cares _ _ O
about _ _ O
matching _ _ O
names _ _ O
to _ _ O
the _ _ O
things _ _ O
that _ _ O
declared _ _ O
them _ _ O
. _ _ O
o _ _ O
this _ _ O
example _ _ O
is _ _ O
a _ _ O
type _ _ O
error _ _ O
and _ _ O
will _ _ O
be _ _ O
caught _ _ O
further _ _ O
on _ _ O
during _ _ O
a _ _ O
subsequent _ _ O
phase _ _ O
of _ _ O
semantic _ _ O
analysis _ _ O
. _ _ O
13 _ _ O

Keeping _ _ O
track _ _ O
of _ _ O
resolved _ _ O
names _ _ O
● _ _ O
we _ _ O
could _ _ O
perform _ _ O
name _ _ O
resolution _ _ O
every _ _ O
time _ _ O
we _ _ O
need _ _ O
to _ _ O
know _ _ O
the _ _ O
referent _ _ O
during _ _ O
subsequent _ _ O
compiler _ _ O
phases _ _ O
. _ _ O
o _ _ O
but _ _ O
real-world _ _ O
experience _ _ O
( _ _ O
by _ _ O
other _ _ O
people _ _ O
) _ _ O
has _ _ O
shown _ _ O
that _ _ O
these _ _ O
resolutions _ _ O
happen _ _ O
a _ _ O
lot _ _ O
and _ _ O
that _ _ O
can _ _ O
waste _ _ O
a _ _ O
lot _ _ O
of _ _ O
time _ _ O
. _ _ O
● _ _ O
since _ _ O
the _ _ O
referent _ _ O
never _ _ O
changes _ _ O
, _ _ O
it _ _ O
makes _ _ O
sense _ _ O
to _ _ O
remember _ _ O
that _ _ O
. _ _ O
int _ _ O
x _ _ O
= _ _ O
0 _ _ O
; _ _ O
x _ _ O
= _ _ O
x _ _ O
+ _ _ O
1 _ _ O
; _ _ O
println _ _ O
( _ _ O
x _ _ O
) _ _ O
; _ _ O
x _ _ O
= _ _ O
f _ _ O
( _ _ O
) _ _ O
; _ _ O
return _ _ O
x _ _ O
; _ _ O
we _ _ O
can _ _ O
do _ _ O
this _ _ O
by _ _ O
keeping _ _ O
a _ _ O
map _ _ O
which _ _ O
maps _ _ O
from _ _ O
the _ _ O
AST _ _ O
nodes _ _ O
which _ _ O
use _ _ O
a _ _ O
name _ _ O
to _ _ O
the _ _ O
node _ _ O
which _ _ O
declares _ _ O
it _ _ O
. _ _ O
this _ _ O
is _ _ O
yet _ _ O
another _ _ O
data _ _ O
structure _ _ O
that _ _ O
I _ _ O
call _ _ O
the _ _ O
use _ _ O
map _ _ O
. _ _ O
it _ _ O
’s _ _ O
a _ _ O
bit _ _ O
like _ _ O
drawing _ _ O
arrows _ _ O
all _ _ O
over _ _ O
the _ _ O
code _ _ O
. _ _ O
again _ _ O
, _ _ O
we _ _ O
'll _ _ O
see _ _ O
how _ _ O
to _ _ O
implement _ _ O
this _ _ O
soon _ _ O
… _ _ O
14 _ _ O

Accessing _ _ O
names _ _ O
inside _ _ O
things _ _ O
● _ _ O
this _ _ O
piece _ _ O
of _ _ O
code _ _ O
presents _ _ O
another _ _ O
interesting _ _ O
scenario _ _ O
: _ _ O
System.out.println _ _ O
( _ _ O
y _ _ O
) _ _ O
; _ _ O
is _ _ O
this _ _ O
also _ _ O
a _ _ O
name _ _ O
resolution _ _ O
? _ _ O
? _ _ O
well _ _ O
, _ _ O
yes _ _ O
! _ _ O
this _ _ O
is _ _ O
saying _ _ O
" _ _ O
access _ _ O
out _ _ O
from _ _ O
the _ _ O
System _ _ O
scope _ _ O
. _ _ O
" _ _ O
but _ _ O
there _ _ O
's _ _ O
a _ _ O
complication _ _ O
: _ _ O
we _ _ O
may _ _ O
not _ _ O
be _ _ O
able _ _ O
to _ _ O
perform _ _ O
the _ _ O
resolution _ _ O
until _ _ O
after _ _ O
we _ _ O
do _ _ O
typechecking _ _ O
: _ _ O
obj.x _ _ O
= _ _ O
10 _ _ O
; _ _ O
here _ _ O
, _ _ O
we _ _ O
have _ _ O
to _ _ O
know _ _ O
what _ _ O
type _ _ O
obj _ _ O
is _ _ O
to _ _ O
know _ _ O
if _ _ O
x _ _ O
is _ _ O
a _ _ O
valid _ _ O
name _ _ O
inside _ _ O
of _ _ O
that _ _ O
type _ _ O
. _ _ O
then _ _ O
we _ _ O
will _ _ O
have _ _ O
to _ _ O
check _ _ O
that _ _ O
the _ _ O
type _ _ O
of _ _ O
x _ _ O
is _ _ O
actually _ _ O
valid _ _ O
for _ _ O
this _ _ O
assignment _ _ O
! _ _ O
wow _ _ O
! _ _ O
very _ _ O
circular _ _ O
! _ _ O
! _ _ O
fortunately _ _ O
this _ _ O
is _ _ O
a _ _ O
relatively _ _ O
limited _ _ O
situation _ _ O
that _ _ O
can _ _ O
be _ _ O
resolved _ _ O
later _ _ O
… _ _ O
15 _ _ O

Forward _ _ O
/ _ _ O
mutual _ _ O
references _ _ O
● _ _ O
a _ _ O
forward _ _ O
reference _ _ O
is _ _ O
when _ _ O
the _ _ O
use _ _ O
of _ _ O
a _ _ O
name _ _ O
occurs _ _ O
before _ _ O
its _ _ O
declaration _ _ O
in _ _ O
the _ _ O
source _ _ O
code _ _ O
. _ _ O
class _ _ O
A _ _ O
{ _ _ O
B _ _ O
b _ _ O
; _ _ O
} _ _ O
this _ _ O
is _ _ O
a _ _ O
forward _ _ O
reference _ _ O
, _ _ O
because _ _ O
B _ _ O
is _ _ O
class _ _ O
B _ _ O
{ _ _ O
} _ _ O
declared _ _ O
later _ _ O
. _ _ O
if _ _ O
we _ _ O
did _ _ O
all _ _ O
the _ _ O
name _ _ O
stuff _ _ O
in _ _ O
one _ _ O
pass _ _ O
, _ _ O
we _ _ O
would _ _ O
get _ _ O
an _ _ O
error _ _ O
here _ _ O
because _ _ O
B _ _ O
does _ _ O
n’t _ _ O
exist _ _ O
in _ _ O
the _ _ O
symbol _ _ O
table _ _ O
yet _ _ O
! _ _ O
this _ _ O
means _ _ O
we _ _ O
have _ _ O
to _ _ O
do _ _ O
name _ _ O
stuff _ _ O
in _ _ O
two _ _ O
passes _ _ O
: _ _ O
on _ _ O
the _ _ O
first _ _ O
pass _ _ O
, _ _ O
we _ _ O
build _ _ O
the _ _ O
scope _ _ O
tree _ _ O
and _ _ O
insert _ _ O
declarations _ _ O
into _ _ O
each _ _ O
scope _ _ O
’s _ _ O
symbol _ _ O
table _ _ O
; _ _ O
then _ _ O
on _ _ O
the _ _ O
second _ _ O
pass _ _ O
, _ _ O
we _ _ O
can _ _ O
do _ _ O
the _ _ O
name _ _ O
resolution _ _ O
using _ _ O
the _ _ O
already-built _ _ O
symbol _ _ O
tables _ _ O
. _ _ O
16 _ _ O

… _ _ O
but _ _ O
that _ _ O
does _ _ O
n’t _ _ O
work _ _ O
for _ _ O
locals _ _ O
● _ _ O
consider _ _ O
this _ _ O
code _ _ O
: _ _ O
static _ _ O
void _ _ O
func _ _ O
( _ _ O
) _ _ O
{ _ _ O
you _ _ O
know _ _ O
that _ _ O
this _ _ O
is _ _ O
wrong _ _ O
. _ _ O
but _ _ O
why _ _ O
? _ _ O
S.o.println _ _ O
( _ _ O
x _ _ O
) _ _ O
; _ _ O
int _ _ O
x _ _ O
= _ _ O
10 _ _ O
; _ _ O
} _ _ O
the _ _ O
code _ _ O
in _ _ O
a _ _ O
function _ _ O
executes _ _ O
in _ _ O
order _ _ O
, _ _ O
including _ _ O
local _ _ O
variable _ _ O
declarations _ _ O
. _ _ O
so _ _ O
on _ _ O
the _ _ O
first _ _ O
line _ _ O
, _ _ O
x _ _ O
has _ _ O
no _ _ O
value _ _ O
yet _ _ O
. _ _ O
there _ _ O
are _ _ O
two _ _ O
ways _ _ O
to _ _ O
solve _ _ O
this _ _ O
: _ _ O
1 _ _ O
. _ _ O
introduce _ _ O
a _ _ O
new _ _ O
scope _ _ O
that _ _ O
begins _ _ O
after _ _ O
each _ _ O
local _ _ O
declaration _ _ O
and _ _ O
ends _ _ O
at _ _ O
the _ _ O
enclosing _ _ O
close-brace _ _ O
; _ _ O
or _ _ O
2 _ _ O
. _ _ O
do _ _ O
the _ _ O
name _ _ O
resolution _ _ O
at _ _ O
the _ _ O
same _ _ O
time _ _ O
as _ _ O
scopebuilding _ _ O
, _ _ O
but _ _ O
only _ _ O
for _ _ O
the _ _ O
code _ _ O
within _ _ O
functions _ _ O
. _ _ O
17 _ _ O

Annotating _ _ O
the _ _ O
AST _ _ O
time _ _ O
check _ _ O
≤ _ _ O
55 _ _ O
18 _ _ O

Throwing _ _ O
arrows _ _ O
all _ _ O
over _ _ O
the _ _ O
place _ _ O
● _ _ O
we _ _ O
've _ _ O
now _ _ O
got _ _ O
two _ _ O
things _ _ O
that _ _ O
want _ _ O
to _ _ O
draw _ _ O
arrows _ _ O
all _ _ O
over _ _ O
the _ _ O
AST _ _ O
: _ _ O
o _ _ O
symbol _ _ O
tables _ _ O
want _ _ O
to _ _ O
point _ _ O
at _ _ O
declarations _ _ O
o _ _ O
name _ _ O
resolution _ _ O
wants _ _ O
to _ _ O
make _ _ O
AST _ _ O
nodes _ _ O
point _ _ O
at _ _ O
other _ _ O
ones _ _ O
● _ _ O
in _ _ O
a _ _ O
language _ _ O
like _ _ O
Java _ _ O
, _ _ O
" _ _ O
arrows _ _ O
" _ _ O
are _ _ O
object _ _ O
reference _ _ O
variables _ _ O
, _ _ O
and _ _ O
we _ _ O
might _ _ O
be _ _ O
tempted _ _ O
to _ _ O
start _ _ O
throwing _ _ O
those _ _ O
everywhere _ _ O
. _ _ O
o _ _ O
“ _ _ O
add _ _ O
a _ _ O
field _ _ O
to _ _ O
Identifier _ _ O
AST _ _ O
nodes _ _ O
so _ _ O
they _ _ O
can _ _ O
point _ _ O
at _ _ O
the _ _ O
declarations _ _ O
they _ _ O
refer _ _ O
to _ _ O
! _ _ O
” _ _ O
o _ _ O
“ _ _ O
add _ _ O
fields _ _ O
to _ _ O
{ _ _ O
Block _ _ O
Statement _ _ O
} _ _ O
AST _ _ O
nodes _ _ O
to _ _ O
hold _ _ O
scope _ _ O
info _ _ O
! _ _ O
” _ _ O
● _ _ O
OOP _ _ O
makes _ _ O
it _ _ O
really _ _ O
easy _ _ O
to _ _ O
start _ _ O
doing _ _ O
this _ _ O
… _ _ O
o _ _ O
but _ _ O
it _ _ O
's _ _ O
very _ _ O
difficult _ _ O
to _ _ O
stop _ _ O
once _ _ O
you _ _ O
've _ _ O
started _ _ O
, _ _ O
because _ _ O
it _ _ O
creates _ _ O
tight _ _ O
coupling _ _ O
between _ _ O
the _ _ O
two _ _ O
" _ _ O
ends _ _ O
" _ _ O
of _ _ O
the _ _ O
arrow _ _ O
. _ _ O
● _ _ O
since _ _ O
we _ _ O
'll _ _ O
only _ _ O
be _ _ O
adding _ _ O
more _ _ O
info _ _ O
from _ _ O
now _ _ O
on _ _ O
( _ _ O
typechecking _ _ O
! _ _ O
) _ _ O
, _ _ O
it _ _ O
makes _ _ O
sense _ _ O
to _ _ O
reconsider _ _ O
how _ _ O
we _ _ O
" _ _ O
add _ _ O
information _ _ O
" _ _ O
to _ _ O
the _ _ O
AST _ _ O
. _ _ O
19 _ _ O

Nametags _ _ O
, _ _ O
not _ _ O
arrows _ _ O
● _ _ O
first _ _ O
, _ _ O
let _ _ O
's _ _ O
make _ _ O
a _ _ O
small _ _ O
change _ _ O
to _ _ O
our _ _ O
AST _ _ O
. _ _ O
● _ _ O
every _ _ O
AST _ _ O
node _ _ O
is _ _ O
given _ _ O
a _ _ O
unique _ _ O
identifier _ _ O
when _ _ O
it _ _ O
is _ _ O
created _ _ O
. _ _ O
o _ _ O
this _ _ O
can _ _ O
be _ _ O
as _ _ O
simple _ _ O
as _ _ O
an _ _ O
int _ _ O
that _ _ O
's _ _ O
incremented _ _ O
for _ _ O
each _ _ O
node _ _ O
. _ _ O
f _ _ O
( _ _ O
y _ _ O
+ _ _ O
2 _ _ O
) _ _ O
this _ _ O
lets _ _ O
us _ _ O
create _ _ O
relationships _ _ O
without _ _ O
adding _ _ O
any _ _ O
arrows _ _ O
. _ _ O
CallExp _ _ O
: _ _ O
5 _ _ O
callee _ _ O
args _ _ O
[ _ _ O
] _ _ O
IdentExp _ _ O
: _ _ O
1 _ _ O
AddExp _ _ O
: _ _ O
4 _ _ O
name _ _ O
lhs _ _ O
" _ _ O
f _ _ O
" _ _ O
let _ _ O
's _ _ O
say _ _ O
the _ _ O
name _ _ O
f _ _ O
resolves _ _ O
to _ _ O
a _ _ O
function _ _ O
declared _ _ O
by _ _ O
node _ _ O
49 _ _ O
. _ _ O
then _ _ O
in _ _ O
our _ _ O
name _ _ O
resolution _ _ O
map _ _ O
, _ _ O
we _ _ O
add _ _ O
an _ _ O
entry _ _ O
with _ _ O
a _ _ O
key _ _ O
of _ _ O
1 _ _ O
and _ _ O
a _ _ O
value _ _ O
of _ _ O
49 _ _ O
. _ _ O
rhs _ _ O
IdentExp _ _ O
: _ _ O
2 _ _ O
IntExp _ _ O
: _ _ O
3 _ _ O
name _ _ O
value _ _ O
" _ _ O
y _ _ O
" _ _ O
2 _ _ O
20 _ _ O

Wh _ _ O
.. _ _ O
but _ _ O
… _ _ O
why _ _ O
? _ _ O
Why _ _ O
not _ _ O
just _ _ O
point _ _ O
to _ _ O
the _ _ O
node _ _ O
? _ _ O
● _ _ O
decoupling _ _ O
is _ _ O
good _ _ O
practice _ _ O
. _ _ O
it _ _ O
gives _ _ O
you _ _ O
a _ _ O
cleaner _ _ O
design _ _ O
. _ _ O
● _ _ O
we _ _ O
can _ _ O
add _ _ O
arbitrarily _ _ O
many _ _ O
pieces _ _ O
of _ _ O
data _ _ O
to _ _ O
an _ _ O
AST _ _ O
node _ _ O
, _ _ O
without _ _ O
having _ _ O
to _ _ O
change _ _ O
the _ _ O
AST _ _ O
node _ _ O
types _ _ O
at _ _ O
all _ _ O
! _ _ O
o _ _ O
we _ _ O
just _ _ O
add _ _ O
more _ _ O
maps _ _ O
that _ _ O
use _ _ O
the _ _ O
node _ _ O
IDs _ _ O
as _ _ O
keys _ _ O
. _ _ O
o _ _ O
this _ _ O
lets _ _ O
us _ _ O
add _ _ O
new _ _ O
compilation _ _ O
passes _ _ O
and _ _ O
modularize _ _ O
the _ _ O
compiler _ _ O
much _ _ O
more _ _ O
easily _ _ O
. _ _ O
● _ _ O
it _ _ O
improves _ _ O
compiler _ _ O
compile _ _ O
times _ _ O
by _ _ O
not _ _ O
requiring _ _ O
a _ _ O
recompile _ _ O
of _ _ O
the _ _ O
entire _ _ O
compiler _ _ O
every _ _ O
time _ _ O
you _ _ O
change _ _ O
the _ _ O
AST _ _ O
type _ _ O
. _ _ O
o _ _ O
and _ _ O
real _ _ O
compilers _ _ O
can _ _ O
be _ _ O
massive _ _ O
, _ _ O
so _ _ O
this _ _ O
is _ _ O
a _ _ O
big _ _ O
timesaver _ _ O
! _ _ O
● _ _ O
it _ _ O
can _ _ O
improve _ _ O
performance _ _ O
by _ _ O
exploiting _ _ O
physical _ _ O
locality _ _ O
. _ _ O
o _ _ O
the _ _ O
cache _ _ O
in _ _ O
your _ _ O
CPU _ _ O
likes _ _ O
arrays _ _ O
and _ _ O
small _ _ O
structs _ _ O
. _ _ O
o _ _ O
the _ _ O
AST _ _ O
node _ _ O
struct _ _ O
stays _ _ O
small _ _ O
, _ _ O
meaning _ _ O
it _ _ O
'll _ _ O
likely _ _ O
fit _ _ O
into _ _ O
cache _ _ O
. _ _ O
o _ _ O
associated _ _ O
data _ _ O
can _ _ O
even _ _ O
be _ _ O
stored _ _ O
in _ _ O
a _ _ O
contiguous _ _ O
array _ _ O
. _ _ O
21 _ _ O

Another _ _ O
reason _ _ O
● _ _ O
we _ _ O
are _ _ O
also _ _ O
nudged _ _ O
towards _ _ O
this _ _ O
design _ _ O
by _ _ O
Rust _ _ O
. _ _ O
in _ _ O
Java _ _ O
, _ _ O
each _ _ O
object _ _ O
reference _ _ O
is _ _ O
an _ _ O
arrow _ _ O
, _ _ O
and _ _ O
there _ _ O
are _ _ O
no _ _ O
restrictions _ _ O
on _ _ O
them _ _ O
. _ _ O
class _ _ O
Node _ _ O
{ _ _ O
Node _ _ O
[ _ _ O
] _ _ O
others _ _ O
; _ _ O
} _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
in _ _ O
Rust _ _ O
, _ _ O
there _ _ O
are _ _ O
multiple _ _ O
kinds _ _ O
of _ _ O
pointers _ _ O
, _ _ O
but _ _ O
Box _ _ O
can _ _ O
not _ _ O
be _ _ O
used _ _ O
to _ _ O
make _ _ O
cycles _ _ O
. _ _ O
struct _ _ O
Node _ _ O
{ _ _ O
others _ _ O
: _ _ O
Vec _ _ O
< _ _ O
Box _ _ O
< _ _ O
Node _ _ O
> _ _ O
> _ _ O
} _ _ O
1 _ _ O
5 _ _ O
4 _ _ O
2 _ _ O
3 _ _ O
5 _ _ O
4 _ _ O
this _ _ O
" _ _ O
no _ _ O
cycles _ _ O
allowed _ _ O
" _ _ O
thing _ _ O
is _ _ O
a _ _ O
central _ _ O
part _ _ O
of _ _ O
Rust _ _ O
's _ _ O
ownership _ _ O
, _ _ O
borrowing _ _ O
, _ _ O
and _ _ O
memory _ _ O
safety _ _ O
semantics _ _ O
. _ _ O
22 _ _ O

What _ _ O
? _ _ O
? _ _ O
! _ _ O
? _ _ O
You _ _ O
ca _ _ O
n't _ _ O
have _ _ O
cycles _ _ O
in _ _ O
Rust _ _ O
? _ _ O
● _ _ O
well _ _ O
, _ _ O
you _ _ O
can _ _ O
, _ _ O
but _ _ O
it _ _ O
's _ _ O
discouraged _ _ O
by _ _ O
the _ _ O
language _ _ O
and _ _ O
libraries _ _ O
. _ _ O
o _ _ O
Rc _ _ O
< _ _ O
T _ _ O
> _ _ O
is _ _ O
another _ _ O
kind _ _ O
of _ _ O
pointer _ _ O
that _ _ O
, _ _ O
with _ _ O
some _ _ O
care _ _ O
, _ _ O
can _ _ O
let _ _ O
you _ _ O
represent _ _ O
certain _ _ O
kinds _ _ O
of _ _ O
cyclical _ _ O
data _ _ O
structures _ _ O
. _ _ O
● _ _ O
it _ _ O
's _ _ O
not _ _ O
the _ _ O
Rust _ _ O
designer _ _ O
's _ _ O
fault _ _ O
that _ _ O
they _ _ O
made _ _ O
it _ _ O
harder _ _ O
to _ _ O
represent _ _ O
cyclical _ _ O
data _ _ O
structures _ _ O
. _ _ O
o _ _ O
it _ _ O
's _ _ O
that _ _ O
cyclical _ _ O
data _ _ O
structures _ _ O
are _ _ O
just _ _ O
weird _ _ O
, _ _ O
and _ _ O
a _ _ O
lot _ _ O
of _ _ O
other _ _ O
languages _ _ O
do _ _ O
n't _ _ O
really _ _ O
make _ _ O
that _ _ O
fact _ _ O
obvious _ _ O
. _ _ O
o _ _ O
they _ _ O
either _ _ O
hide _ _ O
it _ _ O
, _ _ O
or _ _ O
do _ _ O
n’t _ _ O
give _ _ O
you _ _ O
the _ _ O
tools _ _ O
to _ _ O
manage _ _ O
it _ _ O
! _ _ O
● _ _ O
this _ _ O
restriction _ _ O
does _ _ O
give _ _ O
Rust _ _ O
some _ _ O
great _ _ O
advantages _ _ O
in _ _ O
memory _ _ O
safety _ _ O
and _ _ O
multithreaded _ _ O
code _ _ O
correctness _ _ O
! _ _ O
o _ _ O
which _ _ O
is _ _ O
kind _ _ O
of _ _ O
Rust _ _ O
's _ _ O
whole _ _ O
deal _ _ O
● _ _ O
but _ _ O
it _ _ O
does _ _ O
mean _ _ O
you _ _ O
have _ _ O
to _ _ O
stretch _ _ O
your _ _ O
mind _ _ O
a _ _ O
little _ _ O
. _ _ O
o _ _ O
and _ _ O
interestingly _ _ O
, _ _ O
many _ _ O
of _ _ O
the _ _ O
solutions _ _ O
around _ _ O
this _ _ O
restriction _ _ O
end _ _ O
up _ _ O
being _ _ O
faster _ _ O
and _ _ O
easier _ _ O
to _ _ O
reason _ _ O
about _ _ O
. _ _ O
23 _ _ O

Implementation _ _ O
Details _ _ O
time _ _ O
check _ _ O
≤ _ _ O
85 _ _ O
24 _ _ O

Well _ _ O
Actually _ _ O
● _ _ O
in _ _ O
practice _ _ O
, _ _ O
it _ _ O
’s _ _ O
a _ _ O
good _ _ O
idea _ _ O
to _ _ O
represent _ _ O
symbols _ _ O
as _ _ O
objects _ _ O
. _ _ O
class _ _ O
A _ _ O
{ _ _ O
static _ _ O
int _ _ O
x _ _ O
= _ _ O
5 _ _ O
; _ _ O
static _ _ O
void _ _ O
main _ _ O
( _ _ O
) _ _ O
{ _ _ O
foo _ _ O
( _ _ O
x _ _ O
) _ _ O
; _ _ O
} _ _ O
static _ _ O
void _ _ O
foo _ _ O
( _ _ O
int _ _ O
y _ _ O
) _ _ O
{ _ _ O
S.o.println _ _ O
( _ _ O
y _ _ O
) _ _ O
; _ _ O
} _ _ O
} _ _ O
ID _ _ O
AST _ _ O
Scope _ _ O
Name _ _ O
Kind _ _ O
… _ _ O
1 _ _ O
3 _ _ O
0 _ _ O
A _ _ O
class _ _ O
… _ _ O
2 _ _ O
7 _ _ O
1 _ _ O
x _ _ O
static _ _ O
var _ _ O
… _ _ O
3 _ _ O
12 _ _ O
1 _ _ O
main _ _ O
static _ _ O
func _ _ O
… _ _ O
4 _ _ O
22 _ _ O
1 _ _ O
foo _ _ O
static _ _ O
func _ _ O
... _ _ O
5 _ _ O
24 _ _ O
3 _ _ O
y _ _ O
local _ _ O
var _ _ O
… _ _ O
… _ _ O
… _ _ O
… _ _ O
… _ _ O
… _ _ O
… _ _ O
every _ _ O
name _ _ O
declared _ _ O
in _ _ O
the _ _ O
program _ _ O
gets _ _ O
its _ _ O
own _ _ O
symbol _ _ O
object _ _ O
with _ _ O
a _ _ O
unique _ _ O
symbol _ _ O
ID _ _ O
. _ _ O
extracting _ _ O
this _ _ O
info _ _ O
from _ _ O
the _ _ O
AST _ _ O
is _ _ O
time-consuming _ _ O
, _ _ O
so _ _ O
we _ _ O
only _ _ O
do _ _ O
it _ _ O
once _ _ O
. _ _ O
these _ _ O
are _ _ O
what _ _ O
the _ _ O
symbol _ _ O
tables _ _ O
actually _ _ O
refer _ _ O
to _ _ O
. _ _ O
25 _ _ O

Bidirectionally _ _ O
linked _ _ O
scopes _ _ O
● _ _ O
an _ _ O
easy _ _ O
way _ _ O
to _ _ O
solve _ _ O
this _ _ O
is _ _ O
to _ _ O
keep _ _ O
all _ _ O
scopes _ _ O
in _ _ O
a _ _ O
vector _ _ O
, _ _ O
and _ _ O
have _ _ O
them _ _ O
refer _ _ O
to _ _ O
each _ _ O
other _ _ O
by _ _ O
their _ _ O
index _ _ O
into _ _ O
the _ _ O
vector _ _ O
. _ _ O
< _ _ O
global _ _ O
scope _ _ O
> _ _ O
parent _ _ O
: _ _ O
None _ _ O
children _ _ O
: _ _ O
[ _ _ O
1 _ _ O
] _ _ O
symbols _ _ O
: _ _ O
" _ _ O
A _ _ O
" _ _ O
1 _ _ O
" _ _ O
System _ _ O
" _ _ O
33 _ _ O
index _ _ O
: _ _ O
0 _ _ O
A _ _ O
's _ _ O
scope _ _ O
parent _ _ O
: _ _ O
Some _ _ O
( _ _ O
0 _ _ O
) _ _ O
children _ _ O
: _ _ O
[ _ _ O
2 _ _ O
, _ _ O
3 _ _ O
] _ _ O
symbols _ _ O
: _ _ O
" _ _ O
x _ _ O
" _ _ O
2 _ _ O
" _ _ O
main _ _ O
" _ _ O
3 _ _ O
" _ _ O
foo _ _ O
" _ _ O
4 _ _ O
1 _ _ O
this _ _ O
neatly _ _ O
dodges _ _ O
the _ _ O
" _ _ O
no _ _ O
cycles _ _ O
" _ _ O
rule _ _ O
, _ _ O
and _ _ O
in _ _ O
practice _ _ O
is _ _ O
n’t _ _ O
much _ _ O
harder _ _ O
to _ _ O
use _ _ O
than _ _ O
direct _ _ O
pointers _ _ O
( _ _ O
Box _ _ O
< _ _ O
T _ _ O
> _ _ O
) _ _ O
. _ _ O
… _ _ O
2 _ _ O
… _ _ O
3 _ _ O
26 _ _ O

The _ _ O
declaration _ _ O
and _ _ O
use _ _ O
maps _ _ O
● _ _ O
since _ _ O
we _ _ O
now _ _ O
represent _ _ O
symbols _ _ O
as _ _ O
their _ _ O
own _ _ O
“ _ _ O
thing _ _ O
, _ _ O
” _ _ O
the _ _ O
declaration _ _ O
map _ _ O
maps _ _ O
from _ _ O
AST _ _ O
nodes _ _ O
that _ _ O
declare _ _ O
a _ _ O
symbol _ _ O
, _ _ O
to _ _ O
that _ _ O
symbol _ _ O
. _ _ O
● _ _ O
the _ _ O
use _ _ O
map _ _ O
maps _ _ O
from _ _ O
AST _ _ O
nodes _ _ O
to _ _ O
the _ _ O
symbol _ _ O
they _ _ O
use _ _ O
. _ _ O
int _ _ O
x _ _ O
= _ _ O
0 _ _ O
; _ _ O
x _ _ O
= _ _ O
x _ _ O
+ _ _ O
1 _ _ O
; _ _ O
println _ _ O
( _ _ O
x _ _ O
) _ _ O
; _ _ O
x _ _ O
= _ _ O
f _ _ O
( _ _ O
) _ _ O
; _ _ O
return _ _ O
x _ _ O
; _ _ O
the _ _ O
actual _ _ O
maps _ _ O
map _ _ O
from _ _ O
Node _ _ O
IDs _ _ O
to _ _ O
Symbol _ _ O
IDs _ _ O
. _ _ O
ID _ _ O
AST _ _ O
… _ _ O
… _ _ O
… _ _ O
17 _ _ O
54 _ _ O
… _ _ O
… _ _ O
Decls _ _ O
Scope _ _ O
Name _ _ O
Kind _ _ O
… _ _ O
… _ _ O
… _ _ O
… _ _ O
3 _ _ O
x _ _ O
local _ _ O
var _ _ O
… _ _ O
… _ _ O
… _ _ O
… _ _ O
… _ _ O
Uses _ _ O
AST _ _ O
Sym _ _ O
AST _ _ O
Sym _ _ O
74 _ _ O
17 _ _ O
76 _ _ O
17 _ _ O
… _ _ O
… _ _ O
78 _ _ O
17 _ _ O
… _ _ O
… _ _ O
27 _ _ O

Bundling _ _ O
it _ _ O
all _ _ O
up _ _ O
● _ _ O
the _ _ O
symbols _ _ O
, _ _ O
scope _ _ O
tree _ _ O
, _ _ O
declaration _ _ O
map _ _ O
, _ _ O
and _ _ O
use _ _ O
map _ _ O
are _ _ O
all _ _ O
packaged _ _ O
into _ _ O
one _ _ O
big _ _ O
object _ _ O
, _ _ O
the _ _ O
name _ _ O
context _ _ O
. _ _ O
● _ _ O
this _ _ O
can _ _ O
be _ _ O
used _ _ O
in _ _ O
later _ _ O
phases _ _ O
of _ _ O
the _ _ O
compiler _ _ O
! _ _ O
AST _ _ O
Name _ _ O
checking _ _ O
name _ _ O
context _ _ O
AST _ _ O
Type _ _ O
checking _ _ O
type _ _ O
context _ _ O
… _ _ O
? _ _ O
each _ _ O
phase _ _ O
of _ _ O
semantic _ _ O
analysis _ _ O
generates _ _ O
more _ _ O
information _ _ O
about _ _ O
the _ _ O
program _ _ O
which _ _ O
later _ _ O
phases _ _ O
use _ _ O
. _ _ O
for _ _ O
now _ _ O
, _ _ O
the _ _ O
AST _ _ O
will _ _ O
remain _ _ O
the _ _ O
central _ _ O
representation _ _ O
of _ _ O
the _ _ O
program _ _ O
, _ _ O
but _ _ O
that _ _ O
may _ _ O
change _ _ O
later _ _ O
in _ _ O
compilation _ _ O
… _ _ O
28 _ _ O

Building _ _ O
the _ _ O
scope _ _ O
tree _ _ O
and _ _ O
symbol _ _ O
tables _ _ O
● _ _ O
the _ _ O
actual _ _ O
algorithm _ _ O
for _ _ O
building _ _ O
the _ _ O
scope _ _ O
tree _ _ O
is _ _ O
surprisingly _ _ O
simple _ _ O
. _ _ O
● _ _ O
the _ _ O
idea _ _ O
is _ _ O
like _ _ O
this _ _ O
: _ _ O
o _ _ O
we _ _ O
recursively _ _ O
visit _ _ O
each _ _ O
node _ _ O
in _ _ O
the _ _ O
AST _ _ O
. _ _ O
o _ _ O
if _ _ O
we _ _ O
take _ _ O
a _ _ O
function _ _ O
declaration _ _ O
node _ _ O
as _ _ O
an _ _ O
example _ _ O
… _ _ O
▪ _ _ O
it _ _ O
will _ _ O
create _ _ O
a _ _ O
new _ _ O
scope _ _ O
as _ _ O
a _ _ O
child _ _ O
of _ _ O
the _ _ O
current _ _ O
scope _ _ O
… _ _ O
▪ _ _ O
then _ _ O
visit _ _ O
its _ _ O
children _ _ O
( _ _ O
arguments _ _ O
and _ _ O
code _ _ O
) _ _ O
within _ _ O
that _ _ O
scope _ _ O
. _ _ O
o _ _ O
something _ _ O
similar _ _ O
happens _ _ O
for _ _ O
{ _ _ O
Block _ _ O
Statements _ _ O
} _ _ O
, _ _ O
classes _ _ O
etc _ _ O
. _ _ O
o _ _ O
and _ _ O
when _ _ O
we _ _ O
see _ _ O
a _ _ O
declaration _ _ O
AST _ _ O
node _ _ O
, _ _ O
we _ _ O
insert _ _ O
a _ _ O
symbol _ _ O
into _ _ O
the _ _ O
current _ _ O
scope _ _ O
. _ _ O
▪ _ _ O
this _ _ O
also _ _ O
inserts _ _ O
an _ _ O
entry _ _ O
into _ _ O
the _ _ O
declaration _ _ O
map _ _ O
. _ _ O
● _ _ O
and _ _ O
that _ _ O
’s _ _ O
about _ _ O
it _ _ O
! _ _ O
o _ _ O
there _ _ O
’s _ _ O
the _ _ O
“ _ _ O
forward _ _ O
reference _ _ O
” _ _ O
thing _ _ O
we _ _ O
talked _ _ O
about _ _ O
, _ _ O
and _ _ O
the _ _ O
stuff _ _ O
about _ _ O
local _ _ O
variables _ _ O
, _ _ O
but _ _ O
those _ _ O
are _ _ O
just _ _ O
tweaks _ _ O
to _ _ O
this _ _ O
algorithm _ _ O
. _ _ O
29 _ _ O

Name _ _ O
resolution _ _ O
and _ _ O
building _ _ O
the _ _ O
use _ _ O
map _ _ O
● _ _ O
finally _ _ O
, _ _ O
name _ _ O
resolution _ _ O
is _ _ O
another _ _ O
recursive _ _ O
AST _ _ O
visit _ _ O
. _ _ O
● _ _ O
if _ _ O
this _ _ O
is _ _ O
done _ _ O
simultaneously _ _ O
with _ _ O
building _ _ O
the _ _ O
scope _ _ O
tree _ _ O
… _ _ O
o _ _ O
it _ _ O
’s _ _ O
very _ _ O
simple _ _ O
: _ _ O
whenever _ _ O
you _ _ O
see _ _ O
an _ _ O
Identifier _ _ O
AST _ _ O
node _ _ O
, _ _ O
you _ _ O
perform _ _ O
name _ _ O
resolution _ _ O
starting _ _ O
at _ _ O
the _ _ O
current _ _ O
scope _ _ O
. _ _ O
o _ _ O
if _ _ O
the _ _ O
name _ _ O
exists _ _ O
, _ _ O
add _ _ O
an _ _ O
entry _ _ O
to _ _ O
the _ _ O
use _ _ O
map _ _ O
. _ _ O
o _ _ O
if _ _ O
it _ _ O
does _ _ O
n’t _ _ O
, _ _ O
it _ _ O
’s _ _ O
an _ _ O
error _ _ O
. _ _ O
● _ _ O
if _ _ O
you _ _ O
built _ _ O
the _ _ O
scope _ _ O
tree _ _ O
in _ _ O
one _ _ O
pass _ _ O
and _ _ O
then _ _ O
do _ _ O
name _ _ O
resolution _ _ O
in _ _ O
a _ _ O
second _ _ O
pass _ _ O
after _ _ O
it _ _ O
… _ _ O
o _ _ O
there _ _ O
’s _ _ O
some _ _ O
bookkeeping _ _ O
to _ _ O
make _ _ O
sure _ _ O
you _ _ O
start _ _ O
the _ _ O
name _ _ O
resolution _ _ O
in _ _ O
the _ _ O
correct _ _ O
scope _ _ O
, _ _ O
but _ _ O
it _ _ O
’s _ _ O
otherwise _ _ O
the _ _ O
same _ _ O
. _ _ O
● _ _ O
and _ _ O
at _ _ O
the _ _ O
end _ _ O
, _ _ O
you _ _ O
now _ _ O
have _ _ O
all _ _ O
your _ _ O
data _ _ O
structures _ _ O
built _ _ O
and _ _ O
name-checking _ _ O
is _ _ O
complete _ _ O
! _ _ O
o _ _ O
name-checking _ _ O
is _ _ O
the _ _ O
easiest _ _ O
semantic _ _ O
analysis _ _ O
pass _ _ O
, _ _ O
and _ _ O
things _ _ O
only _ _ O
get _ _ O
harder _ _ O
from _ _ O
here _ _ O
(: _ _ O
30 _ _ O



