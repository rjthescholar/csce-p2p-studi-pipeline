unlabeled|cs1622|lec12
-DOCSTART- -X- -X- O

Dynamic _ _ O
Memory _ _ O
Management _ _ O
CS _ _ O
1622 _ _ O
Jarrett _ _ O
Billingsley _ _ O

Class _ _ O
Announcements _ _ O
‚óè _ _ O
we _ _ O
're _ _ O
gon _ _ O
na _ _ O
talk _ _ O
about _ _ O
some _ _ O
stuff _ _ O
a _ _ O
bit _ _ O
abstractly _ _ O
today _ _ O
o _ _ O
but _ _ O
I _ _ O
think _ _ O
it _ _ O
's _ _ O
a _ _ O
really _ _ O
important _ _ O
topic _ _ O
o _ _ O
dynamic _ _ O
memory _ _ O
management _ _ O
has _ _ O
a _ _ O
H _ _ O
U _ _ O
G _ _ O
E _ _ O
impact _ _ O
on _ _ O
language _ _ O
and _ _ O
compiler _ _ O
design _ _ O
o _ _ O
and _ _ O
it _ _ O
will _ _ O
also _ _ O
be _ _ O
important _ _ O
to _ _ O
know _ _ O
about _ _ O
this _ _ O
for _ _ O
when _ _ O
we _ _ O
start _ _ O
talking _ _ O
about _ _ O
code _ _ O
generation _ _ O
and _ _ O
the _ _ O
runtime _ _ O
library _ _ O
! _ _ O
2 _ _ O

Allocation _ _ O
, _ _ O
Deallocation _ _ O
, _ _ O
Lifetime _ _ O
, _ _ O
and _ _ O
Ownership _ _ O
3 _ _ O

Making _ _ O
room _ _ O
‚óè _ _ O
every _ _ O
value _ _ O
in _ _ O
your _ _ O
program _ _ O
takes _ _ O
up _ _ O
space _ _ O
in _ _ O
memory _ _ O
. _ _ O
‚óè _ _ O
allocation _ _ O
sets _ _ O
aside _ _ O
a _ _ O
piece _ _ O
of _ _ O
memory _ _ O
as _ _ O
a _ _ O
value _ _ O
's _ _ O
" _ _ O
home _ _ O
. _ _ O
" _ _ O
let _ _ O
g _ _ O
= _ _ O
10 _ _ O
; _ _ O
let _ _ O
h _ _ O
= _ _ O
20 _ _ O
; _ _ O
fn _ _ O
main _ _ O
( _ _ O
) _ _ O
{ _ _ O
g _ _ O
= _ _ O
g _ _ O
+ _ _ O
h _ _ O
; _ _ O
} _ _ O
global _ _ O
variables _ _ O
are _ _ O
the _ _ O
easiest _ _ O
to _ _ O
allocate _ _ O
, _ _ O
because _ _ O
the _ _ O
compiler _ _ O
knows _ _ O
how _ _ O
many _ _ O
globals _ _ O
there _ _ O
are _ _ O
. _ _ O
it _ _ O
does _ _ O
static _ _ O
allocation _ _ O
: _ _ O
it _ _ O
gives _ _ O
each _ _ O
global _ _ O
a _ _ O
unique _ _ O
location _ _ O
, _ _ O
which _ _ O
is _ _ O
encoded _ _ O
in _ _ O
the _ _ O
output _ _ O
machine _ _ O
code _ _ O
. _ _ O
static _ _ O
allocation _ _ O
is _ _ O
also _ _ O
used _ _ O
for _ _ O
certain _ _ O
kinds _ _ O
of _ _ O
constants _ _ O
, _ _ O
like _ _ O
" _ _ O
quoted _ _ O
string _ _ O
literals _ _ O
" _ _ O
. _ _ O
4 _ _ O

But _ _ O
that _ _ O
's _ _ O
boring _ _ O
‚óè _ _ O
what _ _ O
about _ _ O
locals _ _ O
? _ _ O
they _ _ O
" _ _ O
appear _ _ O
" _ _ O
and _ _ O
" _ _ O
disappear _ _ O
" _ _ O
with _ _ O
function _ _ O
calls _ _ O
. _ _ O
‚óè _ _ O
that _ _ O
means _ _ O
we _ _ O
have _ _ O
to _ _ O
do _ _ O
dynamic _ _ O
allocation _ _ O
: _ _ O
we _ _ O
come _ _ O
up _ _ O
with _ _ O
the _ _ O
locations _ _ O
of _ _ O
variables _ _ O
at _ _ O
runtime _ _ O
. _ _ O
fn _ _ O
r _ _ O
( _ _ O
x _ _ O
: _ _ O
int _ _ O
) _ _ O
{ _ _ O
this _ _ O
is _ _ O
easier _ _ O
than _ _ O
it _ _ O
sounds _ _ O
at _ _ O
if _ _ O
x _ _ O
> _ _ O
1 _ _ O
{ _ _ O
first _ _ O
, _ _ O
because _ _ O
every _ _ O
function _ _ O
has _ _ O
a _ _ O
fixed _ _ O
number _ _ O
of _ _ O
variables _ _ O
. _ _ O
return _ _ O
x _ _ O
+ _ _ O
r _ _ O
( _ _ O
x-1 _ _ O
) _ _ O
; _ _ O
} _ _ O
else _ _ O
{ _ _ O
return _ _ O
x _ _ O
; _ _ O
because _ _ O
of _ _ O
how _ _ O
function _ _ O
calls _ _ O
work _ _ O
, _ _ O
the _ _ O
variables _ _ O
can _ _ O
be _ _ O
allocated _ _ O
using _ _ O
a _ _ O
stack _ _ O
. _ _ O
} _ _ O
} _ _ O
so _ _ O
, _ _ O
each _ _ O
local _ _ O
variable _ _ O
gets _ _ O
a _ _ O
statically-determined _ _ O
location _ _ O
within _ _ O
the _ _ O
stack _ _ O
frame _ _ O
, _ _ O
relative _ _ O
to _ _ O
the _ _ O
sp _ _ O
. _ _ O
5 _ _ O

Deallocation _ _ O
‚óè _ _ O
memory _ _ O
is _ _ O
a _ _ O
finite _ _ O
resource _ _ O
. _ _ O
we _ _ O
have _ _ O
to _ _ O
reuse _ _ O
it _ _ O
when _ _ O
we _ _ O
can _ _ O
. _ _ O
‚óè _ _ O
deallocation _ _ O
marks _ _ O
a _ _ O
previously-used _ _ O
location _ _ O
as _ _ O
ready _ _ O
for _ _ O
reuse _ _ O
. _ _ O
stacks _ _ O
are _ _ O
natural _ _ O
recyclers _ _ O
. _ _ O
3 _ _ O
3 _ _ O
3 _ _ O
3 _ _ O
10 _ _ O
10 _ _ O
10 _ _ O
10 _ _ O
as _ _ O
we _ _ O
push _ _ O
values _ _ O
, _ _ O
they _ _ O
are _ _ O
placed _ _ O
in _ _ O
new _ _ O
locations _ _ O
. _ _ O
99 _ _ O
99 _ _ O
433 _ _ O
4 _ _ O
4 _ _ O
4 _ _ O
163 _ _ O
163 _ _ O
163 _ _ O
when _ _ O
they _ _ O
're _ _ O
popped _ _ O
, _ _ O
the _ _ O
values _ _ O
are _ _ O
deallocated _ _ O
, _ _ O
but _ _ O
the _ _ O
locations _ _ O
stick _ _ O
around _ _ O
‚Ä¶ _ _ O
and _ _ O
can _ _ O
be _ _ O
easily _ _ O
reused _ _ O
by _ _ O
the _ _ O
next _ _ O
push _ _ O
. _ _ O
6 _ _ O

Lifetime _ _ O
and _ _ O
Ownership _ _ O
‚óè _ _ O
a _ _ O
value _ _ O
's _ _ O
lifetime _ _ O
is _ _ O
the _ _ O
span _ _ O
of _ _ O
time _ _ O
from _ _ O
allocation _ _ O
to _ _ O
deallocation _ _ O
. _ _ O
‚óè _ _ O
its _ _ O
owner _ _ O
is _ _ O
what _ _ O
decides _ _ O
when _ _ O
it _ _ O
's _ _ O
safe _ _ O
to _ _ O
deallocate _ _ O
it _ _ O
. _ _ O
let _ _ O
g _ _ O
= _ _ O
10 _ _ O
; _ _ O
fn _ _ O
main _ _ O
( _ _ O
) _ _ O
{ _ _ O
let _ _ O
x _ _ O
= _ _ O
g _ _ O
+ _ _ O
5 _ _ O
; _ _ O
println_i _ _ O
( _ _ O
x _ _ O
) _ _ O
; _ _ O
} _ _ O
global _ _ O
variables _ _ O
are _ _ O
owned _ _ O
by _ _ O
the _ _ O
program _ _ O
: _ _ O
they _ _ O
ca _ _ O
n't _ _ O
be _ _ O
deallocated _ _ O
until _ _ O
the _ _ O
program _ _ O
ends _ _ O
. _ _ O
local _ _ O
variables _ _ O
are _ _ O
owned _ _ O
by _ _ O
the _ _ O
enclosing _ _ O
function _ _ O
: _ _ O
they _ _ O
can _ _ O
be _ _ O
deallocated _ _ O
when _ _ O
it _ _ O
returns _ _ O
. _ _ O
‚Ä¶ _ _ O
but _ _ O
this _ _ O
is _ _ O
n't _ _ O
the _ _ O
whole _ _ O
story _ _ O
, _ _ O
is _ _ O
it _ _ O
? _ _ O
7 _ _ O

Indirection _ _ O
time _ _ O
check _ _ O
< _ _ O
20 _ _ O
min _ _ O
8 _ _ O

Indirection _ _ O
, _ _ O
the _ _ O
concept _ _ O
‚óè _ _ O
indirection _ _ O
means _ _ O
using _ _ O
a _ _ O
symbol _ _ O
to _ _ O
stand _ _ O
in _ _ O
for _ _ O
something _ _ O
, _ _ O
instead _ _ O
of _ _ O
using _ _ O
that _ _ O
thing _ _ O
directly _ _ O
. _ _ O
o _ _ O
yes _ _ O
, _ _ O
this _ _ O
is _ _ O
really _ _ O
abstract _ _ O
, _ _ O
but _ _ O
it _ _ O
's _ _ O
an _ _ O
abstract _ _ O
concept _ _ O
! _ _ O
linguistic _ _ O
symbols _ _ O
‚Äì _ _ O
spoken _ _ O
or _ _ O
written _ _ O
‚Äì _ _ O
all _ _ O
stand _ _ O
in _ _ O
for _ _ O
something _ _ O
else _ _ O
. _ _ O
üëâ _ _ O
if _ _ O
I _ _ O
point _ _ O
at _ _ O
a _ _ O
cat _ _ O
, _ _ O
my _ _ O
finger _ _ O
is _ _ O
the _ _ O
symbol _ _ O
which _ _ O
refers _ _ O
to _ _ O
the _ _ O
cat _ _ O
. _ _ O
if _ _ O
I _ _ O
want _ _ O
to _ _ O
refer _ _ O
to _ _ O
houses _ _ O
on _ _ O
my _ _ O
street _ _ O
, _ _ O
I _ _ O
can _ _ O
refer _ _ O
to _ _ O
them _ _ O
by _ _ O
number _ _ O
. _ _ O
121 _ _ O
123 _ _ O
125 _ _ O
127 _ _ O
129 _ _ O
9 _ _ O

It _ _ O
works _ _ O
for _ _ O
houses _ _ O
, _ _ O
and _ _ O
it _ _ O
works _ _ O
for _ _ O
objects _ _ O
‚óè _ _ O
if _ _ O
I _ _ O
have _ _ O
a _ _ O
program _ _ O
which _ _ O
deals _ _ O
with _ _ O
very _ _ O
large _ _ O
objects _ _ O
( _ _ O
kB-MB _ _ O
? _ _ O
) _ _ O
, _ _ O
o _ _ O
I _ _ O
can _ _ O
put _ _ O
them _ _ O
in _ _ O
an _ _ O
array _ _ O
and _ _ O
access _ _ O
them _ _ O
by _ _ O
their _ _ O
index _ _ O
. _ _ O
64kB _ _ O
64kB _ _ O
64kB _ _ O
64kB _ _ O
64kB _ _ O
64kB _ _ O
64kB _ _ O
0 _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
5 _ _ O
6 _ _ O
the _ _ O
number _ _ O
3 _ _ O
is _ _ O
small _ _ O
enough _ _ O
to _ _ O
fit _ _ O
into _ _ O
a _ _ O
register _ _ O
. _ _ O
of _ _ O
course _ _ O
, _ _ O
memory _ _ O
itself _ _ O
is _ _ O
an _ _ O
array _ _ O
( _ _ O
of _ _ O
bytes _ _ O
) _ _ O
, _ _ O
so _ _ O
we _ _ O
can _ _ O
refer _ _ O
to _ _ O
anything _ _ O
in _ _ O
memory _ _ O
by _ _ O
its _ _ O
index _ _ O
: _ _ O
its _ _ O
memory _ _ O
address _ _ O
. _ _ O
01 _ _ O
00 _ _ O
00 _ _ O
80 _ _ O
F8 _ _ O
FF _ _ O
FF _ _ O
8000 _ _ O
8001 _ _ O
8002 _ _ O
8003 _ _ O
8004 _ _ O
8005 _ _ O
8006 _ _ O
10 _ _ O

Pointers _ _ O
and _ _ O
references _ _ O
‚óè _ _ O
programs _ _ O
manipulate _ _ O
values _ _ O
, _ _ O
like _ _ O
ints _ _ O
, _ _ O
strings _ _ O
, _ _ O
objects _ _ O
, _ _ O
etc _ _ O
. _ _ O
‚óè _ _ O
a _ _ O
pointer _ _ O
is _ _ O
a _ _ O
value _ _ O
which _ _ O
is _ _ O
the _ _ O
memory _ _ O
address _ _ O
of _ _ O
another _ _ O
value _ _ O
. _ _ O
o _ _ O
" _ _ O
reference _ _ O
" _ _ O
is _ _ O
another _ _ O
name _ _ O
for _ _ O
a _ _ O
pointer _ _ O
, _ _ O
with _ _ O
a _ _ O
" _ _ O
safer _ _ O
" _ _ O
connotation _ _ O
. _ _ O
let _ _ O
x _ _ O
= _ _ O
1 _ _ O
; _ _ O
07FF8FFC _ _ O
let _ _ O
y _ _ O
= _ _ O
5 _ _ O
; _ _ O
07FF8FF8 _ _ O
let _ _ O
r _ _ O
= _ _ O
& _ _ O
x _ _ O
; _ _ O
07FF8FF4 _ _ O
00000001 _ _ O
00000005 _ _ O
07FF8FFC _ _ O
we _ _ O
say _ _ O
, _ _ O
" _ _ O
r _ _ O
points _ _ O
to _ _ O
x. _ _ O
" _ _ O
r _ _ O
is _ _ O
the _ _ O
pointer _ _ O
, _ _ O
and _ _ O
x _ _ O
is _ _ O
its _ _ O
referent _ _ O
. _ _ O
when _ _ O
you _ _ O
run _ _ O
this _ _ O
code _ _ O
, _ _ O
the _ _ O
variables _ _ O
might _ _ O
look _ _ O
something _ _ O
like _ _ O
this _ _ O
in _ _ O
memory _ _ O
. _ _ O
if _ _ O
I _ _ O
now _ _ O
write _ _ O
this _ _ O
: _ _ O
let _ _ O
z _ _ O
= _ _ O
* _ _ O
r _ _ O
; _ _ O
the _ _ O
asterisk _ _ O
follows _ _ O
the _ _ O
arrow _ _ O
from _ _ O
r _ _ O
to _ _ O
x _ _ O
, _ _ O
and _ _ O
loads _ _ O
the _ _ O
value _ _ O
stored _ _ O
there _ _ O
. _ _ O
so _ _ O
z _ _ O
will _ _ O
be _ _ O
‚Ä¶ _ _ O
? _ _ O
11 _ _ O

Dereferencing _ _ O
‚óè _ _ O
dereferencing _ _ O
means _ _ O
‚Äú _ _ O
accessing _ _ O
the _ _ O
referent _ _ O
of _ _ O
a _ _ O
reference _ _ O
. _ _ O
‚Äù _ _ O
‚óè _ _ O
it _ _ O
does _ _ O
not _ _ O
mean _ _ O
‚Äú _ _ O
to _ _ O
deallocate _ _ O
a _ _ O
piece _ _ O
of _ _ O
memory _ _ O
. _ _ O
‚Äù _ _ O
A _ _ O
a _ _ O
= _ _ O
new _ _ O
A _ _ O
( _ _ O
) _ _ O
; _ _ O
a.x _ _ O
= _ _ O
10 _ _ O
; _ _ O
a.method _ _ O
( _ _ O
) _ _ O
; _ _ O
arr _ _ O
[ _ _ O
i _ _ O
] _ _ O
= _ _ O
a _ _ O
; _ _ O
let _ _ O
mut _ _ O
x _ _ O
= _ _ O
1 _ _ O
; _ _ O
let _ _ O
r _ _ O
= _ _ O
& _ _ O
mut _ _ O
x _ _ O
; _ _ O
let _ _ O
z _ _ O
= _ _ O
* _ _ O
r _ _ O
; _ _ O
* _ _ O
r _ _ O
= _ _ O
10 _ _ O
; _ _ O
in _ _ O
Java _ _ O
, _ _ O
the _ _ O
dot _ _ O
and _ _ O
square _ _ O
bracket _ _ O
operators _ _ O
perform _ _ O
dereferencing _ _ O
, _ _ O
to _ _ O
access _ _ O
values _ _ O
and _ _ O
methods _ _ O
within _ _ O
an _ _ O
object _ _ O
or _ _ O
array _ _ O
. _ _ O
Rust _ _ O
has _ _ O
those _ _ O
, _ _ O
as _ _ O
well _ _ O
as _ _ O
the _ _ O
prefix _ _ O
asterisk _ _ O
operator _ _ O
, _ _ O
which _ _ O
can _ _ O
get _ _ O
or _ _ O
set _ _ O
the _ _ O
value _ _ O
at _ _ O
the _ _ O
other _ _ O
end _ _ O
of _ _ O
the _ _ O
reference _ _ O
. _ _ O
12 _ _ O

The _ _ O
necessity _ _ O
of _ _ O
indirection _ _ O
‚óè _ _ O
when _ _ O
you _ _ O
write _ _ O
a _ _ O
program _ _ O
, _ _ O
you _ _ O
have _ _ O
a _ _ O
fixed _ _ O
number _ _ O
of _ _ O
variables _ _ O
‚Ä¶ _ _ O
o _ _ O
but _ _ O
the _ _ O
size _ _ O
of _ _ O
most _ _ O
data _ _ O
structures _ _ O
is _ _ O
dynamic _ _ O
. _ _ O
o _ _ O
you _ _ O
do _ _ O
n't _ _ O
know _ _ O
how _ _ O
many _ _ O
values _ _ O
there _ _ O
will _ _ O
be _ _ O
until _ _ O
runtime _ _ O
. _ _ O
‚óè _ _ O
so _ _ O
, _ _ O
we _ _ O
have _ _ O
to _ _ O
dynamically _ _ O
allocate _ _ O
memory _ _ O
: _ _ O
int _ _ O
[ _ _ O
] _ _ O
a _ _ O
= _ _ O
new _ _ O
int _ _ O
[ _ _ O
100 _ _ O
] _ _ O
; _ _ O
/ _ _ O
/ _ _ O
gimme _ _ O
100 _ _ O
new _ _ O
variables _ _ O
‚óè _ _ O
but _ _ O
we _ _ O
wo _ _ O
n't _ _ O
know _ _ O
the _ _ O
array _ _ O
's _ _ O
address _ _ O
until _ _ O
runtime _ _ O
! _ _ O
o _ _ O
so _ _ O
the _ _ O
only _ _ O
way _ _ O
to _ _ O
access _ _ O
it _ _ O
is _ _ O
indirectly _ _ O
. _ _ O
‚óè _ _ O
the _ _ O
variable _ _ O
above _ _ O
is _ _ O
a _ _ O
pointer _ _ O
to _ _ O
an _ _ O
value _ _ O
on _ _ O
the _ _ O
heap _ _ O
, _ _ O
the _ _ O
area _ _ O
of _ _ O
memory _ _ O
where _ _ O
dynamic _ _ O
allocation _ _ O
happens _ _ O
. _ _ O
o _ _ O
from _ _ O
now _ _ O
on _ _ O
, _ _ O
I _ _ O
'll _ _ O
use _ _ O
the _ _ O
term _ _ O
object _ _ O
to _ _ O
refer _ _ O
to _ _ O
heap-allocated _ _ O
values _ _ O
, _ _ O
but _ _ O
not _ _ O
necessarily _ _ O
in _ _ O
the _ _ O
" _ _ O
object-oriented _ _ O
" _ _ O
sense _ _ O
. _ _ O
13 _ _ O

The _ _ O
power _ _ O
of _ _ O
the _ _ O
heap _ _ O
‚óè _ _ O
the _ _ O
heap _ _ O
lets _ _ O
us _ _ O
create _ _ O
data _ _ O
structures _ _ O
of _ _ O
any _ _ O
practical _ _ O
size _ _ O
at _ _ O
runtime _ _ O
. _ _ O
‚óè _ _ O
the _ _ O
lifetime _ _ O
of _ _ O
heap-allocated _ _ O
values _ _ O
( _ _ O
objects _ _ O
) _ _ O
is _ _ O
also _ _ O
dynamic _ _ O
. _ _ O
fn _ _ O
f _ _ O
( _ _ O
) _ _ O
: _ _ O
Cat _ _ O
{ _ _ O
return _ _ O
new _ _ O
Cat _ _ O
( _ _ O
) _ _ O
; _ _ O
} _ _ O
fn _ _ O
main _ _ O
( _ _ O
) _ _ O
{ _ _ O
let _ _ O
c _ _ O
= _ _ O
f _ _ O
( _ _ O
) _ _ O
; _ _ O
c.meow _ _ O
( _ _ O
) _ _ O
; _ _ O
} _ _ O
an _ _ O
object _ _ O
can _ _ O
outlive _ _ O
the _ _ O
function _ _ O
which _ _ O
allocated _ _ O
it _ _ O
! _ _ O
but _ _ O
this _ _ O
presents _ _ O
a _ _ O
problem _ _ O
: _ _ O
when _ _ O
does _ _ O
the _ _ O
lifetime _ _ O
of _ _ O
an _ _ O
object _ _ O
end _ _ O
? _ _ O
( _ _ O
who _ _ O
's _ _ O
the _ _ O
owner _ _ O
? _ _ O
? _ _ O
) _ _ O
14 _ _ O

Heap _ _ O
memory _ _ O
management _ _ O
time _ _ O
check _ _ O
< _ _ O
40 _ _ O
min _ _ O
15 _ _ O

Memory _ _ O
safety _ _ O
( _ _ O
slightly _ _ O
animated _ _ O
) _ _ O
‚óè _ _ O
a _ _ O
program _ _ O
is _ _ O
memory-safe _ _ O
if _ _ O
, _ _ O
when _ _ O
you _ _ O
follow _ _ O
an _ _ O
arrow _ _ O
: _ _ O
o _ _ O
there _ _ O
is _ _ O
exactly _ _ O
one _ _ O
possible _ _ O
value _ _ O
on _ _ O
the _ _ O
other _ _ O
end _ _ O
; _ _ O
and _ _ O
o _ _ O
that _ _ O
value _ _ O
is _ _ O
guaranteed _ _ O
to _ _ O
be _ _ O
alive _ _ O
. _ _ O
fn _ _ O
main _ _ O
( _ _ O
) _ _ O
{ _ _ O
let _ _ O
a _ _ O
= _ _ O
new _ _ O
A _ _ O
( _ _ O
) _ _ O
; _ _ O
a.method _ _ O
( _ _ O
) _ _ O
; _ _ O
a _ _ O
= _ _ O
new _ _ O
A _ _ O
( _ _ O
) _ _ O
; _ _ O
a.method _ _ O
( _ _ O
) _ _ O
; _ _ O
} _ _ O
a _ _ O
Stack _ _ O
Heap _ _ O
00000000 _ _ O
00804000 _ _ O
00804018 _ _ O
instance _ _ O
of _ _ O
A _ _ O
instance _ _ O
of _ _ O
A _ _ O
at _ _ O
all _ _ O
times _ _ O
, _ _ O
a _ _ O
is _ _ O
pointing _ _ O
to _ _ O
a _ _ O
live _ _ O
object _ _ O
, _ _ O
so _ _ O
calling _ _ O
a _ _ O
method _ _ O
on _ _ O
it _ _ O
is _ _ O
safe _ _ O
. _ _ O
for _ _ O
memory _ _ O
safety _ _ O
to _ _ O
hold _ _ O
, _ _ O
as _ _ O
long _ _ O
as _ _ O
at _ _ O
least _ _ O
one _ _ O
arrow _ _ O
is _ _ O
pointing _ _ O
to _ _ O
an _ _ O
object _ _ O
, _ _ O
it _ _ O
must _ _ O
not _ _ O
be _ _ O
deallocated _ _ O
. _ _ O
but _ _ O
that _ _ O
sounds _ _ O
hard _ _ O
to _ _ O
prove _ _ O
‚Ä¶ _ _ O
16 _ _ O

So _ _ O
let _ _ O
's _ _ O
not _ _ O
prove _ _ O
it _ _ O
! _ _ O
‚óè _ _ O
one _ _ O
way _ _ O
to _ _ O
ensure _ _ O
arrows _ _ O
always _ _ O
point _ _ O
to _ _ O
live _ _ O
objects _ _ O
is _ _ O
‚Ä¶ _ _ O
o _ _ O
you _ _ O
never _ _ O
deallocate _ _ O
them _ _ O
! _ _ O
‚óè _ _ O
what _ _ O
? _ _ O
? _ _ O
did _ _ O
n't _ _ O
we _ _ O
say _ _ O
memory _ _ O
was _ _ O
finite _ _ O
, _ _ O
and _ _ O
we _ _ O
have _ _ O
to _ _ O
reuse _ _ O
it _ _ O
? _ _ O
o _ _ O
well _ _ O
, _ _ O
yeah _ _ O
, _ _ O
but _ _ O
not _ _ O
every _ _ O
program _ _ O
needs _ _ O
to _ _ O
reuse _ _ O
memory _ _ O
. _ _ O
‚óè _ _ O
if _ _ O
you _ _ O
have _ _ O
a _ _ O
short-lived _ _ O
program _ _ O
which _ _ O
allocates _ _ O
memory _ _ O
, _ _ O
does _ _ O
its _ _ O
work _ _ O
, _ _ O
and _ _ O
exits _ _ O
, _ _ O
there _ _ O
may _ _ O
be _ _ O
no _ _ O
need _ _ O
to _ _ O
deallocate _ _ O
at _ _ O
all _ _ O
. _ _ O
o _ _ O
for _ _ O
example _ _ O
, _ _ O
a _ _ O
program _ _ O
that _ _ O
reads _ _ O
some _ _ O
text _ _ O
, _ _ O
parses _ _ O
it _ _ O
into _ _ O
a _ _ O
tree _ _ O
, _ _ O
does _ _ O
some _ _ O
processing _ _ O
on _ _ O
that _ _ O
tree _ _ O
, _ _ O
and _ _ O
spits _ _ O
out _ _ O
different _ _ O
text _ _ O
. _ _ O
‚ñ™ _ _ O
what _ _ O
could _ _ O
I _ _ O
be _ _ O
talking _ _ O
about _ _ O
? _ _ O
: _ _ O
^ _ _ O
) _ _ O
‚óè _ _ O
this _ _ O
idea _ _ O
can _ _ O
be _ _ O
applied _ _ O
at _ _ O
smaller _ _ O
scales _ _ O
within _ _ O
programs _ _ O
by _ _ O
using _ _ O
arena _ _ O
allocation _ _ O
: _ _ O
tying _ _ O
heap _ _ O
allocation _ _ O
to _ _ O
the _ _ O
stack _ _ O
by _ _ O
deallocating _ _ O
a _ _ O
group _ _ O
of _ _ O
objects _ _ O
when _ _ O
a _ _ O
function _ _ O
returns _ _ O
. _ _ O
‚óè _ _ O
buuuuut _ _ O
obviously _ _ O
this _ _ O
is _ _ O
n't _ _ O
a _ _ O
general _ _ O
solution _ _ O
. _ _ O
17 _ _ O

Manual _ _ O
memory _ _ O
management _ _ O
‚óè _ _ O
since _ _ O
the _ _ O
programmer _ _ O
decides _ _ O
when _ _ O
object _ _ O
lifetimes _ _ O
begin _ _ O
‚Ä¶ _ _ O
‚óè _ _ O
let _ _ O
's _ _ O
also _ _ O
have _ _ O
them _ _ O
decide _ _ O
when _ _ O
their _ _ O
lifetimes _ _ O
end _ _ O
! _ _ O
o _ _ O
hahaha _ _ O
what _ _ O
could _ _ O
possibly _ _ O
go _ _ O
wrong _ _ O
? _ _ O
this _ _ O
is _ _ O
not _ _ O
a _ _ O
solution _ _ O
to _ _ O
the _ _ O
problem _ _ O
. _ _ O
we _ _ O
've _ _ O
just _ _ O
pushed _ _ O
it _ _ O
somewhere _ _ O
else _ _ O
. _ _ O
/ _ _ O
/ _ _ O
C++ _ _ O
void _ _ O
main _ _ O
( _ _ O
) _ _ O
{ _ _ O
auto _ _ O
a _ _ O
= _ _ O
new _ _ O
A _ _ O
( _ _ O
) _ _ O
; _ _ O
a- _ _ O
> _ _ O
method _ _ O
( _ _ O
) _ _ O
; _ _ O
delete _ _ O
a _ _ O
; _ _ O
easy _ _ O
peasy _ _ O
! _ _ O
a- _ _ O
> _ _ O
method _ _ O
( _ _ O
) _ _ O
; _ _ O
oh _ _ O
fu--- _ _ O
} _ _ O
humans _ _ O
suck _ _ O
at _ _ O
knowing _ _ O
when _ _ O
is _ _ O
the _ _ O
right _ _ O
time _ _ O
to _ _ O
deallocate _ _ O
an _ _ O
object _ _ O
. _ _ O
what _ _ O
makes _ _ O
it _ _ O
hard _ _ O
? _ _ O
18 _ _ O

It _ _ O
's _ _ O
those _ _ O
dang _ _ O
arrows _ _ O
( _ _ O
slightly _ _ O
animated _ _ O
) _ _ O
‚óè _ _ O
lots _ _ O
of _ _ O
languages _ _ O
make _ _ O
it _ _ O
really _ _ O
, _ _ O
really _ _ O
easy _ _ O
to _ _ O
create _ _ O
arrows _ _ O
‚Ä¶ _ _ O
o _ _ O
but _ _ O
they _ _ O
offer _ _ O
little _ _ O
or _ _ O
no _ _ O
help _ _ O
in _ _ O
ensuring _ _ O
that _ _ O
those _ _ O
arrows _ _ O
are _ _ O
valid _ _ O
( _ _ O
that _ _ O
is _ _ O
, _ _ O
they _ _ O
point _ _ O
to _ _ O
a _ _ O
live _ _ O
object _ _ O
) _ _ O
/ _ _ O
/ _ _ O
C _ _ O
int _ _ O
* _ _ O
p _ _ O
= _ _ O
malloc _ _ O
( _ _ O
40 _ _ O
) _ _ O
; _ _ O
int _ _ O
* _ _ O
q _ _ O
= _ _ O
p _ _ O
+ _ _ O
256 _ _ O
; _ _ O
p _ _ O
* _ _ O
q _ _ O
= _ _ O
5000 _ _ O
; _ _ O
/ _ _ O
/ _ _ O
UB _ _ O
q _ _ O
free _ _ O
( _ _ O
p _ _ O
) _ _ O
; _ _ O
x _ _ O
* _ _ O
p _ _ O
= _ _ O
10 _ _ O
; _ _ O
/ _ _ O
/ _ _ O
UB _ _ O
int _ _ O
x _ _ O
= _ _ O
3 _ _ O
; _ _ O
p _ _ O
= _ _ O
& _ _ O
x _ _ O
; _ _ O
free _ _ O
( _ _ O
p _ _ O
) _ _ O
; _ _ O
/ _ _ O
/ _ _ O
UB _ _ O
( _ _ O
UB _ _ O
= _ _ O
Undefined _ _ O
Behavior _ _ O
) _ _ O
Heap _ _ O
Stack _ _ O
07FF8FF8 _ _ O
00804000 _ _ O
00804400 _ _ O
40 _ _ O
bytes _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
( _ _ O
10 _ _ O
ints _ _ O
) _ _ O
00000003 _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
it _ _ O
gets _ _ O
worse _ _ O
. _ _ O
19 _ _ O

Aliasing _ _ O
‚óè _ _ O
this _ _ O
is _ _ O
when _ _ O
two _ _ O
or _ _ O
more _ _ O
arrows _ _ O
point _ _ O
to _ _ O
the _ _ O
same _ _ O
value _ _ O
. _ _ O
‚óè _ _ O
it _ _ O
's _ _ O
very _ _ O
powerful _ _ O
: _ _ O
it _ _ O
lets _ _ O
you _ _ O
create _ _ O
any _ _ O
directed _ _ O
graph _ _ O
( _ _ O
digraph _ _ O
) _ _ O
. _ _ O
Stack _ _ O
1 _ _ O
1 _ _ O
1 _ _ O
lists _ _ O
‚Ä¶ _ _ O
1 _ _ O
1 _ _ O
trees _ _ O
‚Ä¶ _ _ O
1 _ _ O
1 _ _ O
2 _ _ O
2 _ _ O
doubly-linked _ _ O
lists _ _ O
‚Ä¶ _ _ O
1 _ _ O
3 _ _ O
1 _ _ O
trees _ _ O
with _ _ O
parent _ _ O
links _ _ O
‚Ä¶ _ _ O
1 _ _ O
2 _ _ O
1 _ _ O
1 _ _ O
directed _ _ O
acyclic _ _ O
graphs _ _ O
( _ _ O
DAGs _ _ O
) _ _ O
‚Ä¶ _ _ O
a _ _ O
node _ _ O
's _ _ O
in-degree _ _ O
is _ _ O
how _ _ O
many _ _ O
arrows _ _ O
point _ _ O
to _ _ O
it _ _ O
. _ _ O
20 _ _ O

WITH _ _ O
GREAT _ _ O
POWER _ _ O
etc _ _ O
. _ _ O
‚óè _ _ O
unrestricted _ _ O
pointer _ _ O
aliasing _ _ O
can _ _ O
cause _ _ O
a _ _ O
lot _ _ O
of _ _ O
problems _ _ O
. _ _ O
p _ _ O
t1 _ _ O
delete _ _ O
p _ _ O
; _ _ O
t2 _ _ O
q _ _ O
two _ _ O
threads _ _ O
of _ _ O
execution _ _ O
both _ _ O
accessing _ _ O
the _ _ O
same _ _ O
object _ _ O
at _ _ O
the _ _ O
same _ _ O
time _ _ O
can _ _ O
cause _ _ O
race _ _ O
conditions _ _ O
, _ _ O
deadlocks _ _ O
, _ _ O
and _ _ O
more _ _ O
. _ _ O
if _ _ O
the _ _ O
programmer _ _ O
can _ _ O
deallocate _ _ O
objects _ _ O
, _ _ O
two _ _ O
pointers _ _ O
pointing _ _ O
at _ _ O
the _ _ O
same _ _ O
thing _ _ O
can _ _ O
lead _ _ O
to _ _ O
dangling _ _ O
pointers _ _ O
. _ _ O
other _ _ O
sources _ _ O
of _ _ O
dangling _ _ O
/ _ _ O
invalid _ _ O
pointers _ _ O
are _ _ O
pointer _ _ O
arithmetic _ _ O
and _ _ O
pointers _ _ O
to _ _ O
stack _ _ O
values _ _ O
. _ _ O
21 _ _ O

Automatic _ _ O
heap _ _ O
memory _ _ O
management _ _ O
time _ _ O
check _ _ O
‚â§ _ _ O
70 _ _ O
min _ _ O
22 _ _ O

Hard _ _ O
for _ _ O
humans _ _ O
, _ _ O
easy _ _ O
for _ _ O
computers _ _ O
( _ _ O
animated _ _ O
) _ _ O
‚óè _ _ O
at _ _ O
a _ _ O
high _ _ O
level _ _ O
, _ _ O
the _ _ O
problem _ _ O
is _ _ O
not _ _ O
that _ _ O
complicated _ _ O
. _ _ O
Stack _ _ O
objects _ _ O
and _ _ O
pointers _ _ O
form _ _ O
graphs _ _ O
. _ _ O
Globals _ _ O
the _ _ O
roots _ _ O
are _ _ O
the _ _ O
stack _ _ O
( _ _ O
s _ _ O
) _ _ O
and _ _ O
globals _ _ O
. _ _ O
reachable _ _ O
objects _ _ O
are _ _ O
pointed _ _ O
to _ _ O
‚Äì _ _ O
directly _ _ O
or _ _ O
transitively _ _ O
‚Äì _ _ O
from _ _ O
the _ _ O
roots _ _ O
. _ _ O
any _ _ O
objects _ _ O
that _ _ O
become _ _ O
unreachable _ _ O
can _ _ O
never _ _ O
be _ _ O
used _ _ O
by _ _ O
the _ _ O
program _ _ O
again _ _ O
, _ _ O
and _ _ O
are _ _ O
therefore _ _ O
safe _ _ O
to _ _ O
deallocate _ _ O
. _ _ O
this _ _ O
gives _ _ O
us _ _ O
a _ _ O
simple _ _ O
* _ _ O
rule _ _ O
: _ _ O
an _ _ O
object _ _ O
's _ _ O
lifetime _ _ O
ends _ _ O
when _ _ O
its _ _ O
in-degree _ _ O
reaches _ _ O
0 _ _ O
. _ _ O
23 _ _ O

Counting _ _ O
the _ _ O
arrows _ _ O
by _ _ O
‚Ä¶ _ _ O
counting _ _ O
them _ _ O
( _ _ O
animated _ _ O
) _ _ O
‚óè _ _ O
reference _ _ O
counting _ _ O
( _ _ O
refcounting _ _ O
) _ _ O
explicitly _ _ O
tracks _ _ O
the _ _ O
number _ _ O
of _ _ O
arrows _ _ O
pointing _ _ O
to _ _ O
an _ _ O
object _ _ O
at _ _ O
any _ _ O
given _ _ O
time _ _ O
. _ _ O
when _ _ O
an _ _ O
object _ _ O
is _ _ O
whenever _ _ O
a _ _ O
reference _ _ O
to _ _ O
it _ _ O
is _ _ O
allocated _ _ O
, _ _ O
its _ _ O
refcount _ _ O
is _ _ O
0 _ _ O
. _ _ O
created _ _ O
, _ _ O
the _ _ O
count _ _ O
is _ _ O
incremented _ _ O
. _ _ O
Ant _ _ O
a _ _ O
= _ _ O
new _ _ O
Ant _ _ O
( _ _ O
) _ _ O
; _ _ O
Ant _ _ O
b _ _ O
= _ _ O
a _ _ O
; _ _ O
a _ _ O
= _ _ O
new _ _ O
Ant _ _ O
( _ _ O
) _ _ O
; _ _ O
b _ _ O
= _ _ O
null _ _ O
; _ _ O
a _ _ O
= _ _ O
null _ _ O
; _ _ O
a _ _ O
b _ _ O
when _ _ O
a _ _ O
variable _ _ O
is _ _ O
reassigned _ _ O
, _ _ O
the _ _ O
previous _ _ O
object _ _ O
's _ _ O
count _ _ O
is _ _ O
decremented _ _ O
. _ _ O
vtbl _ _ O
: _ _ O
‚Ä¶ _ _ O
refs _ _ O
: _ _ O
1 _ _ O
0 _ _ O
2 _ _ O
species _ _ O
: _ _ O
" _ _ O
ant _ _ O
" _ _ O
vtbl _ _ O
: _ _ O
‚Ä¶ _ _ O
refs _ _ O
: _ _ O
0 _ _ O
1 _ _ O
species _ _ O
: _ _ O
" _ _ O
ant _ _ O
" _ _ O
when _ _ O
the _ _ O
count _ _ O
reaches _ _ O
0 _ _ O
, _ _ O
the _ _ O
object _ _ O
is _ _ O
deallocated _ _ O
. _ _ O
24 _ _ O

The _ _ O
compiler _ _ O
's _ _ O
job _ _ O
‚óè _ _ O
the _ _ O
compiler _ _ O
knows _ _ O
when _ _ O
the _ _ O
references _ _ O
are _ _ O
created _ _ O
and _ _ O
destroyed _ _ O
. _ _ O
‚óè _ _ O
so _ _ O
, _ _ O
around _ _ O
each _ _ O
assignment _ _ O
, _ _ O
it _ _ O
inserts _ _ O
those _ _ O
' _ _ O
crements _ _ O
. _ _ O
Ant _ _ O
a _ _ O
= _ _ O
new _ _ O
Ant _ _ O
( _ _ O
) _ _ O
; _ _ O
tricky _ _ O
details _ _ O
to _ _ O
consider _ _ O
: _ _ O
incRef _ _ O
( _ _ O
a _ _ O
) _ _ O
; _ _ O
when _ _ O
a _ _ O
local _ _ O
variable _ _ O
goes _ _ O
out _ _ O
of _ _ O
scope _ _ O
, _ _ O
Ant _ _ O
b _ _ O
= _ _ O
a _ _ O
; _ _ O
we _ _ O
need _ _ O
to _ _ O
decRef _ _ O
( _ _ O
) _ _ O
it _ _ O
. _ _ O
incRef _ _ O
( _ _ O
b _ _ O
) _ _ O
; _ _ O
decRef _ _ O
( _ _ O
a _ _ O
) _ _ O
; _ _ O
returning _ _ O
a _ _ O
reference _ _ O
or _ _ O
passing _ _ O
one _ _ O
as _ _ O
a _ _ O
= _ _ O
new _ _ O
Ant _ _ O
( _ _ O
) _ _ O
; _ _ O
an _ _ O
argument _ _ O
will _ _ O
increment _ _ O
the _ _ O
refcount _ _ O
. _ _ O
incRef _ _ O
( _ _ O
a _ _ O
) _ _ O
; _ _ O
decRef _ _ O
( _ _ O
b _ _ O
) _ _ O
; _ _ O
before _ _ O
an _ _ O
object _ _ O
is _ _ O
deallocated _ _ O
, _ _ O
any _ _ O
b _ _ O
= _ _ O
null _ _ O
; _ _ O
references _ _ O
it _ _ O
has _ _ O
to _ _ O
other _ _ O
objects _ _ O
must _ _ O
decRef _ _ O
( _ _ O
a _ _ O
) _ _ O
; _ _ O
be _ _ O
recursively _ _ O
decremented _ _ O
first _ _ O
. _ _ O
a _ _ O
= _ _ O
null _ _ O
; _ _ O
25 _ _ O

So _ _ O
what _ _ O
's _ _ O
the _ _ O
catch _ _ O
? _ _ O
( _ _ O
animated _ _ O
) _ _ O
‚óè _ _ O
" _ _ O
when _ _ O
an _ _ O
object _ _ O
's _ _ O
in-degree _ _ O
reaches _ _ O
0 _ _ O
" _ _ O
may _ _ O
never _ _ O
happen _ _ O
. _ _ O
1 _ _ O
2 _ _ O
now _ _ O
what _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
1 _ _ O
these _ _ O
objects _ _ O
are _ _ O
unreachable _ _ O
and _ _ O
should _ _ O
be _ _ O
deallocated _ _ O
. _ _ O
but _ _ O
they _ _ O
wo _ _ O
n't _ _ O
be _ _ O
. _ _ O
this _ _ O
is _ _ O
a _ _ O
memory _ _ O
leak _ _ O
: _ _ O
these _ _ O
objects _ _ O
take _ _ O
up _ _ O
space _ _ O
that _ _ O
can _ _ O
never _ _ O
be _ _ O
deallocated _ _ O
. _ _ O
it _ _ O
's _ _ O
2 _ _ O
! _ _ O
2 _ _ O
! _ _ O
! _ _ O
! _ _ O
1 _ _ O
! _ _ O
! _ _ O
! _ _ O
t1 _ _ O
: _ _ O
c _ _ O
it _ _ O
's _ _ O
also _ _ O
bad _ _ O
for _ _ O
multithreaded _ _ O
programs _ _ O
, _ _ O
since _ _ O
the _ _ O
threads _ _ O
will _ _ O
fight _ _ O
over _ _ O
the _ _ O
refcount _ _ O
. _ _ O
it _ _ O
's _ _ O
1 _ _ O
! _ _ O
t2 _ _ O
knowing _ _ O
the _ _ O
in-degree _ _ O
is _ _ O
necessary _ _ O
for _ _ O
automatic _ _ O
memory _ _ O
management _ _ O
, _ _ O
but _ _ O
it _ _ O
is _ _ O
n't _ _ O
sufficient _ _ O
: _ _ O
it _ _ O
's _ _ O
not _ _ O
all _ _ O
you _ _ O
need _ _ O
to _ _ O
know _ _ O
. _ _ O
26 _ _ O

Tracing _ _ O
Garbage _ _ O
Collection _ _ O
time _ _ O
check _ _ O
‚â§ _ _ O
90 _ _ O
min _ _ O
27 _ _ O

The _ _ O
idea _ _ O
( _ _ O
animated _ _ O
) _ _ O
‚óè _ _ O
same _ _ O
ideas _ _ O
as _ _ O
before _ _ O
: _ _ O
roots _ _ O
, _ _ O
graph _ _ O
, _ _ O
reachability _ _ O
. _ _ O
Stack _ _ O
Globals _ _ O
‚úÖ _ _ O
‚úÖ _ _ O
‚úÖ _ _ O
‚úÖ _ _ O
your _ _ O
program _ _ O
runs _ _ O
normally _ _ O
, _ _ O
with _ _ O
no _ _ O
reference _ _ O
counting _ _ O
. _ _ O
this _ _ O
is _ _ O
called _ _ O
the _ _ O
mutation _ _ O
phase _ _ O
. _ _ O
periodically _ _ O
, _ _ O
your _ _ O
program _ _ O
is _ _ O
paused _ _ O
and _ _ O
the _ _ O
collection _ _ O
phase _ _ O
begins _ _ O
. _ _ O
the _ _ O
collector _ _ O
starts _ _ O
at _ _ O
the _ _ O
roots _ _ O
, _ _ O
and _ _ O
follows _ _ O
every _ _ O
arrow _ _ O
it _ _ O
can _ _ O
find _ _ O
, _ _ O
marking _ _ O
each _ _ O
object _ _ O
it _ _ O
encounters _ _ O
as _ _ O
live _ _ O
. _ _ O
when _ _ O
there _ _ O
are _ _ O
no _ _ O
more _ _ O
arrows _ _ O
to _ _ O
follow _ _ O
, _ _ O
the _ _ O
remaining _ _ O
objects _ _ O
are _ _ O
garbage _ _ O
and _ _ O
are _ _ O
swept _ _ O
away _ _ O
. _ _ O
28 _ _ O

The _ _ O
correctness _ _ O
‚óè _ _ O
this _ _ O
algorithm _ _ O
is _ _ O
mark-and-sweep _ _ O
and _ _ O
is _ _ O
the _ _ O
basis _ _ O
of _ _ O
tracing _ _ O
GC _ _ O
. _ _ O
‚óè _ _ O
it _ _ O
works _ _ O
because _ _ O
an _ _ O
object _ _ O
is _ _ O
not _ _ O
garbage _ _ O
when _ _ O
its _ _ O
in-degree _ _ O
is _ _ O
0 _ _ O
‚Ä¶ _ _ O
o _ _ O
it _ _ O
's _ _ O
garbage _ _ O
when _ _ O
it _ _ O
is _ _ O
unreachable _ _ O
from _ _ O
the _ _ O
roots _ _ O
. _ _ O
‚óè _ _ O
but _ _ O
wait _ _ O
, _ _ O
how _ _ O
does _ _ O
the _ _ O
collector _ _ O
get _ _ O
to _ _ O
the _ _ O
dead _ _ O
objects _ _ O
? _ _ O
o _ _ O
simple _ _ O
: _ _ O
you _ _ O
are _ _ O
no _ _ O
longer _ _ O
the _ _ O
objects _ _ O
' _ _ O
owner _ _ O
. _ _ O
the _ _ O
collector _ _ O
is _ _ O
. _ _ O
‚óè _ _ O
every _ _ O
time _ _ O
you _ _ O
allocate _ _ O
an _ _ O
object _ _ O
, _ _ O
the _ _ O
collector _ _ O
remembers _ _ O
it _ _ O
. _ _ O
o _ _ O
the _ _ O
collector _ _ O
has _ _ O
a _ _ O
list _ _ O
of _ _ O
every _ _ O
object _ _ O
on _ _ O
the _ _ O
heap _ _ O
. _ _ O
o _ _ O
in _ _ O
the _ _ O
mutation _ _ O
phase _ _ O
, _ _ O
it _ _ O
adds _ _ O
to _ _ O
this _ _ O
list _ _ O
when _ _ O
you _ _ O
new _ _ O
. _ _ O
o _ _ O
the _ _ O
collection _ _ O
phase _ _ O
, _ _ O
it _ _ O
uses _ _ O
this _ _ O
list _ _ O
to _ _ O
find _ _ O
disconnected _ _ O
objects _ _ O
. _ _ O
‚óè _ _ O
this _ _ O
works _ _ O
great _ _ O
for _ _ O
: _ _ O
o _ _ O
cycles _ _ O
, _ _ O
cause _ _ O
the _ _ O
collector _ _ O
does _ _ O
n't _ _ O
care _ _ O
about _ _ O
in-degree _ _ O
. _ _ O
o _ _ O
multithreading _ _ O
, _ _ O
cause _ _ O
there _ _ O
are _ _ O
no _ _ O
ref _ _ O
counts _ _ O
to _ _ O
argue _ _ O
over _ _ O
, _ _ O
and _ _ O
the _ _ O
collector _ _ O
considers _ _ O
all _ _ O
threads _ _ O
' _ _ O
stacks _ _ O
as _ _ O
roots _ _ O
. _ _ O
29 _ _ O

Concessions _ _ O
we _ _ O
make _ _ O
‚óè _ _ O
for _ _ O
the _ _ O
tracing _ _ O
algorithm _ _ O
to _ _ O
work _ _ O
well _ _ O
, _ _ O
there _ _ O
are _ _ O
some _ _ O
requirements _ _ O
. _ _ O
let _ _ O
x _ _ O
= _ _ O
0x08004030 _ _ O
; _ _ O
let _ _ O
a _ _ O
= _ _ O
new _ _ O
A _ _ O
( _ _ O
) _ _ O
; _ _ O
x _ _ O
08004030 _ _ O
a _ _ O
08004030 _ _ O
what _ _ O
if _ _ O
this _ _ O
happened _ _ O
by _ _ O
chance _ _ O
? _ _ O
how _ _ O
can _ _ O
the _ _ O
collector _ _ O
know _ _ O
a _ _ O
is _ _ O
a _ _ O
pointer _ _ O
but _ _ O
x _ _ O
is _ _ O
not _ _ O
? _ _ O
the _ _ O
compiler _ _ O
must _ _ O
produce _ _ O
information _ _ O
for _ _ O
every _ _ O
global _ _ O
, _ _ O
local _ _ O
, _ _ O
and _ _ O
class _ _ O
field _ _ O
saying _ _ O
whether _ _ O
or _ _ O
not _ _ O
something _ _ O
is _ _ O
a _ _ O
pointer _ _ O
. _ _ O
int _ _ O
x _ _ O
= _ _ O
0x08004030 _ _ O
; _ _ O
int _ _ O
* _ _ O
p _ _ O
= _ _ O
( _ _ O
int* _ _ O
) _ _ O
x _ _ O
; _ _ O
type _ _ O
safety _ _ O
is _ _ O
crucial _ _ O
. _ _ O
being _ _ O
able _ _ O
to _ _ O
freely _ _ O
change _ _ O
the _ _ O
types _ _ O
of _ _ O
values _ _ O
will _ _ O
throw _ _ O
the _ _ O
collector _ _ O
way _ _ O
off _ _ O
. _ _ O
pointer _ _ O
arithmetic _ _ O
is _ _ O
a _ _ O
no-go _ _ O
. _ _ O
nuh _ _ O
uh _ _ O
. _ _ O
no _ _ O
way _ _ O
. _ _ O
30 _ _ O

What _ _ O
's _ _ O
the _ _ O
downside _ _ O
? _ _ O
‚óè _ _ O
well _ _ O
, _ _ O
the _ _ O
mark-and-sweep _ _ O
algorithm _ _ O
I _ _ O
showed _ _ O
is _ _ O
‚Ä¶ _ _ O
too _ _ O
simple _ _ O
. _ _ O
o _ _ O
it _ _ O
does _ _ O
n't _ _ O
have _ _ O
great _ _ O
performance _ _ O
. _ _ O
‚óè _ _ O
getting _ _ O
good _ _ O
performance _ _ O
means _ _ O
making _ _ O
it _ _ O
way _ _ O
more _ _ O
complex _ _ O
. _ _ O
o _ _ O
concurrent _ _ O
collectors _ _ O
do _ _ O
some _ _ O
/ _ _ O
most _ _ O
of _ _ O
their _ _ O
work _ _ O
during _ _ O
the _ _ O
mutation _ _ O
phase _ _ O
, _ _ O
making _ _ O
the _ _ O
collection _ _ O
phase _ _ O
shorter _ _ O
. _ _ O
o _ _ O
multithreaded _ _ O
collectors _ _ O
extend _ _ O
that _ _ O
to _ _ O
multiple _ _ O
mutators _ _ O
. _ _ O
o _ _ O
generational _ _ O
collectors _ _ O
take _ _ O
advantage _ _ O
of _ _ O
the _ _ O
fact _ _ O
that _ _ O
most _ _ O
objects _ _ O
are _ _ O
deallocated _ _ O
very _ _ O
quickly _ _ O
after _ _ O
they _ _ O
're _ _ O
allocated _ _ O
, _ _ O
and _ _ O
focus _ _ O
more _ _ O
effort _ _ O
on _ _ O
newer _ _ O
objects _ _ O
. _ _ O
o _ _ O
copying _ _ O
collectors _ _ O
reduce _ _ O
the _ _ O
amount _ _ O
of _ _ O
memory _ _ O
needed _ _ O
by _ _ O
moving _ _ O
objects _ _ O
around _ _ O
. _ _ O
31 _ _ O



