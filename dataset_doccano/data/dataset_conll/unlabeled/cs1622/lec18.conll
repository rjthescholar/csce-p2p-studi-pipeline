unlabeled|cs1622|lec18
-DOCSTART- -X- -X- O

Global _ _ O
Optimization _ _ O
CS _ _ O
1622 _ _ O
Jarrett _ _ O
Billingsley _ _ O

Class _ _ O
Announcements _ _ O
● _ _ O
exam _ _ O
1 _ _ O
grades _ _ O
were _ _ O
posted _ _ O
on _ _ O
Monday _ _ O
, _ _ O
if _ _ O
you _ _ O
missed _ _ O
that _ _ O
o _ _ O
if _ _ O
you _ _ O
have _ _ O
questions _ _ O
about _ _ O
it _ _ O
, _ _ O
please _ _ O
ask _ _ O
me _ _ O
in _ _ O
private _ _ O
● _ _ O
do _ _ O
n’t _ _ O
forget _ _ O
project _ _ O
4 _ _ O
is _ _ O
due _ _ O
on _ _ O
Saturday _ _ O
( _ _ O
or _ _ O
late _ _ O
Sunday _ _ O
) _ _ O
! _ _ O
2 _ _ O

From _ _ O
Local _ _ O
to _ _ O
Global _ _ O
3 _ _ O

Local _ _ O
optimization _ _ O
only _ _ O
gets _ _ O
you _ _ O
so _ _ O
far _ _ O
● _ _ O
last _ _ O
time _ _ O
we _ _ O
saw _ _ O
that _ _ O
optimizations _ _ O
like _ _ O
copy _ _ O
propagation _ _ O
and _ _ O
dead _ _ O
store _ _ O
elimination _ _ O
could _ _ O
greatly _ _ O
simplify _ _ O
our _ _ O
code _ _ O
. _ _ O
let _ _ O
x _ _ O
= _ _ O
5 _ _ O
* _ _ O
5 _ _ O
; _ _ O
return _ _ O
x _ _ O
; _ _ O
x _ _ O
= _ _ O
5 _ _ O
* _ _ O
5 _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
x _ _ O
return _ _ O
x _ _ O
= _ _ O
25 _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
x _ _ O
return _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
25 _ _ O
return _ _ O
but _ _ O
local _ _ O
optimizations _ _ O
only _ _ O
work _ _ O
on _ _ O
a _ _ O
single _ _ O
basic _ _ O
block _ _ O
, _ _ O
which _ _ O
means _ _ O
they _ _ O
have _ _ O
two _ _ O
significant _ _ O
weaknesses _ _ O
: _ _ O
1 _ _ O
. _ _ O
real _ _ O
functions _ _ O
can _ _ O
have _ _ O
many _ _ O
BBs _ _ O
, _ _ O
and _ _ O
they _ _ O
connect _ _ O
to _ _ O
and _ _ O
affect _ _ O
each _ _ O
other _ _ O
in _ _ O
nontrivial _ _ O
ways _ _ O
. _ _ O
2 _ _ O
. _ _ O
many _ _ O
of _ _ O
those _ _ O
BBs _ _ O
are _ _ O
short _ _ O
, _ _ O
only _ _ O
a _ _ O
few _ _ O
instructions _ _ O
long _ _ O
, _ _ O
meaning _ _ O
there _ _ O
just _ _ O
is _ _ O
n't _ _ O
much _ _ O
opportunity _ _ O
for _ _ O
optimization _ _ O
. _ _ O
4 _ _ O

Stumbling _ _ O
block _ _ O
basic _ _ O
● _ _ O
if _ _ O
we _ _ O
make _ _ O
that _ _ O
code _ _ O
just _ _ O
a _ _ O
little _ _ O
more _ _ O
complex _ _ O
… _ _ O
( _ _ O
assume _ _ O
a _ _ O
is _ _ O
an _ _ O
argument _ _ O
) _ _ O
let _ _ O
x _ _ O
= _ _ O
5 _ _ O
* _ _ O
5 _ _ O
; _ _ O
if _ _ O
a _ _ O
{ _ _ O
f _ _ O
( _ _ O
) _ _ O
; _ _ O
} _ _ O
return _ _ O
x _ _ O
; _ _ O
bb0 _ _ O
: _ _ O
x _ _ O
= _ _ O
5 _ _ O
* _ _ O
5 _ _ O
if _ _ O
a _ _ O
bb1 _ _ O
else _ _ O
bb2 _ _ O
bb1 _ _ O
: _ _ O
f _ _ O
( _ _ O
) _ _ O
goto _ _ O
bb2 _ _ O
bb2 _ _ O
: _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
x _ _ O
return _ _ O
we _ _ O
can _ _ O
still _ _ O
constfold _ _ O
up _ _ O
here _ _ O
… _ _ O
but _ _ O
now _ _ O
the _ _ O
assignment _ _ O
to _ _ O
$ _ _ O
t0 _ _ O
is _ _ O
in _ _ O
a _ _ O
different _ _ O
BB _ _ O
! _ _ O
if _ _ O
we _ _ O
want _ _ O
our _ _ O
optimizations _ _ O
to _ _ O
be _ _ O
worthwhile _ _ O
at _ _ O
all _ _ O
, _ _ O
we _ _ O
're _ _ O
going _ _ O
to _ _ O
have _ _ O
to _ _ O
make _ _ O
them _ _ O
operate _ _ O
on _ _ O
the _ _ O
whole _ _ O
CFG _ _ O
. _ _ O
intuitively _ _ O
, _ _ O
the _ _ O
above _ _ O
should _ _ O
be _ _ O
possible _ _ O
to _ _ O
optimize _ _ O
, _ _ O
no _ _ O
? _ _ O
5 _ _ O

Trying _ _ O
to _ _ O
intuit _ _ O
our _ _ O
way _ _ O
through _ _ O
it _ _ O
● _ _ O
we _ _ O
're _ _ O
going _ _ O
to _ _ O
use _ _ O
the _ _ O
same _ _ O
rules _ _ O
for _ _ O
copy _ _ O
prop _ _ O
/ _ _ O
dead _ _ O
stores _ _ O
as _ _ O
before _ _ O
, _ _ O
but _ _ O
we _ _ O
'll _ _ O
look _ _ O
at _ _ O
all _ _ O
the _ _ O
BBs _ _ O
instead _ _ O
of _ _ O
just _ _ O
one _ _ O
at _ _ O
a _ _ O
time _ _ O
. _ _ O
bb0 _ _ O
: _ _ O
x _ _ O
= _ _ O
25 _ _ O
if _ _ O
a _ _ O
bb1 _ _ O
else _ _ O
bb2 _ _ O
bb1 _ _ O
: _ _ O
f _ _ O
( _ _ O
) _ _ O
goto _ _ O
bb2 _ _ O
bb2 _ _ O
: _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
x _ _ O
return _ _ O
x _ _ O
is _ _ O
only _ _ O
assigned _ _ O
once _ _ O
, _ _ O
so _ _ O
copy _ _ O
its _ _ O
RHS _ _ O
everywhere _ _ O
it _ _ O
's _ _ O
used _ _ O
. _ _ O
bb0 _ _ O
: _ _ O
x _ _ O
= _ _ O
25 _ _ O
if _ _ O
a _ _ O
bb1 _ _ O
else _ _ O
bb2 _ _ O
bb1 _ _ O
: _ _ O
f _ _ O
( _ _ O
) _ _ O
goto _ _ O
bb2 _ _ O
bb2 _ _ O
: _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
25 _ _ O
return _ _ O
now _ _ O
x _ _ O
is _ _ O
never _ _ O
used _ _ O
, _ _ O
so _ _ O
delete _ _ O
it _ _ O
. _ _ O
bb0 _ _ O
: _ _ O
if _ _ O
a _ _ O
bb1 _ _ O
else _ _ O
bb2 _ _ O
bb1 _ _ O
: _ _ O
f _ _ O
( _ _ O
) _ _ O
goto _ _ O
bb2 _ _ O
bb2 _ _ O
: _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
25 _ _ O
return _ _ O
that _ _ O
was _ _ O
n't _ _ O
so _ _ O
bad _ _ O
, _ _ O
was _ _ O
it _ _ O
? _ _ O
well _ _ O
… _ _ O
6 _ _ O

Intuit _ _ O
THIS _ _ O
● _ _ O
if _ _ O
x _ _ O
is _ _ O
reassigned _ _ O
, _ _ O
does _ _ O
that _ _ O
always _ _ O
mean _ _ O
we _ _ O
ca _ _ O
n't _ _ O
propagate _ _ O
? _ _ O
bb0 _ _ O
: _ _ O
x _ _ O
= _ _ O
25 _ _ O
if _ _ O
a _ _ O
bb1 _ _ O
else _ _ O
bb2 _ _ O
bb1 _ _ O
: _ _ O
x _ _ O
= _ _ O
10 _ _ O
goto _ _ O
bb2 _ _ O
bb2 _ _ O
: _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
x _ _ O
return _ _ O
here _ _ O
, _ _ O
x _ _ O
has _ _ O
different _ _ O
values _ _ O
on _ _ O
each _ _ O
path _ _ O
to _ _ O
bb2 _ _ O
, _ _ O
so _ _ O
we _ _ O
ca _ _ O
n't _ _ O
propagate _ _ O
. _ _ O
bb0 _ _ O
: _ _ O
x _ _ O
= _ _ O
25 _ _ O
if _ _ O
a _ _ O
bb1 _ _ O
else _ _ O
bb2 _ _ O
bb1 _ _ O
: _ _ O
x _ _ O
= _ _ O
10 _ _ O
goto _ _ O
bb3 _ _ O
bb2 _ _ O
: _ _ O
x _ _ O
= _ _ O
10 _ _ O
goto _ _ O
bb3 _ _ O
bb3 _ _ O
: _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
x _ _ O
return _ _ O
but _ _ O
here _ _ O
, _ _ O
although _ _ O
x _ _ O
is _ _ O
assigned _ _ O
in _ _ O
multiple _ _ O
places _ _ O
, _ _ O
it _ _ O
has _ _ O
the _ _ O
same _ _ O
value _ _ O
on _ _ O
both _ _ O
paths _ _ O
to _ _ O
bb3 _ _ O
, _ _ O
so _ _ O
… _ _ O
we _ _ O
can _ _ O
propagate _ _ O
it _ _ O
to _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
10 _ _ O
? _ _ O
? _ _ O
? _ _ O
7 _ _ O

False _ _ O
confidence _ _ O
● _ _ O
it _ _ O
only _ _ O
gets _ _ O
worse _ _ O
. _ _ O
intuitively _ _ O
, _ _ O
we _ _ O
can _ _ O
simplify _ _ O
this _ _ O
whole _ _ O
function _ _ O
let _ _ O
x _ _ O
= _ _ O
0 _ _ O
; _ _ O
to _ _ O
return _ _ O
5 _ _ O
; _ _ O
but _ _ O
how _ _ O
do _ _ O
you _ _ O
prove _ _ O
that _ _ O
? _ _ O
for _ _ O
i _ _ O
in _ _ O
0 _ _ O
, _ _ O
10 _ _ O
{ _ _ O
x _ _ O
= _ _ O
5 _ _ O
; _ _ O
x _ _ O
is _ _ O
assigned _ _ O
twice _ _ O
, _ _ O
or _ _ O
maybe _ _ O
11 _ _ O
times _ _ O
? _ _ O
bb0 _ _ O
: _ _ O
x _ _ O
= _ _ O
0 _ _ O
} _ _ O
( _ _ O
do _ _ O
assignments _ _ O
in _ _ O
loops _ _ O
count _ _ O
as _ _ O
" _ _ O
once _ _ O
" _ _ O
? _ _ O
) _ _ O
i _ _ O
= _ _ O
0 _ _ O
goto _ _ O
bb1 _ _ O
return _ _ O
x _ _ O
; _ _ O
bb1 _ _ O
: _ _ O
$ _ _ O
t1 _ _ O
= _ _ O
i _ _ O
< _ _ O
10 _ _ O
if _ _ O
$ _ _ O
t1 _ _ O
bb2 _ _ O
else _ _ O
bb3 _ _ O
bb2 _ _ O
: _ _ O
x _ _ O
= _ _ O
5 _ _ O
i _ _ O
= _ _ O
i _ _ O
+ _ _ O
1 _ _ O
goto _ _ O
bb1 _ _ O
but _ _ O
the _ _ O
first _ _ O
assignment _ _ O
x _ _ O
= _ _ O
0 _ _ O
is _ _ O
never _ _ O
used _ _ O
… _ _ O
and _ _ O
the _ _ O
assignment _ _ O
( _ _ O
s _ _ O
) _ _ O
in _ _ O
the _ _ O
loop _ _ O
are _ _ O
redundant _ _ O
… _ _ O
( _ _ O
does _ _ O
that _ _ O
mean _ _ O
the _ _ O
whole _ _ O
loop _ _ O
can _ _ O
be _ _ O
removed _ _ O
? _ _ O
) _ _ O
bb3 _ _ O
: _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
x _ _ O
return _ _ O
8 _ _ O

We _ _ O
need _ _ O
some _ _ O
RIGOR _ _ O
● _ _ O
optimizations _ _ O
are _ _ O
basically _ _ O
proofs _ _ O
. _ _ O
o _ _ O
if _ _ O
you _ _ O
can _ _ O
prove _ _ O
that _ _ O
a _ _ O
variable _ _ O
is _ _ O
never _ _ O
read _ _ O
, _ _ O
you _ _ O
can _ _ O
remove _ _ O
it _ _ O
. _ _ O
o _ _ O
if _ _ O
you _ _ O
can _ _ O
prove _ _ O
that _ _ O
a _ _ O
variable _ _ O
only _ _ O
ever _ _ O
holds _ _ O
a _ _ O
constant _ _ O
value _ _ O
, _ _ O
you _ _ O
can _ _ O
replace _ _ O
all _ _ O
uses _ _ O
of _ _ O
it _ _ O
with _ _ O
that _ _ O
constant _ _ O
. _ _ O
● _ _ O
what _ _ O
we _ _ O
need _ _ O
is _ _ O
some _ _ O
kind _ _ O
of _ _ O
framework _ _ O
to _ _ O
build _ _ O
these _ _ O
proofs _ _ O
from _ _ O
. _ _ O
o _ _ O
many _ _ O
optimizations _ _ O
have _ _ O
the _ _ O
same _ _ O
kind _ _ O
of _ _ O
" _ _ O
algorithmic _ _ O
shape _ _ O
. _ _ O
" _ _ O
o _ _ O
most _ _ O
of _ _ O
them _ _ O
have _ _ O
repeated _ _ O
steps _ _ O
that _ _ O
stem _ _ O
from _ _ O
a _ _ O
common _ _ O
underlying _ _ O
reason _ _ O
. _ _ O
● _ _ O
so _ _ O
let _ _ O
's _ _ O
talk _ _ O
about _ _ O
data _ _ O
flow _ _ O
analysis _ _ O
. _ _ O
9 _ _ O

Data _ _ O
Flow _ _ O
Analysis _ _ O
10 _ _ O

Coming _ _ O
for _ _ O
a _ _ O
visit _ _ O
( _ _ O
animated _ _ O
) _ _ O
● _ _ O
remember _ _ O
this _ _ O
graph-visiting _ _ O
algorithm _ _ O
? _ _ O
the _ _ O
visited _ _ O
set _ _ O
records _ _ O
which _ _ O
nodes _ _ O
fn _ _ O
visit_node _ _ O
( _ _ O
n _ _ O
, _ _ O
visited _ _ O
) _ _ O
{ _ _ O
if _ _ O
visited _ _ O
[ _ _ O
n _ _ O
] _ _ O
{ _ _ O
return _ _ O
; _ _ O
} _ _ O
have _ _ O
already _ _ O
been _ _ O
visited _ _ O
, _ _ O
and _ _ O
is _ _ O
visited _ _ O
[ _ _ O
n _ _ O
] _ _ O
= _ _ O
true _ _ O
; _ _ O
necessary _ _ O
to _ _ O
prevent _ _ O
infinite _ _ O
loops _ _ O
. _ _ O
for _ _ O
s _ _ O
in _ _ O
n.successors _ _ O
( _ _ O
) _ _ O
{ _ _ O
visit_node _ _ O
( _ _ O
s _ _ O
, _ _ O
visited _ _ O
) _ _ O
; _ _ O
} _ _ O
} _ _ O
visit_node _ _ O
1 _ _ O
so _ _ O
you _ _ O
can _ _ O
imagine _ _ O
all _ _ O
the _ _ O
nodes _ _ O
starting _ _ O
in _ _ O
an _ _ O
" _ _ O
unvisited _ _ O
" _ _ O
set _ _ O
, _ _ O
and _ _ O
gradually _ _ O
being _ _ O
moved _ _ O
to _ _ O
visited _ _ O
. _ _ O
Unvisited _ _ O
2 _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
3 _ _ O
4 _ _ O
4 _ _ O
Visited _ _ O
11 _ _ O

Why _ _ O
does _ _ O
it _ _ O
terminate _ _ O
? _ _ O
● _ _ O
it _ _ O
might _ _ O
seem _ _ O
silly _ _ O
to _ _ O
ask _ _ O
, _ _ O
but _ _ O
termination _ _ O
is _ _ O
crucial _ _ O
to _ _ O
being _ _ O
able _ _ O
to _ _ O
specify _ _ O
optimizations _ _ O
that _ _ O
do _ _ O
n't _ _ O
get _ _ O
our _ _ O
compiler _ _ O
stuck _ _ O
in _ _ O
a _ _ O
loop _ _ O
. _ _ O
1 _ _ O
. _ _ O
every _ _ O
node _ _ O
is _ _ O
in _ _ O
one _ _ O
of _ _ O
a _ _ O
finite _ _ O
number _ _ O
of _ _ O
sets _ _ O
. _ _ O
( _ _ O
here _ _ O
, _ _ O
it _ _ O
's _ _ O
one _ _ O
of _ _ O
two _ _ O
sets _ _ O
. _ _ O
) _ _ O
4 _ _ O
. _ _ O
on _ _ O
every _ _ O
step _ _ O
, _ _ O
3 _ _ O
. _ _ O
once _ _ O
a _ _ O
node _ _ O
we _ _ O
move _ _ O
at _ _ O
least _ _ O
reaches _ _ O
the _ _ O
" _ _ O
last _ _ O
" _ _ O
Unvisited _ _ O
Visited _ _ O
one _ _ O
node _ _ O
from _ _ O
set _ _ O
, _ _ O
we _ _ O
do _ _ O
n't _ _ O
look _ _ O
one _ _ O
set _ _ O
to _ _ O
another _ _ O
. _ _ O
at _ _ O
it _ _ O
anymore _ _ O
. _ _ O
2 _ _ O
. _ _ O
nodes _ _ O
can _ _ O
move _ _ O
from _ _ O
one _ _ O
set _ _ O
to _ _ O
another _ _ O
, _ _ O
but _ _ O
only _ _ O
in _ _ O
one _ _ O
direction _ _ O
. _ _ O
therefore _ _ O
, _ _ O
the _ _ O
big-O _ _ O
upper _ _ O
bound _ _ O
on _ _ O
the _ _ O
number _ _ O
of _ _ O
steps _ _ O
in _ _ O
the _ _ O
algorithm _ _ O
is _ _ O
the _ _ O
number _ _ O
of _ _ O
nodes _ _ O
multiplied _ _ O
by _ _ O
the _ _ O
number _ _ O
of _ _ O
sets _ _ O
. _ _ O
minus _ _ O
one _ _ O
12 _ _ O

A _ _ O
simple _ _ O
control _ _ O
flow _ _ O
optimization _ _ O
● _ _ O
in _ _ O
this _ _ O
function _ _ O
, _ _ O
can _ _ O
we _ _ O
ever _ _ O
run _ _ O
the _ _ O
else _ _ O
code _ _ O
( _ _ O
g _ _ O
( _ _ O
) _ _ O
) _ _ O
? _ _ O
if _ _ O
true _ _ O
{ _ _ O
f _ _ O
( _ _ O
) _ _ O
; _ _ O
} _ _ O
else _ _ O
{ _ _ O
g _ _ O
( _ _ O
) _ _ O
; _ _ O
} _ _ O
no _ _ O
. _ _ O
what _ _ O
does _ _ O
that _ _ O
look _ _ O
like _ _ O
in _ _ O
the _ _ O
CFG _ _ O
? _ _ O
this _ _ O
can _ _ O
come _ _ O
up _ _ O
in _ _ O
real _ _ O
code _ _ O
: _ _ O
these _ _ O
nodes _ _ O
/ _ _ O
edges _ _ O
are _ _ O
useless _ _ O
; _ _ O
we _ _ O
can _ _ O
remove _ _ O
them _ _ O
. _ _ O
if _ _ O
f _ _ O
( _ _ O
) _ _ O
g _ _ O
( _ _ O
) _ _ O
f _ _ O
( _ _ O
) _ _ O
… _ _ O
const _ _ O
FEATURE_ENABLED _ _ O
= _ _ O
true _ _ O
; _ _ O
... _ _ O
if _ _ O
FEATURE_ENABLED _ _ O
{ _ _ O
or _ _ O
, _ _ O
the _ _ O
condition _ _ O
may _ _ O
have _ _ O
f _ _ O
( _ _ O
) _ _ O
; _ _ O
become _ _ O
a _ _ O
constant _ _ O
due _ _ O
to _ _ O
} _ _ O
else _ _ O
{ _ _ O
other _ _ O
optimizations _ _ O
. _ _ O
g _ _ O
( _ _ O
) _ _ O
; _ _ O
} _ _ O
… _ _ O
13 _ _ O

Tweaking _ _ O
the _ _ O
visitor _ _ O
algorithm _ _ O
● _ _ O
we _ _ O
want _ _ O
to _ _ O
detect _ _ O
if _ _ O
a _ _ O
BB _ _ O
is _ _ O
unreachable _ _ O
, _ _ O
meaning _ _ O
it _ _ O
can _ _ O
never _ _ O
run _ _ O
. _ _ O
● _ _ O
we _ _ O
'll _ _ O
modify _ _ O
the _ _ O
visiting _ _ O
algorithm _ _ O
in _ _ O
a _ _ O
simple _ _ O
way _ _ O
to _ _ O
do _ _ O
this _ _ O
. _ _ O
fn _ _ O
visit_node _ _ O
( _ _ O
n _ _ O
, _ _ O
visited _ _ O
) _ _ O
{ _ _ O
if _ _ O
visited _ _ O
[ _ _ O
n _ _ O
] _ _ O
{ _ _ O
return _ _ O
; _ _ O
} _ _ O
visited _ _ O
[ _ _ O
n _ _ O
] _ _ O
= _ _ O
true _ _ O
; _ _ O
let _ _ O
t _ _ O
= _ _ O
n.terminator _ _ O
; _ _ O
if _ _ O
t _ _ O
's _ _ O
condition _ _ O
is _ _ O
constant _ _ O
true _ _ O
{ _ _ O
visit_node _ _ O
( _ _ O
t.true_side _ _ O
, _ _ O
visited _ _ O
) _ _ O
; _ _ O
} _ _ O
else _ _ O
if _ _ O
it _ _ O
's _ _ O
constant _ _ O
false _ _ O
{ _ _ O
visit_node _ _ O
( _ _ O
t.false_side _ _ O
, _ _ O
visited _ _ O
) _ _ O
; _ _ O
} _ _ O
else _ _ O
{ _ _ O
for _ _ O
s _ _ O
in _ _ O
n.successors _ _ O
( _ _ O
) _ _ O
{ _ _ O
visit_node _ _ O
( _ _ O
s _ _ O
, _ _ O
visited _ _ O
) _ _ O
; _ _ O
} _ _ O
} _ _ O
} _ _ O
I _ _ O
'm _ _ O
paraphrasing _ _ O
the _ _ O
" _ _ O
real _ _ O
code _ _ O
" _ _ O
but _ _ O
the _ _ O
idea _ _ O
is _ _ O
simple _ _ O
: _ _ O
if _ _ O
the _ _ O
condition _ _ O
is _ _ O
constant _ _ O
, _ _ O
only _ _ O
recursively _ _ O
visit _ _ O
the _ _ O
BB _ _ O
that _ _ O
corresponds _ _ O
to _ _ O
it _ _ O
. _ _ O
at _ _ O
the _ _ O
end _ _ O
of _ _ O
running _ _ O
this _ _ O
, _ _ O
any _ _ O
nodes _ _ O
not _ _ O
in _ _ O
the _ _ O
visited _ _ O
set _ _ O
are _ _ O
unreachable _ _ O
and _ _ O
can _ _ O
be _ _ O
removed _ _ O
from _ _ O
the _ _ O
CFG _ _ O
. _ _ O
14 _ _ O

Running _ _ O
it _ _ O
on _ _ O
this _ _ O
CFG _ _ O
( _ _ O
animated _ _ O
) _ _ O
● _ _ O
we _ _ O
'll _ _ O
mark _ _ O
any _ _ O
visited _ _ O
node _ _ O
with _ _ O
a _ _ O
green _ _ O
circle _ _ O
. _ _ O
if _ _ O
true _ _ O
{ _ _ O
f _ _ O
( _ _ O
) _ _ O
; _ _ O
} _ _ O
else _ _ O
{ _ _ O
g _ _ O
( _ _ O
) _ _ O
; _ _ O
} _ _ O
if _ _ O
f _ _ O
( _ _ O
) _ _ O
g _ _ O
( _ _ O
) _ _ O
… _ _ O
done _ _ O
. _ _ O
now _ _ O
we _ _ O
can _ _ O
see _ _ O
that _ _ O
the _ _ O
else _ _ O
node _ _ O
( _ _ O
g _ _ O
( _ _ O
) _ _ O
) _ _ O
was _ _ O
not _ _ O
visited _ _ O
, _ _ O
and _ _ O
is _ _ O
therefore _ _ O
not _ _ O
reachable _ _ O
. _ _ O
( _ _ O
how _ _ O
we _ _ O
remove _ _ O
it _ _ O
from _ _ O
the _ _ O
CFG _ _ O
is _ _ O
a _ _ O
separate _ _ O
issue _ _ O
, _ _ O
but _ _ O
it _ _ O
's _ _ O
not _ _ O
super _ _ O
complicated _ _ O
. _ _ O
) _ _ O
do _ _ O
you _ _ O
remember _ _ O
another _ _ O
algorithm _ _ O
that _ _ O
worked _ _ O
like _ _ O
this _ _ O
? _ _ O
you _ _ O
start _ _ O
at _ _ O
a _ _ O
root _ _ O
and _ _ O
mark _ _ O
reachable _ _ O
things _ _ O
, _ _ O
then _ _ O
sweep _ _ O
away _ _ O
anything _ _ O
that _ _ O
is _ _ O
n't _ _ O
reachable _ _ O
… _ _ O
; _ _ O
o _ _ O
15 _ _ O

Forward _ _ O
analysis _ _ O
● _ _ O
the _ _ O
way _ _ O
this _ _ O
( _ _ O
and _ _ O
most _ _ O
optimizations _ _ O
) _ _ O
works _ _ O
is _ _ O
by _ _ O
transferring _ _ O
some _ _ O
kind _ _ O
of _ _ O
" _ _ O
knowledge _ _ O
" _ _ O
from _ _ O
BB _ _ O
to _ _ O
BB _ _ O
by _ _ O
following _ _ O
edges _ _ O
. _ _ O
o _ _ O
here _ _ O
, _ _ O
that _ _ O
knowledge _ _ O
is _ _ O
the _ _ O
reachability _ _ O
of _ _ O
a _ _ O
node _ _ O
. _ _ O
o _ _ O
when _ _ O
we _ _ O
enter _ _ O
visit_node _ _ O
, _ _ O
we _ _ O
know _ _ O
that _ _ O
n _ _ O
is _ _ O
reachable _ _ O
… _ _ O
o _ _ O
… _ _ O
and _ _ O
that _ _ O
reachability _ _ O
is _ _ O
transferred _ _ O
to _ _ O
its _ _ O
successors _ _ O
. _ _ O
● _ _ O
a _ _ O
forward _ _ O
analysis _ _ O
spreads _ _ O
this _ _ O
knowledge _ _ O
forward _ _ O
with _ _ O
the _ _ O
edges _ _ O
: _ _ O
from _ _ O
the _ _ O
predecessors _ _ O
to _ _ O
the _ _ O
successors _ _ O
. _ _ O
o _ _ O
a _ _ O
backward _ _ O
analysis _ _ O
does _ _ O
the _ _ O
opposite _ _ O
– _ _ O
from _ _ O
successors _ _ O
to _ _ O
predecessors _ _ O
– _ _ O
but _ _ O
we _ _ O
wo _ _ O
n't _ _ O
see _ _ O
one _ _ O
of _ _ O
those _ _ O
until _ _ O
next _ _ O
time _ _ O
. _ _ O
● _ _ O
so _ _ O
: _ _ O
let _ _ O
's _ _ O
use _ _ O
this _ _ O
new _ _ O
knowledge _ _ O
to _ _ O
solve _ _ O
the _ _ O
problems _ _ O
we _ _ O
encountered _ _ O
before _ _ O
! _ _ O
16 _ _ O

Global _ _ O
Constant _ _ O
Copy _ _ O
Propagation _ _ O
( _ _ O
GCCP _ _ O
) _ _ O
17 _ _ O

Defs _ _ O
and _ _ O
Uses _ _ O
● _ _ O
a _ _ O
def _ _ O
of _ _ O
a _ _ O
variable _ _ O
is _ _ O
when _ _ O
you _ _ O
assign _ _ O
it _ _ O
( _ _ O
it _ _ O
appears _ _ O
on _ _ O
= _ _ O
's _ _ O
LHS _ _ O
) _ _ O
. _ _ O
o _ _ O
defs _ _ O
of _ _ O
x _ _ O
: _ _ O
x _ _ O
= _ _ O
0 _ _ O
, _ _ O
x _ _ O
= _ _ O
y _ _ O
● _ _ O
a _ _ O
use _ _ O
of _ _ O
a _ _ O
variable _ _ O
is _ _ O
when _ _ O
you _ _ O
get _ _ O
its _ _ O
value _ _ O
. _ _ O
o _ _ O
uses _ _ O
of _ _ O
x _ _ O
: _ _ O
z _ _ O
= _ _ O
x _ _ O
, _ _ O
if _ _ O
x _ _ O
, _ _ O
f _ _ O
( _ _ O
x _ _ O
) _ _ O
● _ _ O
we _ _ O
'll _ _ O
use _ _ O
def-use _ _ O
to _ _ O
mean _ _ O
a _ _ O
pair _ _ O
of _ _ O
def _ _ O
and _ _ O
use _ _ O
, _ _ O
where _ _ O
the _ _ O
def _ _ O
sets _ _ O
the _ _ O
value _ _ O
that _ _ O
the _ _ O
use _ _ O
gets _ _ O
. _ _ O
x _ _ O
= _ _ O
3 _ _ O
y _ _ O
= _ _ O
5 _ _ O
z _ _ O
= _ _ O
a _ _ O
+ _ _ O
b _ _ O
f _ _ O
( _ _ O
x _ _ O
) _ _ O
here _ _ O
's _ _ O
a _ _ O
def-use _ _ O
. _ _ O
x _ _ O
= _ _ O
3 _ _ O
x _ _ O
= _ _ O
5 _ _ O
f _ _ O
( _ _ O
x _ _ O
) _ _ O
there _ _ O
can _ _ O
be _ _ O
multiple _ _ O
defs _ _ O
for _ _ O
one _ _ O
use _ _ O
, _ _ O
too _ _ O
. _ _ O
18 _ _ O

What _ _ O
is _ _ O
Global _ _ O
Constant _ _ O
Copy _ _ O
Propagation _ _ O
? _ _ O
● _ _ O
remember _ _ O
that _ _ O
copy _ _ O
propagation _ _ O
said _ _ O
that _ _ O
if _ _ O
we _ _ O
have _ _ O
an _ _ O
instruction _ _ O
of _ _ O
the _ _ O
form _ _ O
” _ _ O
x _ _ O
= _ _ O
y _ _ O
” _ _ O
, _ _ O
and _ _ O
x _ _ O
is _ _ O
never _ _ O
reassigned _ _ O
, _ _ O
then _ _ O
we _ _ O
can _ _ O
replace _ _ O
all _ _ O
uses _ _ O
of _ _ O
x _ _ O
with _ _ O
y. _ _ O
● _ _ O
constant _ _ O
copy _ _ O
propagation _ _ O
is _ _ O
the _ _ O
same _ _ O
thing _ _ O
, _ _ O
but _ _ O
only _ _ O
in _ _ O
the _ _ O
cases _ _ O
where _ _ O
the _ _ O
RHS _ _ O
of _ _ O
” _ _ O
x _ _ O
= _ _ O
y _ _ O
” _ _ O
is _ _ O
a _ _ O
constant _ _ O
. _ _ O
o _ _ O
and _ _ O
global _ _ O
constant _ _ O
copy _ _ O
propagation _ _ O
is _ _ O
that _ _ O
, _ _ O
but _ _ O
applied _ _ O
to _ _ O
the _ _ O
entire _ _ O
CFG _ _ O
instead _ _ O
of _ _ O
just _ _ O
one _ _ O
BB _ _ O
! _ _ O
● _ _ O
for _ _ O
the _ _ O
purposes _ _ O
of _ _ O
this _ _ O
example _ _ O
, _ _ O
we _ _ O
will _ _ O
not _ _ O
be _ _ O
using _ _ O
SSA _ _ O
, _ _ O
so _ _ O
variables _ _ O
can _ _ O
be _ _ O
reassigned _ _ O
. _ _ O
o _ _ O
essentially _ _ O
SSA _ _ O
makes _ _ O
it _ _ O
so _ _ O
every _ _ O
use _ _ O
has _ _ O
exactly _ _ O
one _ _ O
def _ _ O
, _ _ O
which _ _ O
simplifies _ _ O
some _ _ O
things _ _ O
… _ _ O
o _ _ O
but _ _ O
the _ _ O
details _ _ O
of _ _ O
SSA _ _ O
are _ _ O
too _ _ O
much _ _ O
for _ _ O
this _ _ O
course _ _ O
, _ _ O
so _ _ O
we _ _ O
’ll _ _ O
stick _ _ O
with _ _ O
non-SSA _ _ O
for _ _ O
these _ _ O
global _ _ O
optimizations _ _ O
. _ _ O
19 _ _ O

Global _ _ O
Constant _ _ O
Copy _ _ O
Propagation _ _ O
● _ _ O
if _ _ O
we _ _ O
are _ _ O
looking _ _ O
at _ _ O
a _ _ O
use _ _ O
of _ _ O
x _ _ O
… _ _ O
● _ _ O
and _ _ O
, _ _ O
every _ _ O
def _ _ O
for _ _ O
that _ _ O
use _ _ O
of _ _ O
x _ _ O
set _ _ O
it _ _ O
to _ _ O
some _ _ O
constant _ _ O
C _ _ O
… _ _ O
● _ _ O
then _ _ O
, _ _ O
we _ _ O
can _ _ O
replace _ _ O
that _ _ O
use _ _ O
of _ _ O
x _ _ O
with _ _ O
that _ _ O
constant _ _ O
C. _ _ O
bb0 _ _ O
: _ _ O
x _ _ O
= _ _ O
25 _ _ O
if _ _ O
a _ _ O
bb1 _ _ O
else _ _ O
bb2 _ _ O
bb0 _ _ O
: _ _ O
x _ _ O
= _ _ O
25 _ _ O
if _ _ O
a _ _ O
bb1 _ _ O
else _ _ O
bb2 _ _ O
bb1 _ _ O
: _ _ O
f _ _ O
( _ _ O
) _ _ O
goto _ _ O
bb2 _ _ O
bb1 _ _ O
: _ _ O
x _ _ O
= _ _ O
10 _ _ O
goto _ _ O
bb2 _ _ O
bb2 _ _ O
: _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
x _ _ O
return _ _ O
bb2 _ _ O
: _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
x _ _ O
return _ _ O
1 _ _ O
def-use _ _ O
, _ _ O
sets _ _ O
x _ _ O
to _ _ O
25 _ _ O
; _ _ O
we _ _ O
can _ _ O
replace _ _ O
x _ _ O
with _ _ O
25 _ _ O
. _ _ O
2 _ _ O
def-uses _ _ O
; _ _ O
set _ _ O
x _ _ O
to _ _ O
different _ _ O
values _ _ O
; _ _ O
no _ _ O
good _ _ O
. _ _ O
bb0 _ _ O
: _ _ O
x _ _ O
= _ _ O
25 _ _ O
if _ _ O
a _ _ O
bb1 _ _ O
else _ _ O
bb2 _ _ O
bb1 _ _ O
: _ _ O
x _ _ O
= _ _ O
10 _ _ O
goto _ _ O
bb3 _ _ O
bb2 _ _ O
: _ _ O
x _ _ O
= _ _ O
10 _ _ O
goto _ _ O
bb3 _ _ O
bb3 _ _ O
: _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
x _ _ O
return _ _ O
2 _ _ O
def-uses _ _ O
; _ _ O
both _ _ O
set _ _ O
x _ _ O
to _ _ O
same _ _ O
value _ _ O
; _ _ O
we _ _ O
can _ _ O
replace _ _ O
x _ _ O
with _ _ O
10 _ _ O
. _ _ O
20 _ _ O

From _ _ O
the _ _ O
bottom _ _ O
up _ _ O
( _ _ O
animated _ _ O
) _ _ O
● _ _ O
that _ _ O
's _ _ O
cool _ _ O
and _ _ O
all _ _ O
, _ _ O
but _ _ O
how _ _ O
do _ _ O
we _ _ O
start _ _ O
implementing _ _ O
this _ _ O
? _ _ O
● _ _ O
let _ _ O
's _ _ O
start _ _ O
by _ _ O
looking _ _ O
at _ _ O
the _ _ O
instructions _ _ O
within _ _ O
a _ _ O
basic _ _ O
block _ _ O
. _ _ O
we _ _ O
'll _ _ O
focus _ _ O
on _ _ O
the _ _ O
variable _ _ O
x _ _ O
right _ _ O
now _ _ O
. _ _ O
before _ _ O
this _ _ O
code _ _ O
runs _ _ O
, _ _ O
we _ _ O
do _ _ O
n't _ _ O
know _ _ O
what _ _ O
's _ _ O
in _ _ O
x. _ _ O
but _ _ O
each _ _ O
line _ _ O
changes _ _ O
what _ _ O
we _ _ O
know _ _ O
. _ _ O
Knowledge _ _ O
x _ _ O
= _ _ O
? _ _ O
? _ _ O
? _ _ O
x _ _ O
= _ _ O
4 _ _ O
x _ _ O
= _ _ O
4 _ _ O
y _ _ O
= _ _ O
5 _ _ O
x _ _ O
= _ _ O
4 _ _ O
x _ _ O
= _ _ O
f _ _ O
( _ _ O
) _ _ O
x _ _ O
= _ _ O
? _ _ O
? _ _ O
? _ _ O
x _ _ O
= _ _ O
9 _ _ O
x _ _ O
= _ _ O
9 _ _ O
the _ _ O
change _ _ O
in _ _ O
knowledge _ _ O
from _ _ O
one _ _ O
step _ _ O
to _ _ O
the _ _ O
next _ _ O
is _ _ O
formally _ _ O
known _ _ O
as _ _ O
the _ _ O
transfer _ _ O
function _ _ O
. _ _ O
so _ _ O
let _ _ O
's _ _ O
be _ _ O
a _ _ O
bit _ _ O
more _ _ O
rigorous _ _ O
about _ _ O
this _ _ O
. _ _ O
21 _ _ O

Our _ _ O
states _ _ O
and _ _ O
transfer _ _ O
function _ _ O
● _ _ O
the _ _ O
" _ _ O
knowledge _ _ O
" _ _ O
is _ _ O
properly _ _ O
called _ _ O
the _ _ O
state _ _ O
, _ _ O
and _ _ O
we _ _ O
have _ _ O
two _ _ O
states _ _ O
: _ _ O
o _ _ O
x _ _ O
= _ _ O
ANY _ _ O
, _ _ O
meaning _ _ O
that _ _ O
x _ _ O
could _ _ O
be _ _ O
one _ _ O
of _ _ O
several _ _ O
values _ _ O
; _ _ O
and _ _ O
o _ _ O
x _ _ O
= _ _ O
CONST _ _ O
( _ _ O
c _ _ O
) _ _ O
, _ _ O
meaning _ _ O
x _ _ O
holds _ _ O
a _ _ O
constant _ _ O
c. _ _ O
( _ _ O
e.g. _ _ O
CONST _ _ O
( _ _ O
7 _ _ O
) _ _ O
) _ _ O
● _ _ O
each _ _ O
instruction _ _ O
has _ _ O
an _ _ O
in-state _ _ O
and _ _ O
an _ _ O
out-state _ _ O
… _ _ O
o _ _ O
and _ _ O
the _ _ O
out-state _ _ O
of _ _ O
one _ _ O
instruction _ _ O
is _ _ O
the _ _ O
in-state _ _ O
of _ _ O
the _ _ O
next _ _ O
. _ _ O
● _ _ O
the _ _ O
transfer _ _ O
function _ _ O
takes _ _ O
an _ _ O
instruction _ _ O
and _ _ O
its _ _ O
in-state _ _ O
, _ _ O
and _ _ O
produces _ _ O
its _ _ O
out-state _ _ O
. _ _ O
● _ _ O
the _ _ O
transfer _ _ O
function _ _ O
here _ _ O
is _ _ O
simple _ _ O
: _ _ O
o _ _ O
if _ _ O
the _ _ O
instruction _ _ O
is _ _ O
of _ _ O
the _ _ O
form _ _ O
x _ _ O
= _ _ O
c _ _ O
for _ _ O
some _ _ O
constant _ _ O
c _ _ O
, _ _ O
▪ _ _ O
then _ _ O
the _ _ O
out-state _ _ O
is _ _ O
CONST _ _ O
( _ _ O
c _ _ O
) _ _ O
. _ _ O
o _ _ O
else _ _ O
, _ _ O
if _ _ O
the _ _ O
instruction _ _ O
is _ _ O
of _ _ O
the _ _ O
form _ _ O
x _ _ O
= _ _ O
… _ _ O
for _ _ O
any _ _ O
other _ _ O
RHS _ _ O
, _ _ O
▪ _ _ O
then _ _ O
the _ _ O
out-state _ _ O
is _ _ O
ANY _ _ O
. _ _ O
o _ _ O
else _ _ O
, _ _ O
the _ _ O
out-state _ _ O
is _ _ O
the _ _ O
in-state _ _ O
, _ _ O
unmodified _ _ O
. _ _ O
22 _ _ O

Lather _ _ O
, _ _ O
rinse _ _ O
, _ _ O
repeat _ _ O
● _ _ O
we _ _ O
can _ _ O
use _ _ O
this _ _ O
transfer _ _ O
function _ _ O
to _ _ O
compute _ _ O
the _ _ O
out-state _ _ O
for _ _ O
a _ _ O
basic _ _ O
block _ _ O
as _ _ O
a _ _ O
whole _ _ O
, _ _ O
as _ _ O
well _ _ O
. _ _ O
x _ _ O
= _ _ O
ANY _ _ O
x _ _ O
= _ _ O
CONST _ _ O
( _ _ O
4 _ _ O
) _ _ O
x _ _ O
= _ _ O
CONST _ _ O
( _ _ O
4 _ _ O
) _ _ O
x _ _ O
= _ _ O
ANY _ _ O
x _ _ O
= _ _ O
CONST _ _ O
( _ _ O
9 _ _ O
) _ _ O
x _ _ O
= _ _ O
CONST _ _ O
( _ _ O
9 _ _ O
) _ _ O
there _ _ O
is _ _ O
some _ _ O
in-state _ _ O
for _ _ O
this _ _ O
BB _ _ O
. _ _ O
x _ _ O
= _ _ O
4 _ _ O
y _ _ O
= _ _ O
5 _ _ O
x _ _ O
= _ _ O
f _ _ O
( _ _ O
) _ _ O
x _ _ O
= _ _ O
9 _ _ O
y _ _ O
= _ _ O
g _ _ O
( _ _ O
) _ _ O
goto _ _ O
bb7 _ _ O
x _ _ O
= _ _ O
CONST _ _ O
( _ _ O
9 _ _ O
) _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
x _ _ O
return _ _ O
we _ _ O
repeatedly _ _ O
apply _ _ O
the _ _ O
transfer _ _ O
function _ _ O
to _ _ O
the _ _ O
instructions _ _ O
inside _ _ O
… _ _ O
and _ _ O
that _ _ O
gives _ _ O
us _ _ O
the _ _ O
BB _ _ O
's _ _ O
out-state _ _ O
. _ _ O
and _ _ O
as _ _ O
you _ _ O
might _ _ O
imagine _ _ O
, _ _ O
that _ _ O
can _ _ O
become _ _ O
the _ _ O
in-state _ _ O
for _ _ O
the _ _ O
next _ _ O
BB _ _ O
! _ _ O
… _ _ O
but _ _ O
wait _ _ O
, _ _ O
BBs _ _ O
can _ _ O
have _ _ O
multiple _ _ O
predecessors _ _ O
. _ _ O
23 _ _ O

The _ _ O
join _ _ O
function _ _ O
● _ _ O
a _ _ O
BB _ _ O
's _ _ O
predecessors _ _ O
may _ _ O
all _ _ O
be _ _ O
feeding _ _ O
different _ _ O
states _ _ O
into _ _ O
it _ _ O
. _ _ O
● _ _ O
the _ _ O
join _ _ O
function _ _ O
combines _ _ O
those _ _ O
states _ _ O
to _ _ O
produce _ _ O
a _ _ O
BB _ _ O
's _ _ O
in-state _ _ O
. _ _ O
● _ _ O
let _ _ O
's _ _ O
look _ _ O
at _ _ O
some _ _ O
examples _ _ O
. _ _ O
the _ _ O
labels _ _ O
are _ _ O
the _ _ O
state _ _ O
for _ _ O
x. _ _ O
x _ _ O
= _ _ O
5 _ _ O
CONST _ _ O
( _ _ O
5 _ _ O
) _ _ O
x _ _ O
= _ _ O
f _ _ O
( _ _ O
) _ _ O
ANY _ _ O
so _ _ O
, _ _ O
red _ _ O
's _ _ O
in-state _ _ O
must _ _ O
be _ _ O
x _ _ O
= _ _ O
ANY _ _ O
. _ _ O
x _ _ O
= _ _ O
5 _ _ O
CONST _ _ O
( _ _ O
5 _ _ O
) _ _ O
x _ _ O
= _ _ O
3 _ _ O
CONST _ _ O
( _ _ O
3 _ _ O
) _ _ O
still _ _ O
, _ _ O
red _ _ O
's _ _ O
in-state _ _ O
must _ _ O
be _ _ O
x _ _ O
= _ _ O
ANY _ _ O
. _ _ O
x _ _ O
= _ _ O
3 _ _ O
CONST _ _ O
( _ _ O
3 _ _ O
) _ _ O
x _ _ O
= _ _ O
3 _ _ O
CONST _ _ O
( _ _ O
3 _ _ O
) _ _ O
success _ _ O
! _ _ O
red _ _ O
's _ _ O
in-state _ _ O
is _ _ O
x _ _ O
= _ _ O
CONST _ _ O
( _ _ O
3 _ _ O
) _ _ O
. _ _ O
so _ _ O
: _ _ O
if _ _ O
all _ _ O
the _ _ O
predecessors _ _ O
say _ _ O
CONST _ _ O
( _ _ O
c _ _ O
) _ _ O
for _ _ O
the _ _ O
same _ _ O
constant _ _ O
c _ _ O
, _ _ O
then _ _ O
the _ _ O
in-state _ _ O
is _ _ O
CONST _ _ O
( _ _ O
c _ _ O
) _ _ O
; _ _ O
otherwise _ _ O
, _ _ O
it _ _ O
's _ _ O
ANY _ _ O
. _ _ O
24 _ _ O

Let _ _ O
's _ _ O
try _ _ O
it _ _ O
out _ _ O
! _ _ O
● _ _ O
here _ _ O
are _ _ O
two _ _ O
functions _ _ O
from _ _ O
before _ _ O
. _ _ O
let _ _ O
's _ _ O
annotate _ _ O
the _ _ O
edges _ _ O
with _ _ O
the _ _ O
state _ _ O
for _ _ O
x. _ _ O
x _ _ O
= _ _ O
25 _ _ O
if _ _ O
a _ _ O
bb1 _ _ O
else _ _ O
bb2 _ _ O
x _ _ O
= _ _ O
25 _ _ O
if _ _ O
a _ _ O
bb1 _ _ O
else _ _ O
bb2 _ _ O
CONST _ _ O
( _ _ O
25 _ _ O
) _ _ O
x _ _ O
= _ _ O
10 _ _ O
CONST _ _ O
( _ _ O
25 _ _ O
) _ _ O
CONST _ _ O
( _ _ O
25 _ _ O
) _ _ O
x _ _ O
= _ _ O
10 _ _ O
CONST _ _ O
( _ _ O
25 _ _ O
) _ _ O
x _ _ O
= _ _ O
10 _ _ O
CONST _ _ O
( _ _ O
10 _ _ O
) _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
x _ _ O
CONST _ _ O
( _ _ O
10 _ _ O
) _ _ O
return _ _ O
CONST _ _ O
( _ _ O
10 _ _ O
) _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
x _ _ O
return _ _ O
so _ _ O
, _ _ O
red _ _ O
's _ _ O
in-state _ _ O
must _ _ O
be _ _ O
x _ _ O
= _ _ O
ANY _ _ O
. _ _ O
so _ _ O
, _ _ O
red _ _ O
's _ _ O
in-state _ _ O
is _ _ O
x _ _ O
= _ _ O
CONST _ _ O
( _ _ O
10 _ _ O
) _ _ O
! _ _ O
problem _ _ O
solved _ _ O
! _ _ O
............ _ _ O
right _ _ O
? _ _ O
25 _ _ O

The _ _ O
catch _ _ O
● _ _ O
let _ _ O
's _ _ O
try _ _ O
it _ _ O
on _ _ O
this _ _ O
CFG _ _ O
! _ _ O
again _ _ O
, _ _ O
we _ _ O
're _ _ O
annotating _ _ O
the _ _ O
state _ _ O
for _ _ O
x. _ _ O
x _ _ O
= _ _ O
10 _ _ O
i _ _ O
= _ _ O
0 _ _ O
wait _ _ O
, _ _ O
there _ _ O
's _ _ O
nothing _ _ O
on _ _ O
this _ _ O
edge _ _ O
. _ _ O
then _ _ O
how _ _ O
do _ _ O
we _ _ O
compute _ _ O
the _ _ O
in-state _ _ O
for _ _ O
the _ _ O
orange _ _ O
BB _ _ O
? _ _ O
and _ _ O
if _ _ O
we _ _ O
try _ _ O
to _ _ O
follow _ _ O
it _ _ O
backwards _ _ O
, _ _ O
we _ _ O
end _ _ O
up _ _ O
back _ _ O
at _ _ O
the _ _ O
same _ _ O
orange _ _ O
BB _ _ O
! _ _ O
CONST _ _ O
( _ _ O
10 _ _ O
) _ _ O
$ _ _ O
t1 _ _ O
= _ _ O
i _ _ O
< _ _ O
10 _ _ O
if _ _ O
$ _ _ O
t1 _ _ O
bb2 _ _ O
else _ _ O
bb3 _ _ O
print _ _ O
( _ _ O
"ha _ _ O
" _ _ O
) _ _ O
i _ _ O
= _ _ O
i _ _ O
+ _ _ O
1 _ _ O
IT _ _ O
KEEPS _ _ O
HAPPENING _ _ O
! _ _ O
I _ _ O
TOLD _ _ O
YOU _ _ O
ABOUT _ _ O
CYCLIC _ _ O
GRAPHS _ _ O
BRO _ _ O
! _ _ O
! _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
x _ _ O
return _ _ O
26 _ _ O

Fixing _ _ O
it _ _ O
27 _ _ O

Oh _ _ O
yeah _ _ O
, _ _ O
we _ _ O
forgot _ _ O
a _ _ O
state _ _ O
● _ _ O
we _ _ O
need _ _ O
one _ _ O
more _ _ O
state _ _ O
to _ _ O
indicate _ _ O
that _ _ O
we _ _ O
have _ _ O
n't _ _ O
visited _ _ O
that _ _ O
instruction _ _ O
/ _ _ O
BB _ _ O
, _ _ O
UNK _ _ O
for _ _ O
" _ _ O
unknown _ _ O
. _ _ O
" _ _ O
● _ _ O
it _ _ O
will _ _ O
be _ _ O
the _ _ O
initial _ _ O
value _ _ O
: _ _ O
every _ _ O
instruction _ _ O
/ _ _ O
BB _ _ O
's _ _ O
in-state _ _ O
and _ _ O
outstate _ _ O
will _ _ O
be _ _ O
set _ _ O
to _ _ O
UNK _ _ O
before _ _ O
the _ _ O
algorithm _ _ O
begins _ _ O
. _ _ O
● _ _ O
our _ _ O
transfer _ _ O
function _ _ O
is _ _ O
n't _ _ O
going _ _ O
to _ _ O
have _ _ O
to _ _ O
change _ _ O
, _ _ O
fortunately _ _ O
. _ _ O
o _ _ O
it _ _ O
implicitly _ _ O
handles _ _ O
UNK _ _ O
in _ _ O
the _ _ O
" _ _ O
else _ _ O
" _ _ O
case _ _ O
: _ _ O
unknown _ _ O
in _ _ O
, _ _ O
unknown _ _ O
out _ _ O
! _ _ O
● _ _ O
but _ _ O
there _ _ O
's _ _ O
the _ _ O
other _ _ O
function _ _ O
… _ _ O
28 _ _ O

The _ _ O
new _ _ O
, _ _ O
improved _ _ O
join _ _ O
function _ _ O
● _ _ O
here _ _ O
's _ _ O
where _ _ O
things _ _ O
get _ _ O
a _ _ O
bit _ _ O
weird _ _ O
, _ _ O
but _ _ O
it _ _ O
will _ _ O
all _ _ O
work _ _ O
out _ _ O
. _ _ O
if _ _ O
any _ _ O
predecessor _ _ O
says _ _ O
x _ _ O
= _ _ O
ANY _ _ O
, _ _ O
then _ _ O
the _ _ O
output _ _ O
is _ _ O
x _ _ O
= _ _ O
ANY _ _ O
. _ _ O
p1 _ _ O
: _ _ O
x _ _ O
= _ _ O
CONST _ _ O
( _ _ O
10 _ _ O
) _ _ O
p2 _ _ O
: _ _ O
x _ _ O
= _ _ O
CONST _ _ O
( _ _ O
4 _ _ O
) _ _ O
p3 _ _ O
: _ _ O
x _ _ O
= _ _ O
ANY _ _ O
p4 _ _ O
: _ _ O
x _ _ O
= _ _ O
UNK _ _ O
x _ _ O
= _ _ O
ANY _ _ O
if _ _ O
all _ _ O
predecessors _ _ O
say _ _ O
x _ _ O
= _ _ O
UNK _ _ O
, _ _ O
then _ _ O
the _ _ O
output _ _ O
is _ _ O
x _ _ O
= _ _ O
UNK _ _ O
. _ _ O
p1 _ _ O
: _ _ O
x _ _ O
= _ _ O
UNK _ _ O
p2 _ _ O
: _ _ O
x _ _ O
= _ _ O
UNK _ _ O
p3 _ _ O
: _ _ O
x _ _ O
= _ _ O
UNK _ _ O
p4 _ _ O
: _ _ O
x _ _ O
= _ _ O
UNK _ _ O
x _ _ O
= _ _ O
UNK _ _ O
if _ _ O
the _ _ O
predecessors _ _ O
are _ _ O
a _ _ O
mix _ _ O
of _ _ O
x _ _ O
= _ _ O
UNK _ _ O
and _ _ O
x _ _ O
= _ _ O
CONST _ _ O
, _ _ O
then _ _ O
ignore _ _ O
the _ _ O
UNKs _ _ O
, _ _ O
and _ _ O
the _ _ O
output _ _ O
is _ _ O
CONST _ _ O
or _ _ O
ANY _ _ O
like _ _ O
before _ _ O
. _ _ O
p1 _ _ O
: _ _ O
x _ _ O
= _ _ O
UNK _ _ O
p2 _ _ O
: _ _ O
x _ _ O
= _ _ O
CONST _ _ O
( _ _ O
3 _ _ O
) _ _ O
p3 _ _ O
: _ _ O
x _ _ O
= _ _ O
UNK _ _ O
p4 _ _ O
: _ _ O
x _ _ O
= _ _ O
CONST _ _ O
( _ _ O
3 _ _ O
) _ _ O
x _ _ O
= _ _ O
CONST _ _ O
( _ _ O
3 _ _ O
) _ _ O
29 _ _ O

Let _ _ O
's _ _ O
watch _ _ O
it _ _ O
go _ _ O
( _ _ O
animated _ _ O
, _ _ O
important _ _ O
, _ _ O
you _ _ O
have _ _ O
to _ _ O
watch _ _ O
this _ _ O
) _ _ O
● _ _ O
if _ _ O
these _ _ O
rules _ _ O
seem _ _ O
strange _ _ O
, _ _ O
wait _ _ O
till _ _ O
you _ _ O
see _ _ O
how _ _ O
it _ _ O
behaves _ _ O
. _ _ O
● _ _ O
notice _ _ O
that _ _ O
x _ _ O
starts _ _ O
off _ _ O
as _ _ O
UNK _ _ O
everywhere _ _ O
. _ _ O
guess _ _ O
what _ _ O
: _ _ O
we _ _ O
are _ _ O
visiting _ _ O
this _ _ O
orange _ _ O
BB _ _ O
a _ _ O
second _ _ O
time _ _ O
! _ _ O
UNK _ _ O
x _ _ O
= _ _ O
10 _ _ O
i _ _ O
= _ _ O
0 _ _ O
UNK _ _ O
CONST _ _ O
( _ _ O
10 _ _ O
) _ _ O
join _ _ O
( _ _ O
CONST _ _ O
( _ _ O
10 _ _ O
) _ _ O
, _ _ O
join _ _ O
( _ _ O
CONST _ _ O
( _ _ O
10 _ _ O
) _ _ O
, _ _ O
CONST _ _ O
( _ _ O
10 _ _ O
) _ _ O
) _ _ O
UNK _ _ O
) _ _ O
= _ _ O
CONST _ _ O
( _ _ O
10 _ _ O
) _ _ O
$ _ _ O
t1 _ _ O
= _ _ O
i _ _ O
< _ _ O
10 _ _ O
if _ _ O
$ _ _ O
t1 _ _ O
bb2 _ _ O
else _ _ O
bb3 _ _ O
CONST _ _ O
( _ _ O
10 _ _ O
) _ _ O
UNK _ _ O
but _ _ O
no _ _ O
more _ _ O
changes _ _ O
occur _ _ O
. _ _ O
we _ _ O
have _ _ O
reached _ _ O
equilibrium _ _ O
: _ _ O
the _ _ O
algorithm _ _ O
is _ _ O
done _ _ O
. _ _ O
CONST _ _ O
( _ _ O
10 _ _ O
) _ _ O
UNK _ _ O
CONST _ _ O
( _ _ O
10 _ _ O
) _ _ O
UNK _ _ O
print _ _ O
( _ _ O
"ha _ _ O
" _ _ O
) _ _ O
i _ _ O
= _ _ O
i _ _ O
+ _ _ O
1 _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
x _ _ O
return _ _ O
30 _ _ O

Sometimes _ _ O
one _ _ O
visit _ _ O
is _ _ O
not _ _ O
enough _ _ O
● _ _ O
because _ _ O
each _ _ O
visit _ _ O
to _ _ O
a _ _ O
BB _ _ O
might _ _ O
move _ _ O
it _ _ O
from _ _ O
one _ _ O
set _ _ O
( _ _ O
UNK _ _ O
) _ _ O
to _ _ O
another _ _ O
( _ _ O
say _ _ O
, _ _ O
CONST _ _ O
( _ _ O
10 _ _ O
) _ _ O
) _ _ O
… _ _ O
and _ _ O
because _ _ O
we _ _ O
have _ _ O
three _ _ O
sets _ _ O
… _ _ O
o _ _ O
then _ _ O
we _ _ O
may _ _ O
have _ _ O
to _ _ O
visit _ _ O
a _ _ O
BB _ _ O
more _ _ O
than _ _ O
one _ _ O
time _ _ O
! _ _ O
● _ _ O
we _ _ O
're _ _ O
not _ _ O
risking _ _ O
an _ _ O
infinite _ _ O
loop _ _ O
though _ _ O
. _ _ O
why _ _ O
? _ _ O
CONST _ _ O
UNK _ _ O
we _ _ O
have _ _ O
a _ _ O
finite _ _ O
number _ _ O
of _ _ O
states _ _ O
( _ _ O
3 _ _ O
) _ _ O
, _ _ O
and _ _ O
the _ _ O
transitions _ _ O
between _ _ O
them _ _ O
are _ _ O
unidirectional _ _ O
. _ _ O
ANY _ _ O
that _ _ O
's _ _ O
all _ _ O
we _ _ O
need _ _ O
to _ _ O
prove _ _ O
to _ _ O
guarantee _ _ O
termination _ _ O
. _ _ O
nice _ _ O
. _ _ O
31 _ _ O

Shortcomings _ _ O
( _ _ O
animated _ _ O
) _ _ O
● _ _ O
now _ _ O
let _ _ O
's _ _ O
see _ _ O
what _ _ O
happens _ _ O
when _ _ O
we _ _ O
reassign _ _ O
x _ _ O
in _ _ O
the _ _ O
loop _ _ O
. _ _ O
UNK _ _ O
x _ _ O
= _ _ O
10 _ _ O
i _ _ O
= _ _ O
0 _ _ O
UNK _ _ O
CONST _ _ O
( _ _ O
10 _ _ O
) _ _ O
join _ _ O
( _ _ O
CONST _ _ O
( _ _ O
10 _ _ O
) _ _ O
, _ _ O
join _ _ O
( _ _ O
CONST _ _ O
( _ _ O
10 _ _ O
) _ _ O
, _ _ O
CONST _ _ O
( _ _ O
20 _ _ O
) _ _ O
) _ _ O
UNK _ _ O
) _ _ O
= _ _ O
CONST _ _ O
( _ _ O
10 _ _ O
) _ _ O
= _ _ O
ANY _ _ O
$ _ _ O
t1 _ _ O
= _ _ O
i _ _ O
< _ _ O
10 _ _ O
what _ _ O
happened _ _ O
? _ _ O
well _ _ O
, _ _ O
it _ _ O
CONST _ _ O
( _ _ O
20 _ _ O
) _ _ O
UNK _ _ O
determined _ _ O
that _ _ O
at _ _ O
the _ _ O
start _ _ O
of _ _ O
the _ _ O
orange _ _ O
BB _ _ O
, _ _ O
x _ _ O
could _ _ O
be _ _ O
10 _ _ O
or _ _ O
20 _ _ O
. _ _ O
so _ _ O
it _ _ O
assumes _ _ O
it _ _ O
's _ _ O
ANY _ _ O
from _ _ O
then _ _ O
on _ _ O
. _ _ O
the _ _ O
algorithm _ _ O
does _ _ O
n't _ _ O
know _ _ O
that _ _ O
this _ _ O
loop _ _ O
always _ _ O
runs _ _ O
. _ _ O
it _ _ O
does _ _ O
n't _ _ O
know _ _ O
anything _ _ O
about _ _ O
loops _ _ O
at _ _ O
all _ _ O
! _ _ O
if _ _ O
$ _ _ O
t1 _ _ O
bb2 _ _ O
else _ _ O
bb3 _ _ O
CONST _ _ O
( _ _ O
10 _ _ O
) _ _ O
UNK _ _ O
ANY _ _ O
CONST _ _ O
( _ _ O
10 _ _ O
) _ _ O
UNK _ _ O
ANY _ _ O
x _ _ O
= _ _ O
20 _ _ O
i _ _ O
= _ _ O
i _ _ O
+ _ _ O
1 _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
x _ _ O
return _ _ O
32 _ _ O

It _ _ O
never _ _ O
hurts _ _ O
to _ _ O
not _ _ O
optimize _ _ O
● _ _ O
the _ _ O
example _ _ O
on _ _ O
the _ _ O
previous _ _ O
slide _ _ O
is _ _ O
an _ _ O
example _ _ O
of _ _ O
the _ _ O
algorithm _ _ O
being _ _ O
a _ _ O
little _ _ O
cautious _ _ O
. _ _ O
o _ _ O
yeah _ _ O
, _ _ O
we _ _ O
can _ _ O
see _ _ O
that _ _ O
x _ _ O
= _ _ O
20 _ _ O
at _ _ O
the _ _ O
return _ _ O
, _ _ O
but _ _ O
that _ _ O
would _ _ O
n't _ _ O
be _ _ O
true _ _ O
if _ _ O
the _ _ O
loop _ _ O
never _ _ O
ran _ _ O
! _ _ O
o _ _ O
consider _ _ O
a _ _ O
slight _ _ O
modification _ _ O
where _ _ O
the _ _ O
loop _ _ O
upper _ _ O
bound _ _ O
is _ _ O
an _ _ O
argument _ _ O
– _ _ O
in _ _ O
that _ _ O
case _ _ O
, _ _ O
the _ _ O
loop _ _ O
may _ _ O
run _ _ O
0 _ _ O
times _ _ O
. _ _ O
● _ _ O
what _ _ O
you _ _ O
do _ _ O
n't _ _ O
want _ _ O
is _ _ O
for _ _ O
your _ _ O
algorithm _ _ O
to _ _ O
optimize _ _ O
in _ _ O
a _ _ O
situation _ _ O
where _ _ O
it _ _ O
should _ _ O
n't _ _ O
. _ _ O
o _ _ O
cause _ _ O
that _ _ O
's _ _ O
a _ _ O
broken _ _ O
proof _ _ O
, _ _ O
and _ _ O
you _ _ O
'll _ _ O
get _ _ O
a _ _ O
broken _ _ O
program _ _ O
. _ _ O
● _ _ O
sometimes _ _ O
an _ _ O
optimization _ _ O
pass _ _ O
wo _ _ O
n't _ _ O
find _ _ O
anything _ _ O
to _ _ O
do _ _ O
. _ _ O
o _ _ O
that _ _ O
's _ _ O
okay _ _ O
. _ _ O
there _ _ O
's _ _ O
no _ _ O
judgment _ _ O
. _ _ O
it _ _ O
ca _ _ O
n't _ _ O
know _ _ O
until _ _ O
it _ _ O
tries _ _ O
. _ _ O
● _ _ O
and _ _ O
if _ _ O
it _ _ O
does _ _ O
n't _ _ O
optimize _ _ O
anything _ _ O
, _ _ O
you _ _ O
'll _ _ O
still _ _ O
have _ _ O
a _ _ O
correct _ _ O
program _ _ O
. _ _ O
33 _ _ O

Summing _ _ O
it _ _ O
up _ _ O
● _ _ O
to _ _ O
recap _ _ O
how _ _ O
dataflow _ _ O
analysis _ _ O
works _ _ O
: _ _ O
join _ _ O
( _ _ O
p1 _ _ O
, _ _ O
p2 _ _ O
, _ _ O
p3 _ _ O
) _ _ O
in-state _ _ O
the _ _ O
transfer _ _ O
function _ _ O
is _ _ O
repeatedly _ _ O
applied _ _ O
to _ _ O
its _ _ O
instructions _ _ O
, _ _ O
which _ _ O
computes _ _ O
the _ _ O
BB _ _ O
's _ _ O
out-state _ _ O
. _ _ O
inst1 _ _ O
inst2 _ _ O
inst3 _ _ O
inst4 _ _ O
inst5 _ _ O
goto _ _ O
bb2 _ _ O
out-state _ _ O
state _ _ O
flows _ _ O
from _ _ O
a _ _ O
BB _ _ O
's _ _ O
predecessors _ _ O
into _ _ O
its _ _ O
join _ _ O
function _ _ O
, _ _ O
which _ _ O
computes _ _ O
the _ _ O
in-state _ _ O
for _ _ O
the _ _ O
BB _ _ O
. _ _ O
this _ _ O
is _ _ O
repeated _ _ O
for _ _ O
every _ _ O
BB _ _ O
until _ _ O
the _ _ O
in- _ _ O
and _ _ O
outstates _ _ O
reach _ _ O
equilibrium _ _ O
: _ _ O
they _ _ O
stop _ _ O
changing _ _ O
. _ _ O
as _ _ O
long _ _ O
as _ _ O
there _ _ O
are _ _ O
a _ _ O
finite _ _ O
number _ _ O
of _ _ O
states _ _ O
, _ _ O
and _ _ O
they _ _ O
change _ _ O
monotonically _ _ O
, _ _ O
this _ _ O
algorithm _ _ O
will _ _ O
terminate _ _ O
. _ _ O
34 _ _ O

Liveness _ _ O
time _ _ O
check _ _ O
≤ _ _ O
87 _ _ O
35 _ _ O

Liveness _ _ O
● _ _ O
a _ _ O
local _ _ O
variable _ _ O
is _ _ O
live _ _ O
if _ _ O
its _ _ O
value _ _ O
will _ _ O
be _ _ O
used _ _ O
in _ _ O
the _ _ O
future _ _ O
. _ _ O
o _ _ O
this _ _ O
is _ _ O
not _ _ O
its _ _ O
lifetime _ _ O
; _ _ O
liveness _ _ O
can _ _ O
be _ _ O
– _ _ O
and _ _ O
often _ _ O
is _ _ O
– _ _ O
shorter _ _ O
! _ _ O
● _ _ O
it _ _ O
lasts _ _ O
from _ _ O
a _ _ O
def _ _ O
until _ _ O
the _ _ O
last _ _ O
use _ _ O
of _ _ O
that _ _ O
def _ _ O
. _ _ O
arg _ _ O
is _ _ O
only _ _ O
used _ _ O
once _ _ O
on _ _ O
the _ _ O
first _ _ O
line _ _ O
, _ _ O
so _ _ O
it _ _ O
's _ _ O
dead _ _ O
after _ _ O
that _ _ O
. _ _ O
arguments _ _ O
are _ _ O
" _ _ O
def _ _ O
' _ _ O
ed _ _ O
" _ _ O
at _ _ O
the _ _ O
start _ _ O
of _ _ O
the _ _ O
function _ _ O
. _ _ O
arg _ _ O
ret _ _ O
fn _ _ O
lifey _ _ O
( _ _ O
arg _ _ O
: _ _ O
int _ _ O
) _ _ O
: _ _ O
int _ _ O
{ _ _ O
let _ _ O
ret _ _ O
= _ _ O
arg _ _ O
+ _ _ O
10 _ _ O
; _ _ O
ret _ _ O
becomes _ _ O
live _ _ O
when _ _ O
we _ _ O
declare _ _ O
it _ _ O
, _ _ O
and _ _ O
lives _ _ O
until _ _ O
its _ _ O
last _ _ O
use _ _ O
in _ _ O
the _ _ O
return _ _ O
statement _ _ O
. _ _ O
println_i _ _ O
( _ _ O
ret _ _ O
) _ _ O
; _ _ O
return _ _ O
ret _ _ O
; _ _ O
} _ _ O
these _ _ O
lines _ _ O
are _ _ O
the _ _ O
locals _ _ O
' _ _ O
liveness _ _ O
ranges _ _ O
. _ _ O
36 _ _ O

One _ _ O
local _ _ O
, _ _ O
many _ _ O
ranges _ _ O
● _ _ O
sometimes _ _ O
, _ _ O
a _ _ O
local _ _ O
can _ _ O
be _ _ O
live _ _ O
and _ _ O
dead _ _ O
multiple _ _ O
times _ _ O
! _ _ O
x _ _ O
x _ _ O
is _ _ O
live _ _ O
twice _ _ O
in _ _ O
this _ _ O
code _ _ O
… _ _ O
with _ _ O
a _ _ O
sort _ _ O
of _ _ O
" _ _ O
dead _ _ O
zone _ _ O
" _ _ O
in _ _ O
between _ _ O
. _ _ O
this _ _ O
seems _ _ O
weird _ _ O
, _ _ O
but _ _ O
it _ _ O
's _ _ O
telling _ _ O
us _ _ O
something _ _ O
useful _ _ O
: _ _ O
x _ _ O
is _ _ O
behaving _ _ O
like _ _ O
two _ _ O
different _ _ O
variables _ _ O
in _ _ O
this _ _ O
code _ _ O
. _ _ O
let _ _ O
x _ _ O
= _ _ O
10 _ _ O
; _ _ O
println_i _ _ O
( _ _ O
x _ _ O
) _ _ O
; _ _ O
println_s _ _ O
( _ _ O
" _ _ O
? _ _ O
" _ _ O
) _ _ O
; _ _ O
x _ _ O
= _ _ O
20 _ _ O
; _ _ O
println_i _ _ O
( _ _ O
x _ _ O
) _ _ O
; _ _ O
( _ _ O
remember _ _ O
SSA _ _ O
? _ _ O
this _ _ O
feels _ _ O
like _ _ O
a _ _ O
step _ _ O
towards _ _ O
it _ _ O
… _ _ O
) _ _ O
liveness _ _ O
is _ _ O
the _ _ O
basis _ _ O
for _ _ O
a _ _ O
lot _ _ O
of _ _ O
other _ _ O
optimizations _ _ O
( _ _ O
and _ _ O
error _ _ O
checking _ _ O
! _ _ O
) _ _ O
, _ _ O
and _ _ O
we _ _ O
'll _ _ O
see _ _ O
other _ _ O
examples _ _ O
along _ _ O
the _ _ O
way _ _ O
. _ _ O
37 _ _ O

Two _ _ O
perspectives _ _ O
i _ _ O
obj _ _ O
now _ _ O
we _ _ O
can _ _ O
answer _ _ O
: _ _ O
at _ _ O
any _ _ O
point _ _ O
in _ _ O
this _ _ O
function _ _ O
, _ _ O
which _ _ O
variables _ _ O
are _ _ O
live _ _ O
? _ _ O
found _ _ O
n _ _ O
val _ _ O
l _ _ O
● _ _ O
we _ _ O
already _ _ O
saw _ _ O
that _ _ O
we _ _ O
can _ _ O
view _ _ O
liveness _ _ O
as _ _ O
a _ _ O
set _ _ O
of _ _ O
ranges _ _ O
of _ _ O
instructions _ _ O
( _ _ O
and _ _ O
basic _ _ O
blocks _ _ O
) _ _ O
during _ _ O
which _ _ O
a _ _ O
variable _ _ O
is _ _ O
live _ _ O
. _ _ O
● _ _ O
but _ _ O
another _ _ O
view _ _ O
becomes _ _ O
useful _ _ O
when _ _ O
you _ _ O
have _ _ O
multiple _ _ O
variables _ _ O
. _ _ O
this _ _ O
is _ _ O
very _ _ O
relevant _ _ O
to _ _ O
register _ _ O
allocation _ _ O
, _ _ O
since _ _ O
we _ _ O
're _ _ O
trying _ _ O
to _ _ O
map _ _ O
these _ _ O
variables _ _ O
onto _ _ O
the _ _ O
limited _ _ O
CPU _ _ O
registers _ _ O
. _ _ O
fn _ _ O
has _ _ O
( _ _ O
l _ _ O
: _ _ O
List _ _ O
, _ _ O
val _ _ O
: _ _ O
int _ _ O
) _ _ O
: _ _ O
bool _ _ O
{ _ _ O
let _ _ O
n _ _ O
= _ _ O
l.length _ _ O
( _ _ O
) _ _ O
; _ _ O
let _ _ O
found _ _ O
= _ _ O
false _ _ O
; _ _ O
for _ _ O
i _ _ O
in _ _ O
0 _ _ O
, _ _ O
n _ _ O
{ _ _ O
let _ _ O
obj _ _ O
= _ _ O
l.get _ _ O
( _ _ O
i _ _ O
) _ _ O
; _ _ O
if _ _ O
obj.value _ _ O
( _ _ O
) _ _ O
= _ _ O
= _ _ O
val _ _ O
{ _ _ O
found _ _ O
= _ _ O
true _ _ O
; _ _ O
} _ _ O
} _ _ O
return _ _ O
found _ _ O
; _ _ O
} _ _ O
38 _ _ O

Trying _ _ O
( _ _ O
and _ _ O
failing _ _ O
) _ _ O
to _ _ O
determine _ _ O
liveness _ _ O
● _ _ O
below _ _ O
, _ _ O
the _ _ O
O _ _ O
and _ _ O
X _ _ O
say _ _ O
whether _ _ O
x _ _ O
is _ _ O
alive _ _ O
O _ _ O
or _ _ O
dead _ _ O
X. _ _ O
o _ _ O
the _ _ O
state _ _ O
is _ _ O
tracked _ _ O
between _ _ O
instructions _ _ O
, _ _ O
hence _ _ O
the _ _ O
misalignment _ _ O
. _ _ O
let _ _ O
's _ _ O
assume _ _ O
by _ _ O
default _ _ O
that _ _ O
it _ _ O
's _ _ O
dead _ _ O
. _ _ O
this _ _ O
def _ _ O
seems _ _ O
to _ _ O
make _ _ O
x _ _ O
live _ _ O
. _ _ O
here _ _ O
's _ _ O
a _ _ O
use _ _ O
of _ _ O
x. _ _ O
but _ _ O
is _ _ O
x _ _ O
used _ _ O
again _ _ O
after _ _ O
this _ _ O
? _ _ O
let _ _ O
's _ _ O
assume _ _ O
it _ _ O
'll _ _ O
be _ _ O
used _ _ O
again _ _ O
… _ _ O
x _ _ O
= _ _ O
5 _ _ O
println_i _ _ O
( _ _ O
x _ _ O
) _ _ O
y _ _ O
= _ _ O
10 _ _ O
println_i _ _ O
( _ _ O
y _ _ O
) _ _ O
another _ _ O
use _ _ O
. _ _ O
let _ _ O
's _ _ O
keep _ _ O
assuming _ _ O
. _ _ O
z _ _ O
= _ _ O
x _ _ O
= _ _ O
= _ _ O
y _ _ O
println_b _ _ O
( _ _ O
z _ _ O
) _ _ O
uh _ _ O
oh _ _ O
. _ _ O
it _ _ O
's _ _ O
the _ _ O
end _ _ O
. _ _ O
clearly _ _ O
, _ _ O
x _ _ O
's _ _ O
last _ _ O
use _ _ O
was _ _ O
in _ _ O
x _ _ O
= _ _ O
= _ _ O
y. _ _ O
so _ _ O
this _ _ O
is _ _ O
wrong _ _ O
… _ _ O
39 _ _ O



