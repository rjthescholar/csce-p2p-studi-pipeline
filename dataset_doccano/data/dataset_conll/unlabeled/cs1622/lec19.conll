unlabeled|cs1622|lec19
-DOCSTART- -X- -X- O

Liveness _ _ O
and _ _ O
Register _ _ O
Allocation _ _ O
CS _ _ O
1622 _ _ O
Jarrett _ _ O
Billingsley _ _ O

Class _ _ O
Announcements _ _ O
● _ _ O
uhhhhhh _ _ O
exam _ _ O
Wednesday _ _ O
! _ _ O
woo _ _ O
! _ _ O
● _ _ O
keep _ _ O
in _ _ O
mind _ _ O
this _ _ O
stuff _ _ O
from _ _ O
today _ _ O
, _ _ O
while _ _ O
interesting _ _ O
, _ _ O
is _ _ O
not _ _ O
likely _ _ O
to _ _ O
be _ _ O
covered _ _ O
in-depth _ _ O
on _ _ O
the _ _ O
exam _ _ O
for _ _ O
obvious _ _ O
practical _ _ O
reasons _ _ O
● _ _ O
also _ _ O
I _ _ O
should _ _ O
acknowledge _ _ O
Stephen _ _ O
Chong _ _ O
of _ _ O
Harvard _ _ O
’s _ _ O
CS _ _ O
department _ _ O
as _ _ O
I _ _ O
would _ _ O
not _ _ O
have _ _ O
understood _ _ O
this _ _ O
stuff _ _ O
myself _ _ O
nearly _ _ O
as _ _ O
well _ _ O
without _ _ O
the _ _ O
slides _ _ O
from _ _ O
his _ _ O
compilers _ _ O
course _ _ O
2 _ _ O

The _ _ O
liveness _ _ O
algorithm _ _ O
3 _ _ O

Backwards _ _ O
Analyses _ _ O
● _ _ O
it _ _ O
sounds _ _ O
silly _ _ O
, _ _ O
but _ _ O
some _ _ O
analyses _ _ O
make _ _ O
more _ _ O
sense _ _ O
to _ _ O
do _ _ O
backwards _ _ O
. _ _ O
out-state _ _ O
before-state _ _ O
inst1 _ _ O
inst2 _ _ O
inst3 _ _ O
inst4 _ _ O
inst5 _ _ O
if _ _ O
x _ _ O
bb2 _ _ O
else _ _ O
bb3 _ _ O
in-state _ _ O
after-state _ _ O
join _ _ O
( _ _ O
s1 _ _ O
, _ _ O
s2 _ _ O
) _ _ O
a _ _ O
backwards _ _ O
analysis _ _ O
works _ _ O
exactly _ _ O
the _ _ O
same _ _ O
way _ _ O
, _ _ O
but _ _ O
in _ _ O
the _ _ O
opposite _ _ O
direction _ _ O
: _ _ O
state _ _ O
flows _ _ O
from _ _ O
the _ _ O
successors _ _ O
into _ _ O
the _ _ O
join _ _ O
function _ _ O
. _ _ O
the _ _ O
terms _ _ O
" _ _ O
in-state _ _ O
" _ _ O
and _ _ O
" _ _ O
out-state _ _ O
" _ _ O
take _ _ O
on _ _ O
different _ _ O
meanings _ _ O
, _ _ O
so _ _ O
it _ _ O
can _ _ O
get _ _ O
confusing _ _ O
… _ _ O
so _ _ O
I _ _ O
'm _ _ O
going _ _ O
to _ _ O
use _ _ O
before _ _ O
and _ _ O
after _ _ O
instead _ _ O
of _ _ O
in _ _ O
and _ _ O
out _ _ O
. _ _ O
in _ _ O
forward _ _ O
, _ _ O
state _ _ O
goes _ _ O
before _ _ O
→ _ _ O
after _ _ O
; _ _ O
in _ _ O
backward _ _ O
, _ _ O
state _ _ O
goes _ _ O
after _ _ O
→ _ _ O
before _ _ O
. _ _ O
4 _ _ O

States _ _ O
and _ _ O
transfer _ _ O
function _ _ O
● _ _ O
let _ _ O
's _ _ O
just _ _ O
focus _ _ O
on _ _ O
one _ _ O
variable _ _ O
x _ _ O
for _ _ O
now _ _ O
. _ _ O
● _ _ O
x _ _ O
can _ _ O
be _ _ O
in _ _ O
one _ _ O
of _ _ O
two _ _ O
states _ _ O
: _ _ O
DEAD _ _ O
or _ _ O
LIVE _ _ O
. _ _ O
o _ _ O
DEAD _ _ O
is _ _ O
also _ _ O
the _ _ O
initial _ _ O
value _ _ O
, _ _ O
so _ _ O
the _ _ O
whole _ _ O
CFG _ _ O
is _ _ O
filled _ _ O
with _ _ O
it _ _ O
. _ _ O
o _ _ O
DEAD _ _ O
is _ _ O
also _ _ O
pulling _ _ O
triple _ _ O
duty _ _ O
as _ _ O
the _ _ O
" _ _ O
unvisited _ _ O
/ _ _ O
unknown _ _ O
" _ _ O
value _ _ O
. _ _ O
● _ _ O
the _ _ O
transfer _ _ O
function _ _ O
works _ _ O
like _ _ O
this _ _ O
: _ _ O
x _ _ O
= _ _ O
LIVE _ _ O
println_i _ _ O
( _ _ O
x _ _ O
) _ _ O
x _ _ O
= _ _ O
DEAD _ _ O
x _ _ O
= _ _ O
5 _ _ O
if _ _ O
an _ _ O
instruction _ _ O
uses _ _ O
x _ _ O
, _ _ O
then _ _ O
x _ _ O
is _ _ O
LIVE _ _ O
before _ _ O
it _ _ O
. _ _ O
else _ _ O
, _ _ O
if _ _ O
an _ _ O
instruction _ _ O
defs _ _ O
x _ _ O
, _ _ O
then _ _ O
x _ _ O
is _ _ O
DEAD _ _ O
before _ _ O
it _ _ O
. _ _ O
x _ _ O
= _ _ O
DEAD _ _ O
y _ _ O
= _ _ O
5 _ _ O
x _ _ O
= _ _ O
DEAD _ _ O
x _ _ O
= _ _ O
LIVE _ _ O
y _ _ O
= _ _ O
5 _ _ O
x _ _ O
= _ _ O
LIVE _ _ O
else _ _ O
, _ _ O
before _ _ O
= _ _ O
after _ _ O
( _ _ O
just _ _ O
copy _ _ O
the _ _ O
state _ _ O
) _ _ O
. _ _ O
( _ _ O
in _ _ O
x _ _ O
= _ _ O
x _ _ O
+ _ _ O
1 _ _ O
, _ _ O
the _ _ O
first _ _ O
rule _ _ O
takes _ _ O
precedence _ _ O
, _ _ O
so _ _ O
x _ _ O
is _ _ O
LIVE _ _ O
before _ _ O
it _ _ O
. _ _ O
) _ _ O
5 _ _ O

The _ _ O
join _ _ O
function _ _ O
● _ _ O
the _ _ O
join _ _ O
function _ _ O
is _ _ O
pretty _ _ O
simple _ _ O
. _ _ O
if _ _ O
x _ _ O
is _ _ O
LIVE _ _ O
at _ _ O
the _ _ O
beginning _ _ O
of _ _ O
any _ _ O
successor _ _ O
, _ _ O
then _ _ O
x _ _ O
is _ _ O
LIVE _ _ O
at _ _ O
the _ _ O
end _ _ O
of _ _ O
this _ _ O
block _ _ O
. _ _ O
LIVE _ _ O
DEAD _ _ O
s1 _ _ O
else _ _ O
, _ _ O
x _ _ O
is _ _ O
DEAD _ _ O
at _ _ O
the _ _ O
end _ _ O
of _ _ O
this _ _ O
block _ _ O
. _ _ O
DEAD _ _ O
LIVE _ _ O
s2 _ _ O
DEAD _ _ O
s3 _ _ O
DEAD _ _ O
s1 _ _ O
DEAD _ _ O
s2 _ _ O
DEAD _ _ O
s3 _ _ O
( _ _ O
yeah _ _ O
, _ _ O
in _ _ O
our _ _ O
IR _ _ O
, _ _ O
BBs _ _ O
can _ _ O
have _ _ O
at _ _ O
most _ _ O
2 _ _ O
successors _ _ O
, _ _ O
but _ _ O
this _ _ O
rule _ _ O
works _ _ O
for _ _ O
any _ _ O
number _ _ O
of _ _ O
successors _ _ O
. _ _ O
) _ _ O
6 _ _ O

Trying _ _ O
it _ _ O
out _ _ O
( _ _ O
animated _ _ O
) _ _ O
● _ _ O
let _ _ O
's _ _ O
try _ _ O
it _ _ O
on _ _ O
this _ _ O
simple _ _ O
, _ _ O
one-BB _ _ O
function _ _ O
. _ _ O
we _ _ O
initialize _ _ O
it _ _ O
by _ _ O
setting _ _ O
x _ _ O
to _ _ O
DEAD _ _ O
everywhere _ _ O
. _ _ O
then _ _ O
we _ _ O
run _ _ O
the _ _ O
transfer _ _ O
function _ _ O
on _ _ O
each _ _ O
instruction _ _ O
. _ _ O
x _ _ O
DEAD _ _ O
DEAD _ _ O
LIVE _ _ O
DEAD _ _ O
LIVE _ _ O
DEAD _ _ O
DEAD _ _ O
x _ _ O
= _ _ O
arg _ _ O
+ _ _ O
10 _ _ O
defs _ _ O
x _ _ O
… _ _ O
println_i _ _ O
( _ _ O
x _ _ O
) _ _ O
uses _ _ O
x _ _ O
… _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
x _ _ O
uses _ _ O
x _ _ O
… _ _ O
return _ _ O
does _ _ O
n't _ _ O
touch _ _ O
x _ _ O
… _ _ O
and _ _ O
there _ _ O
we _ _ O
go _ _ O
! _ _ O
notice _ _ O
how _ _ O
on _ _ O
the _ _ O
last _ _ O
step _ _ O
( _ _ O
the _ _ O
first _ _ O
instruction _ _ O
) _ _ O
, _ _ O
x _ _ O
was _ _ O
marked _ _ O
dead _ _ O
before _ _ O
it _ _ O
, _ _ O
so _ _ O
we _ _ O
did _ _ O
n't _ _ O
have _ _ O
to _ _ O
change _ _ O
that _ _ O
state _ _ O
. _ _ O
and _ _ O
? _ _ O
why _ _ O
's _ _ O
that _ _ O
matter _ _ O
? _ _ O
7 _ _ O

It _ _ O
matters _ _ O
for _ _ O
termination _ _ O
● _ _ O
we _ _ O
have _ _ O
a _ _ O
finite _ _ O
number _ _ O
of _ _ O
states _ _ O
( _ _ O
2 _ _ O
) _ _ O
… _ _ O
● _ _ O
and _ _ O
the _ _ O
states _ _ O
only _ _ O
change _ _ O
monotonically _ _ O
: _ _ O
o _ _ O
every _ _ O
location _ _ O
starts _ _ O
as _ _ O
DEAD _ _ O
. _ _ O
o _ _ O
a _ _ O
location _ _ O
's _ _ O
DEAD _ _ O
can _ _ O
become _ _ O
LIVE _ _ O
, _ _ O
but _ _ O
not _ _ O
the _ _ O
other _ _ O
way _ _ O
around _ _ O
. _ _ O
o _ _ O
" _ _ O
changing _ _ O
" _ _ O
DEAD _ _ O
to _ _ O
DEAD _ _ O
like _ _ O
in _ _ O
that _ _ O
last _ _ O
step _ _ O
is _ _ O
not _ _ O
breaking _ _ O
the _ _ O
rule _ _ O
, _ _ O
because _ _ O
you _ _ O
're _ _ O
not _ _ O
changing _ _ O
anything _ _ O
! _ _ O
● _ _ O
so _ _ O
we _ _ O
've _ _ O
satisfied _ _ O
the _ _ O
conditions _ _ O
for _ _ O
termination _ _ O
! _ _ O
o _ _ O
let _ _ O
's _ _ O
try _ _ O
it _ _ O
on _ _ O
some _ _ O
more _ _ O
complex _ _ O
functions _ _ O
to _ _ O
convince _ _ O
ourselves _ _ O
. _ _ O
8 _ _ O

One _ _ O
with _ _ O
a _ _ O
diamond _ _ O
( _ _ O
animated _ _ O
) _ _ O
● _ _ O
a _ _ O
diamond _ _ O
shape _ _ O
will _ _ O
force _ _ O
us _ _ O
to _ _ O
visit _ _ O
some _ _ O
nodes _ _ O
twice _ _ O
. _ _ O
just _ _ O
a _ _ O
def _ _ O
here _ _ O
, _ _ O
no _ _ O
change _ _ O
. _ _ O
DEAD _ _ O
x _ _ O
= _ _ O
10 _ _ O
DEAD _ _ O
LIVE _ _ O
if _ _ O
arg _ _ O
bb1 _ _ O
else _ _ O
bb2 _ _ O
join _ _ O
DEAD _ _ O
with _ _ O
DEAD _ _ O
, _ _ O
get _ _ O
DEAD _ _ O
. _ _ O
join _ _ O
DEAD _ _ O
with _ _ O
LIVE _ _ O
, _ _ O
get _ _ O
LIVE _ _ O
! _ _ O
DEAD _ _ O
LIVE _ _ O
LIVE _ _ O
DEAD _ _ O
DEAD _ _ O
print_s _ _ O
( _ _ O
"x _ _ O
= _ _ O
") _ _ O
println_s _ _ O
( _ _ O
"argh _ _ O
! _ _ O
" _ _ O
) _ _ O
LIVE _ _ O
DEAD _ _ O
DEAD _ _ O
println_i _ _ O
( _ _ O
x _ _ O
) _ _ O
ooh _ _ O
, _ _ O
a _ _ O
use _ _ O
! _ _ O
DEAD _ _ O
let _ _ O
's _ _ O
go _ _ O
left _ _ O
.. _ _ O
we _ _ O
start _ _ O
at _ _ O
the _ _ O
return _ _ O
node _ _ O
. _ _ O
DEAD _ _ O
wait _ _ O
, _ _ O
we _ _ O
have _ _ O
this _ _ O
other _ _ O
path _ _ O
. _ _ O
return _ _ O
DEAD _ _ O
9 _ _ O

One _ _ O
with _ _ O
a _ _ O
loop _ _ O
( _ _ O
animated _ _ O
) _ _ O
● _ _ O
this _ _ O
should _ _ O
be _ _ O
interesting _ _ O
… _ _ O
println_s _ _ O
( _ _ O
"start _ _ O
! _ _ O
" _ _ O
) _ _ O
DEAD _ _ O
x _ _ O
= _ _ O
0 _ _ O
LIVE _ _ O
i _ _ O
= _ _ O
0 _ _ O
LIVE _ _ O
DEAD _ _ O
DEAD _ _ O
$ _ _ O
t1 _ _ O
= _ _ O
i _ _ O
< _ _ O
10 _ _ O
LIVE _ _ O
if _ _ O
$ _ _ O
t1 _ _ O
bb2 _ _ O
else _ _ O
bb3 _ _ O
follow _ _ O
the _ _ O
loop _ _ O
back _ _ O
… _ _ O
LIVE _ _ O
println_i _ _ O
( _ _ O
x _ _ O
) _ _ O
i _ _ O
= _ _ O
i _ _ O
+ _ _ O
1 _ _ O
oh _ _ O
that _ _ O
's _ _ O
interesting _ _ O
! _ _ O
the _ _ O
liveness _ _ O
changes _ _ O
in _ _ O
the _ _ O
middle _ _ O
of _ _ O
this _ _ O
BB _ _ O
. _ _ O
join _ _ O
DEAD _ _ O
with _ _ O
DEAD _ _ O
, _ _ O
things _ _ O
are _ _ O
different _ _ O
the _ _ O
gettime _ _ O
DEAD _ _ O
. _ _ O
second _ _ O
around _ _ O
! _ _ O
DEAD _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
5 _ _ O
return _ _ O
x _ _ O
is _ _ O
n't _ _ O
mentioned _ _ O
, _ _ O
so _ _ O
it _ _ O
's _ _ O
dead _ _ O
before _ _ O
this _ _ O
BB _ _ O
. _ _ O
10 _ _ O

Wait _ _ O
, _ _ O
is _ _ O
that _ _ O
right _ _ O
… _ _ O
? _ _ O
● _ _ O
these _ _ O
might _ _ O
look _ _ O
wrong _ _ O
at _ _ O
first _ _ O
, _ _ O
but _ _ O
the _ _ O
liveness _ _ O
algorithm _ _ O
is _ _ O
telling _ _ O
you _ _ O
something _ _ O
important _ _ O
about _ _ O
x. _ _ O
fn _ _ O
f _ _ O
( _ _ O
a _ _ O
: _ _ O
int _ _ O
) _ _ O
{ _ _ O
let _ _ O
x _ _ O
= _ _ O
10 _ _ O
; _ _ O
let _ _ O
x _ _ O
= _ _ O
whatever _ _ O
( _ _ O
) _ _ O
; _ _ O
x _ _ O
= _ _ O
20 _ _ O
; _ _ O
println_i _ _ O
( _ _ O
a _ _ O
) _ _ O
; _ _ O
println_i _ _ O
( _ _ O
x _ _ O
) _ _ O
; _ _ O
} _ _ O
x _ _ O
is _ _ O
always _ _ O
dead _ _ O
? _ _ O
? _ _ O
yeah _ _ O
, _ _ O
the _ _ O
code _ _ O
never _ _ O
used _ _ O
x. _ _ O
maybe _ _ O
the _ _ O
compiler _ _ O
would _ _ O
report _ _ O
a _ _ O
warning _ _ O
/ _ _ O
error _ _ O
here _ _ O
. _ _ O
x _ _ O
is _ _ O
only _ _ O
live _ _ O
for _ _ O
one _ _ O
instruction _ _ O
? _ _ O
? _ _ O
the _ _ O
code _ _ O
never _ _ O
uses _ _ O
the _ _ O
first _ _ O
value _ _ O
assigned _ _ O
to _ _ O
x. _ _ O
maybe _ _ O
a _ _ O
warning _ _ O
/ _ _ O
error _ _ O
again _ _ O
! _ _ O
11 _ _ O

Some _ _ O
implementation _ _ O
thoughts _ _ O
● _ _ O
there _ _ O
are _ _ O
only _ _ O
two _ _ O
states _ _ O
. _ _ O
o _ _ O
so _ _ O
we _ _ O
could _ _ O
store _ _ O
the _ _ O
state _ _ O
of _ _ O
one _ _ O
variable _ _ O
with _ _ O
one _ _ O
bit _ _ O
. _ _ O
efficient _ _ O
! _ _ O
● _ _ O
therefore _ _ O
, _ _ O
to _ _ O
track _ _ O
n _ _ O
variables _ _ O
' _ _ O
states _ _ O
, _ _ O
we _ _ O
'd _ _ O
need _ _ O
n _ _ O
bits _ _ O
per _ _ O
location _ _ O
. _ _ O
o _ _ O
e.g. _ _ O
if _ _ O
we _ _ O
have _ _ O
3 _ _ O
variables _ _ O
x _ _ O
, _ _ O
y _ _ O
, _ _ O
z _ _ O
… _ _ O
▪ _ _ O
then _ _ O
000 _ _ O
would _ _ O
mean _ _ O
all _ _ O
3 _ _ O
are _ _ O
dead _ _ O
▪ _ _ O
and _ _ O
010 _ _ O
would _ _ O
mean _ _ O
y _ _ O
is _ _ O
live _ _ O
and _ _ O
x _ _ O
/ _ _ O
z _ _ O
are _ _ O
dead _ _ O
. _ _ O
● _ _ O
this _ _ O
places _ _ O
liveness _ _ O
into _ _ O
a _ _ O
special _ _ O
class _ _ O
of _ _ O
analysis _ _ O
problems _ _ O
called _ _ O
bit _ _ O
vector _ _ O
problems _ _ O
, _ _ O
and _ _ O
you _ _ O
can _ _ O
guess _ _ O
why _ _ O
they _ _ O
're _ _ O
called _ _ O
that _ _ O
. _ _ O
o _ _ O
bitwise _ _ O
operations _ _ O
are _ _ O
fast _ _ O
, _ _ O
and _ _ O
bits _ _ O
are _ _ O
tiny _ _ O
! _ _ O
o _ _ O
think _ _ O
about _ _ O
the _ _ O
join _ _ O
function _ _ O
: _ _ O
if _ _ O
any _ _ O
of _ _ O
the _ _ O
successors _ _ O
are _ _ O
live _ _ O
( _ _ O
1 _ _ O
) _ _ O
… _ _ O
▪ _ _ O
that _ _ O
means _ _ O
just _ _ O
ORing _ _ O
together _ _ O
all _ _ O
the _ _ O
successors _ _ O
. _ _ O
● _ _ O
okay _ _ O
. _ _ O
enough _ _ O
about _ _ O
liveness _ _ O
. _ _ O
how _ _ O
do _ _ O
we _ _ O
allocate _ _ O
registers _ _ O
? _ _ O
12 _ _ O

Register _ _ O
Allocation _ _ O
time _ _ O
check _ _ O
≤ _ _ O
27 _ _ O
13 _ _ O

State _ _ O
of _ _ O
the _ _ O
art _ _ O
circa _ _ O
1980 _ _ O
● _ _ O
currently _ _ O
, _ _ O
our _ _ O
compiler _ _ O
places _ _ O
all _ _ O
locals _ _ O
( _ _ O
including _ _ O
args _ _ O
) _ _ O
in _ _ O
memory _ _ O
. _ _ O
o _ _ O
so _ _ O
, _ _ O
accessing _ _ O
them _ _ O
requires _ _ O
loads _ _ O
and _ _ O
stores _ _ O
. _ _ O
x _ _ O
= _ _ O
y _ _ O
+ _ _ O
z _ _ O
; _ _ O
lw _ _ O
s0 _ _ O
, _ _ O
-12 _ _ O
( _ _ O
fp _ _ O
) _ _ O
lw _ _ O
s1 _ _ O
, _ _ O
-16 _ _ O
( _ _ O
fp _ _ O
) _ _ O
add _ _ O
s0 _ _ O
, _ _ O
s0 _ _ O
, _ _ O
s1 _ _ O
sw _ _ O
s0 _ _ O
, _ _ O
-20 _ _ O
( _ _ O
fp _ _ O
) _ _ O
this _ _ O
is _ _ O
definitely _ _ O
correct _ _ O
( _ _ O
our _ _ O
main _ _ O
goal _ _ O
) _ _ O
, _ _ O
but _ _ O
it _ _ O
has _ _ O
serious _ _ O
performance _ _ O
problems _ _ O
. _ _ O
in _ _ O
, _ _ O
say _ _ O
, _ _ O
1980 _ _ O
, _ _ O
the _ _ O
memory _ _ O
in _ _ O
your _ _ O
computer _ _ O
was _ _ O
faster _ _ O
than _ _ O
the _ _ O
CPU _ _ O
. _ _ O
so _ _ O
loads _ _ O
, _ _ O
stores _ _ O
, _ _ O
and _ _ O
adds _ _ O
all _ _ O
took _ _ O
the _ _ O
same _ _ O
amount _ _ O
of _ _ O
time _ _ O
. _ _ O
that _ _ O
is _ _ O
absolutely _ _ O
not _ _ O
the _ _ O
case _ _ O
anymore _ _ O
. _ _ O
in _ _ O
the _ _ O
absolute _ _ O
worst _ _ O
case _ _ O
, _ _ O
a _ _ O
load _ _ O
or _ _ O
store _ _ O
can _ _ O
take _ _ O
around _ _ O
100 _ _ O
times _ _ O
longer _ _ O
than _ _ O
an _ _ O
add _ _ O
. _ _ O
14 _ _ O

Not _ _ O
all _ _ O
doom _ _ O
and _ _ O
gloom _ _ O
● _ _ O
due _ _ O
to _ _ O
Reasons _ _ O
You _ _ O
Learn _ _ O
In _ _ O
1541 _ _ O
™ _ _ O
, _ _ O
that _ _ O
's _ _ O
just _ _ O
the _ _ O
worst _ _ O
case _ _ O
performance _ _ O
. _ _ O
some _ _ O
memory _ _ O
accesses _ _ O
are _ _ O
as _ _ O
fast _ _ O
as _ _ O
an _ _ O
add _ _ O
! _ _ O
● _ _ O
but _ _ O
memory _ _ O
accesses _ _ O
still _ _ O
cause _ _ O
issues _ _ O
for _ _ O
the _ _ O
CPU _ _ O
's _ _ O
pipeline _ _ O
. _ _ O
● _ _ O
and _ _ O
it _ _ O
's _ _ O
still _ _ O
, _ _ O
like _ _ O
, _ _ O
more _ _ O
instructions _ _ O
. _ _ O
cause _ _ O
what _ _ O
if _ _ O
our _ _ O
variables _ _ O
lived _ _ O
in _ _ O
registers _ _ O
instead _ _ O
? _ _ O
x _ _ O
= _ _ O
y _ _ O
+ _ _ O
z _ _ O
; _ _ O
add _ _ O
s0 _ _ O
, _ _ O
s1 _ _ O
, _ _ O
s2 _ _ O
this _ _ O
is _ _ O
one _ _ O
of _ _ O
the _ _ O
reasons _ _ O
RISC _ _ O
ISAs _ _ O
like _ _ O
MIPS _ _ O
have _ _ O
so _ _ O
many _ _ O
registers _ _ O
to _ _ O
begin _ _ O
with _ _ O
: _ _ O
so _ _ O
you _ _ O
can _ _ O
use _ _ O
them _ _ O
for _ _ O
stuff _ _ O
like _ _ O
this _ _ O
. _ _ O
more _ _ O
values _ _ O
in _ _ O
registers _ _ O
means _ _ O
fewer _ _ O
in _ _ O
memory _ _ O
means _ _ O
fewer _ _ O
loads _ _ O
/ _ _ O
stores _ _ O
means _ _ O
higher _ _ O
performance _ _ O
. _ _ O
15 _ _ O

Real _ _ O
ABIs _ _ O
use _ _ O
registers _ _ O
● _ _ O
as _ _ O
you _ _ O
learned _ _ O
in _ _ O
447 _ _ O
, _ _ O
the _ _ O
real _ _ O
MIPS _ _ O
ABI _ _ O
has _ _ O
four _ _ O
main _ _ O
kinds _ _ O
: _ _ O
o _ _ O
a _ _ O
registers _ _ O
, _ _ O
for _ _ O
passing _ _ O
arguments _ _ O
( _ _ O
which _ _ O
we _ _ O
are _ _ O
n't _ _ O
using _ _ O
) _ _ O
o _ _ O
v _ _ O
registers _ _ O
, _ _ O
for _ _ O
returning _ _ O
values _ _ O
o _ _ O
t _ _ O
registers _ _ O
, _ _ O
for _ _ O
temporaries _ _ O
which _ _ O
do _ _ O
not _ _ O
cross _ _ O
jals _ _ O
o _ _ O
s _ _ O
registers _ _ O
, _ _ O
for _ _ O
temporaries _ _ O
which _ _ O
do _ _ O
cross _ _ O
jals _ _ O
● _ _ O
our _ _ O
compiler _ _ O
is _ _ O
n't _ _ O
even _ _ O
using _ _ O
a _ _ O
or _ _ O
t _ _ O
registers _ _ O
! _ _ O
how _ _ O
wasteful _ _ O
. _ _ O
● _ _ O
register _ _ O
allocation _ _ O
algorithms _ _ O
allow _ _ O
us _ _ O
to _ _ O
set _ _ O
up _ _ O
constraints _ _ O
to _ _ O
say _ _ O
" _ _ O
hey _ _ O
, _ _ O
this _ _ O
value _ _ O
must _ _ O
go _ _ O
in _ _ O
a0 _ _ O
" _ _ O
or _ _ O
similar _ _ O
, _ _ O
so _ _ O
that _ _ O
we _ _ O
can _ _ O
generate _ _ O
code _ _ O
that _ _ O
follows _ _ O
these _ _ O
real _ _ O
ABIs _ _ O
. _ _ O
16 _ _ O

Under _ _ O
pressure _ _ O
● _ _ O
the _ _ O
core _ _ O
idea _ _ O
of _ _ O
register _ _ O
allocation _ _ O
is _ _ O
simple _ _ O
: _ _ O
o _ _ O
a _ _ O
function _ _ O
has _ _ O
v _ _ O
variables _ _ O
, _ _ O
and _ _ O
the _ _ O
CPU _ _ O
has _ _ O
r _ _ O
registers _ _ O
. _ _ O
o _ _ O
if _ _ O
v _ _ O
≤ _ _ O
r _ _ O
, _ _ O
it _ _ O
's _ _ O
easy _ _ O
: _ _ O
assign _ _ O
each _ _ O
variable _ _ O
to _ _ O
a _ _ O
register _ _ O
. _ _ O
done _ _ O
! _ _ O
o _ _ O
if _ _ O
v _ _ O
> _ _ O
r _ _ O
, _ _ O
put _ _ O
( _ _ O
v _ _ O
- _ _ O
r _ _ O
) _ _ O
variables _ _ O
in _ _ O
memory _ _ O
, _ _ O
and _ _ O
the _ _ O
rest _ _ O
in _ _ O
registers _ _ O
. _ _ O
● _ _ O
but _ _ O
this _ _ O
is _ _ O
too _ _ O
simplistic _ _ O
, _ _ O
even _ _ O
for _ _ O
simple _ _ O
functions _ _ O
. _ _ O
o _ _ O
our _ _ O
IR _ _ O
creates _ _ O
a _ _ O
lot _ _ O
of _ _ O
temporary _ _ O
variables _ _ O
. _ _ O
o _ _ O
this _ _ O
increases _ _ O
register _ _ O
pressure _ _ O
: _ _ O
the _ _ O
number _ _ O
of _ _ O
values _ _ O
we _ _ O
" _ _ O
want _ _ O
" _ _ O
to _ _ O
keep _ _ O
in _ _ O
registers _ _ O
at _ _ O
any _ _ O
given _ _ O
time _ _ O
. _ _ O
● _ _ O
some _ _ O
optimization _ _ O
passes _ _ O
also _ _ O
increase _ _ O
register _ _ O
pressure _ _ O
! _ _ O
o _ _ O
e.g. _ _ O
function _ _ O
inlining _ _ O
can _ _ O
really _ _ O
blow _ _ O
up _ _ O
the _ _ O
number _ _ O
of _ _ O
locals _ _ O
. _ _ O
● _ _ O
so _ _ O
, _ _ O
we _ _ O
need _ _ O
something _ _ O
that _ _ O
tells _ _ O
us _ _ O
which _ _ O
variables _ _ O
are _ _ O
" _ _ O
in _ _ O
use _ _ O
" _ _ O
at _ _ O
any _ _ O
given _ _ O
time _ _ O
, _ _ O
and _ _ O
assign _ _ O
registers _ _ O
based _ _ O
on _ _ O
that _ _ O
. _ _ O
o _ _ O
… _ _ O
o _ _ O
… _ _ O
oh _ _ O
right _ _ O
, _ _ O
that _ _ O
's _ _ O
liveness _ _ O
:) _ _ O
17 _ _ O

The _ _ O
Register _ _ O
Interference _ _ O
Graph _ _ O
time _ _ O
check _ _ O
≤ _ _ O
40 _ _ O
18 _ _ O

Oh _ _ O
boy _ _ O
, _ _ O
more _ _ O
graphs _ _ O
! _ _ O
Whee _ _ O
! _ _ O
● _ _ O
the _ _ O
Register _ _ O
Interference _ _ O
Graph _ _ O
( _ _ O
RIG _ _ O
) _ _ O
is _ _ O
the _ _ O
data _ _ O
structure _ _ O
used _ _ O
for _ _ O
register _ _ O
allocation _ _ O
. _ _ O
it _ _ O
is _ _ O
an _ _ O
undirected _ _ O
graph _ _ O
with _ _ O
: _ _ O
o _ _ O
one _ _ O
node _ _ O
for _ _ O
each _ _ O
local _ _ O
in _ _ O
the _ _ O
function _ _ O
; _ _ O
and _ _ O
o _ _ O
an _ _ O
edge _ _ O
between _ _ O
any _ _ O
two _ _ O
locals _ _ O
which _ _ O
are _ _ O
live _ _ O
at _ _ O
the _ _ O
same _ _ O
time _ _ O
. _ _ O
● _ _ O
here _ _ O
is _ _ O
a _ _ O
small _ _ O
function _ _ O
and _ _ O
its _ _ O
RIG _ _ O
. _ _ O
fn _ _ O
riggy _ _ O
( _ _ O
a _ _ O
: _ _ O
int _ _ O
) _ _ O
: _ _ O
int _ _ O
{ _ _ O
let _ _ O
x _ _ O
= _ _ O
a _ _ O
+ _ _ O
10 _ _ O
; _ _ O
println_i _ _ O
( _ _ O
x _ _ O
) _ _ O
; _ _ O
let _ _ O
y _ _ O
= _ _ O
" _ _ O
--- _ _ O
" _ _ O
; _ _ O
a _ _ O
println_s _ _ O
( _ _ O
y _ _ O
) _ _ O
; _ _ O
return _ _ O
a _ _ O
; _ _ O
} _ _ O
x _ _ O
these _ _ O
two _ _ O
edges _ _ O
indicate _ _ O
that _ _ O
a _ _ O
and _ _ O
x _ _ O
are _ _ O
live _ _ O
at _ _ O
the _ _ O
same _ _ O
time _ _ O
, _ _ O
and _ _ O
so _ _ O
are _ _ O
a _ _ O
and _ _ O
y _ _ O
, _ _ O
but _ _ O
x _ _ O
and _ _ O
y _ _ O
are _ _ O
not _ _ O
live _ _ O
at _ _ O
the _ _ O
same _ _ O
time _ _ O
. _ _ O
y _ _ O
clearly _ _ O
, _ _ O
" _ _ O
live _ _ O
at _ _ O
the _ _ O
same _ _ O
time _ _ O
" _ _ O
is _ _ O
derived _ _ O
directly _ _ O
from _ _ O
the _ _ O
liveness _ _ O
we _ _ O
computed _ _ O
! _ _ O
19 _ _ O

Building _ _ O
the _ _ O
RIG _ _ O
( _ _ O
animated _ _ O
) _ _ O
● _ _ O
after _ _ O
you _ _ O
've _ _ O
computed _ _ O
liveness _ _ O
, _ _ O
it _ _ O
's _ _ O
really _ _ O
straightforward _ _ O
. _ _ O
● _ _ O
you _ _ O
start _ _ O
with _ _ O
a _ _ O
graph _ _ O
with _ _ O
no _ _ O
edges _ _ O
. _ _ O
at _ _ O
every _ _ O
point _ _ O
in _ _ O
the _ _ O
function _ _ O
, _ _ O
if _ _ O
two _ _ O
locals _ _ O
are _ _ O
live _ _ O
at _ _ O
that _ _ O
point _ _ O
, _ _ O
add _ _ O
an _ _ O
edge _ _ O
between _ _ O
them _ _ O
. _ _ O
n _ _ O
obj _ _ O
i _ _ O
obj _ _ O
i _ _ O
val _ _ O
found _ _ O
n _ _ O
val _ _ O
l _ _ O
l _ _ O
found _ _ O
fn _ _ O
has _ _ O
( _ _ O
l _ _ O
: _ _ O
List _ _ O
, _ _ O
val _ _ O
: _ _ O
int _ _ O
) _ _ O
: _ _ O
bool _ _ O
{ _ _ O
let _ _ O
n _ _ O
= _ _ O
l.length _ _ O
( _ _ O
) _ _ O
; _ _ O
let _ _ O
found _ _ O
= _ _ O
false _ _ O
; _ _ O
for _ _ O
i _ _ O
in _ _ O
0 _ _ O
, _ _ O
n _ _ O
{ _ _ O
let _ _ O
obj _ _ O
= _ _ O
l.get _ _ O
( _ _ O
i _ _ O
) _ _ O
; _ _ O
if _ _ O
obj.value _ _ O
( _ _ O
) _ _ O
= _ _ O
= _ _ O
val _ _ O
{ _ _ O
found _ _ O
= _ _ O
true _ _ O
; _ _ O
} _ _ O
} _ _ O
return _ _ O
found _ _ O
; _ _ O
} _ _ O
20 _ _ O

Ok _ _ O
but _ _ O
what _ _ O
's _ _ O
it _ _ O
mean _ _ O
and _ _ O
why _ _ O
is _ _ O
it _ _ O
a _ _ O
graph _ _ O
● _ _ O
it _ _ O
's _ _ O
the _ _ O
register _ _ O
interference _ _ O
graph _ _ O
: _ _ O
an _ _ O
edge _ _ O
between _ _ O
two _ _ O
nodes _ _ O
means _ _ O
that _ _ O
those _ _ O
two _ _ O
locals _ _ O
can _ _ O
not _ _ O
go _ _ O
in _ _ O
the _ _ O
same _ _ O
register _ _ O
! _ _ O
o _ _ O
but _ _ O
the _ _ O
absence _ _ O
of _ _ O
an _ _ O
edge _ _ O
means _ _ O
they _ _ O
can _ _ O
go _ _ O
in _ _ O
the _ _ O
same _ _ O
register _ _ O
. _ _ O
● _ _ O
as _ _ O
for _ _ O
" _ _ O
why _ _ O
a _ _ O
graph _ _ O
, _ _ O
" _ _ O
well _ _ O
, _ _ O
lots _ _ O
of _ _ O
things _ _ O
reduce _ _ O
to _ _ O
graph _ _ O
algorithms _ _ O
. _ _ O
l _ _ O
val _ _ O
n _ _ O
obj _ _ O
i _ _ O
found _ _ O
this _ _ O
is _ _ O
graph _ _ O
coloring _ _ O
: _ _ O
we _ _ O
assign _ _ O
each _ _ O
node _ _ O
a _ _ O
color _ _ O
such _ _ O
that _ _ O
no _ _ O
two _ _ O
nodes _ _ O
of _ _ O
the _ _ O
same _ _ O
color _ _ O
share _ _ O
an _ _ O
edge _ _ O
( _ _ O
touch _ _ O
) _ _ O
. _ _ O
the _ _ O
" _ _ O
color _ _ O
" _ _ O
is _ _ O
just _ _ O
an _ _ O
arbitrary _ _ O
label _ _ O
or _ _ O
set _ _ O
: _ _ O
for _ _ O
our _ _ O
purposes _ _ O
, _ _ O
" _ _ O
color _ _ O
" _ _ O
will _ _ O
mean _ _ O
the _ _ O
register _ _ O
used _ _ O
to _ _ O
store _ _ O
the _ _ O
variable _ _ O
. _ _ O
here _ _ O
, _ _ O
n _ _ O
and _ _ O
obj _ _ O
are _ _ O
the _ _ O
same _ _ O
color _ _ O
, _ _ O
so _ _ O
they _ _ O
can _ _ O
use _ _ O
the _ _ O
same _ _ O
register _ _ O
! _ _ O
21 _ _ O

Graph _ _ O
Coloring _ _ O
time _ _ O
check _ _ O
≤ _ _ O
56 _ _ O
22 _ _ O

Colorability _ _ O
and _ _ O
chromatic _ _ O
number _ _ O
● _ _ O
because _ _ O
our _ _ O
" _ _ O
colors _ _ O
" _ _ O
represent _ _ O
the _ _ O
registers _ _ O
on _ _ O
the _ _ O
target _ _ O
CPU _ _ O
… _ _ O
o _ _ O
we _ _ O
have _ _ O
a _ _ O
fixed _ _ O
number _ _ O
of _ _ O
colors _ _ O
to _ _ O
use _ _ O
. _ _ O
● _ _ O
we _ _ O
say _ _ O
a _ _ O
graph _ _ O
is _ _ O
k-colorable _ _ O
if _ _ O
it _ _ O
can _ _ O
be _ _ O
colored _ _ O
with _ _ O
k _ _ O
colors _ _ O
. _ _ O
a _ _ O
x _ _ O
a _ _ O
y _ _ O
x _ _ O
a _ _ O
y _ _ O
we _ _ O
could _ _ O
color _ _ O
this _ _ O
graph _ _ O
with _ _ O
3 _ _ O
colors _ _ O
… _ _ O
x _ _ O
y _ _ O
or _ _ O
just _ _ O
2 _ _ O
. _ _ O
but _ _ O
2 _ _ O
is _ _ O
the _ _ O
minimum _ _ O
. _ _ O
the _ _ O
chromatic _ _ O
number _ _ O
of _ _ O
a _ _ O
graph _ _ O
is _ _ O
the _ _ O
minimum _ _ O
number _ _ O
of _ _ O
colors _ _ O
needed _ _ O
to _ _ O
color _ _ O
it _ _ O
. _ _ O
if _ _ O
we _ _ O
have _ _ O
r _ _ O
registers _ _ O
, _ _ O
we _ _ O
'd _ _ O
really _ _ O
like _ _ O
the _ _ O
chromatic _ _ O
number _ _ O
of _ _ O
the _ _ O
RIG _ _ O
to _ _ O
be _ _ O
≤ _ _ O
r _ _ O
! _ _ O
23 _ _ O

You _ _ O
did _ _ O
n't _ _ O
think _ _ O
it _ _ O
would _ _ O
be _ _ O
THAT _ _ O
easy _ _ O
, _ _ O
did _ _ O
you _ _ O
● _ _ O
unfortunately _ _ O
, _ _ O
determining _ _ O
k-colorability _ _ O
is _ _ O
NP-complete _ _ O
. _ _ O
o _ _ O
( _ _ O
and _ _ O
determining _ _ O
the _ _ O
chromatic _ _ O
number _ _ O
is _ _ O
NP-hard _ _ O
! _ _ O
) _ _ O
● _ _ O
so _ _ O
, _ _ O
what _ _ O
do _ _ O
we _ _ O
do _ _ O
? _ _ O
o _ _ O
sometimes _ _ O
, _ _ O
an _ _ O
imperfect _ _ O
solution _ _ O
is _ _ O
good _ _ O
enough _ _ O
. _ _ O
● _ _ O
we _ _ O
're _ _ O
going _ _ O
to _ _ O
use _ _ O
a _ _ O
heuristic _ _ O
to _ _ O
figure _ _ O
out _ _ O
a _ _ O
coloring _ _ O
order _ _ O
that _ _ O
is _ _ O
likely _ _ O
to _ _ O
lead _ _ O
to _ _ O
a _ _ O
successful _ _ O
coloring _ _ O
. _ _ O
o _ _ O
and _ _ O
if _ _ O
that _ _ O
fails _ _ O
, _ _ O
we _ _ O
can _ _ O
tweak _ _ O
the _ _ O
graph _ _ O
a _ _ O
bit _ _ O
and _ _ O
try _ _ O
it _ _ O
again _ _ O
. _ _ O
● _ _ O
this _ _ O
leads _ _ O
to _ _ O
an _ _ O
iterative _ _ O
solution _ _ O
that _ _ O
is _ _ O
near-linear _ _ O
for _ _ O
most _ _ O
common _ _ O
cases _ _ O
. _ _ O
o _ _ O
yeah _ _ O
we _ _ O
might _ _ O
not _ _ O
find _ _ O
the _ _ O
perfect _ _ O
register _ _ O
allocation _ _ O
, _ _ O
but _ _ O
perfection _ _ O
is _ _ O
the _ _ O
enemy _ _ O
of _ _ O
good _ _ O
. _ _ O
24 _ _ O

The _ _ O
coloring _ _ O
heuristic _ _ O
( _ _ O
animated _ _ O
) _ _ O
● _ _ O
let _ _ O
's _ _ O
say _ _ O
r _ _ O
= _ _ O
5 _ _ O
( _ _ O
where _ _ O
r _ _ O
= _ _ O
number _ _ O
of _ _ O
CPU _ _ O
registers _ _ O
) _ _ O
. _ _ O
● _ _ O
if _ _ O
the _ _ O
RIG _ _ O
has _ _ O
a _ _ O
node _ _ O
with _ _ O
< _ _ O
r _ _ O
neighbors _ _ O
, _ _ O
and _ _ O
you _ _ O
remove _ _ O
that _ _ O
node _ _ O
… _ _ O
o _ _ O
and _ _ O
the _ _ O
resulting _ _ O
graph _ _ O
is _ _ O
r-colorable _ _ O
… _ _ O
o _ _ O
then _ _ O
the _ _ O
original _ _ O
graph _ _ O
is _ _ O
r-colorable _ _ O
. _ _ O
Stack _ _ O
we _ _ O
'll _ _ O
repeatedly _ _ O
remove _ _ O
l _ _ O
nodes _ _ O
with _ _ O
< _ _ O
5 _ _ O
neighbors _ _ O
( _ _ O
edges _ _ O
) _ _ O
, _ _ O
and _ _ O
put _ _ O
them _ _ O
in _ _ O
val _ _ O
n _ _ O
this _ _ O
stack _ _ O
as _ _ O
we _ _ O
do _ _ O
so _ _ O
. _ _ O
obj _ _ O
i _ _ O
found _ _ O
25 _ _ O

Pop _ _ O
' _ _ O
n _ _ O
' _ _ O
color _ _ O
( _ _ O
animated _ _ O
) _ _ O
● _ _ O
now _ _ O
we _ _ O
pop _ _ O
the _ _ O
nodes _ _ O
off _ _ O
the _ _ O
stack _ _ O
, _ _ O
and _ _ O
as _ _ O
we _ _ O
do _ _ O
so _ _ O
, _ _ O
color _ _ O
them _ _ O
according _ _ O
to _ _ O
what _ _ O
their _ _ O
neighbors _ _ O
are _ _ O
. _ _ O
Stack _ _ O
i _ _ O
n _ _ O
val _ _ O
l _ _ O
has _ _ O
red _ _ O
and _ _ O
green _ _ O
neighbors _ _ O
, _ _ O
so _ _ O
blue _ _ O
it _ _ O
is _ _ O
. _ _ O
l _ _ O
n _ _ O
has _ _ O
no _ _ O
colored _ _ O
neighbors _ _ O
, _ _ O
so _ _ O
let _ _ O
's _ _ O
make _ _ O
it _ _ O
red _ _ O
too _ _ O
. _ _ O
n _ _ O
found _ _ O
val _ _ O
needs _ _ O
to _ _ O
be _ _ O
a _ _ O
fourth _ _ O
color _ _ O
… _ _ O
l _ _ O
and _ _ O
obj _ _ O
needs _ _ O
to _ _ O
be _ _ O
a _ _ O
fifth _ _ O
. _ _ O
val _ _ O
obj _ _ O
obj _ _ O
i _ _ O
found _ _ O
i _ _ O
has _ _ O
no _ _ O
colored _ _ O
neighbors _ _ O
, _ _ O
so _ _ O
let _ _ O
's _ _ O
make _ _ O
it _ _ O
red _ _ O
. _ _ O
found _ _ O
has _ _ O
two _ _ O
red _ _ O
neighbors _ _ O
, _ _ O
so _ _ O
let _ _ O
's _ _ O
make _ _ O
it _ _ O
green _ _ O
. _ _ O
26 _ _ O

This _ _ O
works _ _ O
? _ _ O
? _ _ O
● _ _ O
it _ _ O
's _ _ O
a _ _ O
little _ _ O
mind-blowing _ _ O
, _ _ O
but _ _ O
it _ _ O
does _ _ O
work _ _ O
, _ _ O
because _ _ O
that _ _ O
heuristic _ _ O
actually _ _ O
goes _ _ O
both _ _ O
ways _ _ O
: _ _ O
it _ _ O
's _ _ O
an _ _ O
" _ _ O
if _ _ O
and _ _ O
only _ _ O
if _ _ O
. _ _ O
" _ _ O
o _ _ O
because _ _ O
we _ _ O
were _ _ O
able _ _ O
to _ _ O
5-color _ _ O
each _ _ O
sub-graph _ _ O
of _ _ O
the _ _ O
RIG _ _ O
as _ _ O
we _ _ O
built _ _ O
it _ _ O
back _ _ O
up _ _ O
by _ _ O
popping _ _ O
… _ _ O
o _ _ O
then _ _ O
the _ _ O
whole _ _ O
RIG _ _ O
was _ _ O
5-colorable _ _ O
. _ _ O
● _ _ O
BUT _ _ O
: _ _ O
it _ _ O
does _ _ O
n't _ _ O
always _ _ O
work _ _ O
. _ _ O
if _ _ O
the _ _ O
RIG _ _ O
is _ _ O
not _ _ O
actually _ _ O
r-colorable _ _ O
, _ _ O
we _ _ O
will _ _ O
run _ _ O
into _ _ O
one _ _ O
of _ _ O
two _ _ O
things _ _ O
: _ _ O
o _ _ O
no _ _ O
nodes _ _ O
with _ _ O
< _ _ O
r _ _ O
neighbors _ _ O
on _ _ O
the _ _ O
removal _ _ O
phase _ _ O
; _ _ O
or _ _ O
: _ _ O
o _ _ O
impossible-to-color _ _ O
nodes _ _ O
in _ _ O
the _ _ O
popping _ _ O
phase _ _ O
! _ _ O
27 _ _ O

Failure _ _ O
to _ _ O
color _ _ O
● _ _ O
let _ _ O
's _ _ O
see _ _ O
what _ _ O
happens _ _ O
on _ _ O
the _ _ O
same _ _ O
RIG _ _ O
if _ _ O
r _ _ O
= _ _ O
4 _ _ O
instead _ _ O
. _ _ O
o _ _ O
we _ _ O
have _ _ O
to _ _ O
remove _ _ O
nodes _ _ O
with _ _ O
< _ _ O
4 _ _ O
neighbors _ _ O
now _ _ O
. _ _ O
Stack _ _ O
l _ _ O
found _ _ O
obj _ _ O
val _ _ O
aaaand _ _ O
we _ _ O
're _ _ O
stuck _ _ O
. _ _ O
we _ _ O
ca _ _ O
n't _ _ O
color _ _ O
l _ _ O
! _ _ O
n _ _ O
uh _ _ O
oh _ _ O
. _ _ O
everyone _ _ O
has _ _ O
≥ _ _ O
4 _ _ O
neighbors _ _ O
. _ _ O
let _ _ O
's _ _ O
just _ _ O
remove _ _ O
one _ _ O
and _ _ O
move _ _ O
on _ _ O
anyway _ _ O
. _ _ O
val _ _ O
i _ _ O
l _ _ O
n _ _ O
obj _ _ O
i _ _ O
found _ _ O
28 _ _ O

Spilling _ _ O
time _ _ O
check _ _ O
≤ _ _ O
85 _ _ O
29 _ _ O

So _ _ O
what _ _ O
do _ _ O
we _ _ O
do _ _ O
? _ _ O
? _ _ O
● _ _ O
a _ _ O
failure _ _ O
to _ _ O
color _ _ O
the _ _ O
RIG _ _ O
means _ _ O
that _ _ O
there _ _ O
are _ _ O
more _ _ O
values _ _ O
being _ _ O
used _ _ O
at _ _ O
one _ _ O
time _ _ O
than _ _ O
will _ _ O
fit _ _ O
into _ _ O
the _ _ O
CPU _ _ O
's _ _ O
registers _ _ O
. _ _ O
o _ _ O
it _ _ O
's _ _ O
a _ _ O
setback _ _ O
, _ _ O
but _ _ O
it _ _ O
's _ _ O
not _ _ O
catastrophic _ _ O
, _ _ O
right _ _ O
? _ _ O
we _ _ O
can _ _ O
use _ _ O
memory _ _ O
. _ _ O
● _ _ O
so _ _ O
in _ _ O
this _ _ O
case _ _ O
we _ _ O
turn _ _ O
to _ _ O
spilling _ _ O
: _ _ O
picking _ _ O
one _ _ O
or _ _ O
more _ _ O
locals _ _ O
to _ _ O
live _ _ O
on _ _ O
the _ _ O
stack _ _ O
instead _ _ O
of _ _ O
in _ _ O
registers _ _ O
. _ _ O
● _ _ O
ideally _ _ O
, _ _ O
we _ _ O
’d _ _ O
like _ _ O
to _ _ O
pick _ _ O
some _ _ O
local _ _ O
that _ _ O
is _ _ O
n’t _ _ O
used _ _ O
very _ _ O
often _ _ O
to _ _ O
be _ _ O
placed _ _ O
into _ _ O
memory _ _ O
instead _ _ O
of _ _ O
a _ _ O
register _ _ O
… _ _ O
but _ _ O
which _ _ O
one _ _ O
? _ _ O
o _ _ O
if _ _ O
we _ _ O
pick _ _ O
poorly _ _ O
, _ _ O
we _ _ O
could _ _ O
slow _ _ O
down _ _ O
our _ _ O
program _ _ O
a _ _ O
lot _ _ O
by _ _ O
causing _ _ O
a _ _ O
bunch _ _ O
of _ _ O
excess _ _ O
loads _ _ O
and _ _ O
stores _ _ O
… _ _ O
30 _ _ O

Stop _ _ O
interfering _ _ O
with _ _ O
me _ _ O
! _ _ O
obj _ _ O
i _ _ O
found _ _ O
n _ _ O
val _ _ O
l _ _ O
● _ _ O
picking _ _ O
which _ _ O
local _ _ O
to _ _ O
spill _ _ O
is _ _ O
, _ _ O
again _ _ O
, _ _ O
something _ _ O
we _ _ O
ca _ _ O
n’t _ _ O
do _ _ O
perfectly _ _ O
. _ _ O
● _ _ O
so _ _ O
we _ _ O
can _ _ O
again _ _ O
use _ _ O
heuristics _ _ O
to _ _ O
pick _ _ O
a _ _ O
likely _ _ O
candidate _ _ O
. _ _ O
maybe _ _ O
some _ _ O
variable _ _ O
that _ _ O
interferes _ _ O
with _ _ O
a _ _ O
lot _ _ O
of _ _ O
others _ _ O
but _ _ O
is _ _ O
n’t _ _ O
used _ _ O
much _ _ O
… _ _ O
locals _ _ O
with _ _ O
long _ _ O
live _ _ O
ranges _ _ O
fn _ _ O
has _ _ O
( _ _ O
l _ _ O
: _ _ O
List _ _ O
, _ _ O
val _ _ O
: _ _ O
int _ _ O
) _ _ O
: _ _ O
bool _ _ O
{ _ _ O
tend _ _ O
to _ _ O
interfere _ _ O
a _ _ O
lot _ _ O
. _ _ O
let _ _ O
n _ _ O
= _ _ O
l.length _ _ O
( _ _ O
) _ _ O
; _ _ O
let _ _ O
found _ _ O
= _ _ O
false _ _ O
; _ _ O
we _ _ O
also _ _ O
have _ _ O
to _ _ O
consider _ _ O
for _ _ O
i _ _ O
in _ _ O
0 _ _ O
, _ _ O
n _ _ O
{ _ _ O
things _ _ O
like _ _ O
loops _ _ O
– _ _ O
how _ _ O
many _ _ O
let _ _ O
obj _ _ O
= _ _ O
l.get _ _ O
( _ _ O
i _ _ O
) _ _ O
; _ _ O
accesses _ _ O
to _ _ O
the _ _ O
local _ _ O
will _ _ O
if _ _ O
obj.value _ _ O
( _ _ O
) _ _ O
= _ _ O
= _ _ O
val _ _ O
{ _ _ O
found _ _ O
= _ _ O
true _ _ O
; _ _ O
happen _ _ O
because _ _ O
of _ _ O
the _ _ O
loop _ _ O
? _ _ O
} _ _ O
can _ _ O
we _ _ O
estimate _ _ O
that _ _ O
? _ _ O
} _ _ O
return _ _ O
found _ _ O
; _ _ O
found _ _ O
seems _ _ O
like _ _ O
a _ _ O
good _ _ O
} _ _ O
spilling _ _ O
candidate _ _ O
here _ _ O
. _ _ O
31 _ _ O

So _ _ O
how _ _ O
does _ _ O
it _ _ O
work _ _ O
? _ _ O
● _ _ O
if _ _ O
we _ _ O
get _ _ O
stuck _ _ O
when _ _ O
removing _ _ O
nodes _ _ O
from _ _ O
the _ _ O
RIG _ _ O
… _ _ O
o _ _ O
we _ _ O
pick _ _ O
a _ _ O
local _ _ O
to _ _ O
maybe _ _ O
spill _ _ O
. _ _ O
but _ _ O
we _ _ O
do _ _ O
n’t _ _ O
spill _ _ O
it _ _ O
yet _ _ O
. _ _ O
o _ _ O
we _ _ O
push _ _ O
that _ _ O
node _ _ O
on _ _ O
the _ _ O
stack _ _ O
, _ _ O
along _ _ O
with _ _ O
a _ _ O
note _ _ O
that _ _ O
says _ _ O
, _ _ O
“ _ _ O
maybe _ _ O
spill _ _ O
this _ _ O
? _ _ O
” _ _ O
● _ _ O
then _ _ O
, _ _ O
when _ _ O
we _ _ O
pop-and-color _ _ O
… _ _ O
o _ _ O
if _ _ O
we _ _ O
get _ _ O
to _ _ O
a _ _ O
maybe-spill _ _ O
entry _ _ O
on _ _ O
the _ _ O
stack _ _ O
... _ _ O
o _ _ O
AND _ _ O
that _ _ O
node _ _ O
can _ _ O
not _ _ O
be _ _ O
colored _ _ O
… _ _ O
o _ _ O
then _ _ O
we _ _ O
know _ _ O
that _ _ O
we _ _ O
have _ _ O
to _ _ O
spill _ _ O
it _ _ O
, _ _ O
and _ _ O
we _ _ O
rewrite _ _ O
the _ _ O
code _ _ O
! _ _ O
● _ _ O
why _ _ O
do _ _ O
we _ _ O
wait _ _ O
to _ _ O
rewrite _ _ O
until _ _ O
the _ _ O
pop-and-color _ _ O
phase _ _ O
? _ _ O
o _ _ O
because _ _ O
we _ _ O
’re _ _ O
just _ _ O
using _ _ O
heuristics _ _ O
here _ _ O
. _ _ O
it _ _ O
’s _ _ O
entirely _ _ O
possible _ _ O
that _ _ O
the _ _ O
graph _ _ O
is _ _ O
colorable _ _ O
when _ _ O
we _ _ O
remove _ _ O
a _ _ O
node _ _ O
with _ _ O
≥ _ _ O
r _ _ O
neighbors _ _ O
! _ _ O
so _ _ O
, _ _ O
we _ _ O
have _ _ O
to _ _ O
be _ _ O
conservative _ _ O
. _ _ O
32 _ _ O

How _ _ O
the _ _ O
code _ _ O
is _ _ O
rewritten _ _ O
● _ _ O
in _ _ O
our _ _ O
IR _ _ O
, _ _ O
we _ _ O
might _ _ O
add _ _ O
new _ _ O
instructions _ _ O
to _ _ O
represent _ _ O
loads _ _ O
/ _ _ O
stores _ _ O
. _ _ O
● _ _ O
then _ _ O
, _ _ O
each _ _ O
use _ _ O
and _ _ O
def _ _ O
of _ _ O
the _ _ O
spilled _ _ O
variable _ _ O
is _ _ O
replaced _ _ O
with _ _ O
loads _ _ O
and _ _ O
stores _ _ O
to _ _ O
the _ _ O
stack _ _ O
. _ _ O
found _ _ O
= _ _ O
false _ _ O
found_1 _ _ O
= _ _ O
false _ _ O
Store _ _ O
( _ _ O
fp-12 _ _ O
, _ _ O
found_1 _ _ O
) _ _ O
found _ _ O
= _ _ O
true _ _ O
found_2 _ _ O
= _ _ O
true _ _ O
Store _ _ O
( _ _ O
fp-12 _ _ O
, _ _ O
found_2 _ _ O
) _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
found _ _ O
found_3 _ _ O
= _ _ O
Load _ _ O
( _ _ O
fp-12 _ _ O
) _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
found_3 _ _ O
we _ _ O
also _ _ O
rename _ _ O
the _ _ O
spilled _ _ O
local _ _ O
at _ _ O
each _ _ O
use _ _ O
location _ _ O
with _ _ O
a _ _ O
unique _ _ O
name _ _ O
. _ _ O
each _ _ O
of _ _ O
these _ _ O
new _ _ O
locals _ _ O
has _ _ O
a _ _ O
very _ _ O
short _ _ O
live _ _ O
range _ _ O
! _ _ O
33 _ _ O

Then _ _ O
what _ _ O
? _ _ O
● _ _ O
then _ _ O
… _ _ O
we _ _ O
start _ _ O
all _ _ O
over _ _ O
again _ _ O
! _ _ O
compute _ _ O
liveness _ _ O
, _ _ O
build _ _ O
the _ _ O
RIG _ _ O
… _ _ O
● _ _ O
this _ _ O
is _ _ O
the _ _ O
iterative _ _ O
register _ _ O
allocation _ _ O
algorithm _ _ O
in _ _ O
a _ _ O
nutshell _ _ O
: _ _ O
Rewrite _ _ O
spill _ _ O
Liveness _ _ O
and _ _ O
RIG _ _ O
Remove _ _ O
nodes _ _ O
Pop _ _ O
and _ _ O
color _ _ O
Done _ _ O
! _ _ O
Pick _ _ O
spill _ _ O
candidate _ _ O
34 _ _ O

And _ _ O
it _ _ O
keeps _ _ O
going _ _ O
… _ _ O
● _ _ O
this _ _ O
is _ _ O
just _ _ O
the _ _ O
basic _ _ O
shape _ _ O
of _ _ O
the _ _ O
algorithm _ _ O
. _ _ O
● _ _ O
there _ _ O
are _ _ O
several _ _ O
more _ _ O
features _ _ O
, _ _ O
such _ _ O
as _ _ O
: _ _ O
o _ _ O
coalescing _ _ O
pairs _ _ O
of _ _ O
nodes _ _ O
that _ _ O
are _ _ O
likely _ _ O
to _ _ O
end _ _ O
up _ _ O
in _ _ O
the _ _ O
same _ _ O
register _ _ O
anyway _ _ O
▪ _ _ O
e.g. _ _ O
in _ _ O
a _ _ O
= _ _ O
b _ _ O
where _ _ O
their _ _ O
liveness _ _ O
does _ _ O
n’t _ _ O
overlap _ _ O
o _ _ O
pre-coloring _ _ O
some _ _ O
nodes _ _ O
to _ _ O
indicate _ _ O
they _ _ O
must _ _ O
be _ _ O
in _ _ O
certain _ _ O
registers _ _ O
. _ _ O
this _ _ O
is _ _ O
used _ _ O
for _ _ O
: _ _ O
▪ _ _ O
argument _ _ O
and _ _ O
return _ _ O
value _ _ O
registers _ _ O
( _ _ O
MIPS _ _ O
“ _ _ O
a _ _ O
” _ _ O
and _ _ O
“ _ _ O
v _ _ O
” _ _ O
registers _ _ O
) _ _ O
▪ _ _ O
saved _ _ O
temporary _ _ O
registers _ _ O
( _ _ O
MIPS _ _ O
“ _ _ O
s _ _ O
” _ _ O
registers _ _ O
) _ _ O
o _ _ O
and _ _ O
more _ _ O
… _ _ O
35 _ _ O



