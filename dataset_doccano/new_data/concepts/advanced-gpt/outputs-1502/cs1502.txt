function
functions
parameter
parameters
function body
return
returns
function header
function name
header
return type
scope
passing-in
pass-by-value
pass-by-reference
void
variable
variables
primitive
public
computational models
finite automata
turing machine
turing machines
decidability
reducibility
time complexity
post correspondence problem
modified travel salesman problem
proof
proof by contradiction
truth table
assumptions
hypotheses
definitions
general accepted facts
statements that have been derived previously
integer
even number
odd number
rational number
irrational number
numerator
denominator
irreducible fraction
coprime integers
canonical form
Z
integral rootfunction
function body
function header
parameters
return type
function name
visibility type
public
protected
private
static
function call
scope
passing-in
pass-by-value
pass-by-reference
void
variable
primitive type
non-primitive type
return statement
turing machine
TM
turing machine m1
turing machine m2
language b
language a
tape
tape head
left-most square
left-most end of the tape
blank symbol
state diagram
qaccept
qreject
transition
shorthand notation
accept
reject
input string
Σ
Γ
εfunction
function call
function header
function body
function name
return type
return statement
parameter
parameters
visibility type
public
static
parentheses
curly braces
scope
passing-in
pass-by-value
pass-by-reference
void
variable
primitive type
turing machine
TM
combining turing machines
start state
accept state
reject state
transition function
tape alphabet
tape
tape head
blank symbol
left-end of the tape
palindrome
copy
NB
PB
R
equal
reverse of a string
multitape turing machine
single-tape turing machine
one-tape turing machine
multitape to one-tape conversion
separator symbol #
tape head position marker
equivalent single-tape turing machine
nondeterministic turing machine
NTM
nondeterministic finite automata
NFA
deterministic turing machine
computational tree
breadth first search
universal turing machine
universal TM
church-turing thesis
algorithm
formal definition of a turing machine
input string
infinite loopfunction
functions
function body
function header
function name
parameter
parameters
return
returns
return type
scope
passing-in
pass-by-value
pass-by-reference
void
variable
variables
primitive
primitive type
non-primitive type
public
deterministic finite automaton
DFA
state diagram
formal definition of a dfa
Q
Σ
δ
q0
F
transition function
start state
accept state
language of a dfa
regular language
language operators
union
concatenation
star
closed under union
closed under concatenation
closed under star
nondeterministic finite automaton
NFA
Σε
ε
epsilon transition
computational tree
powerset
P(Q)
equivalence of nfas and dfas
regular expression
regular expression to nfa
GNFA
dfa to regular expression
pumping lemma
proof by contradictionturing machine
TM
recognizable language
decidable language
undecidable language
decider
root of a polynomial
integral root
string representation
hilbert's tenth problem
brute force algorithm
formal description
implementation description
high-level description
state diagram
where clause
church-turing thesis
universal turing machinedecidable language
decider
Turing machine
TM
accept state
reject state
halting
language
string representation
membership problem
ADFA
DFA
nonaccepting state
DFA simulation
ANFA
NFA
NFA to DFA conversion
equivalent DFA
regular expression
AREX
regular expression to NFA conversionfunction
function header
function body
function name
parameter
parameters
return type
scope
passing-in
pass-by-value
pass-by-reference
void
variable
primitive type
non-primitive type
public
decidability
decidable language
decider
DFA
NFA
TM
turing machine
regular expression
regular languages
EDFA
EQDFA
ADFA
ANFA
AREX
ONE DFA
accept state
start state
reachable state
state diagram
graph theory
set theory
closed under complement
closed under union
closed under intersectionfunction
function header
function body
function name
parameter
parameters
return type
scope
passing-in
pass-by-value
pass-by-reference
void
variable
primitive type
non-primitive type
public
decidability
decidable language
decider
DFA
NFA
TM
turing machine
regular expression
regular languages
EDFA
EQDFA
ADFA
ANFA
AREX
ONE DFA
accept state
start state
reachable state
state diagram
graph theory
set theory
closed under complement
closed under union
closed under intersectionundecidability
ATM
recognizable
TM
turing machine
u
decidable
undecidable
unrecognizable language
turing-recognizable
cantor’s observation
pairing
one-to-one
onto
bijection
correspondence
same size
countable
uncountable
smaller than
N
set of natural numbers
E
set of even natural numbers
Z
set of integers
Q
set of rational numbers
set of positive rational numbersreal number
decimal representation
set of real numbers
R
countable
uncountable
proof by contradiction
correspondence
one-to-one
onto
diagonalization
Σ
alphabet
Σ∗
set of all strings over Σ
binary representation
natural numbers
infinite binary sequence
B
set of all infinite binary sequences
turing machine
TM
encoding
<M>
string
set of all languages
language
dictionary order
turing-recognizablefunction
function components
function header
function body
function name
parameters
return type
return
visibility type
public
protected
private
static
non-static
parentheses
curly brackets
braces
function call
scope
passing-in
pass-by-value
pass-by-reference
primitive type
non-primitive type
void
variable
turing machine
TM
decider
encoding of a machine
decidable language
undecidable language
recognizable language
unrecognizable language
complement of a language
boolean algebra
correspondence
one-to-one
onto
countable
uncountable
infinite set
natural numbers
N
diagonalization
ATM
ADFA
ANFA
AREX
EDFA
EQDFA
DFA
NFA
regular expressionfunction
function header
function body
function name
parameters
return type
return
scope
passing-in
pass-by-value
pass-by-reference
void
reducibility
membership problem
decidable
undecidable
TM
ATM
boolean algebra
proof by contradiction
deciderfunction
function header
function body
function name
parameters
return type
return
visibility type
public
protected
private
static
parentheses
curly brackets
curly braces
scope
passing-in
pass-by-value
pass-by-reference
primitive type
non-primitive type
void
variable
sumdoubles
turing machine
TM
language of a turing machine
L(M)
accept
reject
infinite loop
ε
empty string
Σ
Σ∗
∅
0n 1n
{0n 1n | n ≥ 0}
0Σ∗
Σ∗ − {ε}
decider
ATM
input string
reducibilityfunction
function header
function body
function name
return type
parameter
return
visibility type
static
function call
scope
passing-in
pass-by-value
pass-by-reference
primitive type
non-primitive type
void
set
empty set
set membership
domain
range
predicate
union
intersection
complement
set difference
cartesian product
cardinality
big union
sequence
tuple
k-tuple
ordered pair
alphabet
string
string length
concatenation
substring
empty string
language
shortlex order
lexicographic ordering
boolean value
boolean operators
demorgan's laws
implication
equality
exclusive or
distributive law
truth table
proof
proof by construction
proof by contradiction
irrational number
rational number
odd integer
even numberfunction
functions
function header
function body
function name
header
parameter
parameters
return
returns
return type
visibility type
public
protected
private
static
parentheses
curly brackets/braces
scope
passing-in
pass-by-value
pass-by-reference
void
variable
variables
primitive
non-primitive
turing machine
language of a turing machine
L(M)
method
language of a method
accept
reject
loops indefinitely
infinite loop
Σ∗
∅
ε
empty string
0n 1n
is_0n1nhalting problem
HALT TM
ATM
ETM
turing machine
TM
decider
decidable
undecidable
undecidability
undecidability proofs
proof by contradiction
accept
reject
infinite loopREGULAR TM
EQ TM
ONE TM
ATM
HALT TM
ETM
undecidable
decidable
decider
proof by contradiction
regular language
L(M)
Σ∗
∅
ε
0n 1nreducibility
reduction
reduction via computation histories
turing machine
TM
deterministic turing machine
configuration
start configuration
accepting configuration
rejecting configuration
computation history
accepting computation history
rejecting computation history
linear bounded automaton
LBA
ATM
HALT TM
ETM
REGULAR TM
EQ TM
ALBA
ELBA
decidable
undecidable
empty languagefunction
function header
function body
parameters
return type
function name
visibility type
static
scope
passing-in
pass-by-value
pass-by-reference
void
variable
primitive
public
post correspondence problem
PCP
modified post correspondence problem
MPCP
domino
top string
bottom string
match
instance of pcp
reducibility
mapping reducibility
reduction via computation history
computable function
TM
LBA
ATM
ETM
EQTM
ELBA
computation history
accepting computation history
configuration
sequence of configurations
start state
?u
u?
?u?mapping reducibility
mapping reducible
reduction
computable function
decidable
undecidable
decider
TM
ATM
HALT TM
ETM
REGULAR TM
EQ TM
PCP
post correspondence problem
MPCPfunction
function name
function body
function header
parameters
return type
return
visibility type
static
void
scope
passing-in
pass-by-value
pass-by-reference
variable
primitive
public
time complexity
running time
turing machine
TM
deterministic turing machine
nondeterministic turing machine
NTM
asymptotic analysis
big-o notation
small-o notation
upper bound
asymptotic upper bound
polynomial bounds
exponential bounds
time complexity class
TIME(t(n))
computation tree
multitape turing machine
single-tape turing machine
two-tape turing machine
linear time
language a
{0^k 1^k | k ≥ 0}function
functions
function header
function body
parameter
parameters
function name
return type
return
visibility type
public
protected
private
static
scope
passing-in
pass-by-value
pass-by-reference
void
variable
variables
primitive type
non-primitive type
polynomial time
exponential time
P
TIME(nk)
turing machine
TM
deterministic single-tape turing machine
turing machine step
configuration
PATH
directed graph
directed path
node
edge
brute-force algorithm
breadth-first search
problem size
RELPRIME
relatively prime
greatest common divisor
gcd
euclidean algorithm
HAMPATH
hamiltonian path
COMPOSITES
composite numberhamiltonian path
HAMPATH
directed graph
directed path
verifier
polynomial time verifier
polynomial verifiability
polynomially verifiable
turing machine
TM
composites
composite number
divisor
factor
certificate
proof of membership
NP
nondeterministic polynomial time
P
polynomial time
nondeterministic finite automaton
NFA
nondeterministic turing machine
NTM
brute-force algorithm
nondeterministic polynomial time turing machine
NTIME
nondeterministic time
clique
k-clique
undirected graph
subgraph
subset-sum
multiset
permutation
exponential timefunction
functions
parameter
parameters
function body
return
returns
function header
function name
header
return type
scope
passing-in
pass-by-value
pass-by-reference
void
variable
variables
primitive
public
np-completeness
np-complete
NP
P
polynomial time
polynomial time algorithm
polynomial time computable function
polynomial time turing machine
turing machine
TM
nondeterministic turing machine
NTM
polynomial time reducibility
polynomial time reducible
polynomial time mapping reducible
mapping reducibility
polynomial time reduction
satisfiability problem
SAT
boolean formula
boolean variable
boolean operator
literal
clause
conjunctive normal form
CNF
cnf-formula
3cnf-formula
3SAT
clique
k-clique
vertex cover
HAMPATH
subset-sum
cook-levin theorem
computation history
accepting computation history
verifier
polynomial time verifierexternal input
state diagram
state transition table
finite state machine
finite-state automaton
five tuple
state
start state
accept state
non-accept state
transition function
alphabet
input string
language
language of a machine
l(m)
recognizes
formal definition
empty string
ε
Q
set of states
Σ
δ
q0
F
set of accept states
<RESET>
substring
accept
reject
computation model
state-of-mindfunction
functions
function body
function header
function name
header
parameters
parameter
return type
return
returns
parentheses
curly brackets/braces
visibility type
scope
passing-in
pass-by-value
pass-by-reference
void
variable
variables
primitive
public
PSUBSETDFA
DFA
TM
decider
decidable
proper subset
EQDFA
EDFA
ALLBUTONETM
undecidable
ATM
mapping reducibility
reduction
NOTPRIME
verifier
NTM
brute force algorithmfinite automata
finite automaton
finite-state automaton
finite-state machine
computational model
alphabet
string
substring
language
regular language
deterministic finite automaton
DFA
problem as language
solvable problem
unsolvable problem
regular operations
union
concatenation
star
closed under operation
closure under union
closure under concatenation
closure under star
intersection
empty string
epsilon
empty set
accept
reject
recognize
statenondeterministic finite automaton
NFA
deterministic finite automaton
DFA
alphabet
Σ
epsilon
ε
epsilon transition
state
set of states
start state
accept state
set of accept states
reject state
non-accept state
transition function
δ
powerset
P(Q)
Σε
epsilon-closure
E(R)
5-tuple
regular language
union
concatenation
star operation
star operator
closure under union
closure under concatenation
closure under star
state diagram
equivalence of nfas and dfas
simulation of an nfa with a dfa
computational tree
unreachable stateregular expression
alphabet
Σ
ε
empty string
∅
empty language
union
∪
concatenation
star
∗
recursive definition
Σ∗
R+
RR∗
Rk
regular language
closure under union
closure under concatenation
closure under star
operator precedence
NFA
DFA
lemma 1.55
regular expression to NFA conversion
floating-point number
floating-point representation
Dfunction
function header
function body
function name
parameters
return type
scope
passing-in
pass-by-value
pass-by-reference
void
visibility type
static
primitive type
regular language
regular expression
finite-state machine
finite automaton
deterministic finite automaton
DFA
nondeterministic finite automaton
NFA
generalized nondeterministic finite automaton
GNFA
start state
accept state
non-accept state
transition
transition label
ε arrow
converting a dfa to a gnfa
gnfa to regular expression
reducing number of states of gnfa
state diagram
theorem 1.54
nonregular language
{0n 1n | n ≥ 0}language
regular language
non-regular language
finite language
infinite language
empty language
regular expression
∅
finite state machine
DFA
state
start state
accept state
loop
substring
pumping lemma
pumping length
pumped
string length
concatenation
ε
pigeonhole principle
proof by contradiction
language {w | w contains 011 as a substring}
language {0n 1n | n ≥ 0}pumping lemma
regular language
non-regular language
length at least p
s = xyz
|y| > 0
|xy| ≤ p
xy^i z is in the language for any i ≥ 0
contradiction
rule of thumb
c
strings with an equal number of 0s and 1s
d
strings with more 0s than 1s
e
strings of 0s with length i^2function
functions
function call
function components
function header
function body
function name
parameters
parameter
parameter type
parameter name
return
return type
return statement
visibility type
public
protected
private
static
parentheses
curly brackets/braces
scope
passing-in
pass-by-value
pass-by-reference
primitive type
non-primitive type
variable
variables
void
human computer
primitive steps of human computation
examining an individual symbol
erasing or replacing a symbol
transferring attention between symbols
finite-state machine
turing machine
tm
control
state diagram
transition function
tape
infinite tape
tape head
input string
blank symbol
blank symbol t
accept
reject
state
set of states
start state
q0
accept state
qaccept
reject state
qreject
input alphabet
tape alphabet
7-tuple
computation of a turing machine
configuration
starting configuration
accepting configuration
rejecting configuration
halting configuration
yields
tracing a turing machine
computational tree
language of a turing machine
L(M)
recognizes
turing-recognizable
decider
decide
turing-decidable
loops indefinitely
pumping lemma
regular language
language B
dfa
nfa