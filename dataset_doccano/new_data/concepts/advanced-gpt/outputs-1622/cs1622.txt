function
function header
function body
function name
parameter
return
return type
scope
passing-in
pass-by-value
pass-by-reference
void
variable
primitive type
non-primitive type
static
non-static
public
protected
private
visibility type
parentheses
curly brackets
braces
computer language
declarative language
programming language
interchange format
binary file format
network protocol
curry-howard correspondence
proof language
proof assistant
machine code
machine language
assembly language
high-level language
HLL
low-level language
abstraction
compiler
source language
target language
transpiler
recompiler
decompiler
JVM bytecode
interpreter
ahead-of-time
AOT
just-in-time
JIT
frontend
backend
intermediate representation
IR
lexical analysis
lexing
scanning
token
syntactic analysis
parsing
grammar
abstract syntax tree
AST
semantic analysis
type checking
optimization
code generation
type theory
type system
static typing
dynamic typing
strong typing
weak typing
parametric types
generics
runtime representation
memory management
automatic memory management
ABI
linking
systems language
rustup
cargo
crate
crates.io
vector
algebraic data types
functional programmingvec
indexing
len
push
iterator
iter
for-in loop
enumerate
mapping
map
collect
function literal
anonymous function
lambda
algebraic data types
adts
abstract data types
algebraic types
primitive types
product types
sum types
struct
tuple
field
pub
impl
constructor
new
method
self
&self
&mut self
associated function
mutator
. operator
:: operator
enum
variant
match
if let
..
option
some
none
lexing
lexer
token
unicode
codepoint
combining mark
utf-8
utf-16
utf-32
be
le
grapheme cluster
ascii
canonicalizationlexing
scanning
lexer
source code
parsing
token
whitespace
indentation
comment
newline
location information
line number
column number
truss
keyword
identifier
symbol
literal
integer literal
string literal
float literal
grammar
language
alphabet
terminal
nonterminal
metalanguage
sequencing
alternation
repetition
optional
grouping
unicode
digit
lookahead
EOF
end of file
start rule
top-level rule
compiler compiler
ambiguity
tokenization
maximal munch
parser
regular language
disambiguation
semantic analyzer
semantic analysis
lexing algorithm
error messagefunction
functions
parameter
parameters
function body
function header
function name
header
return
returns
return type
scope
passing-in
pass-by-value
pass-by-reference
void
variable
variables
primitive
public
lexing
lexing grammars
regular languages
dependency graph
DAG
directed acyclic graph
alphabet
context-free grammars
CFGs
context-free languages
recursive rules
recursion
nesting
lexer
parser
token
terminals
abstract syntax trees
ASTs
syntax
value
expression
statement
box
reference
heap
stack
call stack
null
option
constructor
enum
binary operator
constant
negation
macro
preprocessor macros
parsingtop-down parsing
parsing
grammar
grammar rule
nonterminal
terminal
right-hand side
derivation
abstract syntax tree
AST
token
lisp
recursive descent
recursive descent parser
recursion
recursive function
metalanguage
sequencing
alternation
0+ repetition
1+ repetition
optional
ast node
struct
enum
array
vector
option
parser
lexer
lexing
program rule
exp
parens
id
num
identifier
integer
parenthesized expression
left parenthesis
right parenthesis
error handling
rust
result type
ok
err
? operator
type alias
error message
error reporting
error recovery
unexpected token
lookahead
backtracking
exponential time
location information
line
column
range
semantic analysis
semantic error
context-free grammar
CFG
error contextbottom-up parsing
top-down parsing
generalized bottom-up parsing
hybrid parsing approach
order of operations
PEMDAS
BODMAS
BIDMAS
operator
operator precedence
operator associativity
left-associative operators
right-associative operators
non-associative operators
operator precedence table
order of evaluation
parentheses
implicit parentheses
AST
expression
expression grammar
grammar
right-branching
left-branching
unary operator
postfix operator
binary operator
primary expression
parenthesized expression
identifier
literal
function call
field access
array indexing
cast
bitwise operators
operator stack
operand stack
parser
expression parser
recursive descent
recursive-descent parser
program
function
block
stmt
ifstmt
expstmt
assignstmt
primaryexp
idexp
intlitexp
parenexp
term
unaryop
postfixop
callop
fieldop
indexop
exp
binaryop
syntactic sugar
desugaring
lexing
parsing
semantics
semantic analysis
optimization
code generation
iterator
generic for loopfunction
function header
function body
function name
parameter
return type
scope
passing-in
pass-by-value
pass-by-reference
void
variable
primitive type
non-primitive type
visibility type
public
static
semantics
dynamic
compile-time
runtime
link-time
load-time
abstraction
HLLs
high-level languages
static check
halting problem
semantic analysis
type
type system
untyped language
compound type
struct
class
tuple
array
generic type
type constructor
type argument
name resolution
scoping
static name resolution
dynamic name resolution
static scope
dynamic scope
shadowing
evaluation
side effect
evaluation order
eager evaluation
lazy evaluation
dynamically-typed language
AST
abstract syntax tree
AST interpreter
call stack
arrayindexoutofboundsexceptionfunction
function call
static function call
non-static function call
function components
function header
function body
function name
parameter
return
return type
void
scope
visibility type
public
protected
private
static
passing-in
pass-by-value
pass-by-reference
variable
primitive type
non-primitive type
symbol table
symbol
scope tree
scope tree data structure
global scope
parent scope
child scope
scoping rules
scoping violation
name-checking
semantic analysis
declaration
use
name resolution
name resolution algorithm
forward reference
local variable
block statement
identifier
ID
AST
abstract syntax tree
referent
use map
declaration map
name context
type context
type checking
type error
symbol object
symbol id
node id
current scope
class scope
method scopefunction
function header
function body
function name
parameter
return type
visibility type
static
function call
scope
passing-in
pass-by-value
pass-by-reference
void
variable
primitive type
public
type
type theory
type system
type error
type safety
progress
preservation
undefined behavior
UB
decidability
decidable
undecidable
type checking
halting problem
problem domain
domain-specific languages
DSLs
static typing
dynamic typing
statically typed language
dynamically typed language
subtyping
virtual methods
existential polymorphism
type coercion
punning
type conversion
implicit conversion
strong typing
weak typing
type inference
term
inference rules
axiomatic rule
type context
symbol table
name resolution
truss
int
bool
string
()
function type
type constructor
higher-order function
statement
AST
depth-first traversal
type equalitypolymorphism
ad-hoc polymorphism
overloading
function overloading
operator overloading
overload set
symbol table
implicit type conversion
name mangling
signature
subtype polymorphism
subtyping
class hierarchy
base type
subtype
subclass
superclass
interface
trait
supertrait
generics
templates
duck typing
late binding
union
void pointer
static dispatch
dynamic dispatch
data layout
virtual method
virtual method table
vtable
parametric polymorphism
type argument
identity function
universal quantification
monomorphization
type inference
turbofish
bounded quantification
existential type
extends
comparable
partialord
downcast
instanceof
type checking
runtime type checking
multiple dispatch
type system
static type system
undecidable type system
object graph
don't repeat yourself
arraylistbackend
source language
target language
AST
semantic analysis
intermediate representation
IR
code generation
codegen
correctness
code quality
speed
size
runtime
compile-time
dynamic dispatch
reflection
class loading
garbage collection
exceptions
CPU
ISA
ABI
application binary interface
calling convention
system call
stack
heap
runtime library
standard library
stdlib
stack frame
symbol table
local variable
global variable
control flow
linking
linker
call graph
symbolic linking
relocation
position-independent code
pc-relative addressing
branch-and-link
debugging info
executable format
.text
.data
.rodata
.debug
object file
executable
executable file
library
static library
dynamically linked library
assembly language
machine code
MIPS
entry point
registerdynamic memory management
allocation
deallocation
lifetime
ownership
owner
static allocation
dynamic allocation
global variables
local variables
stack
stack frame
indirection
memory address
pointer
reference
referent
dereferencing
heap
object
memory safety
arena allocation
manual memory management
aliasing
pointer aliasing
dangling pointers
pointer arithmetic
undefined behavior
UB
roots
reachability
in-degree
reference counting
refcounting
memory leak
garbage collection
GC
tracing garbage collection
tracing GC
mark-and-sweep
garbage
garbage collector
mutation phase
collection phase
type safety
concurrent collectors
multithreaded collectors
generational collectors
copying collectors
directed acyclic graph
DAG
automatic heap memory managementapplication binary interface
abi
architectural abi
os abi
language abi
operating system
os
isa
backend
calling convention
function calls
call stack
stack pointer
sp
frame pointer
fp
frame pointer register
return address
return address register
ra
v0
a registers
t registers
v registers
s registers
stack frame
function prologue
function epilogue
callee cleans the stack
stack alignment
stack overflow
stack growth direction
system call
syscall
system call mechanism
syscall instruction
native function
jvm
codegen
code generator
standard library
stdlib
runtime library
language runtime
memory regions
.data segment
heap
stack
global variables
local variables
string literals
runtime data representation
reference types
function pointers
struct references
zero-terminated ascii
mips abi
standard mips abi
truss's mips abi
mips
mars
object file formats
executable format
executables
shared libraries
memory layout
asynchronous messages
bare metal
dynamic method dispatch
exceptions
function closures
string concatenation
array bounds checking
object allocation
tracing garbage collector
garbage collector
os api
HLLs
STRLIT labelcalling convention
caller
callee
stack frame
prologue
epilogue
fp
sp
ra
saved registers
s registers
t registers
a registers
v registers
ATV rule
function call
return value
block statement
local variable
global variable
AST
register allocation
saved register contract
control flow statements
conditional
loop
lazy operators
short-circuiting
logical and
logical or
comparison operator
code generation
codegen
lexing
lexer
parsing
token
semantic analysis
typing rules
evaluation rules
array
array type
index
length field
array length
runtime representation
heap
runtime library
rt$new_array
dynamic memory allocation
runtime error checking
array allocation
standard library
array initializer
array literal
multi-dimensional array
multi-dimensional array initialization
array of arrays
minimum viable product
item sizeprimitive types
arrays
tuple
heterogeneous types
empty tuple
unit
void
record type
struct
fields
structural identity
nominal identity
value types
reference types
null
bottom type
runtime representation
data layout
alignment
struct padding
field offset
dynamic allocation
runtime library function
rt$new
object-oriented programming
OOP
method
method call
static dispatch
constructor
inheritance
data inheritance
method inheritance
base class
derived class
subtyping
supertype
virtual method
dynamic dispatch
run-time type identification
RTTI
virtual method table
vtable
virtual method call
prefixing
interface
static variable
static method
nullable reference typescontrol flow graph
CFG
abstract syntax tree
AST
intermediate representation
IR
MIR
basic block
BB
successor
predecessor
back edge
flowchart
control flow analysis
data flow analysis
code generation
codegen
lowering
frontend
backend
source language
target language
optimization
terminator
return terminator
goto terminator
conditional terminator
locals
local variables
temporaries
places
constants
sources
field access
global variables
int literal
string literal
bool literal
function address
function call
return value
$t0
entry point
bb0
postorder
depth-first traversal
machine code
assembly language
asm
control flow statements
unreachable code
MIPS
ABI
MIPS ABI
ISAoptimization
resource utilization
time
code size
memory size
power
registers
common subexpression elimination
CSE
constant folding
strength reduction
local optimization
global optimization
interprocedural optimization
IR
AST
BB
CFG
dead code
dead code elimination
DCE
function inlining
method inlining
side effects
peephole optimization
operation
move
assignment
algebraic simplification
target code
code generator
single assignment form
single static assignment form
SSA
copy propagation
dead store elimination
control flow analysis
function prologue
function epilogue
codegen
round-robin schemeglobal optimization
local optimization
copy propagation
constant folding
dead store elimination
basic block
bb
control flow graph
cfg
data flow analysis
forward analysis
backward analysis
reachability
unreachable basic block
visited set
control flow optimization
global constant copy propagation
gccp
constant copy propagation
def
use
def-use
state
in-state
out-state
transfer function
join function
const
any
unk
predecessor
successor
equilibrium
termination
liveness
live variable
liveness range
ssa
static single assignmentliveness
liveness algorithm
backward analysis
forward analysis
before-state
after-state
in-state
out-state
transfer function
join function
use
def
live
dead
successor
CFG
IR
BB
bit vector problem
register allocation
register pressure
MIPS
ABI
ISA
RISC
a registers
v registers
t registers
s registers
register interference graph
RIG
graph coloring
k-colorable
chromatic number
NP-complete
NP-hard
coloring heuristic
stack
pop and color
spilling
spill candidate
live range
load
store
iterative register allocation
function inlining
coalescing
pre-coloring
argument registers
return value registers
saved temporary registers
temporary registers
locals
edge
node