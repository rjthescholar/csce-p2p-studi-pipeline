Formal Methods
Finite Automata
Turing Machines
Decidability
Reducibility
Time Complexity
Post Correspondence Problem
algorithms
Computational Models
Turing Machine
Modified Travel Salesman Problem
algorithm
Proof
Z
integer
integers
even number
even
odd number
odd
Proof by Contradiction
rational number
numerator
denominator
irreducible fraction
coprime
canonical form
irrational numberFunctions
Predicates
Sets
Notations
Operations
Sequences
Proofs
Construction
Contradiction
Set
∅
empty set
∈
6∈
Function
D
R
domain
range
mod
Predicate
true
false
Union
∪
Intersection
∩
Complement
Set Different
−
\
Cartesian Product
×
|A|
Big Union
Sequence
tuple
k-tuple
2-tuple
ordered pair
Alphabet
Σ
ΣA
ΣB
String
|s|
ε
Concatenation
substring
Language
shortlex order
lexicographic ordering
dictionary ordering
Boolean Logic
boolean value
True
False
Boolean operators
¬
∧
∨
→
↔
⊕
DeMorgan
Implication
Equality
Exclusive or
Distributive
Proof
Proof by Construction
Proof by Contradiction
P
Q
P → Q
T
F
odd
even number
rational number
irrational numberFinite Automata
getFrontPad()
getRearPad()
openDoor()
closeDoor()
State Diagram
State Transition Table
Finite State Machine
start state
accept state
non-accept state
transition functions
language
Finite-State Automaton
five tuple
Q
Σ
alphabet
δ
q0
F
accept states
L(M)
empty string
ε
<RESET>Finite Automata
string
substring
finite automaton
Σ
alphabet
δ
Regular Languages
regular language
finite-state automaton
finite-state machines
Deterministic Finite Automaton
DFA
regular operations
Union
∪
Concatenation
◦
Star
∗
ε
∅
closed under operation
finite-state machine
∩Finite Automata
Nondeterministic Finite Automaton
Σ
Deterministic Finite Automaton
DFA
NFA
alphabet
ε
ε transitions
Computational Tree
accept state
input string
empty string
Q
Σε
δ
transition function
P(Q)
powerset
q0
start state
F
accept states
start states
E(R)
ε arrows
closure
union operation
concatenation operation
star operation
regular language
regular languagesRegular Expressions
regular expression
alphabet
Σ
ε
∅
∪
◦
∗
recursive definition
arithmetic expression
language
languages
Σ∗
R+
Rk
Operator Precedences
Identities
floating-point number
floating-point numbers
D
DFA
NFA
regular language
regular languages
Lemma 1.55
ΣΣ
ΣΣΣRegular Language
regular language
regular expression
regular languages
finite-state machines
finite-state machine
Generalized Nondeterministic Finite Automaton
GNFA
NFA
DFA
accept state
accept states
start state
Regular Expression
regular expressions
Theorem 1.54
Finite Automaton
Nonregular LanguagesLanguage
strings
regular
empty language
regular expression
finite language
infinite language
non-regular language
Regular Infinite Languages
finite state machines
loop
L(M)
10∗ 1
00(1010)∗ 0
DFA
Pigeonhole principle
x
y
z
xy i z
Pumping Lemma
pumping length
0n 1n
0p 1pPumping lemmaHuman Computer
finite alphabet
Turing machines
Turing machine
control
tape
tape head
blank symbol
t
accept
reject
Σ
#
B
Pumping lemma
7-tuple
Q
input alphabet
tape alphabet
Γ
δ
q0
qaccept
qreject
transition function
reject state
L
R
configuration
yields
starting configuration
accepting configuration
rejecting configuration
halting configuration
Turing-recognizable
recognizable
decider
deciders
decide
Turing-decidable
decidableB
#
qaccept
M1
Γ
qreject
A
tape head
left-most square
M2
state diagram
blank symbolTuring Machine
Turing machine
tape
reject state
Copy
NB
PB
R
Equal
tape head
blank symbol
tape heads
Multitape Turing Machines
multitape Turing machines
transition function
three-tape TM
TM
Multitape TMs
one-tape Turing machine
single-tape TM
Nondeterministic Turing Machine
nondeterministic Turing machine
NTM
deterministic Turing machine
Theorem 3.16
breadth first search
Universal Turing Machine
universal TM
Church-Turing Thesis
TMsQ
δ
transition function
q0
F
Language of a DFA
Language Operatorsrecognizable
decidable
deciders
Decidable Language
decidable languages
Undecidable Language
polynomial
root
integral root
brute force
Hilbert’s tenth problem
hxi
string representation
hpi
D1
upper/lower bound
out-of-bound
implementation description
high-level description
where clause
universal Turing machine
subroutine
Church-Turing thesis
power of 2decider
L(M)
Decidable Languages
ADFA
ANFA
decidable language
AREXEDFA
L(A)
TM S
TM M
TM T
graph theory
EQDFA
L(B)
set theory
Closed Under Complement
Closed Under Union
Closed Under Intersection
L(C)
TM F
EQ DFA
TM N
TM P
ADFA
ANFA
AREX
ONE DFA
TM M 0
M 0Decidability
Undecidability
ATM
decidable
Unrecognizable Lanugage
Cantor’s Observation
one-to-one
onto
bijection
correspondence
N
E
Countable
uncountable
Q
Positive Rational NumbersReal Numbers
real numbers
Uncountable
real number
R
decimal representation
countable
correspondence
N
Diagonalization
Countable
one-to-one
onto
binary representation
Infinite Binary Sequence
infinite binary sequence
infinite binary sequences
B
binary sequence
encoding
string representation
dictionary orderUndecidable Language
ATM
decider
encoding
Unrecognizable Language
recognizable language
boolean algebra
ADFA
ANFA
AREX
EDFA
EQDFA
correspondence
countable
uncountable
DiagonalizationReducibility
reducible
decidable
boolean algebra
undecidable
ATMinfinite loop
loops indefinitely
language of a TM
language of TM
Σ∗ − {ε}Turing Machines as Methods
Language of a Turing Machine
L(M)
Language of a MethodReducibility
Undecidability
undecidable language
ATM
proof by contradiction
decidable
Halting Problem
HALT TM
decider
ETMReducibility
REGULAR TM
0n 1n
HALT TM
ETM
EQ TM
ONE TMReductions
HALT TM
ETM
REGULAR TM
EQ TM
Reduction via Computation Histories
Computation Histories
configuration
start configuration
accepting configuration
rejecting configuration
accepting computation history
rejecting computation history
Linear Bounded Automaton
LBA
ALBA
ELBA
computation history methodPost Correspondence Problem
Reducibility
ETM
TM
Mapping Reducibility
mapping reducible
EQTM
Computation History
ELBA
LBA
accepting computation history
PCP
domino
dominoes
match
Modified Post Correspondence Problem
MPCPReducibility
Mapping Reducibility
mapping reducible
computable function
reduction
Reductions
≤m
decidable
undecidable
HALT TM
HALTTM
ETM
REGULAR TM
EQ TM
EQTM
Post Correspondence Problem
MPCP
PCPTime Complexity
running time
Big-O
Big-O notation
Small-o
Small-o notation
asymptotic analysis
asymptotic upper bound
polynomial bounds
exponential bounds
time complexity class
TIME(t(n))
model of computation
multitape Turing machine
multitape Turing machines
single-tape Turing machine
single-tape Turing machines
nondeterministic Turing machine
nondeterministic single-tape Turing machine
deterministic single-tape Turing machine
computation treePolynomial time
Exponential time
TIME(nk )
PATH
Brute-Force Algorithm
RELPRIME
Euclidean Algorithm
Greatest Common Divisor
gcd
Hamiltonian path
HAMPATH
Polynomial verifiability
COMPOSITES
RSA algorithmHamiltonian Path
Hamiltonian path
directed graph
HAMPATH
Verifier
polynomial time
TM
polynomial verifiability
COMPOSITES
polynomially verifiable
certificate
Class NP
NP
Nondeterministic Polynomial time
NP -Problems
P
Nondeterministic
Nondeterministic Finite Automaton
NFA
Nondeterministic Turing Machine
NTM
brute-force algorithm
single-tape Turing machine
nondeterministic polynomial time Turing machine
polynomial time verifier
NTIME(t(n))
NTIME(nk )
CLIQUE
clique
undirected graph
k-clique
SUBSET −SUM
multisets
subsetNP-Complete
NP-COMPLETENESS
Polynomial Time Reducibility
polynomial time computable function
polynomial time Turing machine
polynomial time mapping reducible
polynomial time reducible
≤p
polynomial time reduction
P
Satisfiability Problem
SAT
boolean variables
boolean operators
Conjunctive Normal Form
cnf
literal
literals
clause
clauses
boolean variable
cnf-formula
3cnf-formula
3SAT
CLIQUE
undirected graph
k-clique
NP
polynomial time verifier
Cook-Levin Theorem
VERTEX −COVER
HAMPATH
SUBSET −SUMPSUBSETDFA
ALLBUTONETM
NOTPRIME
verifier
Verifier