function
computer languages
declarative languages
programming languages
network protocols
Curry-Howard correspondence
proof languages
proof assistants
CPU
machine code
assembly language
high-level languages
HLLs
abstraction
compiler
source language
target language
transpilers
recompilers
decompilers
Java
javac
C
gcc
JVM Bytecode
x86 Machine Code
machine language
ghidra
hex-rays
Ahead-of-time compilers
Just-in-time compilers
AOT
JIT
interpreter
bytecode
native code
frontend
backend
intermediate representation
IR
Lexical Analysis
Lexing
Scanning
token
tokens
Syntactic Analysis
Parsing
grammar
AST
Abstract Syntax Tree
Semantic Analysis
type checking
optimization
codegen
code generation
grammars
abstract syntax trees
type theory
type systems
static typing
dynamic typing
strong typing
weak typing
parametric types
generics
runtime representation
memory management
ABIs
ABI
linking
Functional programming style
Algebraic data types
Rust
PL theory
rustup
Rust toolchain
cargo
crate
crates
crates.io
vector
vectorsRust
Strings
Text
Vectors
Vec<T>
ArrayList<T>
Iterable
Iterator
.iter()
for-in loop
enumerate()
mapping
function literal
anonymous function
lambda
Algebraic Data Types
Structs
ADTs
abstract data types
primitive types
char
algebraic types
Product Types
Sum Types
struct
tuples
inheritance
OOP
impl
constructor
new
self
. operator
:: operator
associated function
enum
if let
match
null
Option
Some
None
Unicode
Lexing
tokens
codepoint
codepoints
combining mark
UTF-8
UTF-16
UTF-32
BE
LE
grapheme clusters
substring
toUpper
toLower
collating
codePointAt()
codePoints()
ASCII
canonicalizationLexing
Grammars
compiler
source code
string
scanning
parsing
lexer
Lexer
tokens
token
language
indentation
whitespace
comments
Python
JavaScript
ECMAScript
newlines
semicolons
location info
line number
column number
compilation process
Truss
Rust
Java
keywords
keyword
identifiers
identifier
symbols
symbol
literals
literal
floats
float
strings
alphabet
terminal
grammar
nonterminal
metalanguage
sequencing
alternation
repetition
optional
Unicode
Symbol
Keyword
Id
IdStart
IdCont
Digit
Alphabetic
IntLit
StrLit
StrChar
Whitespace
Comment
CommentChar
CommentEnd
Eof
lookahead
Token
Program
COMPILER COMPILERS
parser
ambiguity
Maximal Munch
regular languages
Semantic Analyzer
semantic analysisCFGs
ASTs
regular grammars
lexing
regular languages
Program
WS
Token
Id
IdStart
IdCont
IntLit
DAG
directed acyclic graph
Exp
alphabet
context-free languages
context-free grammars
expressions
statements
context-sensitive grammar
CSG
lexer
parser
tokens
CFG
terminals
abstract syntax tree
AST
values
expression
value
statement
parsing
semantics
Rust
Box
Call Stack
Heap
Option
None
Some
enum
AstNode
recursion
macrosTop-down Parsing
Parsing
grammar
Exp
Id
Num
Parens
token
nonterminals
derivation
abstract syntax tree
AST
Lisp
lexing
Rust
Result
Ok
Err
AstNode
ParseError
ParseResult
?
Recursive Descent
CFGs
struct
enum
Parser
lexer
backtracking
Expressions
error recovery
semantic analysisBottom-up Parsing
Operators
operator
operators
order of operations
PEMDAS
BODMAS
BIDMAS
Operator Precedence
precedence
Operator Associativity
left-associative
right-associative
associativity
non-associative
Unary operator
Unary operators
postfix operator
postfix operators
binary operator
binary operators
primary expression
PrimaryExp
IdExp
IntLitExp
ParenExp
Term
UnaryOp
PostfixOp
CallOp
FieldOp
IndexOp
Exp
BinaryOp
expression grammar
recursive-descent parser
recursive descent
Bottom-up parsing
Right-branching
Left-branching
operator stack
operand stack
generalized bottom-up parsing
desugaring
syntactic sugarSemantic Analysis
semantics
static
dynamic
compile-time
runtime
link-time
load-time
static checks
halting problem
Types
type
typing
untyped
type system
type systems
primitive types
primitive type
compound types
compound type
arrays
array
generic type
generic types
type constructor
type constructors
ArrayList
ArrayIndexOutOfBoundsException
undecidable
decidable
Naming
name resolution
scoping
scope
static name resolution
dynamic name resolution
Evaluation
Execution
side effects
evaluation order
eager evaluation
lazy evaluation
dynamically-typed language
AST interpreterScoping
Symbol tables
Scope trees
name-checking
semantic analysis
scope
symbol table
symbol
symbols
global scope
child scope
parent scope
Name Resolution
declaration
use
use map
typechecking
forward references
mutual references
forward reference
scope-building
Nametags
Node ID
Box
Rc<T>
symbol object
symbol ID
bidirectionally linked scopes
declaration map
name context
type contexttype
type error
Type safety
Progress
Preservation
undefined behavior
UB
decidability
halting problem
dynamic types
subtyping
virtual methods
existential polymorphism
type coercion
type conversion
punning
type inference
primitive types
int
bool
string
()
void
Truss
function types
fn
type constructor
higher order function
inference rules
axiomatic rules
term
type context
integer literals
depth-first traversal
type equalityPolymorphism
subclasses
interfaces
traits
templates
function name overloading
operator overloading
unions
void pointers
duck typing
late binding
Ad-Hoc Polymorphism
overloading
symbol table
overload set
implicit type conversions
name mangling
Subtype Polymorphism
subtypes
base types
base type
multiple dispatch
virtual method table
vtable
dynamic dispatch
supertrait
Parametric Polymorphism
universal quantification
turbofish
monomorphization
Bounded Quantification
existential type
PartialOrd
function overloading
monomorphizedBackend
Runtime
HLL
code quality
Application Binary Interface
runtime library
Standard Library
stdlib
stack frame
symbol table
call graph
linker
symbolic linking
Relocations
Position-independent code
PC-relative addressing
Debugging info
Executable formats
object files
entry pointDynamic Memory Management
Allocation
Deallocation
Lifetime
Ownership
static allocation
dynamic allocation
stack
stack frame
sp
Indirection
Pointers
references
pointer
reference
memory address
Dereferencing
heap
object
objects
Memory safety
memory-safe
arena allocation
manual memory management
Undefined Behavior
UB
Aliasing
digraph
in-degree
race condition
race conditions
deadlock
deadlocks
dangling pointer
dangling pointers
pointer arithmetic
Automatic heap memory management
root
roots
reachability
reference counting
refcounting
refcount
memory leak
Tracing Garbage Collection
tracing GC
Garbage Collection
mark-and-sweep
type safety
concurrent collectors
multithreaded collectors
generational collectors
copying collectorsABI
Application Binary Interfaces
ABIs
Application Binary Interface
API
Language ABI
OS ABI
Architectural ABI
ISA
object file formats
system calls
shared libraries
exceptions
dynamic method dispatch
function closures
stack pointer
sp
stack overflow
calling convention
return address
ra
syscall
Runtime Libraries
standard library
stdlib
standard libraries
runtime library
runtime libraries
MIPS
MARS
tracing garbage collector
string literals
reference types
Stack Frames
stack frame
local variables
frame pointer
fp
Function Prologue
Function Epiloguecalling convention
caller
sp
t0
jal
v0
ATV rule
a registers
t registers
v registers
s registers
callee
stack frame
saved registers
fp
ra
prologue
epilogue
block statements
global variable
saved register contract
register allocation
control flow statements
lazy operators
short-circuiting
comparison operators
runtime representation
dynamic memory allocation
runtime library
rt$new_arrayStructs
Classes
primitive types
tuple
unit
record type
structural identity
nominal identity
value types
reference types
bottom type
Data layout
alignment
padding
struct padding
memory allocator
object-oriented programming
methods
method call
privacy
constructors
runtime type identification
static dispatch
data inheritance
base class
derived class
prefixed representation
method inheritance
subtype
supertype
type information
Virtual Methods
Dynamic Dispatch
RTTI
virtual method tables
vtables
function pointers
virtual method calls
indirect function call
nullable reference types
multiple inheritanceControl Flow Graphs
IR
CFG
MIPS ABI
MIPS
control flow analysis
data flow analysis
Intermediate Representation
Lowering
MIPS Backend
x86 Backend
x86
ISA
optimization
optimizations
rustc
MIR
control flow graph
basic block
basic blocks
successor
successors
temporary registers
locals
temporaries
local
places
Sources
place
constant
constants
source
function addresses
function address
terminators
return terminator
goto terminator
conditional terminator
BB
entry point
predecessor
predecessors
back edge
postorderLocal Optimization
optimization
resource utilization
common subexpression elimination
CSE
constant folding
strength reduction
local optimizations
global optimizations
interprocedural optimizations
basic block
BB
control flow graph
CFG
Dead code elimination
DCE
Function inlining
peephole optimizations
Algebraic Simplification
Single Static Assignment Form
SSA
copy propagation
dead store eliminationGlobal Optimization
Local optimization
copy propagation
dead store elimination
basic block
BB
BBs
CFG
constfold
RHS
Data Flow Analysis
terminator
forward analysis
backward analysis
Global Constant Copy Propagation
GCCP
def
defs
use
uses
def-use
SSA
state
transfer function
join function
UNK
ANY
CONST
Liveness
register allocationLiveness
Register Allocation
Backwards Analyses
before-state
after-state
DEAD
LIVE
transfer function
control flow graph
CFG
basic block
BB
join function
bit vector problems
Register pressure
RISC
MIPS
load
store
Register Interference Graph
RIG
undirected graph
graph coloring
k-colorable
colorability
chromatic number
NP-complete
NP-hard
heuristic
spill
spilling
live range
coalescing
pre-coloring