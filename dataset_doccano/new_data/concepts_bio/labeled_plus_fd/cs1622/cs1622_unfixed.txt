curry-howard correspondence
machine code
language
rust
assembly language
proof
algebraic data types
& mut self
field
some
abstract data types
primitive types
lambda
mutator
product types:
adts
associated function
& self
be
match
vec
pub
.map
new (
v.len
impl
sum types
constructor
for-in loop
iterator
.iter
mapping
method
.enumerate
enum
new
v.iter
.collect
anonymous function
struct
product types
a.iter
privacy
.iterator
function literal
!
v.push
column number
not-so-whitespace
lexing
indentation
lexer
line number
location info
intlit
token
language
id
scanning
source code
whitespace
lexing
nesting
alphabet
csg
syntax
token
some
dependency graph
parser
dag
directed acyclic graph
cfg
parsing
context-sensitive grammar
abstract syntax tree
lexer
top-down parsing
bottom-up parsing
semantics
semantic analysis
table
void
semantic analysis
scope
variables
of a name
symbol
functions
decidability
halting problem
term
type-safe
ub
system
error!
type
theory
undefined behavior
int
preservation
safety
progress
type-checking
type-unsafety
polymorphism
generics
duck typing
subtype
class hierarchy
set
do n't repeat yourself
symbol table
late binding
name mangling
overload
abstraction
operator overloading
code generation
runtime
intermediate representation
target language
code quality
size
library
ir
correctness
hll
vm
source language
abi
application binary interface
backend
ast
speed
dynamic memory management
deallocation
ownership
lifetime
allocation
static allocation
:
global variables
language abi
abi
codegen
application binary interface
machine code
backend
stack
epilogue
sp
epilogue;
atv rule
v registers
fp
saved registers
prologue
arguments
return value
v0
ra
arrays
s registers
calling convention
callee
codegen
frame
caller
int
tuple
reference type
class
value type
null
unit
oop
void
struct
record type
nominal identity
this
structural identity
mips
source language
frontend
x86
codegen
backend
optimization
ast
assembly code
target language
abi
machine code
if
while
cfg
control flow analysis
semantic analysis
for
intermediate representation
flowchart
ir
data flow analysis
isa
lowering
operation
power
cfg
code size
optimization
constant folding
registers
strength reduction
memory size
elimination
time
ast
dead code
cse
local optimizations
global optimizations
bb
resource utilization
ir
common subexpression elimination
control flow optimization
visited set
cfg
copy propagation
def
gccp
use
function
global optimization
return
basic block
local optimization
graph-visiting algorithm
variable
functions
reachability
def-use
forward analysis
bb
data flow analysis
any
backward analysis
transfer function
before-state
in-state
dead
join function
algorithm
use
after-state
register allocation
ir
out-state
live
bbs
cfg
successor
liveness
