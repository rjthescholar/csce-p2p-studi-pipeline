{"id": 11, "segment": "dev_set", "course": "cs0449", "lec": "lec11", "text": "11\n\nHow\nPrograms\n\nAre Managed\n\nCS/COE 0449\nIntroduction to\nSystems Software\n\nLuis Oliveira\n(with content borrowed from wilkie and Vinicius Petrucci)\n\nWhere's the Lie?\nAnd other operating systems questions.\n\n2\n\nOn the last episode...\n\u2022 Programs are loaded into memory by the\noperating system.\n\u2022 They have to exist in memory before they can\nbe executed.\n\nKernel Memory\nstack\nlibz.so .data\n\nlibz.so .text\n\n\u2022 Programs go through a lot of trouble to have\nall their data/code in memory.\n\n.bss\n.data\n\n.text\n\n3\n\n3\n\nThe Lie\n\u2022 Programs are told that they are\nthe only things running...\n\u2022 The only things in memory...\n\u2022 We know that this is not true!\n\u2022 Operating Systems are big liars\ncrafting illusions.\n\n4\n\nThe Truth\n\u2022 In reality, many programs can be running at the same time.\n\u2022 Each program, when running, is typically called a process.\n\u25aa A multitasking OS is (a rather common) one that supports concurrent\nprocesses.\n\n\u2022 The OS must handle switching from one process to another.\n\u25aa Which processes get to run?\n\u25aa What if you have more processes than CPUs?\n\u25aa When do you switch from one to another?\n\u25aa What if one is more urgent??\n5\n\nMy process is one of method...\n\u2022 A process is an abstraction representing a single instance of a program.\n\u25aa An executable represents the initial state of a program and thus the process.\n\u25aa A program can be instantiated multiple times, if needed.\n\u25aa Each one would be a separate process... of the same program.\n\u25aa Note: A processor is the hardware unit that executes a process. (makes sense!!)\n\n\u2022 The Operating System defines what a process and its abstraction is.\n\u25aa There is an OS representation and metadata associated with a process.\n\u25aa The OS maintains two key lies:\n\n\u2022 The control flow (exclusive use of CPU): as defined by the code (this lecture)\n\u2022 The memory layout (exclusive use of memory): defined by executable/code (next lecture)\n\n\u2022 We are focusing on the control flow, here.\n\n\u25aa How do we determine when a program runs? When does the lie... break down?\n6\n\nCPU Scheduling\nEeny Meeny Miney Moe\n\n7\n\nThe Reality\n\u2022 Let us say that we have a machine with four separate CPUs.\n\u25aa You could run four processes concurrently (at the same time) relatively easily.\n\u25aa What about the fifth?\nstack\n\nstack\n\nstack\n\nstack\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\nCPU State:\nRegisters\n,\n\n8\n\nMultiplexing the CPU\n\u2022 Truth be told, we often have fewer resources than needed.\n\u25aa Sharing a common resource is called multiplexing.\n\n\u2022 Now, consider a machine with a single CPU.\n\nProcess\n\nstack\n.bss\n\n\u2022 We often want to run something in the foreground.\n\n\u25aa Word processor, web browser, minesweeper... whatever.\n\n.data\n\n\u2022 We still want some things running the background...\n\n.text\n\n\u2022 We need to switch from one process to another at\nparticular times.\n\nCPU State:\nRegisters\n,\n\n\u25aa Music player, virus scanner, chat client.\n\n\u25aa Yet... we have to keep the illusion that the program is\nuninterrupted...\n\nCPU\n\n9\n\nNa\u00efve Campbell was great in The Craft (1996)\n\u2022 One way is to run processes sequentially (the na\u00efve solution)\n\u25aa When one process ends... run the next.\n\u25aa Yet that's not very flexible. (Stop your music player to open a PDF)\n\u2022 Humans are in the mix! We need computers to be useful to us.\n\nstack\n\nstack\n\nstack\n\nstack\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\nMemory\nCPU\n\n10\n\nThe cruel passage of time\n\u2022 To multiplex the CPU, we quickly switch from process to process.\n\u2022 The OS retains/restores the state (context) of the process.\n\u25aa The OS must store this as a form of process metadata in memory.\nstack\n\nstack\n\nstack\n\nstack\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\nCPU State A:\nRegisters\n,\n\nCPU State B:\nRegisters\n,\n\nCPU State C:\nRegisters\n,\n\nCPU State D:\nRegisters\n,\n\nMemory\nCPU\n\n11\n\nThe Context Switch\n\u2022 When an Operating System goes from\none process to another, it performs a\ncontext switch.\n\u2022 This swaps out the CPU state of one\nprocess for the next one to run.\n1. Store registers (including stack\npointer and program counter) to\nmemory.\n2. Determine next process to run.\n3. Load those registers from memory.\nSwitch memory space. (see next lecture:\n\nstack\n\nstack\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\nContext\n\nContext\n\nCPU State A:\nRegisters\n,\n\nCPU State B:\nRegisters\n,\n\nvirtual memory)\n\n4. Jump to old program counter. Go!\n\nCPU\n\n12\n\nA deeper dive\n\u2022 When we pause a process... we store the state of registers (context)\nx86-64 (gas / AT&T syntax) - Process A\n\nContext (A)\n\nx86-64 (gas / AT&T syntax) - Process B\n\nCPU State\n\n13\n\nWhen is a good time to call you?\n\u2022 When should a program pause and let another one go?\n\u2022 When programs voluntarily pause, this is called cooperative\nscheduling.\n\u25aa They may give up control at convenient points such as system calls.\n\n\u2022 We often do not expect this, so modern Operating Systems forcibly\npause programs from time to time. Called preemptive scheduling.\n\u25aa Processes give up control when hardware interjects via an \"interrupt\"\n\u25aa How does this work?\n\n14\n\nRound Robin Scheduling\n\u2022 One method is to just cycle through each process each for equal time.\n\u25aa This is an element of \"fairness\" ... each gets equal stake.\n50ms\n\n50ms\n\n50ms\n\n50ms\n\nstack\n\nstack\n\nstack\n\nstack\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\nCPU State A:\nRegisters\n,\n\nCPU State B:\nRegisters\n,\n\nCPU State C:\nRegisters\n,\n\nCPU State D:\nRegisters\n,\n\nMemory\nCPU\n\n15\n\nProblems with \"fairness\"\n\u2022 Let's say I want to play Doom Eternal\n\u25aa In round-robin, I give the video game 25% of my resources.\n50ms\n\n50ms\n\n50ms\n\n50ms\n\nstack\n\nstack\n\nstack\n\nstack\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\n.bss\n.data\n.text\n\nCPU State A:\nRegisters\n,\n\nCPU State B:\nRegisters\n,\n\nCPU State C:\nRegisters\n,\n\nCPU State D:\nRegisters\n,\n\nThis should get\nmore priority.\n\nCPU\n\n16\n\nI have priorities!\n\u2022 Round-Robin schedulers are fair; then we tweak to meet expectations.\n\u25aa How might we add a sense of \"priority\" to the scheduler?\n\n\u2022 Let's look at a visualization of how processes are currently scheduled\nwith a round-robin scheme: (Doom gets only 25% of resources!) \uf04c\n50ms\n\n50ms\n\n50ms\n\n50ms\n\n50ms\n\n50ms\n\nA\n\nA\nB\n\nB\n\nC\n50ms / 200ms = 25%\n\n17\n\nI have priorities!\n\u2022 Round-Robin schedulers are fair; then we tweak to meet expectations.\n\u25aa How might we add a sense of \"priority\" to the scheduler?\n\n\u2022 We could give some tasks a longer quantum.\n\u25aa A quantum is the amount of time a task is guaranteed to run.\n100ms\n\n50ms\n\n50ms\n\n50ms\n\n100ms\n\nA\nB\n\nC\n100ms / 250ms = 40%\n\n18\n\nI have priorities!\n\u2022 Round-Robin schedulers are fair; then we tweak to meet expectations.\n\u25aa How might we add a sense of \"priority\" to the scheduler?\n\n\u2022 We could increase the chance a specific task is scheduled.\n\u25aa Round-robin + priority: two queues, switch back and forth and round-robin\nwithin them.\n50ms\n\n50ms\n\n50ms\n\n50ms\n\n50ms\n\n50ms\n\nA\nB\n\nC\n100ms / 200ms = 50%\n\n19\n\nI have priorities!\n\u2022 Round-Robin schedulers are fair; then we tweak to meet expectations.\n\u25aa How might we add a sense of \"priority\" to the scheduler?\n\n\u2022 We can then always do some sort of combination.\n\u25aa Hybrid approaches do seem very alluring. Hmm. The power of trade-offs.\n100ms\n\n50ms\n\n100ms\n\n50ms\n\nA\nB\n200ms / 300ms = 67%\n\n20\n\nIdeal circumstances: Human perception\n\u2022 The reality: (very quickly switching)\n100ms\n\n50ms\n\n100ms\n\n50ms\n\nA\nB\n\n\u2022 The illusion: (an ideal: perceived concurrency... no delay noticed)\n100ms\n\n50ms\n\n100ms\n\n50ms\n\nA\nB\n\n21\n\nThere is no optimal.\n\u2022 Like many of the topics in this course, there is no possible \"best\".\n\u25aa That is, there is no way to perfectly schedule general processes.\n\n\u2022 Consider: It would be very lovely to schedule a process that handles\nsome user input, like a button press or a network request.\n\u25aa Perfect situation: the OS schedules the task that handles the button\nimmediately before the button is pressed. What luck!\n\n\u2022 However: You do not know when that button will be pressed.\n\u25aa Maybe it is a sensor, like for detecting a fire!\n\u2022 FIRE SEEMS IMPORTANT!! ... and yet.\n\n\u2022 Moral of the story: humans being users make things very hard.\n\n22\n\nAgain, it is not magic.\n\u2022 But... wait... how does hardware stop a program?\n\u25aa For instance, when the quantum is up, how does the OS get control and\nperform the context switch?\n\n\u2022 Ah, the hardware has support for \"being rude\" which is called an\ninterrupt.\n\u25aa A programmable mechanism for asynchronously calling a function when a\nparticular type of error or signal is noticed.\n\n\u2022 Let's take a look.\n\n23\n\nInterrupts\nIt's rude... but necessary.\n\n24\n\nHow rude\n\u2022 An interrupt is an exceptional state that diverts execution from its\nnormal flow.\n\u25aa When issued by hardware, sometimes referred to as a hardware exception\n\u2022 For instance, a hardware timer or external event caused by a sensor.\n\n\u25aa When caused by a user process, sometimes referred to as a software trap\n\u2022 Divide-by-zero error, some floating-point exceptions, system calls.\n\n\u2022 We have seen these before!\n\u25aa System calls are a type of interrupt (software trap).\n\u25aa This is an intentional interrupt caused by a specific program instruction.\n\u2022 The program is \"interrupted\" while the OS performs a task.\n\n\u2022 We have also encountered them in our failures.\n\u25aa Segmentation / Protection / Page Faults are also interrupts. (trap? exception?)\n\u25aa These are (usually) unintentional interrupts caused by a generic instruction. 25\n\nHere are some typical UNIX/Linux system calls:\nNumber\n\nName\n\nDescription\n\nread\n\nReads bytes from an open file.\n\nwrite\n\nWrites bytes to an open file.\n\nopen\n\nOpens a file and returns the file handle.\n\nclose\n\nCloses an open file.\n\nstat\n\nReturns metadata about a file.\n\nfork\n\nSpawns a copy of the current process.\n\nexecve\n\nLoads and then executes a program.\n\n26\n\nSystem calls\n\u2022 System calls: predictable, intentional interrupts at specific instructions.\n\u25aa Interrupts occurring at specific instructions are synchronous interrupts.\n\n\u2022 In x86-64, the program pauses at a\ninstruction, then resumes\nat the following instruction when the OS finishes the task\n\u25aa (... and the OS calls the\n\ninstruction)\n\n\u2022 Let's take a deeper look.\n27\n\nHello, Hello World\nx86-64 (gas / AT&T syntax) - Application\n\nx86-64 (gas / AT&T syntax) - Kernel (main OS program)\n\nPre-registered to be called on syscall\nSaves CPU state\n\nA jump to the kernel\n\nPerforms action\nRestores state\n\nReturns to process\n\n28\n\nTick tock tick tock merrily sings the clock\n\u2022 A hardware timer can preempt (forcibly pause) a program at any time.\n\u25aa Interrupts that occur at any instruction are asynchronous interrupts.\n\n\u2022 In a preemptive operating system, a hardware timer is used to give a\nmaximum bound to how long a process runs.\n\u25aa Your operating system programs the timer such that it sends a signal at a\nregular interval.\n\u25aa Your operating system has a function that is called when such a signal is read.\n\u25aa That function will respond by invoking the scheduler and pausing the current\ntask and resuming or starting another.\n\n\u2022 Let's look at the basic procedure an OS uses to program an interrupt.\n29\n\nProgramming interruption\n\u2022 On most hardware, there is a programmable table somewhere in\nmemory that, when written to, defines where code exist to handle\neach interrupt.\n\u2022 Every possible interrupt is given a number. Segmentation faults might\nbe interrupt 10. Timers might be interrupt 0. Et cetera.\n\u2022 When an interrupt occurs, based on its interrupt number, the\ncorresponding entry in a lookup table called an interrupt vector table\nor an interrupt descriptor table would be used to determine where in\nthe kernel to jump.\n30\n\nThe Interrupt Table\n#\n\nValue\n\n\u2022 The interrupt table is a simple table.\n\nDescription\nDivide by zero\n\n\u2022 Fun Fact: It is often located at\naddress 0x0 in memory!\n\nOverflow\nDouble Fault\nGeneral Protection Fault\nPage Fault\nStack Fault\nAlignment Error\n...\nTimer Signal\nNetwork Device Signal\n\n\u25aa So, operating system kernels can't\nexactly always treat zero as an invalid\naddress...\n\n\u2022 When a process triggers a listed\ninterrupt or external hardware sends\na signal to the interrupt controller...\n\u25aa the CPU jumps to the given address.\n\nAudio Device Signal\n\n31\n\nAh! There art thee ol' interrupt!\n\u2022 Let's take a look at interrupt handling...\nx86-64 (gas / AT&T syntax) - Process B\nA\n\nContext (A)\n\nCPU State\n\nx86-64 (gas / AT&T syntax) - Kernel\n\n\u2022 An interrupt is the likely\ncause of our prior\ninterruption.\n\u2022 The interrupt handler is the\ncode that handles context\nswitching and scheduling\n32\n\nOverview\n\u2022 Interrupts can be categorized in several ways:\n\u25aa They can occur outside of our program:\nhardware exceptions\n\u25aa They can occur on an instruction in our program: software trap\n\u25aa They can occur at any time:\nasynchronous interrupts\n\u25aa They can occur at specific times:\nsynchronous interrupts\n\n\u2022 Interrupts are what allow operating systems to function!\n\u25aa When you press a key on your keyboard.\n\u25aa When you receive a packet on the network.\n\u25aa When your sound card wants the next second of audio.\n\u25aa When you divide by zero...\n\u2022 To then mercilessly murder your process.\n\n33\n\n", "label": [[274, 290, "Concept"], [1520, 1536, "Concept"], [3806, 3822, "Concept"], [10455, 10471, "Concept"], [10557, 10573, "Concept"], [10651, 10667, "Concept"], [11737, 11753, "Concept"], [847, 849, "Concept"], [918, 920, "Concept"], [1598, 1600, "Concept"], [1662, 1664, "Concept"], [3435, 3437, "Concept"], [3497, 3499, "Concept"], [7689, 7691, "Concept"], [8137, 8139, "Concept"], [9039, 9041, "Concept"], [9903, 9905, "Concept"], [9939, 9941, "Concept"], [10102, 10104, "Concept"], [10884, 10886, "Concept"], [1727, 1730, "Concept"], [1986, 1989, "Concept"], [2305, 2308, "Concept"], [2349, 2352, "Concept"], [2506, 2509, "Concept"], [2782, 2785, "Concept"], [2927, 2930, "Concept"], [3327, 3330, "Concept"], [3381, 3384, "Concept"], [3657, 3660, "Concept"], [3683, 3686, "Concept"], [3709, 3712, "Concept"], [3735, 3738, "Concept"], [3768, 3771, "Concept"], [3908, 3911, "Concept"], [4214, 4217, "Concept"], [4240, 4243, "Concept"], [4320, 4323, "Concept"], [4507, 4510, "Concept"], [5266, 5269, "Concept"], [5292, 5295, "Concept"], [5318, 5321, "Concept"], [5344, 5347, "Concept"], [5377, 5380, "Concept"], [5636, 5639, "Concept"], [5662, 5665, "Concept"], [5688, 5691, "Concept"], [5714, 5717, "Concept"], [5772, 5775, "Concept"], [10160, 10163, "Concept"], [11938, 11941, "Concept"], [12130, 12133, "Concept"], [1441, 1450, "Concept"], [2593, 2602, "Concept"], [821, 828, "Concept"], [952, 959, "Concept"], [1126, 1133, "Concept"], [1158, 1165, "Concept"], [1300, 1307, "Concept"], [1399, 1406, "Concept"], [1488, 1495, "Concept"], [1552, 1559, "Concept"], [1647, 1654, "Concept"], [2512, 2519, "Concept"], [2741, 2748, "Concept"], [3055, 3062, "Concept"], [3409, 3416, "Concept"], [3420, 3427, "Concept"], [3482, 3489, "Concept"], [3529, 3536, "Concept"], [3837, 3844, "Concept"], [3925, 3932, "Concept"], [4052, 4059, "Concept"], [4361, 4368, "Concept"], [4443, 4450, "Concept"], [4496, 4503, "Concept"], [5051, 5058, "Concept"], [7584, 7591, "Concept"], [8715, 8722, "Concept"], [9576, 9583, "Concept"], [10236, 10243, "Concept"], [10536, 10543, "Concept"], [11829, 11836, "Concept"], [12104, 12111, "Concept"], [12886, 12893, "Concept"], [1234, 1244, "Concept"], [1829, 1839, "Concept"], [1696, 1708, "Concept"], [1886, 1898, "Concept"], [1777, 1790, "Concept"], [1986, 2000, "Concept"], [5919, 5928, "Concept"], [6279, 6288, "Concept"], [6601, 6610, "Concept"], [6969, 6978, "Concept"], [10771, 10780, "Concept"], [2332, 2344, "Concept"], [2451, 2463, "Concept"], [3466, 3473, "Concept"], [3781, 3788, "Concept"], [3871, 3878, "Concept"], [4196, 4203, "Concept"], [4205, 4212, "Concept"], [4405, 4412, "Concept"], [4454, 4461, "Concept"], [8168, 8175, "Concept"], [12117, 12124, "Concept"], [12289, 12296, "Concept"], [3781, 3795, "Concept"], [3871, 3885, "Concept"], [8168, 8182, "Concept"], [2305, 2314, "Concept"], [2782, 2791, "Concept"], [3657, 3666, "Concept"], [3683, 3692, "Concept"], [3709, 3718, "Concept"], [3735, 3744, "Concept"], [3908, 3917, "Concept"], [4214, 4223, "Concept"], [4240, 4249, "Concept"], [4507, 4516, "Concept"], [5266, 5275, "Concept"], [5292, 5301, "Concept"], [5318, 5327, "Concept"], [5344, 5353, "Concept"], [5636, 5645, "Concept"], [5662, 5671, "Concept"], [5688, 5697, "Concept"], [5714, 5723, "Concept"], [10160, 10169, "Concept"], [12130, 12139, "Concept"], [2316, 2325, "Concept"], [2793, 2802, "Concept"], [3670, 3679, "Concept"], [3696, 3705, "Concept"], [3722, 3731, "Concept"], [3748, 3757, "Concept"], [3967, 3976, "Concept"], [4082, 4091, "Concept"], [4227, 4236, "Concept"], [4253, 4262, "Concept"], [4394, 4403, "Concept"], [5279, 5288, "Concept"], [5305, 5314, "Concept"], [5331, 5340, "Concept"], [5357, 5366, "Concept"], [5649, 5658, "Concept"], [5675, 5684, "Concept"], [5701, 5710, "Concept"], [5727, 5736, "Concept"], [4006, 4021, "Concept"], [4298, 4313, "Concept"], [3529, 3545, "Concept"], [4863, 4884, "Concept"], [834, 849, "Concept"], [5105, 5113, "Concept"], [5401, 5409, "Concept"], [5761, 5769, "Concept"], [5902, 5910, "Concept"], [6262, 6270, "Concept"], [6584, 6592, "Concept"], [6690, 6698, "Concept"], [6952, 6960, "Concept"], [6327, 6334, "Concept"], [6340, 6347, "Concept"], [8109, 8116, "Concept"], [4947, 4956, "Concept"], [8252, 8261, "Concept"], [8467, 8476, "Concept"], [8894, 8903, "Concept"], [8946, 8955, "Concept"], [10906, 10915, "Concept"], [11079, 11088, "Concept"], [11107, 11116, "Concept"], [11165, 11174, "Concept"], [11195, 11204, "Concept"], [11229, 11238, "Concept"], [11260, 11269, "Concept"], [11330, 11339, "Concept"], [11359, 11368, "Concept"], [11450, 11459, "Concept"], [11482, 11491, "Concept"], [11855, 11864, "Concept"], [11908, 11917, "Concept"], [12019, 12028, "Concept"], [12053, 12062, "Concept"], [12183, 12192, "Concept"], [12246, 12255, "Concept"], [8600, 8618, "Concept"], [8751, 8764, "Concept"], [8905, 8918, "Concept"], [12496, 12509, "Concept"], [10146, 10153, "Concept"], [8637, 8651, "Concept"], [10297, 10311, "Concept"], [10475, 10489, "Concept"], [11908, 11928, "Concept"], [11330, 11352, "Concept"], [11359, 11385, "Concept"], [11450, 11465, "Concept"], [11482, 11497, "Concept"], [12246, 12263, "Concept"], [353, 359, "Concept"], [10089, 10095, "Concept"], [10185, 10191, "Concept"], [11426, 11432, "Concept"], [12170, 12176, "Concept"], [11635, 11651, "Concept"], [11652, 11662, "Concept"], [8767, 8787, "Concept"], [10444, 10471, "Concept"]]}