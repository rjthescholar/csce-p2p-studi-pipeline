{"id": 7, "segment": ["train_set", "labeled"], "course": "cs1550", "lec": "lec15", "text": "Introduction to Operating Systems\nCS/COE 1550\nFall 2021\n\nSherif Khattab\nksm73@pitt.edu\n(Some slides are from Silberschatz, Galvin and Gagne \u00a92013)\n\nAnnouncements\n\u2022 Upcoming deadlines:\n\u2022 10/25: Project 2 (extended deadline)\n\u2022 10/29: Homework 6\n\u2022 11/8: Lab 3\n\nCS/COE 1550 - Operating Systems - Sherif Khattab\n\n2\n\nLast Lecture ...\n\u2022 Deadlock prevention\n\nCS/COE 1550 - Operating Systems - Sherif Khattab\n\n3\n\nMuddiest Points (Banker's Algorithm)\n\u2022\n\nwhat are the three steps of the bankers algorithm?\n\n\u2022\n\nCould you go over the Bankers algorithm example again?\n\n\u2022\n\nFor the safe/unsafe algorithm, does that mean we need to know the resources that are available,\nkeep track of the used ones, and also know how many each process will have in the future?\n\n\u2022\n\nIt seems like this detection algorithm has a lot of overhead. Are there any ways of reducing the time\nspent doing these checks\n\n\u2022\n\ncan we run the banker's algorithm or some alternative as a static analysis tool? like build this kind of\ncheck into the compiler or something instead of running it for each request during runtime\n\n\u2022\n\nIf a state is determined unsafe, does that always mean that the resource will not be allocated or is it\npossible to still allocate it and take the risk\n\n\u2022\n\nWhat does the E, P and A stand for in the bankers algorithm\n\n\u2022\n\nif bankers algorithm finds a valid path and grants the resource, can a deadlock still occur if a different\npath is followed than the one bankers algorithm found?\n\n\u2022\n\nI'm a little confused on what the want and hold tables represent\n\n\u2022\n\nWhy is the runtime n^2 * n for the wait algorithm\n\n\u2022\n\nWhat is the difference between wanted and max again?\n\n\u2022\n\nTracing bankers algorithms with multiple resource instances\n\nCS/COE 1550 - Operating Systems - Sherif Khattab\n\n4\n\nMuddiest Points (Resource Trajectory)\n\u2022 the l1, l2 l3 ... in the resource trajectory graph\n\n\u2022 resource trajectory graphs with more than 2 resources\n\u2022 How to prevent a resource trajectory that would cause a\ndeadlock\n\nCS/COE 1550 - Operating Systems - Sherif Khattab\n\n5\n\nMuddiest Points (General Deadlock)\n\u2022 breaking circular wait seems almost always better than breaking\nhold and wait since breaking hold and wait requires you take all\nresources you need whereas breaking circular wait only makes you\ntake some extra resources before you need them\n\u2022 Starvation vs deadlock\n\u2022 Which detection alg is fastest?\n\u2022 Where do deadlock detection algorithms exist? (Operating system\nor external application.) When do they run? Runtime or compile\ntime? Also, how do deadlock avoidance algorithms interfere to\nmake sure a program doesn't deadlock? Are they integrated fully\ninto the application?\n\u2022 how do we know what resources are available to use and the best\nway to choose who gets what resources\n\u2022 What is better practice, deadlock avoidance or deadlock detection?\nCS/COE 1550 - Operating Systems - Sherif Khattab\n\n6\n\nMuddiest Points (Deadlock Prevention)\n\u2022 When checking a program to see it is free of deadlocks, you have to\nlook for whether one of the four condtions is being broken\nsomewhere?\n\u2022 Why do you only need to attack one of the 4 conditions to prevent\ndeadlock?\n\u2022 How to know which deadlock prevention technique to use.\n\u2022 How spooling works\n\u2022\n\nWhat exactly is spooling?\n\n\u2022\n\nSpooling in applications\n\n\u2022\n\nWhen is it appropriate to spool? How do you know?\n\n\u2022 How non-resource deadlocks occur\n\u2022 In regard to attacking \"no preemption\", how would you determine\nwhether it's viable to take a resource away from a process?\n\u2022 how 2 phase locking avoids the hold and wait condition?\nCS/COE 1550 - Operating Systems - Sherif Khattab\n\n7\n\nAttacking Circular Wait\n\nCS/COE 1550 - Operating Systems - Sherif Khattab\n\n8\n\nSpooling Example\n\nCS/COE 1550 - Operating Systems - Sherif Khattab\n\n9\n\nToday ...\n\u2022 CPU Scheduling\n\nCS/COE 1550 - Operating Systems - Sherif Khattab\n\n10\n\n", "label": [[421, 439, "Concept"], [894, 912, "Concept"], [1776, 1795, "Concept"], [1824, 1843, "Concept"], [1853, 1872, "Concept"], [1926, 1945, "Concept"], [1824, 1849, "Concept"], [330, 338, "Concept"], [1370, 1378, "Concept"], [1965, 1973, "Concept"], [2053, 2061, "Concept"], [2322, 2330, "Concept"], [2376, 2384, "Concept"], [2513, 2521, "Concept"], [2584, 2592, "Concept"], [2773, 2781, "Concept"], [2795, 2803, "Concept"], [2885, 2893, "Concept"], [3114, 3122, "Concept"], [3144, 3152, "Concept"], [330, 349, "Concept"], [2885, 2904, "Concept"], [3144, 3163, "Concept"], [2376, 2405, "Concept"], [2513, 2542, "Concept"], [2074, 2087, "Concept"], [2230, 2243, "Concept"], [3598, 3611, "Concept"], [2129, 2142, "Concept"], [2158, 2171, "Concept"], [3510, 3523, "Concept"], [3377, 3390, "Concept"], [2308, 2318, "Concept"], [3188, 3196, "Concept"], [3222, 3230, "Concept"], [3236, 3244, "Concept"], [3666, 3674, "Concept"], [3322, 3344, "Concept"], [3483, 3498, "Concept"], [3749, 3763, "Concept"], [1677, 1704, "Concept"], [1630, 1633, "Concept"]]}