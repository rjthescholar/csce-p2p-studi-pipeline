{"id": 7, "segment": ["test_set", "labeled"], "course": "cs0449", "lec": "lec07", "text": "7\n\nIntroduction\nto x86 asm\n\nCS/COE 0449\nIntroduction to\nSystems Software\n\nLuis Oliveira\n(with content borrowed from wilkie and Vinicius Petrucci)\n\nAssembly Refresher\nWhat is forgotten... is art.\n\n2\n\nWhat is \"Assembly\"\n\u2022 Assembly: Human-readable representation of machine code.\n\u2022 Machine code: what a computer actually runs.\n\u2022 The \"atoms\" that make up a program.\n\u2022 CPUs CAN actually be fairly simple in concept.\n\n\u2022 Each CPU chooses its own machine code (and therefore its own style\nof assembly language)\n\u2022 We used MIPS in CS 447.\n\u2022 A RISC processor.\n\n\u2022 We will compare that to x86 today!\n\u2022 A CISC processor.\n\n3\n\nWhat is \"Assembly\"\n\u2022 Involves very simple commands.\n\u2022 This command copies data from\none place to another.\n\n\u2022 Despite being called \"move\", ugh!\n\n\u2022 Surprise! It's actually shorthand\nfor a different set of instructions.\n\n\u2022 The processor can be made simpler.\n\n\u2022 This command gets transformed\ninto a numerical representation.\n\nCompute t0+0\nPut into \"a0\"\n\n\u2022 The processor then interprets the binary representation.\n\u2022 That's essentially all a computer does!\n\u2022 CS 447 looks at this in much greater detail.\n\n4\n\nAssembly vs. Machine Language\n\u2022 Machine language instructions are the patterns of bits that a\nprocessor reads to know what to do\n\u2022 Assembly language (or \"asm\") is a human-readable (mostly), textual\nrepresentation of machine language.\nMIPS asm\n\nMIPS machine language\n\n5\n\nIs Assembly Useful?\n\u2022 Short answer: YES\n\u2022 Assembly is \"fast\", so we should use it for everything!\n--- NO!!! --\u2022 No type-checking, no control structures, very few abstractions.\nFairly impractical for large things --\u2022 Tied to a particular CPU.\n\n---\n\n\u2022 So, large programs have to be rewritten (usually) to work on new things.\n\n\u2022 Yet: good for specialized stuff.\n\u2022 Critical paths and \"boot\" code in Kernels / Operating Systems\n\u2022 HPC (simulators, supercomputer stuff)\n\u2022 Real-time programs (video games; tho increasingly less / abstracted away)\n\u2022 And...\n\n6\n\nArchitecture Sits at the Hardware Interface\nSource code\n\nCompiler\n\nArchitecture\n\nApplications/algorithms\n\nPerform optimizations,\ngenerate instructions\n\nInstruction set\n\nDifferent implementations\n\nIntel Pentium 4\n\nC Language\nProgram\nA\n\nHardware\n\nIntel Core 2\n\nGCC\n\nx86-64\n\nIntel Core i7\nAMD Opteron\n\nProgram\nB\n\nAMD Athlon\nClang\n\nYour\nprogram\n\nARMv8\n(AArch64/A64)\n\nARM Cortex-A53\nApple A7\n\nPractical Applications of Assembly: Modification\n\u2022 Modifying programs after-the-fact. (Or reverse-engineering them)\n\u2022 Legal \"gray-area,\" / \"confusing-mess\" but generally modification/reverse engineering is allowed.\nKinda? (Section 1201, US Code 17 \u00a7 108, etc)\n\u2022 Removing copy protection in order to preserve/backup.\n\u2022 Librarians and preservationists and \"pirates\" alike may all use/view/write assembly for this!\n\nI'm not a lawyer\n\u2022 I know someone that patched (the freely distributed) Lost Vikings so it would avoid copy protection\uf04c\nand use a different sound configuration (so I could run it in a browser emulator)\n\nx86 (NASM / Intel Syntax, MS-DOS)\n\n8\n\nPractical Applications of Assembly: Debugging\n\n\u2022 Programs written in C, etc are generally translated into assembly.\n\u2022 And then into machine code.\n\n\u2022 You can look at the machine code of programs and get an assembly\ncode listing.\n\u2022 And step through the program one instruction at a time.\n\n\u2022 When programs crash (sometimes programs you don't have the code\nfor) you can look at the assembly code and assess.\n\u2022 Programs exist to help you (gdb, IDA Pro, radare, etc)\n\n\u2022 We will apply this knowledge (using gdb) in a future assignment!\n9\n\nBasics of x86 Assembly\nx86 really puts the... you know what... in Assembly\n\n10\n\nInstruction Set Architecture (ISA)\n\u2022 An ISA is the interface that a CPU presents to the programmer.\n\u2022 When we say \"architecture,\" this is what we mean.\n\n\u2022 The ISA defines:\n\u2022 What the CPU can do (add, subtract, call functions, etc.)\n\u2022 What registers it has (we'll get to those)\n\u2022 The machine language\n\u2022 That is, the bit patterns used to encode instructions.\n\n\u2022 The ISA does not define:\n\u2022 How to design the hardware!\n\u2022 ...if there's any hardware at all (think of Java, etc: virtual/hypothetical ISAs)\n\n11\n\nTypes of ISAs: RISC\n\u2022 RISC: \"Reduced Instruction Set Computer\"\n\u2022 ISA designed to make it easy to:\n\u2022 build the CPU hardware\n\u2022 make that hardware run fast\n\u2022 write compilers that make machine code\n\n\u2022 A small number of instructions.\n\u2022 Instructions are very simple\n\u2022 MIPS (and RISC-V) is very RISCy\n\n12\n\nTypes of ISAs: CISC\n\u2022 CISC: \"Complex Instruction Set Computer\"\n\u2022 ISA designed for humans to write asm.\n\u2022 From the days before compilers!\n\n\u2022 Lots of instructions and ways to use them\n\u2022 Complex (multi-step) instructions to shorten\nand simplify programs.\n\u2022 \"search a string for a character\"\n\u2022 \"copy memory blocks\"\n\u2022 \"check the bounds of an array access\"\n\n\u2022 Without these, you'd just write your programs to use the\nsimpler instructions to build the complex behavior itself.\n\u2022 x86 is very CISCy\n13\n\nTypes of ISAs: Overview\n\u2022 CISC: Complex Instruction Set Computer (does a whole lot)\n\u2022 RISC: Reduced Instruction Set Computer (does enough)\n\u2022 Both: Equivalent!! (RISC programs might be longer)\n\n\"Hackers\" (1995) - Of course, they are talking about a Pentium x86 chip...\nwhich thanks to its backwards compatibility, is CISC. Oh well!\nThen again... x86 is so complex, modern designs translate the CISC instructions into RISC microcode on the fly... so it's RISC?? It can get complicated.\n\n14\n\nx86\n\u2022 Descended from 16-bit 8086 CPU from 1978.\n\u2022 Extended to 32 bits, then 64.\n\u2022 Each version can run most programs from the previous version.\n\u2022 You can (mostly) run programs written in '78 on your brand new x86 CPU!\n\n\u2022 This ISA is complex!\n\u2022 30 years of backwards-compatibility... yikes.\n\u2022 We won't exhaustively go over it.\n\u2022 There are, however, many very common idioms\nand instructions.\n\u2022 We will focus on these.\n\u2022 And we will focus on READING x86, not writing it.\n\n15\n\nx86 Registers (general)\n\u2022 Like MIPS, there are a set of general-purpose registers.\n\u2022 There are 16; 64-bits in size and hold integer values in binary form.\n\n\u2022 Unlike MIPS, you can refer to parts of each register.\n\u2022 Called partial registers.\n\nDenoted\nby %\n\nStack\nPointer\n\n16-bit register names\n\n32-bit register names\n\n16\n\ngeneral purpose\n\n32-bit OLD Registers - 32 bits wide\n8 bits\n\n32 bits\n\n16 bits\n\n%eax\n\n%ax\n\n%ah\n\n%al\n\naccumulate\n\n%ecx\n\n%cx\n\n%ch\n\n%cl\n\ncounter\n\n%edx\n\n%dx\n\n%dh\n\n%dl\n\ndata\n\n%ebx\n\n%bx\n\n%bh\n\n%bl\n\nbase\n\n%esi\n\n%si\n\nsource index\n\n%edi\n\n%di\n\ndestination index\n\n%esp\n\n%sp\n\nstack pointer\n\n%ebp\n\n%bp\n\nbase pointer\n16-bit virtual registers\n(backwards compatibility)\n\nName Origin\n(mostly obsolete)\n\nx86 Registers (specialized)\n\u2022 There are also registers that you cannot directly interact with.\n\u2022 Like MIPS, x86 has a program counter (\n)\n\u2022 Also like MIPS, it cannot be read directly.\n\n\u2022 There is also a\nstatus register, which has information about the\nCPU state after an instruction is completed.\n\u2022 Stuff like a carry flag (CF) that denotes if an addition has a final carry.\n\u2022 Overflow detection (OF) denoting if an operation overflowed.\n\n\u2022 And some extra registers for vector math, floating point math, and for\nOS usage we won't go over.\n18\n\nx86 Instruction Types\n\u2022 In MIPS, you had R-type, I-type and J-type instructions.\n\u2022 In x86 (CISC) you generally can have any instruction refer to data anywhere it is:\n\u2022 Registers, Immediates, Memory addresses, etc\n\u2022 Cannot refer to memory twice! (not possible:\nx86-64 (gas / AT&T syntax)\n\n)\n\nMIPS\n\nImmediates (prefixed by $)\nMemory load (within parens)\nMemory store\n\nDisplacement (can be -4, etc)\n\n19\n\nComplex Addressing\n\u2022 In MIPS, you would carefully craft the set of instructions necessary to\ninterface with an array. (RISC)\n\u2022 In x86, you can do a lot with just a single instruction. (CISC)\n\u2022\n\n: Base + (Index Scalar) where Scalar must be 1, 2, 4 or 8\n\u2022 The fields are all optional; i.e.,\n\nx86-64 (gas / AT&T syntax)\n\ndoes just Index Scalar\n\nMIPS\n\n\"Load Effective Address\"\n\nLEA simply computes address (no memory access)\n\n20\n\nComplex Addressing: CISC Strikes Again!!\n\u2022 When we say you can do a lot with just a single instruction, we\nmean it!\n\u2022\n: Base + (Index Scalar) where Scalar must be 1, 2, 4 or 8\n\u2022 What does the following do?\n\u2022\n\nx86-64 (gas / AT&T syntax)\n\n\"Load Effective Address\" ???\n\nLEA simply computes address... it's just very specific math.\n\n21\n\nx86 Instruction Qualifiers\n\u2022 In MIPS, you sometimes had instructions varying on bitsize.\n\u2022 In x86 (CISC) you can operate on any part of a register.\n\u2022 64-bits, 32-bits, 16-bits... even 8-bit sections sometimes.\n\n\u2022 The assembler can assume usually, but explicit names also work:\nx86-64 (gas / AT&T syntax)\nThe assembler \"figures it out\"\n\nMIPS64\n\n\"quad word\" which is 64-bits.\n\"long word\" which is 32-bits. \uf04c\nUgh. In x86 a \"word\" here is 16-bits\nCS/COE 0449 - Spring 2019/2020\n\n22\n\nHello World! (x86 vs. MIPS)\nx86-64 (gas / AT&T syntax)\n\nMIPS (MARS)\n\n23\n\nDoing some x86 maths\n\u2022 x86 and MIPS have, essentially, the same mathematical instructions.\nx86-64 (gas / AT&T syntax)\n\nMIPS\n\n24\n\nHowever, x86 lets you slice and dice\n\u2022 Each math instruction in x86 has variants based on the bitsize.\n\u2022\n\n(64-bit),\n\n(32-bit),\n\n(16-bit),\n\nx86-64 (gas / AT&T syntax)\n\n(8-bit) (rest of field zero extended!!)\n\nMIPS\n\nArithmetic shift (sign extends)\n\nLogical shift (zero extends)\n\n8-bit register aliases are not commonly used\n\n25\n\nAssembly Interlude\nHere, we take a break, and look at some existing code.\n\n26\n\nWhy write assembly? When you can write C\n\u2022 You can take any of your C programs and emit the assembly.\n\u2022 The compiler can do this for you:\n\n\u2022 This will create a file called\n\nwhich looks... messy.\n\n\u2022 It has a ton of messy specific stuff wedged in there.\n\u2022 But you can generally pull apart some meaning from it.\n\n27\n\nLooking at C compilers...\n\u2022 The messy output of the gcc compilation to assembly:\nx86-64 (gas / AT&T syntax,\n\nmain hasn't even shown up yet...\n\n)\n\nC\n\n28\n\nDisassembly - See how the sausage is made...\n\u2022 So, that's not very useful. And often we don't have the code!\n\u2022 How do we go backward?\n\n\u2022 You can take any compiled program and emit the assembly.\n\u2022 Many tools can help you do this (radare, objdump, gdb)\n\n\u2022 Using a tool called objdump (only disassembles code section):\n\n\u2022 This will create a file called\n\n.\n\n\u2022 You can glance at it and notice that it does not have names.\n\u2022 And labels are a bit, well, nonexistent.\n29\n\nAnd... here we are...\n\u2022 An objdump disassembly is slightly lacking context.\nx86-64 (gas / AT&T syntax,\n\n)\n\nC\n\nMachine code (in bytes)\nInstruction address\n30\n\nLooking deeper\n\u2022 Now we are starting to read the code... It does what we tell it to do!\nx86-64 (gas / AT&T syntax,\n\n)\nPreserves\n(caller activation frame)\nAllocates \" \" on stack ( from top)\nMove argument to\nCompares to and sets\nJumps if\nis 0 ( is positive)\nSets\nto\nResets caller activation frame\nReturns (return value is in\n)\n\nInstructions have varying size\nSo, the next instruction address\nis irregular. Compare with MIPS / RISC-V.\n\n31\n\nBrought to you by the letters: C ABI\n\u2022 The C Application Binary Interface (ABI) are assembly conventions\n\u2022 Like MIPS, certain registers are typically used for returns values, args, etc\n\u2022 It is not defined by the language, but rather the OS.\n\u2022 Windows and Linux (UNIX/System V) have a different C ABI \uf04c\n\n\u2022 In our x86-64 Linux C ABI, registers are used to pass arguments:\n\u2022\n,\n,\n,\n,\n,\n(First, second, etc) (Like MIPS\n-\n)\n\u2022 Remaining arguments go on the stack.\n\u2022 Callee must preserve\n,\n,\n,\n,\n,\n(Like MIPS\n-\n\u2022 Return value:\n(overflows into\nfor 128-bits) (MIPS\n-\n)\n\u2022 Lots of other small things not worth going over.\n\n)\n\n\u2022 For reference: https://github.com/hjl-tools/x86-psABI/wiki/x86-64-psABI-1.0.pdf\n32\n\n", "label": [[484, 501, "Concept"], [1244, 1261, "Concept"], [23, 26, "Concept"], [1267, 1270, "Concept"], [1352, 1355, "Concept"], [4490, 4493, "Concept"], [263, 275, "Concept"], [279, 291, "Concept"], [439, 451, "Concept"], [3109, 3121, "Concept"], [3146, 3158, "Concept"], [4274, 4286, "Concept"], [10383, 10395, "Concept"], [1126, 1142, "Concept"], [1145, 1161, "Concept"], [1329, 1345, "Concept"], [1362, 1378, "Concept"], [3872, 3888, "Concept"], [3589, 3617, "Concept"], [3619, 3622, "Concept"], [3629, 3632, "Concept"], [3748, 3751, "Concept"], [3953, 3956, "Concept"], [4158, 4161, "Concept"], [4457, 4460, "Concept"], [5601, 5604, "Concept"], [4122, 4154, "Concept"], [4978, 5010, "Concept"], [533, 537, "Concept"], [4108, 4112, "Concept"], [4115, 4119, "Concept"], [4365, 4369, "Concept"], [4972, 4976, "Concept"], [5047, 5051, "Concept"], [5302, 5306, "Concept"], [5339, 5343, "Concept"], [7615, 7619, "Concept"], [10855, 10859, "Concept"], [4421, 4453, "Concept"], [4918, 4950, "Concept"], [591, 595, "Concept"], [4407, 4411, "Concept"], [4414, 4418, "Concept"], [4912, 4916, "Concept"], [5202, 5206, "Concept"], [5279, 5283, "Concept"], [7186, 7190, "Concept"], [7681, 7685, "Concept"], [7942, 7946, "Concept"], [8354, 8358, "Concept"], [19, 22, "Concept"], [576, 579, "Concept"], [2199, 2202, "Concept"], [2939, 2942, "Concept"], [3519, 3522, "Concept"], [3532, 3535, "Concept"], [4864, 4867, "Concept"], [5142, 5145, "Concept"], [5231, 5234, "Concept"], [5375, 5378, "Concept"], [5584, 5587, "Concept"], [5822, 5825, "Concept"], [5848, 5851, "Concept"], [6552, 6555, "Concept"], [6660, 6663, "Concept"], [7095, 7098, "Concept"], [7181, 7184, "Concept"], [7355, 7358, "Concept"], [7626, 7629, "Concept"], [7786, 7789, "Concept"], [8131, 8134, "Concept"], [8255, 8258, "Concept"], [8349, 8352, "Concept"], [8532, 8535, "Concept"], [8669, 8672, "Concept"], [8748, 8751, "Concept"], [8762, 8765, "Concept"], [8818, 8821, "Concept"], [8830, 8833, "Concept"], [8898, 8901, "Concept"], [8945, 8948, "Concept"], [9000, 9003, "Concept"], [9075, 9078, "Concept"], [9737, 9740, "Concept"], [10349, 10352, "Concept"], [10519, 10522, "Concept"], [11180, 11183, "Concept"], [11528, 11531, "Concept"], [11543, 11546, "Concept"], [2199, 2205, "Concept"], [7355, 7361, "Concept"], [7786, 7792, "Concept"], [8131, 8137, "Concept"], [8532, 8538, "Concept"], [8762, 8768, "Concept"], [8898, 8904, "Concept"], [9075, 9081, "Concept"], [9737, 9743, "Concept"], [10349, 10355, "Concept"], [10519, 10525, "Concept"], [11180, 11186, "Concept"], [11543, 11549, "Concept"], [5904, 5929, "Concept"], [6069, 6086, "Concept"], [6430, 6443, "Concept"], [6456, 6468, "Concept"], [6670, 6685, "Concept"], [6755, 6770, "Concept"], [6864, 6874, "Concept"], [6876, 6878, "Concept"], [260, 262, "Concept"], [481, 483, "Concept"], [811, 813, "Concept"], [1192, 1194, "Concept"], [1326, 1328, "Concept"], [2346, 2348, "Concept"], [3000, 3002, "Concept"], [3159, 3161, "Concept"], [3516, 3518, "Concept"], [4047, 4049, "Concept"], [4099, 4101, "Concept"], [4305, 4307, "Concept"], [4398, 4400, "Concept"], [4537, 4539, "Concept"], [4723, 4725, "Concept"], [4892, 4894, "Concept"], [5098, 5100, "Concept"], [5628, 5630, "Concept"], [5901, 5903, "Concept"], [6042, 6044, "Concept"], [6949, 6951, "Concept"], [7560, 7562, "Concept"], [8388, 8390, "Concept"], [9117, 9119, "Concept"], [9402, 9404, "Concept"], [9553, 9555, "Concept"], [9701, 9703, "Concept"], [11434, 11436, "Concept"], [7461, 7473, "Concept"], [7496, 7514, "Concept"], [7922, 7940, "Concept"], [6358, 6362, "Concept"], [6456, 6460, "Concept"], [7692, 7696, "Concept"], [8042, 8046, "Concept"], [6382, 6387, "Concept"], [6412, 6417, "Concept"], [7700, 7705, "Concept"], [7824, 7829, "Concept"], [8050, 8055, "Concept"], [7845, 7867, "Concept"], [8160, 8182, "Concept"], [7870, 7873, "Concept"], [8189, 8192, "Concept"], [8259, 8281, "Concept"], [8600, 8609, "Concept"], [8630, 8639, "Concept"], [8605, 8609, "Concept"], [8635, 8639, "Concept"], [8676, 8680, "Concept"], [9150, 9166, "Concept"], [9183, 9196, "Concept"], [2506, 2525, "Concept"], [9809, 9820, "Concept"], [10308, 10319, "Concept"], [10046, 10053, "Concept"], [10083, 10090, "Concept"], [10300, 10307, "Concept"], [3411, 3414, "Concept"], [3477, 3480, "Concept"], [10055, 10058, "Concept"], [10911, 10941, "Concept"], [10901, 10904, "Concept"], [10943, 10946, "Concept"], [11164, 11167, "Concept"], [11195, 11198, "Concept"], [10560, 10583, "Concept"], [10702, 10725, "Concept"], [6103, 6108, "Concept"], [6430, 6435, "Concept"], [10602, 10607, "Concept"], [11318, 11323, "Concept"], [10735, 10747, "Concept"], [11373, 11385, "Concept"]]}