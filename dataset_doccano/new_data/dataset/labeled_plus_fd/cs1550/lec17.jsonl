{"id": 9, "segment": ["train_set", "labeled"], "course": "cs1550", "lec": "lec17", "text": "Introduction to Operating Systems\nCS 1550\nSpring 2022\n\nSherif Khattab\nksm73@pitt.edu\n(Some slides are from Silberschatz, Galvin and Gagne \u00a92013)\n\nAnnouncements\n\u2022 Upcoming deadlines:\n\u2022 Quiz 2: due on 3/25\n\u2022 Homework 9: due on 3/28\n\u2022 Lab 3: due on 4/1\n\u2022 Project 3: due on 4/11\n\nCS 1550 - Operating Systems - Sherif Khattab\n\n2\n\nPrevious lecture ...\n\u2022 Page replacement algorithms\nAlgorithm\n\nComment\n\nOPT (Optimal)\n\nNot implementable, but useful as a benchmark\n\nNRU (Not Recently Used)\n\nCrude\n\nFIFO (First-In, First Out)\n\nMight throw out useful pages\n\nSecond chance\n\nBig improvement over FIFO\n\nClock\n\nBetter implementation of second chance\n\nLRU (Least Recently Used)\n\nExcellent, but hard to implement exactly\n\nNFU (Not Frequently Used)\n\nPoor approximation to LRU\n\nAging\n\nGood approximation to LRU, efficient to implement\n\nWorking Set\n\nSomewhat expensive to implement\n\nWSClock\n\nImplementable version of Working Set\n\nCS 1550 - Operating Systems - Sherif Khattab\n\n3\n\nMuddiest Points (Memory)\n\u2022 Difference between NRU and NFU\n\u2022 For NRU, what is the way in which it separates the pages into\nclasses in order to pick a victim from a group of the lowest nonempty class\n\u2022 On the clock for the clock algorithm, what is t and why does it\nchange to 32 on the referenced pages?\n\u2022 What are we adding to the shift register in the working set\nreplacement algorithm?\n\u2022 Why is the tracking of a process' working set necessary?\n\u2022 Which page replacement algorithm is the best (generally)?\n\u2022 The question on the homework that has the numerical entry\nanswer. I'm not quite sure how to adapt what we discussed in\nclass to that question.\n\u2022 How the eviction happens in the pages\nCS 1550 - Operating Systems - Sherif Khattab\n\n4\n\nMuddiest Points (Memory)\n\u2022 How do we determine tau again?\n\u2022 On the last slide about working set page, does the page\ntable get updated every clock tick? Or do we only care\nabout evey clock interrupt here? I am a little confused\nabout how is the clock interrupt concept applied to the\nworking set page replacement algorithm.\n\u2022 What is k in the working set graph?\n\u2022 in second chance and clock replacement, why do\nreferenced pages have their ref bit set back to 0?\n\u2022 Do most algorithms need to iterate through all pages\n(O(N) runtime)?\n\n\u2022 I am confused on the details of thrashing\n\u2022 LRU page replacement\nCS 1550 - Operating Systems - Sherif Khattab\n\n5\n\nMuddiest Points (Misc.)\n\u2022 i had a bit of a hard time keeping up with pretty much\neverything but i think that's just a side effect of\ncoming back from break\n\u2022 what is it that makes the TLB access fast while being\nslower for memory PTE access\n\u2022 when is the midterm grades posted also will there be\nmakeup to get up to 30% back?\n\u2022 When are TLB entries replaced\n\u2022 Is \"Frame\" the same thing as a physical page?\n\u2022 How is the page table indexed?\n\n\u2022 redo a walk through the address translation process\nwith the CPU, MMU, & TLB caching\nCS 1550 - Operating Systems - Sherif Khattab\n\n6\n\nProblem of the Day\n\u2022 How to simulate page replacement algorithms\n\u2022 FIFO/Clock\n\u2022 LRU, OPT\n\nCS 1550 - Operating Systems - Sherif Khattab\n\n7\n\n\u2022\n\n\u2022\n\nHow is modeling done?\nGenerate a list of references\n\u2022\n\nArtificial (made up)\n\n\u2022\n\nTrace a real workload (set of processes)\n\nUse an array (or other structure) to track the pages in physical memory\nat any given time\n\u2022\n\nMay keep other information per page to help simulate the algorithm (modification\ntime, time when paged in, etc.)\n\n\u2022\n\nRun through references, applying the replacement algorithm\n\n\u2022\n\nExample: FIFO replacement on reference string 0 1 2 3 0 1 4 0 1 2 3 4\n\u2022\n\nPage replacements highlighted in yellow\nPage referenced\n0 1 2 3 0 1 4 0 1 2 3 4\nYoungest page\n\n0 1 2 3 0 1 4 4 4 2 3 3\n0 1 2 3 0 1 1 1 4 2 2\n\nOldest page\n\n0 1 2 3 0 0 0 1 4 4\n\nCS 1550 - Operating Systems - Sherif Khattab\n\n8\n\nInteractive Simulation Tool\n\u2022 https://sim-50.github.io/cs-tools/\n\nCS 1550 - Operating Systems - Sherif Khattab\n\n9\n\nFIFO with 3 frames\n\nCS 1550 - Operating Systems - Sherif Khattab\n\n10\n\nFIFO Example 1\n\nCS 1550 - Operating Systems - Sherif Khattab\n\n11\n\nFIFO with 4 frames\n\nCS 1550 - Operating Systems - Sherif Khattab\n\n12\n\n\u2022\n\n\u2022\n\n\u2022\n\nBelady's anomaly\nReduce the number of page faults by supplying more memory\n\u2022\n\nUse previous reference string and FIFO algorithm\n\n\u2022\n\nAdd another page to physical memory (total 4 pages)\n\nMore page faults (10 vs. 9), not fewer!\n\u2022\n\nThis is called Belady's anomaly\n\n\u2022\n\nAdding more pages shouldn't result in worse performance!\n\nMotivated the study of paging algorithms\n\nCS 1550 - Operating Systems - Sherif Khattab\n\n13\n\nCLOCK Simulation\n\nCS 1550 - Operating Systems - Sherif Khattab\n\n14\n\nModeling more replacement algorithms\n\u2022 Paging system characterized by:\n\u2022 Reference string of executing process\n\u2022 Page replacement algorithm\n\u2022 Number of page frames available in physical memory (m)\n\n\u2022 Model this by keeping track of all n pages referenced\nin array M\n\u2022 Top part of M has m pages in memory\n\u2022 Bottom part of M has n-m pages stored on disk\n\n\u2022 Page replacement occurs when page moves from top\nto bottom\n\u2022 Top and bottom parts may be rearranged without causing\nmovement between memory and disk\nCS 1550 - Operating Systems - Sherif Khattab\n\n15\n\n\u2022\n\nExample: LRU\nModel LRU replacement with\n\u2022\n\n8 unique references in the reference string\n\n\u2022\n\n4 pages of physical memory\n\n\u2022\n\nArray state over time shown below\n\n\u2022\n\nLRU treats list of pages like a stack\n0 2 1 3 5 4 6 3 7 4 7 3 3 5 5 3 1 1 1 7 1 3 4 1\n0 2 1 3 5 4 6 3 7 4 7 3 3 5 5 3 1 1 1 7 1 3 4 1\n0 2 1 3 5 4 6 3 7 4 7 7 3 3 5 3 3 3 1 7 1 3 4\n0 2 1 3 5 4 6 3 3 4 4 7 7 7 5 5 5 3 3 7 1 3\n0 2 1 3 5 4 6 6 6 6 4 4 4 7 7 7 5 5 5 7 7\n0 2 1 1 5 5 5 5 5 6 6 6 4 4 4 4 4 4 5 5\n0 2 2 1 1 1 1 1 1 1 1 6 6 6 6 6 6 6 6\n0 0 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\nCS 1550 - Operating Systems - Sherif Khattab\n\n16\n\nStack algorithms\n\u2022 LRU is an example of a stack algorithm\n\u2022 For stack algorithms\n\u2022 Any page in memory with m physical pages is also in\nmemory with m+1 physical pages\n\u2022 Increasing memory size is guaranteed to reduce (or at\nleast not increase) the number of page faults\n\n\u2022 Stack algorithms do not suffer from Belady's anomaly\n\u2022 Distance of a reference == position of the page in the\nstack before the reference was made\n\u2022 Distance is \uf0a5 if no reference had been made before\n\u2022 Distance depends on reference string and paging\nalgorithm: might be different for LRU and optimal (both\nstack algorithms)\nCS 1550 - Operating Systems - Sherif Khattab\n\n17\n\nPredicting page fault rates using distance\n\u2022 Distance can be used to predict page fault rates\n\u2022 Make a single pass over the reference string to\ngenerate the distance string on-the-fly\n\u2022 Keep an array of counts\n\u2022 Entry j counts the number of times distance j occurs in the\ndistance string\n\n\u2022 The number of page faults for a memory of size m is\nthe sum of the counts for j>m\n\u2022 This can be done in a single pass!\n\u2022 Makes for fast simulations of page replacement\nalgorithms\n\n\u2022 This is why virtual memory theorists like stack\nalgorithms!\nCS 1550 - Operating Systems - Sherif Khattab\n\n18\n\nLRU\n\nCS 1550 - Operating Systems - Sherif Khattab\n\n19\n\nOPT\n\nCS 1550 - Operating Systems - Sherif Khattab\n\n20\n\n", "label": [[1413, 1439, "Concept"], [1994, 2020, "Concept"], [4686, 4712, "Concept"], [348, 364, "Concept"], [1413, 1429, "Concept"], [1994, 2010, "Concept"], [2282, 2298, "Concept"], [2961, 2977, "Concept"], [4686, 4702, "Concept"], [4927, 4943, "Concept"], [6837, 6853, "Concept"], [396, 399, "Concept"], [3009, 3012, "Concept"], [7033, 7036, "Concept"], [401, 408, "Concept"], [6313, 6320, "Concept"], [457, 460, "Concept"], [1005, 1008, "Concept"], [1023, 1026, "Concept"], [462, 479, "Concept"], [489, 493, "Concept"], [583, 587, "Concept"], [2991, 2995, "Concept"], [3473, 3477, "Concept"], [3877, 3881, "Concept"], [3947, 3951, "Concept"], [4013, 4017, "Concept"], [4204, 4208, "Concept"], [495, 514, "Concept"], [547, 560, "Concept"], [621, 634, "Concept"], [2065, 2078, "Concept"], [589, 594, "Concept"], [1166, 1171, "Concept"], [1180, 1185, "Concept"], [1839, 1844, "Concept"], [1881, 1886, "Concept"], [1943, 1948, "Concept"], [2083, 2088, "Concept"], [2996, 3001, "Concept"], [4505, 4510, "Concept"], [636, 639, "Concept"], [754, 757, "Concept"], [788, 791, "Concept"], [2278, 2281, "Concept"], [3004, 3007, "Concept"], [5138, 5141, "Concept"], [5148, 5151, "Concept"], [5289, 5292, "Concept"], [5770, 5773, "Concept"], [6305, 6308, "Concept"], [6978, 6981, "Concept"], [641, 660, "Concept"], [705, 708, "Concept"], [1013, 1016, "Concept"], [710, 729, "Concept"], [759, 764, "Concept"], [817, 828, "Concept"], [897, 908, "Concept"], [1311, 1322, "Concept"], [1382, 1393, "Concept"], [1783, 1794, "Concept"], [1982, 1993, "Concept"], [2041, 2052, "Concept"], [863, 870, "Concept"], [3493, 3509, "Concept"], [4183, 4199, "Concept"], [4646, 4662, "Concept"], [5199, 5215, "Concept"], [6243, 6259, "Concept"], [6519, 6535, "Concept"], [3247, 3262, "Concept"], [4243, 4258, "Concept"], [4750, 4765, "Concept"], [5231, 5246, "Concept"], [6406, 6416, "Concept"], [6472, 6482, "Concept"], [5793, 5808, "Concept"], [6077, 6085, "Concept"], [6170, 6178, "Concept"], [6223, 6231, "Concept"], [6429, 6437, "Concept"], [6440, 6448, "Concept"], [6552, 6560, "Concept"], [6642, 6650, "Concept"], [6667, 6675, "Concept"], [6552, 6567, "Concept"], [6667, 6682, "Concept"]]}