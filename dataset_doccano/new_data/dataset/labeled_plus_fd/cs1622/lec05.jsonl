{"id": 5, "segment": ["train_set", "labeled"], "course": "cs1622", "lec": "lec05", "text": "Top-down Parsing\nCS 1622\nJarrett Billingsley\n\nClass Announcements\n\u25cf how was your weekeeeeend\n\u25cf project 2 will come out this weekend so you'll have 2 weeks for it\n\n2\n\nParsing\n\n3\n\nA generative view\n\u25cf one way to use a grammar is to produce sentences in the language.\nExp:\nId | Num | Parens\nParens: '(' Exp+ ')'\nId:\n<id token>\nNum:\n<int literal token>\n\nwe can produce valid\nsentences by starting at the\nroot rule and repeatedly\nreplacing nonterminals with\ntheir right-hand sides.\n\nExp\n=> Parens\n=> '(' Exp+ ')'\n=> '(' Exp Exp Exp ')'\n\n=> '(' Id Id Num ')'\n=> '(' 'add' Id Num ')'\n=> '(' 'add' 'x' Num ')'\n=> '(' 'add' 'x' '3' ')'\n\nthis sequence is called a derivation.\n\nnow suppose we were given (add x 3) as our input. could\nwe work backwards to figure out how to get to Exp?\n\n4\n\nThat's what parsing is.\n\u25cf given a grammar and an input string...\n\u25cf parsing is figuring out the derivation that was needed to produce\nthe input string. (and if there is no such derivation, it's an error!)\n\u25cf we represent the derivation as... an abstract syntax tree!\nExp: Id | Num | Parens\nParens: '(' Exp+ ')'\nId:\n<id token>\nNum:\n<int token>\n\nInput\ne\n(e)\n(1 2)\n(e\ne)\n()\n\nOutput AST\nId(\"e\")\nParens(Id(\"e\"))\nParens(Num(1), Num(2))\nerror!\nerror!\nerror!\n\nthe last three would benefit from some\nerror messages that help the programmer.\n\n5\n\nOkay what is this language?\n\u25cf this is a variety of Lisp, a language family that started in 1958.\n\u25cf we're not going to get into what it means, but it's a very easy-toparse example language.\n()\n\n(defun fact (x)\n(if (eq x 0)\ndefun\n1\n(mul x (fact (sub x 1)))))\n\nfact\n\nLisp code is basically an AST already;\nparentheses group children.\n\n()\nx\n\n()\nif\neq\n\n()\nx\n\n0\n\nthis is going to make our job of\nparsing much easier.\n\n1\n\n()\nmul\n\nx\n\n()\n\nfact ()\nsub\n\nx\n\n1\n6\n\nSo how do we do it?\n\u25cf well it's a bit like lexing:\no we start at the beginning, looking at tokens one-by-one.\no based on the token, we decide which rule we should use.\no if none of the rules apply, or if we see something that we don't\nexpect, we can give an error.\n\u25cf speaking of which...\n\n7\n\nError Handling in Rust\ntime check: \u2264 17\n\n8\n\nThe Result type\n\u25cf Rust doesn't have exceptions like Java does.\n\u25cf if your function needs to indicate failure, it returns a Result.\n\nResult<T, E>\nT is the type of value\nreturned on success.\n\nif the function doesn't return\nany value on success, you can\nuse () - this is Rust's void.\n\nE is the type of value\nreturned for errors.\nany type can be used for errors,\nbut typically it's an enum.\n\nResult<Box<AstNode>, ParseError>\nthis is a bit unwieldy, so we can use a type alias to shorten it:\ntype ParseResult = Result<Box<AstNode>, ParseError>;\n9\n\nErr, ok...\n\u25cf you create Results with the Ok() and Err() constructors.\nif thing.is_bad() {\n// common to use 'return' to immediately\n// leave the function. kinda like throwing\nreturn Err(ParseError::whatever());\n}\nyou can match on a Result using Ok() and Err():\nmatch parse_thing(input) {\nOk(ast) => { println!(\"{:?}\", ast); }\nErr(e) => { println!(\"o no: {}\", e); }\n}\nmatch patterns declare local variables usable in\ntheir code blocks, if that was unclear before.\n10\n\n???????\n\u25cf when using Result-returning functions, a really ugly pattern appears:\nmatch step_one(input) {\nOk(a) => {\nmatch step_two(a) {\nOk(b) => {\nmatch step_three(b) {\nOk(c) => {\nreturn Ok(c.to_string());\n}\nErr(e) => { return Err(e); }\n}\n}\nErr(e) => { return Err(e); }\n}\n}\nErr(e) => { return Err(e); }\n}\n\nthis is terrible. instead:\nlet a = step_one(input)?;\nlet b = step_two(a)?;\nlet c = step_three(b)?;\nOk(c.to_string())\n\nx? means, \"if x is an error,\nreturn it; otherwise, give\nme the success value.\nwe'll be seeing this a lot\nin parsing code!\n11\n\nRecursive Descent\ntime check: \u2264 34\n\n12\n\nCan we intuit our way through this?\n\u25cf with this grammar, and this sequence of tokens as our input...\n\n'(', '(', 'hi', '5', ')', ')'\n\nExp:\nId | Num | Parens\nParens: '(' Exp+ ')'\nId:\n<id token>\nNum:\n<int literal token>\n\nwe are here. our ultimate goal is to build an Exp. this token is\na left-paren, so which rule do we think applies here?\nParens!\nafter the left-paren, we should see one or\nmore Exps, followed by a right-paren.\n\nbut we're already trying to parse an Exp. how do\nwe parse a new Exp without finishing this one?\n13\n\nThe rules are recursive, so...\n\u25cf recall that all CFGs have this recursive rule structure.\n\u25cf well if the dependencies between the rules are recursive...\no why not use recursive functions to model the rules?\nExp: Id | Num | Parens\nParens: '(' Exp+ ')'\nId:\n<id token>\nNum:\n<int token>\n\nlet's write some pseudocode to\nget our thoughts down.\n\nfn parse_exp() {\nmatch self.cur() {\nId\n=> parse_id(),\nIntLit => parse_num(),\nLParen => parse_parens(),\n}\n}\n\nfn parse_parens() {\neat_an_lparen();\nlet exps = ...parse_exp()...\neat_an_rparen();\nreturn Parens(exps);\n}\n(looping happens here)\n\n14\n\nBelieve it or not, that's pretty much right!\n\u25cf what we've just (pseudo-)written is a recursive descent parser:\no recursive, because uh, it is!\no and descent, because we start at the root rule, and descend into\nthe other rules until we get to the terminals.\n\u25cf the issue with \"trying to parse an Exp while parsing an Exp\" is solved\nby using recursion\no when you recurse, the caller rule's execution is paused, and it\nremembers its place in the rule.\no it can then resume parsing after the callee rule has done its work.\n\u25cf so how can we be a little less \"pseudo\" about this code?\n\n15\n\nFrom Rules to Rust\n\u25cf each grammar rule is really a list of steps, and translating them to\nreal code is relatively straightforward:\n\nParens: '(' Exp+ ')'\nthis says that to parse a Parens:\n1. expect a '(' token and skip it.\n2. parse one Exp, since that's the minimum number.\n3. while we don't see a ')' token,\n\u2022 keep parsing Exps and put them into a list.\n4. expect a ')' token and skip it.\n\nif all of these steps succeed, we can create an\nParens AST node and return it!\n16\n\nOther metalanguage rule correspondences\n\u25cf there's a nice correspondence between the things we see in the\ngrammar metalanguage and the patterns we use in our code.\n\nA B\nA | B\n\nsequencing: parse an A; if that succeeds, then parse a B.\nalternation: an if-else (or a match); either parse\nan A or parse a B.\n\nA*\n\n0+ repetition: while the next token looks like an A,\nkeep parsing As.\n\nA+\n\n1+ repetition: parse an A, then do a while loop\nlike for 0+.\n\nA?\n\noptional: if the next token looks like an A, parse it.\n17\n\nFrom rules to AST nodes\n\u25cf similarly, when we design our AST nodes, these metalanguage rules\nimply different data structures:\n\nA B\nA | B\n\na struct, with an A field and a B field.\nan enum, where A and B are two variants.\n\nA*\nA+\n\nan array/vector, whose length is the number of\nrepetitions.\n\nA?\n\nan Option<A> field, since it might not exist.\n18\n\nThe example\n\u25cf now let's have a look at the new parsing_lisp example I added.\no src/lib.rs is where all the goodies are.\no the Token and AstNode types are familiar to you by now.\n\u25aa there's an extra Program rule in the grammar though.\no ParseError is an example of an error enum.\no Parser looks a lot like Lexer from your project...\n\u25aa except it iterates over Tokens, not chars.\no and there are three parsing methods for the three main rules.\n\u25cf this real parser handles errors, too.\no the expect_blah methods and the match in parse_exp deal with\nunexpected terminals (tokens) in various positions.\n\u25aa they also give customized errors for each of these possibilities.\n\u25aa there's no location info, because it's an example. :B\n\n19\n\nLimits of Recursive\nDescent\ntime check: \u2264 68\n\n20\n\nIf it works so well, why not use it for everything?\n\u25cf there are lots of cases where recursive descent works great!\no import java.util.Arrays;\no use std::blah;\no fn name() { ... }\no class A { ... }\no if x == y { ... }\no match value { ... }\n\u25cf but there's something all of these things have in common:\no they all start with a token that unambiguously indicates which\nrule should be used to parse them.\no if you don't have that, recursive descent gets a lot harder to use.\n\u25cf but, what kind of code looks like that?\n\n21\n\nExpressions!\n\u25cf we want to be able to write expressions like we do in math.\no that is, we want 4 + 5, not (add 4 5).\n\u25cf but this presents a few problems.\n\nInput\n\nOutput\n\nx + y + z\n\n(x + y) + z or either is fine..? what\nx + (y + z) ? if it were *, -, or / ?\n\nx + 4 * y\n\n(x + 4) * y or\nx + (4 * y) ?\n\nthe second\none is right.\n\nand if we allow ** for exponents, like Python:\n\n2 ** x ** 2\n\n(2 ** x) ** 2 or\n2 ** (x ** 2) ?\n\nthe second\none is right.\n22\n\nEven worse...\n\u25cf how do we know what kind of expression we're looking at?\n\n(3 + x + y * 2) / 50\nlet's say our parser is\nlooking at this token....\n\n...how will it know it's a\ndivision until it gets here?\n\nso what do we do? look ahead? how\nmany tokens? 5? 10? is there a limit?\nwhat we would have to do here is try each\npossible parse, and backtrack if we mess up.\n23\n\nOH NO, BACKTRACKING\n\u25cf this is an exponential time (O(2n)) algorithm! just awful!\no and from an intuitive sense, it feels kind of silly to commit to\nparsing something when you don't actually have enough\ninformation yet to parse it.\n\u25cf so for these (and other similar) situations, there is another way to\nparse that's a little more mind-bending, but more powerful.\no that's for next time!\n\n24\n\nError Reporting\ntime check: \u2264 85\n\n25\n\nCompilers have a bit of a reputation\n\u25cf how many times have you gotten compiler errors that:\no seemed totally confused by very simple/common typos, like\nmissing a semicolon or comma or closing brace?\no pointed 100 lines after where the actual error was?\no used weird terminology, like \"specifier-qualifier-list\"?\no gave almost no information, like \"syntax error\"?\n\u25cf is it because the compiler writers suck?\no no\no good error reporting is really hard to do right, okay,\n\n26\n\nWho are error messages for?\n\u25cf I've said it many times: programming languages exist for humans.\n\u25cf so when a compiler gives errors, they should be... for humans!\n\u25cf but there are two things working against us here.\nthe compiler is a dumb\nalgorithm that doesn't\nunderstand our human\nmistakes\n\nf(3 4)\n----^\nexpected `)' or `,' in\nargument-list, not `4'\n\npeople who write\ncompilers tend to forget\nthat other people don't\nknow how they work\n\n(substitution of deduced\ntemplate arguments resulted\nin errors seen above)\n27\n\nCarry on, my wayward son\n\u25cf you know how you sometimes get like 1000 error messages?\no and it's all because you forgot ONE closing brace?\n\u25cf this is error recovery: instead of stopping at the first error, the\ncompiler tries to keep going.\nenum E {\nX,\nY\n// uh oh.\n\nbut how would you algorithmically determine\nwhere the closing brace should go?\n\nfn func() {\nlet x = E::X // oops\n(blah).y();\n}\n\nthis could even parse differently\ndepending on where we infer\nthe semicolon \"should\" be.\n28\n\nTo recover or not?\n\u25cf in the past, languages were simpler, and so was error recovery.\no compilers also ran on huge computers in batch jobs.\no since a compile might take hours, it was useful to report as many\nerrors as possible.\n\u25cf but now, a really, really common thing to do is:\no compile, fix the first error, repeat\n\u25aa (I really recommend you do this if you don't already)\n\n\u25cf so maybe stopping at the first error is fine?\no but what about IDEs?\no they can show multiple errors inline with the code\no so maybe there's still some use to it?\n\u25aa or does it just make using an IDE more annoying? :^)\n\n\u25cf personally I think lexing/parsing error recovery is pointless, but\ngiving multiple semantic errors can still be useful. sometimes.\n29\n\nA philosophy for good errors\n\u25cf there are three ways to improve error messages.\n1. say where it is\ntest.foo(9:17)\n\nbare minimum...\n\ntest.foo(9:17):\nfor num in 10 {\n^ here\nbetter!\n\n2. give a unique message for that particular error\nexpected ',', not '{'\nehh...\n\nfor-loop missing upper bound\nbetter!\n\n3. extra credit: tell the user how they might fix it\n\nhelp: maybe you meant \"for num in 10, something\"?\n^^^^^^^^^^^\n30\n\nFirst: location information\n\u25cf the lexer can associate a line and column with each token.\no well, some tokens span more than one column...\no or even more than one line, if you allow multi-line strings!\no so maybe each token should have a range of locations? hmm\n\u25cf when parsing, that info can be carried from the tokens into the AST.\no that way, we can report errors during semantic analysis.\no or maybe we want to refer back to the token list somehow...?\n\u25aa there are lots of ways to implement this!\n\n31\n\nSecond: accurate error messages\n\u25cf it's really easy to make unhelpful, uninformative messages, sadly!\n\u25cf giving accurate errors is largely about customizing the error\nmessages for each place an error could happen.\no looking through the parser code, every ? is a potential error spot.\no in parse_paren_exp, there are several of these.\n\u25cf matches are another place ripe for better errors:\no in parse_exp, there are a number of possible options, so we\nshould list the options in the error message, like \"expected\nidentifier, integer, or parenthesized expression, not blah blah\"\n\u25cf one possibility is to pass some kind of \"error context\" to the parsing\nfunctions which can be used to tailor the messages better\no since parse_exp is called from multiple places, the error message\nmight be different depending on who calls it.\n32\n\nThird: giving help\n\u25cf this is extremely broad and it's up to you what to say.\no it's really kind of an extension of the previous rule.\n\u25cf have a look at the error messages Rust gives.\no sometimes it's as simple as \"remove this semicolon.\"\no sometimes it links to the appropriate part of the docs.\no sometimes it even detects common mistakes and explains why\nthey won't work. it's amazing!\n\n33\n\n", "label": [[0, 16, "Concept"], [9, 16, "Concept"], [166, 173, "Concept"], [789, 796, "Concept"], [844, 851, "Concept"], [1701, 1708, "Concept"], [3637, 3644, "Concept"], [5106, 5113, "Concept"], [5271, 5278, "Concept"], [5699, 5706, "Concept"], [6223, 6230, "Concept"], [7105, 7112, "Concept"], [8958, 8965, "Concept"], [11332, 11339, "Concept"], [12127, 12134, "Concept"], [12999, 13006, "Concept"], [215, 222, "Concept"], [811, 818, "Concept"], [3743, 3750, "Concept"], [5410, 5417, "Concept"], [5962, 5969, "Concept"], [6924, 6931, "Concept"], [653, 663, "Concept"], [872, 882, "Concept"], [953, 963, "Concept"], [1000, 1010, "Concept"], [1020, 1040, "Concept"], [1154, 1157, "Concept"], [1601, 1604, "Concept"], [2930, 2933, "Concept"], [2957, 2960, "Concept"], [5829, 5832, "Concept"], [6379, 6382, "Concept"], [6421, 6424, "Concept"], [12186, 12189, "Concept"], [1362, 1366, "Concept"], [1575, 1579, "Concept"], [3655, 3672, "Concept"], [4887, 4904, "Concept"], [7565, 7582, "Concept"], [7906, 7923, "Concept"], [4887, 4911, "Concept"], [316, 321, "Concept"], [341, 346, "Concept"], [1094, 1099, "Concept"], [1111, 1116, "Concept"], [1887, 1892, "Concept"], [3880, 3885, "Concept"], [3905, 3910, "Concept"], [3969, 3974, "Concept"], [4480, 4485, "Concept"], [4497, 4502, "Concept"], [5587, 5592, "Concept"], [5685, 5690, "Concept"], [5754, 5759, "Concept"], [6195, 6200, "Concept"], [6328, 6333, "Concept"], [6833, 6838, "Concept"], [7804, 7809, "Concept"], [8579, 8584, "Concept"], [11941, 11946, "Concept"], [12076, 12081, "Concept"], [12290, 12295, "Concept"], [7011, 7016, "Concept"], [11893, 11898, "Concept"], [4905, 4911, "Concept"], [6987, 6993, "Concept"], [7159, 7165, "Concept"], [8553, 8559, "Concept"], [12596, 12602, "Concept"], [2102, 2113, "Concept"], [2645, 2647, "Concept"], [2681, 2683, "Concept"], [2884, 2886, "Concept"], [2927, 2929, "Concept"], [3210, 3212, "Concept"], [3241, 3243, "Concept"], [3274, 3276, "Concept"], [3292, 3294, "Concept"], [3510, 3512, "Concept"], [2640, 2643, "Concept"], [2690, 2693, "Concept"], [2821, 2824, "Concept"], [2893, 2896, "Concept"], [2965, 2968, "Concept"], [3313, 3316, "Concept"], [3332, 3335, "Concept"], [3346, 3349, "Concept"], [3365, 3368, "Concept"], [3379, 3382, "Concept"], [3398, 3401, "Concept"], [2558, 2568, "Concept"], [6973, 6983, "Concept"], [6504, 6510, "Concept"], [2478, 2482, "Concept"], [6546, 6550, "Concept"], [6979, 6983, "Concept"], [10463, 10467, "Concept"], [6595, 6600, "Concept"], [6601, 6607, "Concept"], [6032, 6042, "Concept"], [6090, 6101, "Concept"], [6165, 6178, "Concept"], [6240, 6253, "Concept"], [6306, 6314, "Concept"], [12893, 12917, "Concept"], [12869, 12879, "Concept"], [269, 271, "Concept"], [308, 310, "Concept"], [313, 315, "Concept"], [538, 540, "Concept"], [541, 543, "Concept"], [565, 567, "Concept"], [1047, 1049, "Concept"], [1086, 1088, "Concept"], [1091, 1093, "Concept"], [1158, 1160, "Concept"], [1173, 1175, "Concept"], [3833, 3835, "Concept"], [3872, 3874, "Concept"], [3877, 3879, "Concept"], [4433, 4435, "Concept"], [4472, 4474, "Concept"], [4477, 4479, "Concept"], [4596, 4598, "Concept"], [12881, 12888, "Concept"], [274, 277, "Concept"], [323, 326, "Concept"], [544, 547, "Concept"], [568, 571, "Concept"], [593, 596, "Concept"], [1052, 1055, "Concept"], [1101, 1104, "Concept"], [1189, 1192, "Concept"], [1197, 1200, "Concept"], [3838, 3841, "Concept"], [3887, 3890, "Concept"], [4438, 4441, "Concept"], [4487, 4490, "Concept"], [11592, 11595, "Concept"], [11820, 11823, "Concept"], [7997, 8008, "Concept"], [8040, 8051, "Concept"], [8817, 8829, "Concept"], [8843, 8859, "Concept"], [2054, 2068, "Concept"], [9201, 9216, "Concept"], [9657, 9672, "Concept"], [12839, 12852, "Concept"], [13119, 13132, "Concept"], [10373, 10387, "Concept"], [10778, 10792, "Concept"], [11340, 11354, "Concept"], [12231, 12248, "Concept"], [11866, 11886, "Concept"], [12977, 12990, "Concept"], [5829, 5837, "Concept"], [11280, 11283, "Concept"]]}