{"id": 26, "segment": ["test_set", "labeled"], "course": "cs1502", "lec": "lec03", "text": "Finite Automata 02\nThumrongsak Kosiyatrakul\ntkosiyat@cs.pitt.edu\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\nFinite Automata\nThe computational model called finite automata can be used\nto simulate a set of simple algorithms\nCheck whether a string starts with 010\nCheck whether a string ends with 111\nCheck whether a string contains 0101 as a substring\nCheck whether a string contains substrings 000 and 111 where\n000 comes before 111\n\nIt is a powerful tool in compiler\nAccept or reject your source code based on a programming\nsyntax\nExample: the for statement:\nstarts with for\nfollowed by (\nfollowed by assignment statement(s)\nfollowed by ;\nfollowed by conditional statement(s)\nfollowed by ;\nfollowed by assignment statement(s)\nfollowed by )\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\nFormal Definition of Computation\n\nLet M = (Q, \u03a3, \u03b4, q0 , F ) be a finite automaton and let\nw = w1 w2 . . . wn be a string where each wi is a member of\nthe alphabet \u03a3.\nM accepts w if a sequence of states r0 , r1 , . . . , rn in Q exists\nwith three conditions:\n1\n2\n3\n\nr0 = q 0\n\u03b4(ri , wi+1 ) = ri+1 , where i = 0, . . . , n - 1\nrn \u2208 F\n\nThink in terms of processing the input string w\nw\n\nw\n\nw\n\nw\n\nw\n\nwn-1\n\nw\n\nr0 \u21921 r1 \u21922 r2 \u21923 r3 \u21924 r4 \u21925 . . . \u2192 rn-1 \u2192n rn\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\nRegular Languages\nA language L over an alphabet \u03a3 is said to be a regular\nlanguage if some finite-state automaton recognizes it.\nConsider the following machine M :\n0\n\n0\n1\n\nq0\n\nq1\n\n1\n\nWhat is the language of this machine?\nL(M ) = {w | w contains an odd number of 1s}\n\n\"The set of all strings consisting of an odd number of 1s\" is a\nregular language\nL(M ) is a regular language\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\nRegular Languages\n\nWhy regular language is important in our discussion?\nDefinition: A language is regular if some finite-state machines\nrecognize it.\nIf we can prove that a language is regular\nWe must be able to construct a finite-state machine to\nrecognize it\nIt maybe hard to build but I know that it exists\n\nIf we can prove that a language is not regular\nWe cannot construct a finite-state machine to recognize it\n\nThis is an example of a limitation of this computational model\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\nProblem and Language\nIn theory of computation, a problem is represented as a\nlanguage\nA problem of determining whether a string contains 011 as a\nsubstring\nL(M ) = {x | x contains 011 as a substring}\nWe already see a Deterministic Finite Automaton (DFA) M\nthat accepts all strings that contains 011 as a substring and\nreject those that does not contain 011 as a substring\nIt means this problem is solvable by the algorithm captured by\nthe previous DFA\nIn case of algorithm in a form of DFA (not all algorithms)\nif L(M ) is regular, the problem represented by L(M ) is\nsolvable\nif L(M ) is not regular, no DFA exists, the problem\nrepresented by L(M ) is unsolvable\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\nProblems and Languages\nSolvable problems that we see so far\nThe problem of determining whether a string ends with a 1\n{x | x ends with a 1}\nThe problem of determining whether a string is an empty\nstring or ends in a 0\n{x | x is an empty string or ends in a 0}\nThe problem of determining whether a string starts and ends\nwith the same symbol\n{x | x starts and ends with the same symbol}\nThe problem of determining whether a string contains either\n11 or 00 as a substring\n{x | x contains either 11 or 00 as a substring}\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\nProblems and Languages\nSolvable problems that we see so far (continue)\nThe problem of determining whether a string contains 011 as a\nsubstring\n{x | x contains 011 as a substring}\nThe problem of determining whether a string ends with 0110\n{x | x ends with 0110}\nThe problem of determining whether a string contains an odd\nnumber of 1s\n{x | x contains an odd number of 1s}\n\nEach of the above languages is regular since we can construct\na DFA that recognizes it.\nBut if a language is very complicate, it will be difficult to\nconstruct a DFA that recognizes it\n\nWe need tools to help us to determine whether a language is\nregular or not\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\nThe Regular Operations\nIn arithmetic:\nObjects are numbers\nTools are operations for manipulating numbers (e.g., + and \u00d7)\n1 + 1 gives you a new number which is 2\n\nIn the theory of computation,\nObjects are languages (sets of strings)\nTools are operations for manipulating languages\n\nDefinition 1.23\nLet A and B be languages. We define the regular operations as\nfollows:\nUnion: A \u222a B = {x | x \u2208 A or x \u2208 B}\nConcatenation: A \u25e6 B = {xy | x \u2208 A and y \u2208 B}\nStar: A\u2217 = {x1 x2 . . . xk | k \u2265 0 and each xi \u2208 A}\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\nExamples (Union)\n\nLet \u03a3 = {0, 1}\nConsider the following languages A and B\nA = {00, 11}\nB = {010, 101}\n\nThe union operations is identical to the set's union operation:\nA \u222a B = {x | x \u2208 A or x \u2208 B}\nFrom the above definition:\nA \u222a B = {00, 11, 010, 101}\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\nExamples (Concatenation)\n\nLet \u03a3 = {0, 1}\nConsider the following languages A and B\nA = {00, 11}\nB = {010, 101}\n\nThe definition of concatenation is defined as\nA \u25e6 B = {xy | x \u2208 A and y \u2208 B}\nFrom the above definition:\nA \u25e6 B = {00010, 00101, 11010, 11101}\nFor simplicity, sometimes we write AB instead of A \u25e6 B\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\nExamples (Star)\nLet \u03a3 = {0, 1}\nConsider the following language A\nA = {00, 11}\n\nThe definition of start is defined as\nA\u2217 = {x1 x2 . . . xk | k \u2265 0 and xi \u2208 A}\nIf k = 0, the above definition becomes\n{ | 0 \u2265 0} = {\u03b5}\nIf k = 1, the above definition becomes\n{x1 | 1 \u2265 0 and xi \u2208 A} = {00, 11}\nIf k = 2, the above definition becomes\n{x1 x2 | 2 \u2265 0 and xi \u2208 A} = {0000, 0011, 1100, 1111}\nIf k = 3, the above definition becomes\n{x1 x2 x3 | 3 \u2265 0 and xi \u2208 A} = {000000, 000011, . . . , 111111}\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\nExamples (Star)\nLet \u03a3 = {0, 1}\nSuppose A = {00, 11}, what is A\u2217 ?\nA\u2217 = {\u03b5, 00, 11, 0000, 0011, 1100, 1111, 000000, . . . }\nSuppose A = {011}, what is A\u2217 ?\nA\u2217 = {\u03b5, 011, 011011, 011011011, 011011011011, . . . }\nSuppose A = {0, 1}, what is A\u2217 ?\nA\u2217 = {\u03b5, 0, 1, 00, 01, 10, 11, 000, 001, 010, 011, 100, . . . }\nThis is the set of all strings over {0, 1}\nSuppose A = \u2205, what is A\u2217 ?\nA\u2217 = {\u03b5}\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\nDefinition of Closed Under Operations\n\nLet A be a set of objects (a collection of object)\nWe say that A is closed under operation 4 if for any x \u2208 A\nand y \u2208 A, x4y is also in A.\nExample: Let N be the set of natural number\nN is closed under addition\nFor any two natural numbers x and y, x + y is a natural\nnumber\n\nN is closed under multiplication\nFor any two natural numbers x and y, x \u00d7 y is a natural\nnumber\n\nN is not closed under subtraction\n5 - 7 is not a natural number\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\nDefinition of Closed Under Operations\n\nLet L be the set of all regular languages\nThis is a set of sets\n\nRecall that we have three operations, union, concatenation,\nand star\nIs L closed under union operation?\nFor any regular languages A and B, is A \u222a B a regular\nlanguage?\n\nIs L closed under concatenation operation?\nFor any regular languages A and B, is A \u25e6 B a regular\nlanguage?\n\nIs L closed under star operation?\nFor any regular language A, is A\u2217 a regular language?\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\nL is regular under union operation\nLet A be a set of strings over {0, 1} that contain a 00 as a\nsubstring\nIs A a regular language?\nCan you construct a DFA that recognizes the language A?\nOne of the machine that recognizes A can be as follows:\n1\n\n0,1\n\n0\n\nqa\n\n0\n\nqb\n\nqc\n\n1\n\nBecause there exists a DFA that recognizes A, A is a regular\nlanguage\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\nL is regular under union operation\n\nLet B be a set of strings over {0, 1} that end with a 1\nIs B a regular language?\nCan you construct a DFA that recognizes the language B?\nOne of the machine that recognizes B can be as follows:\n0\n\n1\n1\n\nq0\n\nq1\n0\n\nBecause there exists a DFA that recognizes B, B is a regular\nlanguage\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\nL is regular under union operation\nWe have A = {x | x contains 00 as a substring} is regular\nWe have B = {x | x ends with a 1} is regular\nHow about A \u222a B?\nA \u222a B = {x | x contains 00 as a substring or x ends with a 1}\nIt is quite straightforward to construct a machine that\nrecognizes A \u222a B (try to build one yourself)\n1\n\n0,1\n\n0\n1\n1\n0\n\n0\n\nThis does not prove that if A and B are regular, A \u222a B is\nregular\nThis is just one example out of infinite may instances of\nregular languages\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\nL is regular under union operation\nWe need to show that for any two regular languages A and B,\nA \u222a B is regular\nGiven a regular language A over a \u03a3, what do we know about\nthe language A?\nThere exists a DFA MA that recognizes A (L(MA ) = A)\nMA = (QA , \u03a3, \u03b4A , qA , FA ) for some QA , \u03b4A , qA , and FA\n\nSimilarly, given a regular language B over a \u03a3:\nThere exists a DFA MB that recognizes B (L(MB ) = B)\nMB = (QB , \u03a3, \u03b4B , qB , FB ) for some QB , \u03b4B , qB , and FB\n\nTo show that A \u222a B is regular for any regular languages A\nand B, we need to construct a DFA that recognizes A \u222a B\nfrom MA and MB\nTo understand the process, we are going to work on a specific\nexample\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\nL is regular under union operation\nRecall the previous two regular languages and its DFAs where\n\u03a3 = {0, 1}\nA = {x | x contains 00 as a substring}\n1\n\n0,1\n\n0\n\nqa\n\n0\n\nqb\n\nqc\n\n1\n\nMA = (QA , \u03a3, \u03b4A , qA , FA ) and L(MA ) = A\nB = {x | x ends with a 1}\n0\n\n1\n1\n\nq0\n\nq1\n0\n\nMB = (QB , \u03a3, \u03b4B , qB , FB ) and L(MB ) = B\n\nGiven a string w and these two DFAs, how to check whether\nw is in A \u222a B?\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\nL is regular under union operation\nRecall that A = L(MA ) and B = L(MB )\nThus, A \u222a B = L(MA ) \u222a L(MB )\n\nw \u2208A\u222aB\niff w \u2208 A or w \u2208 B\niff w \u2208 L(MA ) or w \u2208 L(MB )\niff MA accepts w or w \u2208 L(MB )\niff MA accepts w or MB accepts w\n\nIn other words,\nw \u2208 A \u222a B if and only if MA accepts w or MB accepts w\nTo check whether w \u2208 A \u222a B:\nRun both MA and MB on input w\nIf one of them or both accepts w, w \u2208 A \u222a B\nIf both reject w, w 6\u2208 A \u222a B\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\nL is regular under union operation\nWe can run both machines simultaneously\n1\n\n0,1\n\n0\n\n1\n1\n\n0\n\nqa\n\n0\n\nqb\n\nqc\n\nq0\n\nq1\n\n1\n0\n\nLet state (p, q) represents the situation where\nThe current state of MA is p\nThe current state of MB is q\n\nWith the new notion of states, we have\n0\n\n(qa , q0 )\n1\n1\n1\n\n(qa , q1 )\n\n0\n\n(qb , q0 )\n0\n\n0\n\n1\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\n(qb , q1 )\n\nFinite Automata 02\n\n(qc , q0 )\n0\n\n0\n1\n\n(qc , q1 )\n\n1\n\nL is regular under union operation\nLet MA recognizes A, where MA = (QA , \u03a3, \u03b4A , qA , FA )\nLet MB recognizes B, where MB = (QB , \u03a3, \u03b4B , qB , FB )\nMachine M = (Q, \u03a3, \u03b4, q0 , F ) that recognizes A \u222a B can be\nconstructed as follows:\n1\n2\n\nQ = {(r1 , r2 ) | r1 \u2208 QA and r2 \u2208 QB }\nFor each (r1 , r2 ) \u2208 Q and a \u2208 \u03a3\n\u03b4((r1 , r2 ), a) = (\u03b4A (r1 , a), \u03b4B (r2 , a))\n\n3\n4\n\nq0 = (qA , qB )\nF = {(r1 , r2 ) | r1 \u2208 FA or r2 \u2208 FB }\n\nTo recognize A \u2229 B, simply change the set of accept states to\nF = {(r1 , r2 ) | r1 \u2208 FA and r2 \u2208 FB }\nIf A and B are regular languages, A \u222a B is regular\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\nConclusions\n\nA language is regular if it is recognized by some finite-state\nmachines\nIf you can prove that a language is regular:\nthere exists a finite-state machine that recognizes it\n\nIf you can prove that a language is not regular:\nthere is no finite-state machine that recognizes it\n\nIn formally, we show that if A and B are regular languages,\nA \u222a B is a regular language\nTo prove the closure of concatenation and star operators, we\nneed a sightly different computational model\n\nThumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu\n\nFinite Automata 02\n\n", "label": [[0, 15, "Concept"], [113, 128, "Concept"], [133, 148, "Concept"], [180, 195, "Concept"], [812, 827, "Concept"], [1334, 1349, "Concept"], [1778, 1793, "Concept"], [2327, 2342, "Concept"], [3059, 3074, "Concept"], [3644, 3659, "Concept"], [4344, 4359, "Concept"], [4912, 4927, "Concept"], [5230, 5245, "Concept"], [5605, 5620, "Concept"], [6157, 6172, "Concept"], [6611, 6626, "Concept"], [7153, 7168, "Concept"], [7690, 7705, "Concept"], [8100, 8115, "Concept"], [8485, 8500, "Concept"], [9032, 9047, "Concept"], [9762, 9777, "Concept"], [10210, 10225, "Concept"], [10703, 10718, "Concept"], [11106, 11121, "Concept"], [11778, 11793, "Concept"], [12328, 12343, "Concept"], [898, 914, "Concept"], [2578, 2594, "Concept"], [1445, 1467, "Concept"], [2022, 2042, "Concept"], [2178, 2198, "Concept"], [11943, 11963, "Concept"], [12045, 12065, "Concept"], [2564, 2594, "Concept"], [2596, 2599, "Concept"], [2795, 2798, "Concept"], [2833, 2836, "Concept"], [2952, 2955, "Concept"], [4100, 4103, "Concept"], [4198, 4201, "Concept"], [7861, 7864, "Concept"], [8005, 8008, "Concept"], [8257, 8260, "Concept"], [8390, 8393, "Concept"], [9254, 9257, "Concept"], [9416, 9419, "Concept"], [9603, 9606, "Concept"], [1685, 1701, "Concept"], [1713, 1729, "Concept"], [1821, 1837, "Concept"], [7596, 7612, "Concept"], [7624, 7640, "Concept"], [7823, 7839, "Concept"], [8219, 8235, "Concept"], [9172, 9188, "Concept"], [9372, 9388, "Concept"], [12157, 12173, "Concept"], [4368, 4386, "Concept"], [4700, 4718, "Concept"], [4731, 4736, "Concept"], [4942, 4947, "Concept"], [5039, 5044, "Concept"], [5082, 5087, "Concept"], [7315, 7320, "Concept"], [7364, 7369, "Concept"], [7729, 7734, "Concept"], [8139, 8144, "Concept"], [8524, 8529, "Concept"], [9071, 9076, "Concept"], [9801, 9806, "Concept"], [10249, 10254, "Concept"], [10742, 10747, "Concept"], [11179, 11184, "Concept"], [4767, 4780, "Concept"], [5260, 5273, "Concept"], [5379, 5392, "Concept"], [7322, 7335, "Concept"], [7464, 7477, "Concept"], [12198, 12211, "Concept"], [4813, 4817, "Concept"], [5635, 5639, "Concept"], [6187, 6191, "Concept"], [7341, 7345, "Concept"], [7572, 7576, "Concept"], [12216, 12220, "Concept"], [987, 995, "Concept"], [1393, 1401, "Concept"], [263, 269, "Concept"], [302, 308, "Concept"], [339, 345, "Concept"], [391, 397, "Concept"], [947, 953, "Concept"], [1204, 1210, "Concept"], [2468, 2474, "Concept"], [3176, 3182, "Concept"], [3256, 3262, "Concept"], [3275, 3281, "Concept"], [3316, 3322, "Concept"], [3376, 3382, "Concept"], [3502, 3508, "Concept"], [3772, 3778, "Concept"], [3880, 3886, "Concept"], [3962, 3968, "Concept"], [10098, 10104, "Concept"], [365, 374, "Concept"], [2493, 2502, "Concept"], [2536, 2545, "Concept"], [2651, 2660, "Concept"], [2709, 2718, "Concept"], [3539, 3548, "Concept"], [3586, 3595, "Concept"], [3797, 3806, "Concept"], [3832, 3841, "Concept"], [7806, 7815, "Concept"], [8576, 8585, "Concept"], [8692, 8701, "Concept"], [9917, 9926, "Concept"], [492, 498, "Concept"], [11623, 11629, "Concept"], [502, 508, "Concept"], [2665, 2671, "Concept"], [10634, 10640, "Concept"], [1452, 1457, "Concept"], [1919, 1924, "Concept"], [2029, 2034, "Concept"], [2185, 2190, "Concept"], [10849, 10854, "Concept"], [10905, 10910, "Concept"], [10934, 10939, "Concept"], [11868, 11873, "Concept"], [11950, 11955, "Concept"], [12052, 12057, "Concept"], [11623, 11636, "Concept"], [1198, 1210, "Concept"], [2347, 2354, "Concept"], [2396, 2403, "Concept"], [2435, 2442, "Concept"], [2733, 2740, "Concept"], [2883, 2890, "Concept"], [2968, 2975, "Concept"], [3143, 3150, "Concept"], [3223, 3230, "Concept"], [3343, 3350, "Concept"], [3469, 3476, "Concept"], [3739, 3746, "Concept"], [3847, 3854, "Concept"], [3929, 3936, "Concept"], [2371, 2392, "Concept"], [4532, 4553, "Concept"], [483, 491, "Concept"], [569, 582, "Concept"], [626, 646, "Concept"], [727, 747, "Concept"], [676, 697, "Concept"], [6738, 6760, "Concept"], [12187, 12194, "Concept"], [7225, 7253, "Concept"], [3310, 3322, "Concept"]]}