{"id": 15, "segment": ["train_set", "labeled"], "course": "cs0441", "lec": "lec15", "text": "Discrete Structures for Computer\nScience\n\nWilliam Garrison\nbill@cs.pitt.edu\n6311 Sennott Square\nLecture #15: Recursion and Structural Induction\n\nBased on materials developed by Dr. Adam Lee\n\nThere are many uses of induction in computer\nscience!\nProof by induction is often used to reason about:\nl Algorithm properties (correctness, etc.)\nl Properties of data structures\nl Membership in certain sets\nl Determining whether certain expressions are well-formed\nl...\n\nTo begin looking at how we can use induction to prove\nthe above types of statements, we first need to\nlearn about recursion\n\nSometimes, it is difficult or messy to define\nsome object explicitly\nRecursive objects are defined in terms of (other\ninstances of) themselves\nWe often see the recursive versions of the following\ntypes of objects:\nl Functions\nl Sequences\nl Sets\nl Data structures\n\nLet's look at some examples...\n\nRecursive functions are useful\nWhen defining a recursive function whose domain is\nthe set of natural numbers, we have two steps:\n1. Basis step: Define the behavior of f(0)\n2. Recursive step: Compute f(n+1) using f(0), ..., f(n)\nDoesn't this look a little bit like strong induction?\n\nExample: Let f(0) = 3, f(n+1) = 2f(n) + 3\nl\nl\nl\nl\nl\n\nf(1) = 2f(0) + 3 = 2(3) + 3 = 9\nf(2) = 2f(1) + 3 = 2(9) + 3 = 21\nf(3) = 2f(2) + 3 = 2(21) + 3 = 45\nf(4) = 2f(3) + 3 = 2(45) + 3 = 93\n...\n\nSome functions can be defined more precisely\nusing recursion\nExample: Define the factorial function F(n) recursively\n1. Basis step: F(0) = 1\n2. Recursive step: F(n+1) = (n+1) \u00d7 F(n)\n\nNote: F(4) = 4 \u00d7 F(3)\nThe recursive definition\n= 4 \u00d7 3 \u00d7 F(2)\navoids using the \"...\"\nshorthand!\n= 4 \u00d7 3 \u00d7 2 \u00d7 F(1)\n= 4 \u00d7 3 \u00d7 2 \u00d7 1 \u00d7 F(0)\n= 4 \u00d7 3 \u00d7 2 \u00d7 1 \u00d7 1 = 24\nCompare the above definition our old definition:\nl\n\nF(n) = n \u00d7 (n-1) \u00d7 ... \u00d7 2 \u00d7 1\n\nIt should be no surprise that we can also define\nrecursive sequences\nExample: The Fibonacci numbers, {fn}, are defined as follows:\nl f0 = 1\nl f1 = 1\nl fn = fn-1 + fn-2\n\nThis is like strong induction, since we need\nmore than fn-1 to compute fn.\n\nCalculate: f2, f3, f4, and f5\nl f2 = f1 + f0 = 1 + 1 = 2\nl f3 = f2 + f1 = 2 + 1 = 3\nl f4 = f3 + f2 = 3 + 2 = 5\nl f5 = f4 + f3 = 5 + 3 = 8\n\nThis gives us the sequence {fn} = 1, 1, 2, 3, 5, 8, 13, 21, 34, ...\n\nRecursion is used heavily in the study of strings\nLet: \u2211 be defined as an alphabet\nl Binary strings: \u2211 = {0, 1}\nl Lower case letters: \u2211 = {a, b, c, ..., z}\n\nWe can define the set \u2211* containing all strings over the\n\u03bb is the empty string\nalphabet \u2211 as follows:\ncontaining no characters\n1. Basis step: \u03bb \u2208 \u2211*\n2. Recursive step: If w \u2208 \u2211* and x \u2208 \u2211, then wx \u2208 \u2211*\n\nExample: If \u2211 = {0, 1}, then \u2211* = {\u03bb, 0, 1, 01, 11, ...}\n\nThis recursive definition allows us to easily\ndefine important string operations\nDefinition: The concatenation of two strings can be\ndefined as follows:\n1. Basis step: if w \u2208 \u2211*, then w\u22c4\u03bb = w\n2. Recursive step: if w1 \u2208 \u2211*, w2 \u2208 \u2211*, and x \u2208 \u2211, then\nw1\u22c4(w2x) = (w1\u22c4w2)x\n\nExample: Concatenate the strings \"Hello\" and \"World\"\n1. Hello\u22c4World = (Hello\u22c4Worl)d\n2.\n= (Hello\u22c4Wor)ld\n3.\n= (Hello\u22c4Wo)rld\n4.\n= (Hello\u22c4W)orld\n5.\n= (Hello\u22c4\u03bb)World\n6.\n= HelloWorld\n\nThis recursive definition allows us to easily\ndefine important string operations\nDefinition: The length l(w) of a string can be defined\nas follows:\n1. Basis step: l(\u03bb) = 0\n2. Recursive step: l(wx) = l(w) + 1 if w \u2208 \u2211* and x \u2208 \u2211\n\nExample: l(1001) = l(100) + 1\n= l(10) + 1 + 1\n= l(1) + 1 + 1 + 1\n= l(\u03bb) + 1 + 1 + 1 + 1\n=0+1+1+1+1\n=4\n\nWe can define sets of well-formed formulae\nrecursively\nThis is often used to specify the operations permissible in\na given formal language (e.g., a programming language)\n\nExample: Defining propositional logic\n1. Basis step: \u27d9, \u27d8, and s are well-formed propositional logic\nstatements (where s is a propositional variable)\n2. Recursive step: If E and F are well-formed statements, so are\n\u27a3\n\u27a3\n\u27a3\n\u27a3\n\u27a3\n\n(\u00acE)\n(E \u2227 F)\n(E \u2228 F)\n(E \u2192 F)\n(E \u2194 F)\n\nExample\nQuestion: Is ((p \u2227 q) \u2192 (((\u00acr) \u2228 q) \u2227 t)) well-formed?\nl\nl\nl\nl\nl\n\nBasis tells us that p, q, r, t are well-formed\n1st application: (p \u2227 q), (\u00acr) are well-formed\n2nd application: ((\u00acr) \u2228 q) is well-formed\n3rd application: (((\u00acr) \u2228 q) \u2227 t)\n4th application: ((p \u2227 q) \u2192 (((\u00acr) \u2228 q) \u2227 t)) is well-formed\n\n\u2714\n\nIn-class exercises\nProblem 1: Construct a recursive definition of the\nsequence a# where the n$% term is a natural number\ncomputed by adding the n - 1 $% term to the square\nof the n - 3 $% term. Assume that the first three\nterms of this sequence are 1, 1, 1.\nProblem 2: Top Hat\n\nLike other forms of induction, structural induction\nrequires that we consider two cases\nBasis step: Show that the result holds for the objects\nspecified in the basis case of the recursive definition\nRecursive step: Show that if the result holds for the\nobjects used to construct new elements using the\nrecursive step of the definition, then it holds for the\nnew object as well.\nTo see how this works, let's revisit string length...\n\nRecall from earlier...\nDefinition: The length l(w) of a string can be defined\nas follows:\n1. Basis step: l(\u03bb) = 0\n2. Recursive step: l(wx) = l(w) + 1 if w \u2208 \u2211* and x \u2208 \u2211\n\nExample: l(1001) = l(100) + 1\n= l(10) + 1 + 1\n= l(1) + 1 + 1 + 1\n= l(\u03bb) + 1 + 1 + 1 + 1\n=0+1+1+1+1\n=4\n\nProve that l(x\u22c4y) = l(x) + l(y) for x,y \u2208 \u2211*\nP(n) \u2261 l(x\u22c4y) = l(x) + l(y) whenever x \u2208 \u2211* and l(y) = n\nBase case: P(0): l(x\u22c4\u03bb) = l(x) = l(x) + 0 = l(x) + l(\u03bb) \u2714\nI.H.: Assume that P(k) holds for an arbitrary integer k\nInductive step: We will now show that P(k) \u2192 P(k+1)\nn Consider the string x\u22c4ya, where x,y \u2208 \u2211*, a \u2208 \u2211 and l(y) = k\nn l(x\u22c4ya) = l(x\u22c4y) + 1 by the recursive definition of l()\nn\n= l(x) + l(y) + 1 by the I.H.\nn Since l(ya) = l(y) + 1 by the recursive defintion of l(), we have\nthat l(x\u22c4ya) = l(x) + l(ya), where ya is a string of size k+1\nConclusion: Since we have proved the base case and the inductive\ncase, the claim holds by structural induction \u274f\n\nMany common data structures used in computer\nscience have recursive definitions\nExample: Rooted Trees\n\nBase step: A single node is a rooted tree\nRecursive step: If T1, T2, ..., Tn are disjoint rooted trees\nwith roots r1, r2, ..., rn then introducing a new root r\nconnected to r1, r2, ..., rn forms a new rooted tree.\n\nExample Rooted Trees\nBase case:\nOne application:\n\n...\n\nTwo applications:\n\n...\n\n...\n\nMany common data structures used in computer\nscience have recursive definitions\nExample: Extended binary trees\n\nBase step: The empty set is an extended binary tree\nRecursive step: If T1 and T2 are disjoint extended binary\ntrees with roots r1 and r2, then introducing a new root\nr connected to r1 and r2 forms a new extended binary\ntree.\n\nExample Extended Binary Trees\nBase case:\n\n\u2205\n\nStep 1:\n\nStep 2:\n\nStep 3:\n\n...\n\n...\n\nMany common data structures used in computer\nscience have recursive definitions\nExample: Full binary trees\n\nBase step: A single root node r is a full binary tree\nRecursive step: If T1 and T2 are disjoint full binary trees\nwith roots r1 and r2, then introducing a new root r\nconnected to r1 and r2 forms a new full binary tree.\n\nExample Full Binary Trees\nBase case:\nStep 1:\n\nStep 2:\n\n...\n\nTrees are used to parse expressions\n\n456\n\n(((3 + 6) \u00d7 7) - (4 + 2)) \u00d7 8\n\n\u00d7\n57\n63\n\n-\n\n8\n\n\u00d7\n\n6\n\n+\n\n9\n+\n3\n\n7\n6\n\n4\n\n2\n\nTrees are used to enable fast searches\nConsider the set S = {56, 22, 34, 89, 99, 77, 16}\n34 < 56\n\n22\n\n34 > 22\n\n34\n\n16\n\n56\n\n262 > 56\n\n89\n77\n\n262 > 89\n\n99\n\nQuestion: Is 34 \u2208 S?\n\nQuestion: Is 262 \u2208 S?\n\nYES!\n\nNO!\n\nAs with other recursively defined objects, we can\ndefine many properties of trees recursively\nDefinition: Given a tree T, we can define the height of\nT recursively, as follows:\n1. Basis step: If T consists only of the root node r, then h(T) = 0\n2. Recursive step: If T consists of a root r that connects to\nsubtrees T1, ..., Tn, then h(T) = 1 + max(h(T1), ..., h(Tn))\n\nExample: What is the height of this tree T?\nh(T) = 1 + max(h(L), h(R)) = 3\nh(L) = 1 + h(L1) = 2\nh(L1) = 1 + max(h(L11), h(L12)) = 1\nh(L11) = 0\n\nh(R) = 1 + h(R1) = 1\nh(R1) = 0\nh(L12) = 0\n\nIf T is a full binary tree, then the number of nodes in T\n(denoted n(T)) is less than or equal to 2h(T)+1-1\nClaim: n(T) \u2264 2h(T)+1-1\nBase case: T contains only a root node. In this case n(T) = 1 and\nh(T) = 0. Note that 20+1-1 = 1, so the claim holds.\nI.H.: Assume that claim holds for a tree of height k\nInductive step: Show that the claim holds for trees of height k+1\nn Let T1 and T2 be disjoint full binary trees of height k\nn By the I.H., n(T1) \u2264 2h(T1)+1-1 and n(T2) \u2264 2h(T2)+1-1\nn Let r be a unique root element, and let T be the tree formed\nusing r as a root, T1 as the left subtree of r, and T2 as the right\nsubtree of r\n\nr\nT1\n\nT2\n\nIf T is a full binary tree, then the number of nodes in T\n(denoted n(T)) is less than or equal to 2h(T)+1-1\nr\nT1\n\nT2\n\nInductive step (cont.): We have that\nn n(T) = 1 + n(T1) + n(T2)\nn\n\u2264 1 + 2h(T1)+1 - 1 + 2h(T2)+1 - 1\nn\n\u2264 2h(T1)+1 + 2h(T2)+1 - 1\nn\n\u2264 2 \u00d7max(2h(T1)+1, 2h(T2)+1) - 1\nn\n\u2264 2 \u00d72max(h(T1), h(T2))+1 - 1\nn\n\u2264 2 \u00d72h(T) - 1\nn\n\u2264 2h(T)+1 - 1\n\nby recursive formula of n(T)\nby I.H.\nsum of 2 terms \u2264 twice larger term\nmax(2x, 2y) = 2max(x,y)\nby recursive def'n of h(T)\n\nConclusion: Since we have proved the base case and the inductive\ncase, the claim holds by structural induction \u274f\n\nIn-class exercises\nProblem 3: Use structural induction to prove that\nchecking whether some number is contained in a\nbinary search tree T involves at most h(T)+1\ncomparison operations.\n\nFinal Thoughts\nn Structural induction can be used to prove properties\nof recursive\nl Functions\nl Sequences\nl Sets\nl Data structures\n\nn Next time, we start learning about counting and\ncombinatorics (Section 6.1)\n\n", "label": [[109, 118, "Concept"], [577, 586, "Concept"], [1409, 1418, "Concept"], [2241, 2250, "Concept"], [657, 674, "Concept"], [1567, 1587, "Concept"], [2664, 2684, "Concept"], [3111, 3131, "Concept"], [4225, 4245, "Concept"], [4639, 4659, "Concept"], [5529, 5549, "Concept"], [931, 949, "Concept"], [1016, 1026, "Concept"], [1478, 1488, "Concept"], [2528, 2538, "Concept"], [2815, 2825, "Concept"], [3257, 3267, "Concept"], [3650, 3660, "Concept"], [4549, 4559, "Concept"], [4987, 4997, "Concept"], [7548, 7558, "Concept"], [1059, 1073, "Concept"], [1502, 1516, "Concept"], [2550, 2564, "Concept"], [2854, 2868, "Concept"], [3281, 3295, "Concept"], [3762, 3776, "Concept"], [4660, 4674, "Concept"], [4763, 4777, "Concept"], [5011, 5025, "Concept"], [5978, 5992, "Concept"], [6399, 6413, "Concept"], [6817, 6831, "Concept"], [7616, 7630, "Concept"], [245, 263, "Concept"], [1148, 1164, "Concept"], [1970, 1986, "Concept"], [1439, 1457, "Concept"], [1870, 1887, "Concept"], [2315, 2323, "Concept"], [2477, 2485, "Concept"], [2326, 2340, "Concept"], [2464, 2476, "Concept"], [4876, 4889, "Concept"], [3460, 3480, "Concept"], [3627, 3646, "Concept"], [3690, 3709, "Concept"], [3735, 3757, "Concept"], [123, 143, "Concept"], [4492, 4512, "Concept"], [5809, 5829, "Concept"], [9124, 9144, "Concept"], [9182, 9202, "Concept"], [9350, 9370, "Concept"], [5270, 5279, "Concept"], [5756, 5765, "Concept"], [6172, 6181, "Concept"], [6603, 6612, "Concept"], [7009, 7018, "Concept"], [8056, 8065, "Concept"], [9071, 9080, "Concept"], [5328, 5332, "Concept"], [5584, 5588, "Concept"], [8174, 8178, "Concept"], [8360, 8364, "Concept"], [8942, 8946, "Concept"], [5384, 5398, "Concept"], [8227, 8241, "Concept"], [8681, 8695, "Concept"], [5966, 5977, "Concept"], [6137, 6148, "Concept"], [6378, 6398, "Concept"], [6800, 6816, "Concept"], [6964, 6980, "Concept"], [7934, 7950, "Concept"], [8573, 8589, "Concept"], [5956, 5960, "Concept"], [6788, 6792, "Concept"], [7591, 7595, "Concept"], [8090, 8094, "Concept"], [7971, 7976, "Concept"], [8610, 8615, "Concept"], [9264, 9282, "Concept"]]}