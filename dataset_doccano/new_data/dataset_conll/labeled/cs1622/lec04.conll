['train_set', 'labeled']|cs1622|lec04
-DOCSTART- -X- -X- O

CFGs _ _ O
and _ _ O
ASTs _ _ O
CS _ _ O
/ _ _ O
COE _ _ O
1622 _ _ O
Jarrett _ _ O
Billingsley _ _ O


 _ _ O
Class _ _ O
Announcements _ _ O
● _ _ O
did _ _ O
you _ _ O
start _ _ O
the _ _ O
project _ _ O
yet _ _ O
? _ _ O
o _ _ O
a _ _ O
fair _ _ O
number _ _ O
of _ _ O
you _ _ O
have _ _ O
n't _ _ O
accepted _ _ O
the _ _ O
assignment _ _ O
on _ _ O
Github _ _ O
... _ _ O
o _ _ O
do _ _ O
iiiiiiit _ _ O
> _ _ O
: _ _ O
V _ _ O


 _ _ O
2 _ _ O


 _ _ O
Beyond _ _ O
Regular _ _ O
Grammars _ _ O


 _ _ O
3 _ _ O


 _ _ O
Regular _ _ O
? _ _ O
● _ _ O
lexing _ _ B-Concept
grammars _ _ O
describe _ _ O
regular _ _ O
languages _ _ O
. _ _ O
what _ _ O
's _ _ O
that _ _ O
mean _ _ O
? _ _ O
Program _ _ O
: _ _ O
( _ _ O
WS _ _ O
? _ _ O
Token _ _ B-Concept
) _ _ O
* _ _ O
WS _ _ O
? _ _ O
' _ _ O
< _ _ O
eof _ _ O
> _ _ O
' _ _ O
WS _ _ O
: _ _ O
' _ _ O
' _ _ O
| _ _ O
' _ _ O
\t _ _ O
' _ _ O
| _ _ O
' _ _ O
\n _ _ O
' _ _ O
it _ _ O
's _ _ O
a _ _ O
little _ _ O
nonobvious _ _ O
, _ _ O
but _ _ O
if _ _ O
we _ _ O
Token _ _ B-Concept
: _ _ O
' _ _ O
( _ _ O
' _ _ O
| _ _ O
' _ _ O
) _ _ O
' _ _ O
| _ _ O
I _ _ O
d _ _ O
| _ _ O
IntLit _ _ O
start _ _ O
at _ _ O
the _ _ O
start _ _ O
rule _ _ O
, _ _ O
Program _ _ O
, _ _ O
I _ _ O
d _ _ O
: _ _ O
IdStart _ _ O
IdCont _ _ O
* _ _ O
the _ _ O
right-hand _ _ O
sides _ _ O
of _ _ O
every _ _ O
IdStart _ _ O
: _ _ O
< _ _ O
alphabetic _ _ O
> _ _ O
| _ _ O
' _ _ O
_ _ _ O
' _ _ O
rule _ _ O
never _ _ O
take _ _ O
us _ _ O
in _ _ O
a _ _ O
loop _ _ O
to _ _ O
IdCont _ _ O
: _ _ O
IdStart _ _ O
| _ _ O
< _ _ O
digit _ _ O
> _ _ O
the _ _ O
same _ _ O
rule _ _ O
twice _ _ O
. _ _ O
IntLit _ _ O
: _ _ O
< _ _ O
digit _ _ O
> _ _ O
+ _ _ O


 _ _ O
this _ _ O
puts _ _ O
strict _ _ O
limitations _ _ O
on _ _ O
the _ _ O
kinds _ _ O
of _ _ O
strings _ _ O
these _ _ O
grammars _ _ O
can _ _ O
recognize _ _ O
... _ _ O
... _ _ O
but _ _ O
it _ _ O
does _ _ O
make _ _ O
these _ _ O
languages _ _ O
easier _ _ O
to _ _ O
reason _ _ O
about _ _ O
and _ _ O
implement _ _ O
. _ _ O
4 _ _ O


 _ _ O
Another _ _ O
way _ _ O
to _ _ O
look _ _ O
at _ _ O
it _ _ O
● _ _ O
if _ _ O
we _ _ O
look _ _ O
at _ _ O
the _ _ O
dependency _ _ B-Concept
graph _ _ I-Concept
of _ _ O
these _ _ O
rules _ _ O
: _ _ O
Program _ _ O


 _ _ O
Token _ _ B-Concept


 _ _ O
I _ _ O
d _ _ O


 _ _ O
IdStart _ _ O


 _ _ O
Ws _ _ O


 _ _ O
IntLit _ _ O


 _ _ O
IdCont _ _ O


 _ _ O
now _ _ O
it _ _ O
becomes _ _ O
more _ _ O
obvious _ _ O
that _ _ O
there _ _ O
are _ _ O
no _ _ O
cycles _ _ O
in _ _ O
this _ _ O
graph _ _ O
. _ _ O
( _ _ O
this _ _ O
is _ _ O
called _ _ O
a _ _ O
DAG _ _ B-Concept
: _ _ O
a _ _ O
directed _ _ B-Concept
acyclic _ _ I-Concept
graph _ _ I-Concept
. _ _ O
it _ _ O
's _ _ O
like _ _ O
a _ _ O
tree _ _ O
, _ _ O
but _ _ O
nodes _ _ O
can _ _ O
share _ _ O
parents _ _ O
. _ _ O
) _ _ O


 _ _ O
but _ _ O
... _ _ O
what _ _ O
happens _ _ O
if _ _ O
we _ _ O
remove _ _ O
that _ _ O
requirement _ _ O
? _ _ O
5 _ _ O


 _ _ O
A _ _ O
whole _ _ O
new _ _ O
world _ _ O
● _ _ O
let _ _ O
's _ _ O
say _ _ O
our _ _ O
alphabet _ _ B-Concept
is _ _ O
A _ _ O
= _ _ O
{ _ _ O
' _ _ O
( _ _ O
' _ _ O
, _ _ O
' _ _ O
) _ _ O
' _ _ O
, _ _ O
' _ _ O
e _ _ O
' _ _ O
} _ _ O
. _ _ O
● _ _ O
and _ _ O
our _ _ O
grammar _ _ O
rule _ _ O
is _ _ O
Exp _ _ O
: _ _ O
' _ _ O
e _ _ O
' _ _ O
| _ _ O
' _ _ O
( _ _ O
' _ _ O
Exp _ _ O
' _ _ O
) _ _ O
' _ _ O
● _ _ O
valid _ _ O
strings _ _ O
would _ _ O
be _ _ O
e _ _ O
, _ _ O
( _ _ O
e _ _ O
) _ _ O
, _ _ O
( _ _ O
( _ _ O
e _ _ O
) _ _ O
) _ _ O
, _ _ O
etc _ _ O
. _ _ O
for _ _ O
any _ _ O
number _ _ O
of _ _ O
parens _ _ O
. _ _ O
one _ _ O
l _ _ O
o _ _ O
o _ _ O
p _ _ O
y _ _ O
b _ _ O
o _ _ O
i _ _ O
is _ _ O
all _ _ O
it _ _ O
takes _ _ O
to _ _ O
give _ _ O
us _ _ O
this _ _ O
power _ _ O
. _ _ O


 _ _ O
Exp _ _ O


 _ _ O
but _ _ O
power _ _ O
comes _ _ O
at _ _ O
a _ _ O
cost _ _ O
: _ _ O
this _ _ O
kind _ _ O
of _ _ O
language _ _ O
is _ _ O
strictly _ _ O
more _ _ O
complex _ _ O
than _ _ O
regular _ _ O
languages _ _ O
and _ _ O
requires _ _ O
more _ _ O
complex _ _ O
algorithms _ _ O
to _ _ O
implement _ _ O
. _ _ O
once _ _ O
you _ _ O
allow _ _ O
these _ _ O
kinds _ _ O
of _ _ O
recursive _ _ O
rules _ _ O
, _ _ O
you _ _ O
are _ _ O
now _ _ O
in _ _ O
the _ _ O
land _ _ O
of _ _ O
context-free _ _ O
languages _ _ O
! _ _ O
6 _ _ O


 _ _ O
So _ _ O
what _ _ O
can _ _ O
they _ _ O
do _ _ O
? _ _ O
● _ _ O
context-free _ _ O
grammars _ _ O
( _ _ O
CFGs _ _ O
) _ _ O
can _ _ O
represent _ _ O
nesting _ _ B-Concept
of _ _ O
any _ _ O
depth _ _ O
. _ _ O
● _ _ O
this _ _ O
happens _ _ O
to _ _ O
map _ _ O
very _ _ O
nicely _ _ O
onto _ _ O
our _ _ O
intuition _ _ O
( _ _ O
instinct _ _ O
? _ _ O
) _ _ O
about _ _ O
how _ _ O
language _ _ O
works _ _ O
in _ _ O
general _ _ O
. _ _ O
in _ _ O
human _ _ O
languages _ _ O
, _ _ O
we _ _ O
can _ _ O
nest _ _ O
phrases _ _ O
inside _ _ O
other _ _ O
ones _ _ O
. _ _ O


 _ _ O
the _ _ O
cat _ _ O
( _ _ O
on _ _ O
the _ _ O
bed _ _ O
( _ _ O
in _ _ O
that _ _ O
room _ _ O
) _ _ O
) _ _ O
with _ _ O
CFGs _ _ O
, _ _ O
we _ _ O
can _ _ O
nest _ _ O
expressions _ _ O
... _ _ O
f _ _ O
( _ _ O
x _ _ O
* _ _ O
( _ _ O
y _ _ O
+ _ _ O
3 _ _ O
) _ _ O
) _ _ O


 _ _ O
and _ _ O
statements _ _ O
! _ _ O


 _ _ O
if _ _ O
x _ _ O
= _ _ O
= _ _ O
10 _ _ O
{ _ _ O
if _ _ O
y _ _ O
= _ _ O
= _ _ O
20 _ _ O
{ _ _ O
f _ _ O
( _ _ O
) _ _ O
; _ _ O
} _ _ O
} _ _ O
7 _ _ O


 _ _ O
But _ _ O
what _ _ O
ca _ _ O
n't _ _ O
they _ _ O
do _ _ O
? _ _ O
● _ _ O
there _ _ O
are _ _ O
a _ _ O
lot _ _ O
of _ _ O
kinds _ _ O
of _ _ O
languages _ _ O
they _ _ O
ca _ _ O
n't _ _ O
represent _ _ O
. _ _ O
● _ _ O
but _ _ O
for _ _ O
most _ _ O
computer _ _ O
languages _ _ O
, _ _ O
this _ _ O
is _ _ O
n't _ _ O
really _ _ O
a _ _ O
problem _ _ O
. _ _ O
● _ _ O
unlike _ _ O
natural _ _ O
human _ _ O
languages _ _ O
, _ _ O
computer _ _ O
languages _ _ O
... _ _ O
o _ _ O
are _ _ O
designed _ _ O
up _ _ O
front _ _ O
, _ _ O
rather _ _ O
than _ _ O
emerging _ _ O
naturally _ _ O
o _ _ O
are _ _ O
meant _ _ O
to _ _ O
be _ _ O
unambiguous _ _ O
o _ _ O
are _ _ O
meant _ _ O
to _ _ O
be _ _ O
easy _ _ O
to _ _ O
read _ _ O
and _ _ O
maintain _ _ O
● _ _ O
so _ _ O
something _ _ O
simpler _ _ O
than _ _ O
human _ _ O
languages _ _ O
is _ _ O
a _ _ O
good _ _ O
thing _ _ O
. _ _ O
● _ _ O
THERE _ _ O
'S _ _ O
STILL _ _ O
THIS _ _ O
THING _ _ O
THOUGH _ _ O


 _ _ O
int _ _ O
y _ _ O
= _ _ O
x _ _ O
> _ _ O
> _ _ O
3 _ _ O
; _ _ O
List _ _ O
< _ _ O
List _ _ O
< _ _ O
String _ _ O
> _ _ O
> _ _ O
l _ _ O
; _ _ O


 _ _ O
to _ _ O
properly _ _ O
parse _ _ O
this _ _ O
requires _ _ O
a _ _ O
context-sensitive _ _ B-Concept
grammar _ _ I-Concept
( _ _ O
CSG _ _ B-Concept
) _ _ O
... _ _ O
but _ _ O
the _ _ O
ambiguity _ _ O
here _ _ O
is _ _ O
simple _ _ O
enough _ _ O
that _ _ O
we _ _ O
can _ _ O
fake _ _ O
it _ _ O
using _ _ O
a _ _ O
CFG _ _ B-Concept
and _ _ O
some _ _ B-Concept
parsing _ _ B-Concept
kludges _ _ O
. _ _ O
8 _ _ O


 _ _ O
ASTs _ _ O


 _ _ O
9 _ _ O


 _ _ O
From _ _ O
lexical _ _ O
to _ _ O
syntactic _ _ O
● _ _ O
the _ _ O
lexer _ _ B-Concept
was _ _ O
responsible _ _ O
for _ _ O
splitting _ _ O
the _ _ O
source _ _ O
into _ _ O
" _ _ O
words _ _ O
. _ _ O
" _ _ O
● _ _ O
the _ _ O
parser _ _ B-Concept
looks _ _ O
at _ _ O
those _ _ O
words _ _ O
and _ _ O
extracts _ _ O
the _ _ O
syntactic _ _ O
structure _ _ O
from _ _ O
them _ _ O
, _ _ O
building _ _ O
a _ _ O
tree _ _ O
representation _ _ O
of _ _ O
your _ _ O
program _ _ O
. _ _ O
source _ _ O
code _ _ O


 _ _ O
Lexer _ _ B-Concept


 _ _ O
tokens _ _ O


 _ _ O
Parser _ _ B-Concept


 _ _ O
tree _ _ O


 _ _ O
the _ _ O
parser _ _ B-Concept
typically _ _ O
implements _ _ O
a _ _ O
CFG _ _ B-Concept
whose _ _ O
alphabet _ _ B-Concept
( _ _ O
the _ _ O
set _ _ O
of _ _ O
terminals _ _ O
) _ _ O
is _ _ O
the _ _ O
tokens _ _ O
that _ _ O
were _ _ O
produced _ _ O
by _ _ O
the _ _ O
parser _ _ B-Concept
. _ _ O
in _ _ O
doing _ _ O
so _ _ O
it _ _ O
checks _ _ O
your _ _ O
syntax _ _ B-Concept
- _ _ O
to _ _ O
make _ _ O
sure _ _ O
you _ _ O
wrote _ _ O
something _ _ O
that _ _ O
, _ _ O
well _ _ O
, _ _ O
looks _ _ O
like _ _ O
a _ _ O
program _ _ O
. _ _ O
10 _ _ O


 _ _ O
A _ _ O
tree _ _ O
of _ _ O
the _ _ O
syntax _ _ B-Concept
, _ _ O
which _ _ O
is _ _ O
abstract _ _ O
● _ _ O
the _ _ O
abstract _ _ B-Concept
syntax _ _ I-Concept
tree _ _ I-Concept
( _ _ O
AST _ _ O
) _ _ O
is _ _ O
the _ _ O
structure _ _ O
the _ _ O
parser _ _ O
builds _ _ O
. _ _ O
● _ _ O
trees _ _ O
are _ _ O
much _ _ O
easier _ _ O
to _ _ O
work _ _ O
with _ _ O
than _ _ O
lists _ _ O
of _ _ O
characters _ _ O
or _ _ O
tokens _ _ O
. _ _ O


 _ _ O
if _ _ O
( _ _ O
x _ _ O
) _ _ O
y _ _ O
( _ _ O
2 _ _ O
) _ _ O
; _ _ O
else _ _ O
return _ _ O
; _ _ O


 _ _ O
IfElseStmt _ _ O
cond _ _ O


 _ _ O
IdentExp _ _ O
name _ _ O


 _ _ O
T _ _ O


 _ _ O
F _ _ O


 _ _ O
CallExp _ _ O


 _ _ O
" _ _ O
x _ _ O
" _ _ O


 _ _ O
callee _ _ O


 _ _ O
ReturnStmt _ _ O


 _ _ O
args _ _ O
[ _ _ O
] _ _ O


 _ _ O
value _ _ O


 _ _ O
ø _ _ O
IdentExp _ _ O
name _ _ O


 _ _ O
" _ _ O
y _ _ O
" _ _ O


 _ _ O
IntExp _ _ O
value _ _ O


 _ _ O
2 _ _ O
11 _ _ O


 _ _ O
Why _ _ O
is _ _ O
it _ _ O
called _ _ O
" _ _ O
abstract _ _ O
" _ _ O
? _ _ O
● _ _ O
because _ _ O
we _ _ O
can _ _ O
change _ _ O
the _ _ O
syntax _ _ O
of _ _ O
our _ _ O
language _ _ O
but _ _ O
the _ _ O
AST _ _ O
representation _ _ O
does _ _ O
n't _ _ O
have _ _ O
to _ _ O
change _ _ O
. _ _ O
it _ _ O
decouples _ _ O
them _ _ O
. _ _ O
Java _ _ O
/ _ _ O
C _ _ O
if _ _ O
( _ _ O
x _ _ O
) _ _ O
y _ _ O
( _ _ O
2 _ _ O
) _ _ O
; _ _ O
else _ _ O
return _ _ O
; _ _ O


 _ _ O
IfElse _ _ O


 _ _ O
Rust _ _ O
if _ _ O
x _ _ O
{ _ _ O
y _ _ O
( _ _ O
2 _ _ O
) _ _ O
; _ _ O
} _ _ O
else _ _ O
{ _ _ O
return _ _ O
} _ _ O


 _ _ O
Lua _ _ O
if _ _ O
x _ _ O
then _ _ O
y _ _ O
( _ _ O
2 _ _ O
) _ _ O
else _ _ O
return _ _ O
end _ _ O
Ruby _ _ O
if _ _ O
x _ _ O
Python _ _ O
if _ _ O
x _ _ O
: _ _ O
y _ _ O
2 _ _ O
y _ _ O
( _ _ O
2 _ _ O
) _ _ O
else _ _ O
else _ _ O
: _ _ O
return _ _ O
return _ _ O
endif _ _ O


 _ _ O
Ident _ _ O


 _ _ O
Call _ _ O


 _ _ O
Ident _ _ O


 _ _ O
Return _ _ O
Int _ _ O


 _ _ O
of _ _ O
course _ _ O
, _ _ O
these _ _ O
languages _ _ O
work _ _ O
differently _ _ O
, _ _ O
but _ _ O
the _ _ O
point _ _ O
is _ _ O
that _ _ O
the _ _ O
syntax _ _ O
is _ _ O
just _ _ O
fluff _ _ O
. _ _ O
12 _ _ O


 _ _ O
Values _ _ O
, _ _ O
expressions _ _ O
, _ _ O
and _ _ O
statements _ _ O
● _ _ O
computation _ _ O
is _ _ O
the _ _ O
act _ _ O
of _ _ O
transforming _ _ O
values _ _ O
into _ _ O
different _ _ O
values _ _ O
. _ _ O
o _ _ O
values _ _ O
are _ _ O
just _ _ O
things _ _ O
like _ _ O
ints _ _ O
, _ _ O
strings _ _ O
, _ _ O
objects _ _ O
, _ _ O
etc _ _ O
. _ _ O
when _ _ O
you _ _ O
execute _ _ O
an _ _ O
expression _ _ O
, _ _ O
you _ _ O
get _ _ O
a _ _ O
value _ _ O
. _ _ O
2.8 _ _ O


 _ _ O
x _ _ O
+ _ _ O
y _ _ O


 _ _ O
sin _ _ O
( _ _ O
2 _ _ O
* _ _ O
ang _ _ O
) _ _ O
arr _ _ O
[ _ _ O
i _ _ O
] _ _ O
+ _ _ O
" _ _ O
; _ _ O
" _ _ O


 _ _ O
obj.field _ _ O


 _ _ O
when _ _ O
you _ _ O
execute _ _ O
a _ _ O
statement _ _ O
, _ _ O
you _ _ O
... _ _ O
do _ _ O
n't _ _ O
. _ _ O


 _ _ O
return _ _ O
; _ _ O


 _ _ O
if _ _ O
( _ _ O
... _ _ O
) _ _ O
... _ _ O
else _ _ O
... _ _ O


 _ _ O
printf _ _ O
( _ _ O
"hi _ _ O
! _ _ O
\n _ _ O
" _ _ O
) _ _ O
; _ _ O
{ _ _ O
... _ _ O
statements _ _ O
... _ _ O
} _ _ O


 _ _ O
but _ _ O
there _ _ O
are _ _ O
many _ _ O
exceptions _ _ O
, _ _ O
and _ _ O
not _ _ O
every _ _ O
language _ _ O
makes _ _ O
this _ _ O
distinction _ _ O
. _ _ O
it _ _ O
's _ _ O
good _ _ O
to _ _ O
know _ _ O
the _ _ O
terms _ _ O
though _ _ O
, _ _ O
cause _ _ O
they _ _ O
come _ _ O
up _ _ O
a _ _ O
lot _ _ O
in _ _ O
parsing _ _ O
and _ _ O
semantics _ _ O
. _ _ O


 _ _ O
13 _ _ O


 _ _ O
What _ _ O
about _ _ O
Rust _ _ O
? _ _ O
● _ _ O
actually _ _ O
, _ _ O
Rust _ _ O
only _ _ O
has _ _ O
expressions _ _ O
. _ _ O
everything _ _ O
can _ _ O
give _ _ O
a _ _ O
value _ _ O
. _ _ O
let _ _ O
x _ _ O
= _ _ O
if _ _ O
y _ _ O
{ _ _ O
10 _ _ O
} _ _ O
else _ _ O
{ _ _ O
20 _ _ O
} _ _ O
; _ _ O
fn _ _ O
radix _ _ O
( _ _ O
c _ _ O
: _ _ O
char _ _ O
) _ _ O
- _ _ O
> _ _ O
Base _ _ O
{ _ _ O
println _ _ O
! _ _ O
( _ _ O
"in _ _ O
radix _ _ O
" _ _ O
) _ _ O
; _ _ O
match _ _ O
c _ _ O
{ _ _ O
this _ _ O
demonstrates _ _ O
a _ _ O
sort _ _ O
of _ _ O
' _ _ O
x _ _ O
' _ _ O
| _ _ O
' _ _ O
X _ _ O
' _ _ O
= _ _ O
> _ _ O
Base _ _ O
: _ _ O
: _ _ O
Hex _ _ O
, _ _ O
confusing _ _ O
rule _ _ O
: _ _ O
you _ _ O
can _ _ O
omit _ _ O
' _ _ O
b _ _ O
' _ _ O
| _ _ O
' _ _ O
B _ _ O
' _ _ O
= _ _ O
> _ _ O
Base _ _ O
: _ _ O
: _ _ O
Bin _ _ O
, _ _ O
return _ _ O
if _ _ O
you _ _ O
're _ _ O
in _ _ O
the _ _ O
last _ _ O
_ _ _ O
= _ _ O
> _ _ O
Base _ _ O
: _ _ O
: _ _ O
Dec _ _ O
, _ _ O
expression _ _ O
in _ _ O
the _ _ O
function _ _ O
. _ _ O
} _ _ O
} _ _ O
this _ _ O
match _ _ O
is _ _ O
the _ _ O
last _ _ O
expression _ _ O
, _ _ O
so _ _ O
whatever _ _ O
value _ _ O
it _ _ O
gives _ _ O
becomes _ _ O
the _ _ O
return _ _ O
value _ _ O
! _ _ O
but _ _ O
this _ _ O
is _ _ O
confusing _ _ O
, _ _ O
so _ _ O
I _ _ O
wo _ _ O
n't _ _ O
use _ _ O
it _ _ O
this _ _ O
term _ _ O
. _ _ O
:) _ _ O
14 _ _ O


 _ _ O
Trees _ _ O
in _ _ O
Rust _ _ O


 _ _ O
15 _ _ O


 _ _ O
In _ _ O
Java _ _ O
... _ _ O
● _ _ O
you _ _ O
may _ _ O
have _ _ O
learned _ _ O
about _ _ O
trees _ _ O
( _ _ O
or _ _ O
their _ _ O
one-dimensional _ _ O
cousins _ _ O
, _ _ O
linked _ _ O
lists _ _ O
) _ _ O
and _ _ O
seen _ _ O
them _ _ O
written _ _ O
like _ _ O
this _ _ O
: _ _ O
class _ _ O
Node _ _ O
< _ _ O
T _ _ O
> _ _ O
{ _ _ O
Node _ _ O
< _ _ O
T _ _ O
> _ _ O
left _ _ O
, _ _ O
right _ _ O
; _ _ O
T _ _ O
value _ _ O
; _ _ O
Node _ _ O
( _ _ O
T _ _ O
t _ _ O
) _ _ O
{ _ _ O
value _ _ O
= _ _ O
t _ _ O
; _ _ O
} _ _ O
} _ _ O


 _ _ O
Node _ _ O
< _ _ O
Integer _ _ O
> _ _ O
a _ _ O
= _ _ O
new _ _ O
Node _ _ O
< _ _ O
> _ _ O
( _ _ O
5 _ _ O
) _ _ O
; _ _ O
a.left _ _ O
= _ _ O
new _ _ O
Node _ _ O
< _ _ O
> _ _ O
( _ _ O
2 _ _ O
) _ _ O
; _ _ O
a.right _ _ O
= _ _ O
new _ _ O
Node _ _ O
< _ _ O
> _ _ O
( _ _ O
7 _ _ O
) _ _ O
; _ _ O


 _ _ O
left _ _ O
and _ _ O
right _ _ O
have _ _ O
two _ _ O
special _ _ O
properties _ _ O
that _ _ O
make _ _ O
this _ _ O
representation _ _ O
work _ _ O
: _ _ O
1 _ _ O
. _ _ O
they _ _ O
are _ _ O
references _ _ O
: _ _ O
they _ _ O
refer _ _ O
indirectly _ _ O
to _ _ O
Node _ _ O
objects _ _ O
. _ _ O
2 _ _ O
. _ _ O
they _ _ O
can _ _ O
optionally _ _ O
hold _ _ O
null _ _ O
to _ _ O
indicate _ _ O
that _ _ O
they _ _ O
are _ _ O
not _ _ O
pointing _ _ O
to _ _ O
anything _ _ O
. _ _ O


 _ _ O
5 _ _ O
2 _ _ O


 _ _ O
7 _ _ O


 _ _ O
16 _ _ O


 _ _ O
Doing _ _ O
it _ _ O
in _ _ O
Rust _ _ O
? _ _ O
● _ _ O
if _ _ O
we _ _ O
try _ _ O
to _ _ O
do _ _ O
this _ _ O
, _ _ O
we _ _ O
get _ _ O
an _ _ O
error _ _ O
: _ _ O
struct _ _ O
Node _ _ O
< _ _ O
T _ _ O
> _ _ O
{ _ _ O
left _ _ O
: _ _ O
Node _ _ O
< _ _ O
T _ _ O
> _ _ O
, _ _ O
right _ _ O
: _ _ O
Node _ _ O
< _ _ O
T _ _ O
> _ _ O
, _ _ O
value _ _ O
: _ _ O
T _ _ O
, _ _ O
} _ _ O


 _ _ O
it _ _ O
says _ _ O
this _ _ O
type _ _ O
has _ _ O
infinite _ _ O
size _ _ O
, _ _ O
but _ _ O
it _ _ O
gives _ _ O
us _ _ O
a _ _ O
hint _ _ O
: _ _ O
struct _ _ O
Node _ _ O
< _ _ O
T _ _ O
> _ _ O
{ _ _ O
left _ _ O
: _ _ O
Box _ _ O
< _ _ O
Node _ _ O
< _ _ O
T _ _ O
> _ _ O
> _ _ O
, _ _ O
right _ _ O
: _ _ O
Box _ _ O
< _ _ O
Node _ _ O
< _ _ O
T _ _ O
> _ _ O
> _ _ O
, _ _ O
value _ _ O
: _ _ O
T _ _ O
, _ _ O
} _ _ O


 _ _ O
great _ _ O
, _ _ O
it _ _ O
compiles _ _ O
! _ _ O
what _ _ O
the _ _ O
heck _ _ O
does _ _ O
it _ _ O
mean _ _ O
tho _ _ O
17 _ _ O


 _ _ O
I _ _ O
would _ _ O
not _ _ O
eat _ _ O
them _ _ O
with _ _ O
a _ _ O
fox _ _ O
● _ _ O
a _ _ O
Box _ _ O
is _ _ O
the _ _ O
simplest _ _ O
kind _ _ O
of _ _ O
reference _ _ O
in _ _ O
Rust _ _ O
: _ _ O
it _ _ O
allocates _ _ O
an _ _ O
object _ _ O
on _ _ O
the _ _ O
heap _ _ O
( _ _ O
just _ _ O
like _ _ O
Java _ _ O
's _ _ O
new _ _ O
) _ _ O
and _ _ O
points _ _ O
to _ _ O
it _ _ O
indirectly _ _ O
. _ _ O
● _ _ O
you _ _ O
create _ _ O
a _ _ O
boxed _ _ O
object _ _ O
with _ _ O
Box _ _ O
: _ _ O
: _ _ O
new _ _ O
( _ _ O
) _ _ O
: _ _ O
let _ _ O
x _ _ O
= _ _ O
10 _ _ O
; _ _ O
/ _ _ O
/ _ _ O
an _ _ O
int _ _ O
on _ _ O
the _ _ O
stack _ _ O
let _ _ O
b _ _ O
= _ _ O
Box _ _ O
: _ _ O
: _ _ O
new _ _ O
( _ _ O
20 _ _ O
) _ _ O
; _ _ O
/ _ _ O
/ _ _ O
an _ _ O
int _ _ O
on _ _ O
the _ _ O
heap _ _ O
Call _ _ O
Stack _ _ O


 _ _ O
Heap _ _ O


 _ _ O
x _ _ O


 _ _ O
the _ _ O
Box _ _ O


 _ _ O
b _ _ O


 _ _ O
10 _ _ O


 _ _ O
20 _ _ O


 _ _ O
I _ _ O
mean _ _ O
, _ _ O
normally _ _ O
you _ _ O
would _ _ O
n't _ _ O
box _ _ O
an _ _ O
int _ _ O
, _ _ O
but _ _ O
it _ _ O
's _ _ O
just _ _ O
for _ _ O
the _ _ O
example _ _ O
. _ _ O


 _ _ O
okay _ _ O
, _ _ O
let _ _ O
's _ _ O
make _ _ O
a _ _ O
Node _ _ O
< _ _ O
T _ _ O
> _ _ O
then _ _ O
! _ _ O


 _ _ O
18 _ _ O


 _ _ O
Curses _ _ O
! _ _ O
Foiled _ _ O
again _ _ O
! _ _ O
● _ _ O
when _ _ O
you _ _ O
make _ _ O
a _ _ O
struct _ _ O
, _ _ O
you _ _ O
have _ _ O
to _ _ O
give _ _ O
values _ _ O
for _ _ O
all _ _ O
the _ _ O
fields _ _ O
. _ _ O
struct _ _ O
Node _ _ O
< _ _ O
T _ _ O
> _ _ O
{ _ _ O
left _ _ O
: _ _ O
Box _ _ O
< _ _ O
Node _ _ O
< _ _ O
T _ _ O
> _ _ O
> _ _ O
, _ _ O
right _ _ O
: _ _ O
Box _ _ O
< _ _ O
Node _ _ O
< _ _ O
T _ _ O
> _ _ O
> _ _ O
, _ _ O
value _ _ O
: _ _ O
T _ _ O
, _ _ O
} _ _ O


 _ _ O
let _ _ O
a _ _ O
= _ _ O
Node _ _ O
{ _ _ O
value _ _ O
: _ _ O
5 _ _ O
, _ _ O
left _ _ O
: _ _ O
Box _ _ O
: _ _ O
: _ _ O
new _ _ O
( _ _ O
Node _ _ O
{ _ _ O
value _ _ O
: _ _ O
2 _ _ O
, _ _ O
left _ _ O
: _ _ O
......... _ _ O
uhhhhhhhh _ _ O


 _ _ O
5 _ _ O
2 _ _ O


 _ _ O
7 _ _ O


 _ _ O
what _ _ O
do _ _ O
we _ _ O
write _ _ O
for _ _ O
left _ _ O
, _ _ O
here _ _ O
? _ _ O
2 _ _ O
has _ _ O
no _ _ O
left _ _ O
child _ _ O
. _ _ O
what _ _ O
we _ _ O
've _ _ O
made _ _ O
here _ _ O
is _ _ O
a _ _ O
type _ _ O
that _ _ O
is _ _ O
impossible _ _ O
to _ _ O
construct _ _ O
! _ _ O


 _ _ O
so _ _ O
we _ _ O
need _ _ O
something _ _ O
to _ _ O
satisfy _ _ O
the _ _ O
other _ _ O
important _ _ O
property _ _ O
of _ _ O
the _ _ O
Java _ _ O
Node _ _ O
< _ _ O
T _ _ O
> _ _ O
variables _ _ O
: _ _ O
the _ _ O
possibility _ _ O
of _ _ O
being _ _ O
null _ _ O
. _ _ O
the _ _ O
solution _ _ O
is _ _ O
to _ _ O
use _ _ O
Option _ _ O
< _ _ O
Box _ _ O
< _ _ O
Node _ _ O
< _ _ O
T _ _ O
> _ _ O
> _ _ O
> _ _ O
. _ _ O
19 _ _ O


 _ _ O
Option _ _ O
< _ _ O
Box _ _ O
< _ _ O
Node _ _ O
< _ _ O
T _ _ O
> _ _ O
> _ _ O
> _ _ O
? _ _ O
That _ _ O
's _ _ O
... _ _ O
verbose _ _ O
● _ _ O
a _ _ O
little _ _ O
, _ _ O
yeah _ _ O
. _ _ O
but _ _ O
this _ _ O
comes _ _ O
up _ _ O
less _ _ O
often _ _ O
than _ _ O
you _ _ O
'd _ _ O
think _ _ O
. _ _ O
● _ _ O
add _ _ O
a _ _ O
constructor _ _ O
and _ _ O
it _ _ O
becomes _ _ O
easy _ _ O
to _ _ O
use _ _ O
: _ _ O
struct _ _ O
Node _ _ O
< _ _ O
T _ _ O
> _ _ O
{ _ _ O
left _ _ O
: _ _ O
Option _ _ O
< _ _ O
Box _ _ O
< _ _ O
Node _ _ O
< _ _ O
T _ _ O
> _ _ O
> _ _ O
> _ _ O
, _ _ O
right _ _ O
: _ _ O
Option _ _ O
< _ _ O
Box _ _ O
< _ _ O
Node _ _ O
< _ _ O
T _ _ O
> _ _ O
> _ _ O
> _ _ O
, _ _ O
value _ _ O
: _ _ O
T _ _ O
, _ _ O
} _ _ O


 _ _ O
let _ _ O
mut _ _ O
a _ _ O
= _ _ O
Node _ _ O
: _ _ O
: _ _ O
new _ _ O
( _ _ O
5 _ _ O
) _ _ O
; _ _ O
a.left _ _ O
= _ _ O
Some _ _ O
( _ _ O
Node _ _ O
: _ _ O
: _ _ O
new _ _ O
( _ _ O
2 _ _ O
) _ _ O
) _ _ O
; _ _ O
a.right _ _ O
= _ _ O
Some _ _ O
( _ _ O
Node _ _ O
: _ _ O
: _ _ O
new _ _ O
( _ _ O
7 _ _ O
) _ _ O
) _ _ O
; _ _ O


 _ _ O
and _ _ O
now _ _ O
we _ _ O
have _ _ O
something _ _ O
very _ _ O
similar _ _ O
to _ _ O
the _ _ O
original _ _ O
Java _ _ O
, _ _ O
except _ _ O
we _ _ O
have _ _ O
to _ _ O
use _ _ O
Some _ _ O
( _ _ O
.. _ _ O
) _ _ O
to _ _ O
indicate _ _ O
the _ _ O
opposite _ _ O
of _ _ O
None _ _ O
( _ _ O
aka _ _ O
null _ _ O
) _ _ O
. _ _ O


 _ _ O
5 _ _ O
2 _ _ O


 _ _ O
7 _ _ O


 _ _ O
this _ _ O
code _ _ O
is _ _ O
in _ _ O
the _ _ O
rust_trees _ _ O
example _ _ O
. _ _ O
20 _ _ O


 _ _ O
A _ _ O
brief _ _ O
digression _ _ O
on _ _ O
Option _ _ O
● _ _ O
let _ _ O
's _ _ O
look _ _ O
at _ _ O
another _ _ O
example _ _ O
, _ _ O
rust_option _ _ O
! _ _ O
● _ _ O
Option _ _ O
gives _ _ O
you _ _ O
something _ _ O
like _ _ O
Java _ _ O
's _ _ O
null _ _ O
, _ _ O
but _ _ O
it _ _ O
's _ _ O
opt-in _ _ O
, _ _ O
and _ _ O
works _ _ O
on _ _ O
any _ _ O
type _ _ O
, _ _ O
not _ _ O
just _ _ O
object _ _ O
references _ _ O
. _ _ O
● _ _ O
there _ _ O
are _ _ O
a _ _ O
few _ _ O
ways _ _ O
of _ _ O
" _ _ O
getting _ _ O
the _ _ O
value _ _ O
out _ _ O
of _ _ O
" _ _ O
an _ _ O
Option _ _ O
, _ _ O
but _ _ O
... _ _ O
o _ _ O
.unwrap _ _ O
( _ _ O
) _ _ O
is _ _ O
the _ _ O
most _ _ O
risky _ _ O
, _ _ O
cause _ _ O
it _ _ O
could _ _ O
crash _ _ O
your _ _ O
program _ _ O
! _ _ O


 _ _ O
21 _ _ O


 _ _ O
Defining _ _ O
and _ _ O
using _ _ O
an _ _ O
AST _ _ O


 _ _ O
22 _ _ O


 _ _ O
Before _ _ O
we _ _ O
get _ _ O
to _ _ O
a _ _ O
real _ _ O
language _ _ O
... _ _ O
● _ _ O
let _ _ O
's _ _ O
start _ _ O
with _ _ O
something _ _ O
simple _ _ O
. _ _ O
● _ _ O
maybe _ _ O
we _ _ O
're _ _ O
writing _ _ O
some _ _ O
calculator _ _ O
software _ _ O
and _ _ O
want _ _ O
to _ _ O
represent _ _ O
what _ _ O
the _ _ O
user _ _ O
types _ _ O
in _ _ O
symbolically _ _ O
, _ _ O
instead _ _ O
of _ _ O
just _ _ O
evaluating _ _ O
it _ _ O
. _ _ O
× _ _ O


 _ _ O
how _ _ O
we _ _ O
get _ _ O
from _ _ O
what _ _ O
was _ _ O
typed _ _ O
in _ _ O
at _ _ O
the _ _ O
bottom _ _ O
to _ _ O
the _ _ O
tree _ _ O
up _ _ O
top _ _ O
is _ _ O
a _ _ O
topic _ _ O
for _ _ O
an _ _ O
upcoming _ _ O
lecture _ _ O
, _ _ O
but _ _ O
... _ _ O


 _ _ O
÷ _ _ O


 _ _ O
+ _ _ O
2 _ _ O


 _ _ O
3 _ _ O


 _ _ O
5 _ _ O


 _ _ O
-40 _ _ O


 _ _ O
if _ _ O
the _ _ O
expression _ _ O
is _ _ O
a _ _ O
tree _ _ O
, _ _ O
we _ _ O
can _ _ O
have _ _ O
fun _ _ O
with _ _ O
it _ _ O
! _ _ O


 _ _ O
( _ _ O
2 _ _ O
/ _ _ O
- _ _ O
( _ _ O
3 _ _ O
+ _ _ O
5 _ _ O
) _ _ O
) _ _ O
* _ _ O
-40 _ _ O
23 _ _ O


 _ _ O
Representing _ _ O
this _ _ O
tree _ _ O
● _ _ O
we _ _ O
've _ _ O
got _ _ O
a _ _ O
few _ _ O
kinds _ _ O
of _ _ O
AST _ _ O
node _ _ O
here _ _ O
: _ _ O
o _ _ O
constants _ _ O
( _ _ O
2 _ _ O
, _ _ O
3 _ _ O
, _ _ O
5 _ _ O
, _ _ O
-40 _ _ O
) _ _ O
o _ _ O
negation _ _ O
( _ _ O
-x _ _ O
) _ _ O
o _ _ O
addition _ _ O
, _ _ O
subtraction _ _ O
, _ _ O
multiplication _ _ O
, _ _ O
division _ _ O
▪ _ _ O
we _ _ O
can _ _ O
group _ _ O
these _ _ O
under _ _ O
a _ _ O
single _ _ O
kind _ _ O
: _ _ O
binary _ _ O
operators _ _ O
▪ _ _ O
not _ _ O
binary _ _ O
as _ _ O
in _ _ O
the _ _ O
base _ _ O
, _ _ O
binary _ _ O
as _ _ O
in _ _ O
" _ _ O
has _ _ O
two _ _ O
operands _ _ O
" _ _ O


 _ _ O
● _ _ O
when _ _ O
you _ _ O
have _ _ O
choices _ _ O
of _ _ O
a _ _ O
type _ _ O
, _ _ O
the _ _ O
thing _ _ O
to _ _ O
use _ _ O
is _ _ O
an _ _ O
enum _ _ O
. _ _ O
● _ _ O
this _ _ O
enum _ _ O
appears _ _ O
in _ _ O
the _ _ O
ast_math _ _ O
example _ _ O
: _ _ O
enum _ _ O
AstNode _ _ O
{ _ _ O
Const _ _ O
{ _ _ O
val _ _ O
: _ _ O
f64 _ _ O
} _ _ O
, _ _ O
Negate _ _ O
{ _ _ O
lhs _ _ O
: _ _ O
Box _ _ O
< _ _ O
AstNode _ _ O
> _ _ O
} _ _ O
, _ _ O
Binary _ _ O
{ _ _ O
op _ _ O
: _ _ O
BinOp _ _ O
, _ _ O
lhs _ _ O
: _ _ O
Box _ _ O
< _ _ O
AstNode _ _ O
> _ _ O
, _ _ O
rhs _ _ O
: _ _ O
Box _ _ O
< _ _ O
AstNode _ _ O
> _ _ O
} _ _ O
, _ _ O
} _ _ O


 _ _ O
look _ _ O
, _ _ O
no _ _ O
Options _ _ O
! _ _ O
24 _ _ O


 _ _ O
Recursion _ _ O
Refresher _ _ O
● _ _ O
recursion _ _ O
is _ _ O
a _ _ O
programming _ _ O
technique _ _ O
where _ _ O
a _ _ O
function _ _ O
calls _ _ O
itself _ _ O
. _ _ O
● _ _ O
there _ _ O
is _ _ O
an _ _ O
important _ _ O
fact _ _ O
about _ _ O
recursion _ _ O
that _ _ O
a _ _ O
lot _ _ O
of _ _ O
people _ _ O
are _ _ O
hazy _ _ O
on _ _ O
, _ _ O
even _ _ O
as _ _ O
juniors _ _ O
and _ _ O
seniors _ _ O
: _ _ O


 _ _ O
local _ _ O
variables _ _ O
are _ _ O
duplicated _ _ O
for _ _ O
each _ _ O
recursive _ _ O
call _ _ O
. _ _ O
fn _ _ O
sum _ _ O
( _ _ O
x _ _ O
: _ _ O
i32 _ _ O
) _ _ O
- _ _ O
> _ _ O
i32 _ _ O
{ _ _ O
if _ _ O
x _ _ O
< _ _ O
= _ _ O
1 _ _ O
{ _ _ O
return _ _ O
x _ _ O
; _ _ O
} _ _ O
else _ _ O
{ _ _ O
return _ _ O
x _ _ O
+ _ _ O
sum _ _ O
( _ _ O
x _ _ O
- _ _ O
1 _ _ O
) _ _ O
; _ _ O
} _ _ O
} _ _ O
if _ _ O
I _ _ O
call _ _ O
sum _ _ O
( _ _ O
5 _ _ O
) _ _ O
, _ _ O
every _ _ O
recursion _ _ O
gets _ _ O
its _ _ O


 _ _ O
own _ _ O
copy _ _ O
of _ _ O
x _ _ O
, _ _ O
and _ _ O
the _ _ O
in-progress _ _ O
recursions _ _ O
do _ _ O
not _ _ O
" _ _ O
share _ _ O
" _ _ O
that _ _ O
variable _ _ O
. _ _ O


 _ _ O
Stack _ _ O
sum _ _ O
( _ _ O
5 _ _ O
) _ _ O
x _ _ O
= _ _ O
5 _ _ O
sum _ _ O
( _ _ O
4 _ _ O
) _ _ O
x _ _ O
= _ _ O
4 _ _ O
sum _ _ O
( _ _ O
3 _ _ O
) _ _ O
x _ _ O
= _ _ O
3 _ _ O
sum _ _ O
( _ _ O
2 _ _ O
) _ _ O
x _ _ O
= _ _ O
2 _ _ O
sum _ _ O
( _ _ O
1 _ _ O
) _ _ O
x _ _ O
= _ _ O
1 _ _ O


 _ _ O
25 _ _ O


 _ _ O
Trees _ _ O
♥ _ _ O
Recursion _ _ O
● _ _ O
forget _ _ O
Fibonacci _ _ O
: _ _ O
recursion _ _ O
is _ _ O
exactly _ _ O
what _ _ O
you _ _ O
need _ _ O
for _ _ O
trees _ _ O
. _ _ O
● _ _ O
we _ _ O
have _ _ O
this _ _ O
tree _ _ O
, _ _ O
and _ _ O
a _ _ O
variable _ _ O
pointing _ _ O
to _ _ O
the _ _ O
root _ _ O
. _ _ O
how _ _ O
do _ _ O
you _ _ O
evaluate _ _ O
a _ _ O
multiplication _ _ O
? _ _ O
× _ _ O


 _ _ O
÷ _ _ O


 _ _ O
-40 _ _ O


 _ _ O
the _ _ O
first _ _ O
two _ _ O
steps _ _ O
are _ _ O
done _ _ O
as _ _ O
recursive _ _ O
calls _ _ O
to _ _ O
evaluate _ _ O
the _ _ O
two _ _ O
children _ _ O
. _ _ O


 _ _ O
- _ _ O


 _ _ O
2 _ _ O


 _ _ O
+ _ _ O
3 _ _ O


 _ _ O
1 _ _ O
. _ _ O
evaluate _ _ O
the _ _ O
left-hand _ _ O
side _ _ O
( _ _ O
LHS _ _ O
) _ _ O
2 _ _ O
. _ _ O
evaluate _ _ O
the _ _ O
right-hand _ _ O
side _ _ O
( _ _ O
RHS _ _ O
) _ _ O
3 _ _ O
. _ _ O
multiply _ _ O
them _ _ O
together _ _ O


 _ _ O
5 _ _ O


 _ _ O
that _ _ O
's _ _ O
it _ _ O
. _ _ O
that _ _ O
's _ _ O
how _ _ O
you _ _ O
write _ _ O
a _ _ O
recursive _ _ O
algorithm _ _ O
over _ _ O
a _ _ O
tree _ _ O
. _ _ O
( _ _ O
see _ _ O
AstNode _ _ O
: _ _ O
: _ _ O
eval _ _ O
) _ _ O
26 _ _ O


 _ _ O
What _ _ O
else _ _ O
could _ _ O
you _ _ O
do _ _ O
with _ _ O
them _ _ O
? _ _ O
● _ _ O
you _ _ O
could _ _ O
apply _ _ O
transformations _ _ O
to _ _ O
the _ _ O
tree _ _ O
. _ _ O
● _ _ O
maybe _ _ O
we _ _ O
have _ _ O
a _ _ O
calculator _ _ O
feature _ _ O
to _ _ O
get _ _ O
the _ _ O
reciprocal _ _ O
. _ _ O
doing _ _ O
" _ _ O
one _ _ O
over _ _ O
" _ _ O
means _ _ O
adding _ _ O
two _ _ O
new _ _ O
nodes _ _ O
and _ _ O
making _ _ O
the _ _ O
division _ _ O
the _ _ O
root _ _ O
. _ _ O


 _ _ O
÷ _ _ O
+ _ _ O
3 _ _ O


 _ _ O
7 _ _ O


 _ _ O
1 _ _ O


 _ _ O
+ _ _ O
3 _ _ O


 _ _ O
of _ _ O
course _ _ O
, _ _ O
if _ _ O
the _ _ O
input _ _ O
is _ _ O
a _ _ O
division _ _ O
, _ _ O
we _ _ O
can _ _ O
special-case _ _ O
it _ _ O
. _ _ O


 _ _ O
÷ _ _ O


 _ _ O
÷ _ _ O
2 _ _ O


 _ _ O
7 _ _ O


 _ _ O
5 _ _ O


 _ _ O
5 _ _ O


 _ _ O
this _ _ O
is _ _ O
what _ _ O
AstNode _ _ O
: _ _ O
: _ _ O
recip _ _ O
in _ _ O
the _ _ O
example _ _ O
does _ _ O
! _ _ O


 _ _ O
2 _ _ O
27 _ _ O


 _ _ O
What _ _ O
if _ _ O
the _ _ O
programmer _ _ O
could _ _ O
do _ _ O
that _ _ O
? _ _ O
● _ _ O
some _ _ O
languages _ _ O
have _ _ O
macros _ _ O
: _ _ O
things _ _ O
that _ _ O
look _ _ O
like _ _ O
functions _ _ O
, _ _ O
but _ _ O
which _ _ O
operate _ _ O
on _ _ O
the _ _ O
AST _ _ O
at _ _ O
compile-time _ _ O
. _ _ O
o _ _ O
that _ _ O
's _ _ O
really _ _ O
what _ _ O
println _ _ O
! _ _ O
( _ _ O
) _ _ O
is _ _ O
! _ _ O
o _ _ O
the _ _ O
details _ _ O
of _ _ O
how _ _ O
println _ _ O
! _ _ O
( _ _ O
) _ _ O
works _ _ O
are _ _ O
beyond _ _ O
the _ _ O
scope _ _ O
of _ _ O
this _ _ O
lecture _ _ O
but _ _ O
that _ _ O
's _ _ O
why _ _ O
it _ _ O
yells _ _ O
: _ _ O
it _ _ O
's _ _ O
a _ _ O
macro _ _ O
, _ _ O
not _ _ O
a _ _ O
function _ _ O
. _ _ O
it _ _ O
generates _ _ O
different _ _ O
ASTs _ _ O
based _ _ O
on _ _ O
what _ _ O
arguments _ _ O
you _ _ O
give _ _ O
it _ _ O
. _ _ O
● _ _ O
if _ _ O
you _ _ O
've _ _ O
experienced _ _ O
C _ _ O
's _ _ O
preprocessor _ _ O
macros _ _ O
( _ _ O
# _ _ O
define _ _ O
) _ _ O
, _ _ O
those _ _ O
are _ _ O
similar _ _ O
, _ _ O
but _ _ O
they _ _ O
operate _ _ O
on _ _ O
tokens _ _ O
instead _ _ O
of _ _ O
the _ _ O
AST _ _ O
. _ _ O
o _ _ O
still _ _ O
, _ _ O
you _ _ O
can _ _ O
do _ _ O
some _ _ O
impressive _ _ O
stuff _ _ O
with _ _ O
them _ _ O
! _ _ O


 _ _ O
28 _ _ O


 _ _ O
Ok _ _ O
, _ _ O
but _ _ O
, _ _ O
how _ _ O
does _ _ O
the _ _ O
AST _ _ O
get _ _ O
built _ _ O
● _ _ O
uhhhhhhhhhhhhhhhh _ _ O
wellll _ _ O
o _ _ O
parsing _ _ O
! _ _ O
! _ _ O
! _ _ O
! _ _ O
! _ _ O
! _ _ O
o _ _ O
parsing _ _ O
is _ _ O
definitely _ _ O
more _ _ O
complicated _ _ O
than _ _ O
lexing _ _ O
o _ _ O
which _ _ O
is _ _ O
why _ _ O
we _ _ O
have _ _ O
the _ _ O
next _ _ O
two _ _ O
lectures _ _ O
dedicated _ _ O
to _ _ O
it _ _ O
. _ _ O
● _ _ O
but _ _ O
that _ _ O
's _ _ O
all _ _ O
for _ _ O
today _ _ O
. _ _ O
good _ _ O
luck _ _ O
on _ _ O
the _ _ O
project _ _ O
, _ _ O
have _ _ O
a _ _ O
nice _ _ O
break _ _ O
, _ _ O
and _ _ O
see _ _ O
you _ _ O
in _ _ O
a _ _ O
week _ _ O
! _ _ O


 _ _ O
29 _ _ O


 _ _ O


