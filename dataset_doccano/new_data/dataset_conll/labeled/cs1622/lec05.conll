['train_set', 'labeled']|cs1622|lec05
-DOCSTART- -X- -X- O

Top-down _ _ B-Concept
Parsing _ _ I-Concept
CS _ _ O
1622 _ _ O
Jarrett _ _ O
Billingsley _ _ O


 _ _ O
Class _ _ O
Announcements _ _ O
● _ _ O
how _ _ O
was _ _ O
your _ _ O
weekeeeeend _ _ O
● _ _ O
project _ _ O
2 _ _ O
will _ _ O
come _ _ O
out _ _ O
this _ _ O
weekend _ _ O
so _ _ O
you _ _ O
'll _ _ O
have _ _ O
2 _ _ O
weeks _ _ O
for _ _ O
it _ _ O


 _ _ O
2 _ _ O


 _ _ O
Parsing _ _ O


 _ _ O
3 _ _ O


 _ _ O
A _ _ O
generative _ _ O
view _ _ O
● _ _ O
one _ _ O
way _ _ O
to _ _ O
use _ _ O
a _ _ O
grammar _ _ O
is _ _ O
to _ _ O
produce _ _ O
sentences _ _ O
in _ _ O
the _ _ O
language _ _ O
. _ _ O
Exp _ _ O
: _ _ O
I _ _ O
d _ _ O
| _ _ O
Num _ _ O
| _ _ O
Parens _ _ O
Parens _ _ O
: _ _ O
' _ _ O
( _ _ O
' _ _ O
Exp+ _ _ O
' _ _ O
) _ _ O
' _ _ O
I _ _ O
d _ _ O
: _ _ O
< _ _ O
i _ _ O
d _ _ O
token _ _ O
> _ _ O
Num _ _ O
: _ _ O
< _ _ O
int _ _ O
literal _ _ O
token _ _ O
> _ _ O


 _ _ O
we _ _ O
can _ _ O
produce _ _ O
valid _ _ O
sentences _ _ O
by _ _ O
starting _ _ O
at _ _ O
the _ _ O
root _ _ O
rule _ _ O
and _ _ O
repeatedly _ _ O
replacing _ _ O
nonterminals _ _ O
with _ _ O
their _ _ O
right-hand _ _ O
sides _ _ O
. _ _ O


 _ _ O
Exp _ _ O
= _ _ O
> _ _ O
Parens _ _ O
= _ _ O
> _ _ O
' _ _ O
( _ _ O
' _ _ O
Exp+ _ _ O
' _ _ O
) _ _ O
' _ _ O
= _ _ O
> _ _ O
' _ _ O
( _ _ O
' _ _ O
Exp _ _ O
Exp _ _ O
Exp _ _ O
' _ _ O
) _ _ O
' _ _ O


 _ _ O
= _ _ O
> _ _ O
' _ _ O
( _ _ O
' _ _ O
I _ _ O
d _ _ O
I _ _ O
d _ _ O
Num _ _ O
' _ _ O
) _ _ O
' _ _ O
= _ _ O
> _ _ O
' _ _ O
( _ _ O
' _ _ O
' _ _ O
add _ _ O
' _ _ O
I _ _ O
d _ _ O
Num _ _ O
' _ _ O
) _ _ O
' _ _ O
= _ _ O
> _ _ O
' _ _ O
( _ _ O
' _ _ O
' _ _ O
add _ _ O
' _ _ O
' _ _ O
x _ _ O
' _ _ O
Num _ _ O
' _ _ O
) _ _ O
' _ _ O
= _ _ O
> _ _ O
' _ _ O
( _ _ O
' _ _ O
' _ _ O
add _ _ O
' _ _ O
' _ _ O
x _ _ O
' _ _ O
' _ _ O
3 _ _ O
' _ _ O
' _ _ O
) _ _ O
' _ _ O


 _ _ O
this _ _ O
sequence _ _ O
is _ _ O
called _ _ O
a _ _ O
derivation _ _ O
. _ _ O


 _ _ O
now _ _ O
suppose _ _ O
we _ _ O
were _ _ O
given _ _ O
( _ _ O
add _ _ O
x _ _ O
3 _ _ O
) _ _ O
as _ _ O
our _ _ O
input _ _ O
. _ _ O
could _ _ O
we _ _ O
work _ _ O
backwards _ _ O
to _ _ O
figure _ _ O
out _ _ O
how _ _ O
to _ _ O
get _ _ O
to _ _ O
Exp _ _ O
? _ _ O


 _ _ O
4 _ _ O


 _ _ O
That _ _ O
's _ _ O
what _ _ O
parsing _ _ O
is _ _ O
. _ _ O
● _ _ O
given _ _ O
a _ _ O
grammar _ _ O
and _ _ O
an _ _ O
input _ _ O
string _ _ O
... _ _ O
● _ _ O
parsing _ _ O
is _ _ O
figuring _ _ O
out _ _ O
the _ _ O
derivation _ _ O
that _ _ O
was _ _ O
needed _ _ O
to _ _ O
produce _ _ O
the _ _ O
input _ _ O
string _ _ O
. _ _ O
( _ _ O
and _ _ O
if _ _ O
there _ _ O
is _ _ O
no _ _ O
such _ _ O
derivation _ _ O
, _ _ O
it _ _ O
's _ _ O
an _ _ O
error _ _ O
! _ _ O
) _ _ O
● _ _ O
we _ _ O
represent _ _ O
the _ _ O
derivation _ _ O
as _ _ O
... _ _ O
an _ _ O
abstract _ _ O
syntax _ _ O
tree _ _ O
! _ _ O
Exp _ _ O
: _ _ O
I _ _ O
d _ _ O
| _ _ O
Num _ _ O
| _ _ O
Parens _ _ O
Parens _ _ O
: _ _ O
' _ _ O
( _ _ O
' _ _ O
Exp+ _ _ O
' _ _ O
) _ _ O
' _ _ O
I _ _ O
d _ _ O
: _ _ O
< _ _ O
i _ _ O
d _ _ O
token _ _ O
> _ _ O
Num _ _ O
: _ _ O
< _ _ O
int _ _ O
token _ _ O
> _ _ O


 _ _ O
Input _ _ O
e _ _ O
( _ _ O
e _ _ O
) _ _ O
( _ _ O
1 _ _ O
2 _ _ O
) _ _ O
( _ _ O
e _ _ O
e _ _ O
) _ _ O
( _ _ O
) _ _ O


 _ _ O
Output _ _ O
AST _ _ O
Id _ _ O
( _ _ O
"e _ _ O
" _ _ O
) _ _ O
Parens _ _ O
( _ _ O
Id _ _ O
( _ _ O
"e _ _ O
" _ _ O
) _ _ O
) _ _ O
Parens _ _ O
( _ _ O
Num _ _ O
( _ _ O
1 _ _ O
) _ _ O
, _ _ O
Num _ _ O
( _ _ O
2 _ _ O
) _ _ O
) _ _ O
error _ _ O
! _ _ O
error _ _ O
! _ _ O
error _ _ O
! _ _ O


 _ _ O
the _ _ O
last _ _ O
three _ _ O
would _ _ O
benefit _ _ O
from _ _ O
some _ _ O
error _ _ O
messages _ _ O
that _ _ O
help _ _ O
the _ _ O
programmer _ _ O
. _ _ O


 _ _ O
5 _ _ O


 _ _ O
Okay _ _ O
what _ _ O
is _ _ O
this _ _ O
language _ _ O
? _ _ O
● _ _ O
this _ _ O
is _ _ O
a _ _ O
variety _ _ O
of _ _ O
Lisp _ _ O
, _ _ O
a _ _ O
language _ _ O
family _ _ O
that _ _ O
started _ _ O
in _ _ O
1958 _ _ O
. _ _ O
● _ _ O
we _ _ O
're _ _ O
not _ _ O
going _ _ O
to _ _ O
get _ _ O
into _ _ O
what _ _ O
it _ _ O
means _ _ O
, _ _ O
but _ _ O
it _ _ O
's _ _ O
a _ _ O
very _ _ O
easy-toparse _ _ O
example _ _ O
language _ _ O
. _ _ O
( _ _ O
) _ _ O


 _ _ O
( _ _ O
defun _ _ O
fact _ _ O
( _ _ O
x _ _ O
) _ _ O
( _ _ O
if _ _ O
( _ _ O
eq _ _ O
x _ _ O
0 _ _ O
) _ _ O
defun _ _ O
1 _ _ O
( _ _ O
mul _ _ O
x _ _ O
( _ _ O
fact _ _ O
( _ _ O
sub _ _ O
x _ _ O
1 _ _ O
) _ _ O
) _ _ O
) _ _ O
) _ _ O
) _ _ O


 _ _ O
fact _ _ O


 _ _ O
Lisp _ _ O
code _ _ O
is _ _ O
basically _ _ O
an _ _ O
AST _ _ O
already _ _ O
; _ _ O
parentheses _ _ O
group _ _ O
children _ _ O
. _ _ O


 _ _ O
( _ _ O
) _ _ O
x _ _ O


 _ _ O
( _ _ O
) _ _ O
if _ _ O
eq _ _ O


 _ _ O
( _ _ O
) _ _ O
x _ _ O


 _ _ O
0 _ _ O


 _ _ O
this _ _ O
is _ _ O
going _ _ O
to _ _ O
make _ _ O
our _ _ O
job _ _ O
of _ _ O
parsing _ _ O
much _ _ O
easier _ _ O
. _ _ O


 _ _ O
1 _ _ O


 _ _ O
( _ _ O
) _ _ O
mul _ _ O


 _ _ O
x _ _ O


 _ _ O
( _ _ O
) _ _ O


 _ _ O
fact _ _ O
( _ _ O
) _ _ O
sub _ _ O


 _ _ O
x _ _ O


 _ _ O
1 _ _ O
6 _ _ O


 _ _ O
So _ _ O
how _ _ O
do _ _ O
we _ _ O
do _ _ O
it _ _ O
? _ _ O
● _ _ O
well _ _ O
it _ _ O
's _ _ O
a _ _ O
bit _ _ O
like _ _ O
lexing _ _ O
: _ _ O
o _ _ O
we _ _ O
start _ _ O
at _ _ O
the _ _ O
beginning _ _ O
, _ _ O
looking _ _ O
at _ _ O
tokens _ _ O
one-by-one _ _ O
. _ _ O
o _ _ O
based _ _ O
on _ _ O
the _ _ O
token _ _ O
, _ _ O
we _ _ O
decide _ _ O
which _ _ O
rule _ _ O
we _ _ O
should _ _ O
use _ _ O
. _ _ O
o _ _ O
if _ _ O
none _ _ O
of _ _ O
the _ _ O
rules _ _ O
apply _ _ O
, _ _ O
or _ _ O
if _ _ O
we _ _ O
see _ _ O
something _ _ O
that _ _ O
we _ _ O
do _ _ O
n't _ _ O
expect _ _ O
, _ _ O
we _ _ O
can _ _ O
give _ _ O
an _ _ O
error _ _ O
. _ _ O
● _ _ O
speaking _ _ O
of _ _ O
which _ _ O
... _ _ O


 _ _ O
7 _ _ O


 _ _ O
Error _ _ O
Handling _ _ O
in _ _ O
Rust _ _ O
time _ _ O
check _ _ O
: _ _ O
≤ _ _ O
17 _ _ O


 _ _ O
8 _ _ O


 _ _ O
The _ _ O
Result _ _ O
type _ _ O
● _ _ O
Rust _ _ O
does _ _ O
n't _ _ O
have _ _ O
exceptions _ _ O
like _ _ O
Java _ _ O
does _ _ O
. _ _ O
● _ _ O
if _ _ O
your _ _ O
function _ _ O
needs _ _ O
to _ _ O
indicate _ _ O
failure _ _ O
, _ _ O
it _ _ O
returns _ _ O
a _ _ O
Result _ _ O
. _ _ O


 _ _ O
Result _ _ O
< _ _ O
T _ _ O
, _ _ O
E _ _ O
> _ _ O
T _ _ O
is _ _ O
the _ _ O
type _ _ O
of _ _ O
value _ _ O
returned _ _ O
on _ _ O
success _ _ O
. _ _ O


 _ _ O
if _ _ O
the _ _ O
function _ _ O
does _ _ O
n't _ _ O
return _ _ O
any _ _ O
value _ _ O
on _ _ O
success _ _ O
, _ _ O
you _ _ O
can _ _ O
use _ _ O
( _ _ O
) _ _ O
- _ _ O
this _ _ O
is _ _ O
Rust _ _ O
's _ _ O
void _ _ O
. _ _ O


 _ _ O
E _ _ O
is _ _ O
the _ _ O
type _ _ O
of _ _ O
value _ _ O
returned _ _ O
for _ _ O
errors _ _ O
. _ _ O
any _ _ O
type _ _ O
can _ _ O
be _ _ O
used _ _ O
for _ _ O
errors _ _ O
, _ _ O
but _ _ O
typically _ _ O
it _ _ O
's _ _ O
an _ _ O
enum _ _ O
. _ _ O


 _ _ O
Result _ _ O
< _ _ O
Box _ _ O
< _ _ O
AstNode _ _ O
> _ _ O
, _ _ O
ParseError _ _ O
> _ _ O
this _ _ O
is _ _ O
a _ _ O
bit _ _ O
unwieldy _ _ O
, _ _ O
so _ _ O
we _ _ O
can _ _ O
use _ _ O
a _ _ O
type _ _ O
alias _ _ O
to _ _ O
shorten _ _ O
it _ _ O
: _ _ O
type _ _ O
ParseResult _ _ O
= _ _ O
Result _ _ O
< _ _ O
Box _ _ O
< _ _ O
AstNode _ _ O
> _ _ O
, _ _ O
ParseError _ _ O
> _ _ O
; _ _ O
9 _ _ O


 _ _ O
Err _ _ O
, _ _ O
ok _ _ O
... _ _ O
● _ _ O
you _ _ O
create _ _ O
Results _ _ O
with _ _ O
the _ _ O
Ok _ _ O
( _ _ O
) _ _ O
and _ _ O
Err _ _ O
( _ _ O
) _ _ O
constructors _ _ O
. _ _ O
if _ _ O
thing.is_bad _ _ O
( _ _ O
) _ _ O
{ _ _ O
/ _ _ O
/ _ _ O
common _ _ O
to _ _ O
use _ _ O
' _ _ O
return _ _ O
' _ _ O
to _ _ O
immediately _ _ O
/ _ _ O
/ _ _ O
leave _ _ O
the _ _ O
function _ _ O
. _ _ O
kinda _ _ O
like _ _ O
throwing _ _ O
return _ _ O
Err _ _ O
( _ _ O
ParseError _ _ O
: _ _ O
: _ _ O
whatever _ _ O
( _ _ O
) _ _ O
) _ _ O
; _ _ O
} _ _ O
you _ _ O
can _ _ O
match _ _ O
on _ _ O
a _ _ O
Result _ _ O
using _ _ O
Ok _ _ O
( _ _ O
) _ _ O
and _ _ O
Err _ _ O
( _ _ O
) _ _ O
: _ _ O
match _ _ O
parse_thing _ _ O
( _ _ O
input _ _ O
) _ _ O
{ _ _ O
Ok _ _ O
( _ _ O
ast _ _ O
) _ _ O
= _ _ O
> _ _ O
{ _ _ O
println _ _ O
! _ _ O
( _ _ O
" _ _ O
{ _ _ O
: _ _ O
? _ _ O
} _ _ O
" _ _ O
, _ _ O
ast _ _ O
) _ _ O
; _ _ O
} _ _ O
Err _ _ O
( _ _ O
e _ _ O
) _ _ O
= _ _ O
> _ _ O
{ _ _ O
println _ _ O
! _ _ O
( _ _ O
"o _ _ O
no _ _ O
: _ _ O
{ _ _ O
} _ _ O
" _ _ O
, _ _ O
e _ _ O
) _ _ O
; _ _ O
} _ _ O
} _ _ O
match _ _ O
patterns _ _ O
declare _ _ O
local _ _ O
variables _ _ O
usable _ _ O
in _ _ O
their _ _ O
code _ _ O
blocks _ _ O
, _ _ O
if _ _ O
that _ _ O
was _ _ O
unclear _ _ O
before _ _ O
. _ _ O
10 _ _ O


 _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
● _ _ O
when _ _ O
using _ _ O
Result-returning _ _ O
functions _ _ O
, _ _ O
a _ _ O
really _ _ O
ugly _ _ O
pattern _ _ O
appears _ _ O
: _ _ O
match _ _ O
step_one _ _ O
( _ _ O
input _ _ O
) _ _ O
{ _ _ O
Ok _ _ O
( _ _ O
a _ _ O
) _ _ O
= _ _ O
> _ _ O
{ _ _ O
match _ _ O
step_two _ _ O
( _ _ O
a _ _ O
) _ _ O
{ _ _ O
Ok _ _ O
( _ _ O
b _ _ O
) _ _ O
= _ _ O
> _ _ O
{ _ _ O
match _ _ O
step_three _ _ O
( _ _ O
b _ _ O
) _ _ O
{ _ _ O
Ok _ _ O
( _ _ O
c _ _ O
) _ _ O
= _ _ O
> _ _ O
{ _ _ O
return _ _ O
Ok _ _ O
( _ _ O
c.to_string _ _ O
( _ _ O
) _ _ O
) _ _ O
; _ _ O
} _ _ O
Err _ _ O
( _ _ O
e _ _ O
) _ _ O
= _ _ O
> _ _ O
{ _ _ O
return _ _ O
Err _ _ O
( _ _ O
e _ _ O
) _ _ O
; _ _ O
} _ _ O
} _ _ O
} _ _ O
Err _ _ O
( _ _ O
e _ _ O
) _ _ O
= _ _ O
> _ _ O
{ _ _ O
return _ _ O
Err _ _ O
( _ _ O
e _ _ O
) _ _ O
; _ _ O
} _ _ O
} _ _ O
} _ _ O
Err _ _ O
( _ _ O
e _ _ O
) _ _ O
= _ _ O
> _ _ O
{ _ _ O
return _ _ O
Err _ _ O
( _ _ O
e _ _ O
) _ _ O
; _ _ O
} _ _ O
} _ _ O


 _ _ O
this _ _ O
is _ _ O
terrible _ _ O
. _ _ O
instead _ _ O
: _ _ O
let _ _ O
a _ _ O
= _ _ O
step_one _ _ O
( _ _ O
input _ _ O
) _ _ O
? _ _ O
; _ _ O
let _ _ O
b _ _ O
= _ _ O
step_two _ _ O
( _ _ O
a _ _ O
) _ _ O
? _ _ O
; _ _ O
let _ _ O
c _ _ O
= _ _ O
step_three _ _ O
( _ _ O
b _ _ O
) _ _ O
? _ _ O
; _ _ O
Ok _ _ O
( _ _ O
c.to_string _ _ O
( _ _ O
) _ _ O
) _ _ O


 _ _ O
x _ _ O
? _ _ O
means _ _ O
, _ _ O
" _ _ O
if _ _ O
x _ _ O
is _ _ O
an _ _ O
error _ _ O
, _ _ O
return _ _ O
it _ _ O
; _ _ O
otherwise _ _ O
, _ _ O
give _ _ O
me _ _ O
the _ _ O
success _ _ O
value _ _ O
. _ _ O
we _ _ O
'll _ _ O
be _ _ O
seeing _ _ O
this _ _ O
a _ _ O
lot _ _ O
in _ _ O
parsing _ _ O
code _ _ O
! _ _ O
11 _ _ O


 _ _ O
Recursive _ _ O
Descent _ _ O
time _ _ O
check _ _ O
: _ _ O
≤ _ _ O
34 _ _ O


 _ _ O
12 _ _ O


 _ _ O
Can _ _ O
we _ _ O
intuit _ _ O
our _ _ O
way _ _ O
through _ _ O
this _ _ O
? _ _ O
● _ _ O
with _ _ O
this _ _ O
grammar _ _ O
, _ _ O
and _ _ O
this _ _ O
sequence _ _ O
of _ _ O
tokens _ _ O
as _ _ O
our _ _ O
input _ _ O
... _ _ O


 _ _ O
' _ _ O
( _ _ O
' _ _ O
, _ _ O
' _ _ O
( _ _ O
' _ _ O
, _ _ O
' _ _ O
hi _ _ O
' _ _ O
, _ _ O
' _ _ O
5 _ _ O
' _ _ O
, _ _ O
' _ _ O
) _ _ O
' _ _ O
, _ _ O
' _ _ O
) _ _ O
' _ _ O


 _ _ O
Exp _ _ O
: _ _ O
I _ _ O
d _ _ O
| _ _ O
Num _ _ O
| _ _ O
Parens _ _ O
Parens _ _ O
: _ _ O
' _ _ O
( _ _ O
' _ _ O
Exp+ _ _ O
' _ _ O
) _ _ O
' _ _ O
I _ _ O
d _ _ O
: _ _ O
< _ _ O
i _ _ O
d _ _ O
token _ _ O
> _ _ O
Num _ _ O
: _ _ O
< _ _ O
int _ _ O
literal _ _ O
token _ _ O
> _ _ O


 _ _ O
we _ _ O
are _ _ O
here _ _ O
. _ _ O
our _ _ O
ultimate _ _ O
goal _ _ O
is _ _ O
to _ _ O
build _ _ O
an _ _ O
Exp _ _ O
. _ _ O
this _ _ O
token _ _ O
is _ _ O
a _ _ O
left-paren _ _ O
, _ _ O
so _ _ O
which _ _ O
rule _ _ O
do _ _ O
we _ _ O
think _ _ O
applies _ _ O
here _ _ O
? _ _ O
Parens _ _ O
! _ _ O
after _ _ O
the _ _ O
left-paren _ _ O
, _ _ O
we _ _ O
should _ _ O
see _ _ O
one _ _ O
or _ _ O
more _ _ O
Exps _ _ O
, _ _ O
followed _ _ O
by _ _ O
a _ _ O
right-paren _ _ O
. _ _ O


 _ _ O
but _ _ O
we _ _ O
're _ _ O
already _ _ O
trying _ _ O
to _ _ O
parse _ _ O
an _ _ O
Exp _ _ O
. _ _ O
how _ _ O
do _ _ O
we _ _ O
parse _ _ O
a _ _ O
new _ _ O
Exp _ _ O
without _ _ O
finishing _ _ O
this _ _ O
one _ _ O
? _ _ O
13 _ _ O


 _ _ O
The _ _ O
rules _ _ O
are _ _ O
recursive _ _ O
, _ _ O
so _ _ O
... _ _ O
● _ _ O
recall _ _ O
that _ _ O
all _ _ O
CFGs _ _ O
have _ _ O
this _ _ O
recursive _ _ O
rule _ _ O
structure _ _ O
. _ _ O
● _ _ O
well _ _ O
if _ _ O
the _ _ O
dependencies _ _ O
between _ _ O
the _ _ O
rules _ _ O
are _ _ O
recursive _ _ O
... _ _ O
o _ _ O
why _ _ O
not _ _ O
use _ _ O
recursive _ _ O
functions _ _ O
to _ _ O
model _ _ O
the _ _ O
rules _ _ O
? _ _ O
Exp _ _ O
: _ _ O
I _ _ O
d _ _ O
| _ _ O
Num _ _ O
| _ _ O
Parens _ _ O
Parens _ _ O
: _ _ O
' _ _ O
( _ _ O
' _ _ O
Exp+ _ _ O
' _ _ O
) _ _ O
' _ _ O
I _ _ O
d _ _ O
: _ _ O
< _ _ O
i _ _ O
d _ _ O
token _ _ O
> _ _ O
Num _ _ O
: _ _ O
< _ _ O
int _ _ O
token _ _ O
> _ _ O


 _ _ O
let _ _ O
's _ _ O
write _ _ O
some _ _ O
pseudocode _ _ O
to _ _ O
get _ _ O
our _ _ O
thoughts _ _ O
down _ _ O
. _ _ O


 _ _ O
fn _ _ O
parse_exp _ _ O
( _ _ O
) _ _ O
{ _ _ O
match _ _ O
self.cur _ _ O
( _ _ O
) _ _ O
{ _ _ O
I _ _ O
d _ _ O
= _ _ O
> _ _ O
parse_id _ _ O
( _ _ O
) _ _ O
, _ _ O
IntLit _ _ O
= _ _ O
> _ _ O
parse_num _ _ O
( _ _ O
) _ _ O
, _ _ O
LParen _ _ O
= _ _ O
> _ _ O
parse_parens _ _ O
( _ _ O
) _ _ O
, _ _ O
} _ _ O
} _ _ O


 _ _ O
fn _ _ O
parse_parens _ _ O
( _ _ O
) _ _ O
{ _ _ O
eat_an_lparen _ _ O
( _ _ O
) _ _ O
; _ _ O
let _ _ O
exps _ _ O
= _ _ O
... _ _ O
parse_exp _ _ O
( _ _ O
) _ _ O
... _ _ O
eat_an_rparen _ _ O
( _ _ O
) _ _ O
; _ _ O
return _ _ O
Parens _ _ O
( _ _ O
exps _ _ O
) _ _ O
; _ _ O
} _ _ O
( _ _ O
looping _ _ O
happens _ _ O
here _ _ O
) _ _ O


 _ _ O
14 _ _ O


 _ _ O
Believe _ _ O
it _ _ O
or _ _ O
not _ _ O
, _ _ O
that _ _ O
's _ _ O
pretty _ _ O
much _ _ O
right _ _ O
! _ _ O
● _ _ O
what _ _ O
we _ _ O
've _ _ O
just _ _ O
( _ _ O
pseudo- _ _ O
) _ _ O
written _ _ O
is _ _ O
a _ _ O
recursive _ _ O
descent _ _ O
parser _ _ O
: _ _ O
o _ _ O
recursive _ _ O
, _ _ O
because _ _ O
uh _ _ O
, _ _ O
it _ _ O
is _ _ O
! _ _ O
o _ _ O
and _ _ O
descent _ _ O
, _ _ O
because _ _ O
we _ _ O
start _ _ O
at _ _ O
the _ _ O
root _ _ O
rule _ _ O
, _ _ O
and _ _ O
descend _ _ O
into _ _ O
the _ _ O
other _ _ O
rules _ _ O
until _ _ O
we _ _ O
get _ _ O
to _ _ O
the _ _ O
terminals _ _ O
. _ _ O
● _ _ O
the _ _ O
issue _ _ O
with _ _ O
" _ _ O
trying _ _ O
to _ _ O
parse _ _ O
an _ _ O
Exp _ _ O
while _ _ O
parsing _ _ O
an _ _ O
Exp _ _ O
" _ _ O
is _ _ O
solved _ _ O
by _ _ O
using _ _ O
recursion _ _ O
o _ _ O
when _ _ O
you _ _ O
recurse _ _ O
, _ _ O
the _ _ O
caller _ _ O
rule _ _ O
's _ _ O
execution _ _ O
is _ _ O
paused _ _ O
, _ _ O
and _ _ O
it _ _ O
remembers _ _ O
its _ _ O
place _ _ O
in _ _ O
the _ _ O
rule _ _ O
. _ _ O
o _ _ O
it _ _ O
can _ _ O
then _ _ O
resume _ _ O
parsing _ _ O
after _ _ O
the _ _ O
callee _ _ O
rule _ _ O
has _ _ O
done _ _ O
its _ _ O
work _ _ O
. _ _ O
● _ _ O
so _ _ O
how _ _ O
can _ _ O
we _ _ O
be _ _ O
a _ _ O
little _ _ O
less _ _ O
" _ _ O
pseudo _ _ O
" _ _ O
about _ _ O
this _ _ O
code _ _ O
? _ _ O


 _ _ O
15 _ _ O


 _ _ O
From _ _ O
Rules _ _ O
to _ _ O
Rust _ _ O
● _ _ O
each _ _ O
grammar _ _ O
rule _ _ O
is _ _ O
really _ _ O
a _ _ O
list _ _ O
of _ _ O
steps _ _ O
, _ _ O
and _ _ O
translating _ _ O
them _ _ O
to _ _ O
real _ _ O
code _ _ O
is _ _ O
relatively _ _ O
straightforward _ _ O
: _ _ O


 _ _ O
Parens _ _ O
: _ _ O
' _ _ O
( _ _ O
' _ _ O
Exp+ _ _ O
' _ _ O
) _ _ O
' _ _ O
this _ _ O
says _ _ O
that _ _ O
to _ _ O
parse _ _ O
a _ _ O
Parens _ _ O
: _ _ O
1 _ _ O
. _ _ O
expect _ _ O
a _ _ O
' _ _ O
( _ _ O
' _ _ O
token _ _ O
and _ _ O
skip _ _ O
it _ _ O
. _ _ O
2 _ _ O
. _ _ O
parse _ _ O
one _ _ O
Exp _ _ O
, _ _ O
since _ _ O
that _ _ O
's _ _ O
the _ _ O
minimum _ _ O
number _ _ O
. _ _ O
3 _ _ O
. _ _ O
while _ _ O
we _ _ O
do _ _ O
n't _ _ O
see _ _ O
a _ _ O
' _ _ O
) _ _ O
' _ _ O
token _ _ O
, _ _ O
• _ _ O
keep _ _ O
parsing _ _ O
Exps _ _ O
and _ _ O
put _ _ O
them _ _ O
into _ _ O
a _ _ O
list _ _ O
. _ _ O
4 _ _ O
. _ _ O
expect _ _ O
a _ _ O
' _ _ O
) _ _ O
' _ _ O
token _ _ O
and _ _ O
skip _ _ O
it _ _ O
. _ _ O


 _ _ O
if _ _ O
all _ _ O
of _ _ O
these _ _ O
steps _ _ O
succeed _ _ O
, _ _ O
we _ _ O
can _ _ O
create _ _ O
an _ _ O
Parens _ _ O
AST _ _ O
node _ _ O
and _ _ O
return _ _ O
it _ _ O
! _ _ O
16 _ _ O


 _ _ O
Other _ _ O
metalanguage _ _ O
rule _ _ O
correspondences _ _ O
● _ _ O
there _ _ O
's _ _ O
a _ _ O
nice _ _ O
correspondence _ _ O
between _ _ O
the _ _ O
things _ _ O
we _ _ O
see _ _ O
in _ _ O
the _ _ O
grammar _ _ O
metalanguage _ _ O
and _ _ O
the _ _ O
patterns _ _ O
we _ _ O
use _ _ O
in _ _ O
our _ _ O
code _ _ O
. _ _ O


 _ _ O
A _ _ O
B _ _ O
A _ _ O
| _ _ O
B _ _ O


 _ _ O
sequencing _ _ O
: _ _ O
parse _ _ O
an _ _ O
A _ _ O
; _ _ O
if _ _ O
that _ _ O
succeeds _ _ O
, _ _ O
then _ _ O
parse _ _ O
a _ _ O
B. _ _ O
alternation _ _ O
: _ _ O
an _ _ O
if-else _ _ O
( _ _ O
or _ _ O
a _ _ O
match _ _ O
) _ _ O
; _ _ O
either _ _ O
parse _ _ O
an _ _ O
A _ _ O
or _ _ O
parse _ _ O
a _ _ O
B. _ _ O


 _ _ O
A _ _ O
* _ _ O


 _ _ O
0 _ _ O
+ _ _ O
repetition _ _ O
: _ _ O
while _ _ O
the _ _ O
next _ _ O
token _ _ O
looks _ _ O
like _ _ O
an _ _ O
A _ _ O
, _ _ O
keep _ _ O
parsing _ _ O
As _ _ O
. _ _ O


 _ _ O
A+ _ _ O


 _ _ O
1 _ _ O
+ _ _ O
repetition _ _ O
: _ _ O
parse _ _ O
an _ _ O
A _ _ O
, _ _ O
then _ _ O
do _ _ O
a _ _ O
while _ _ O
loop _ _ O
like _ _ O
for _ _ O
0 _ _ O
+ _ _ O
. _ _ O


 _ _ O
A _ _ O
? _ _ O


 _ _ O
optional _ _ O
: _ _ O
if _ _ O
the _ _ O
next _ _ O
token _ _ O
looks _ _ O
like _ _ O
an _ _ O
A _ _ O
, _ _ O
parse _ _ O
it _ _ O
. _ _ O
17 _ _ O


 _ _ O
From _ _ O
rules _ _ O
to _ _ O
AST _ _ O
nodes _ _ O
● _ _ O
similarly _ _ O
, _ _ O
when _ _ O
we _ _ O
design _ _ O
our _ _ O
AST _ _ O
nodes _ _ O
, _ _ O
these _ _ O
metalanguage _ _ O
rules _ _ O
imply _ _ O
different _ _ O
data _ _ O
structures _ _ O
: _ _ O


 _ _ O
A _ _ O
B _ _ O
A _ _ O
| _ _ O
B _ _ O


 _ _ O
a _ _ O
struct _ _ O
, _ _ O
with _ _ O
an _ _ O
A _ _ O
field _ _ O
and _ _ O
a _ _ O
B _ _ O
field _ _ O
. _ _ O
an _ _ O
enum _ _ O
, _ _ O
where _ _ O
A _ _ O
and _ _ O
B _ _ O
are _ _ O
two _ _ O
variants _ _ O
. _ _ O


 _ _ O
A _ _ O
* _ _ O
A+ _ _ O


 _ _ O
an _ _ O
array _ _ O
/ _ _ O
vector _ _ O
, _ _ O
whose _ _ O
length _ _ O
is _ _ O
the _ _ O
number _ _ O
of _ _ O
repetitions _ _ O
. _ _ O


 _ _ O
A _ _ O
? _ _ O


 _ _ O
an _ _ O
Option _ _ O
< _ _ O
A _ _ O
> _ _ O
field _ _ O
, _ _ O
since _ _ O
it _ _ O
might _ _ O
not _ _ O
exist _ _ O
. _ _ O
18 _ _ O


 _ _ O
The _ _ O
example _ _ O
● _ _ O
now _ _ O
let _ _ O
's _ _ O
have _ _ O
a _ _ O
look _ _ O
at _ _ O
the _ _ O
new _ _ O
parsing_lisp _ _ O
example _ _ O
I _ _ O
added _ _ O
. _ _ O
o _ _ O
src _ _ O
/ _ _ O
lib.rs _ _ O
is _ _ O
where _ _ O
all _ _ O
the _ _ O
goodies _ _ O
are _ _ O
. _ _ O
o _ _ O
the _ _ O
Token _ _ O
and _ _ O
AstNode _ _ O
types _ _ O
are _ _ O
familiar _ _ O
to _ _ O
you _ _ O
by _ _ O
now _ _ O
. _ _ O
▪ _ _ O
there _ _ O
's _ _ O
an _ _ O
extra _ _ O
Program _ _ O
rule _ _ O
in _ _ O
the _ _ O
grammar _ _ O
though _ _ O
. _ _ O
o _ _ O
ParseError _ _ O
is _ _ O
an _ _ O
example _ _ O
of _ _ O
an _ _ O
error _ _ O
enum _ _ O
. _ _ O
o _ _ O
Parser _ _ O
looks _ _ O
a _ _ O
lot _ _ O
like _ _ O
Lexer _ _ O
from _ _ O
your _ _ O
project _ _ O
... _ _ O
▪ _ _ O
except _ _ O
it _ _ O
iterates _ _ O
over _ _ O
Tokens _ _ O
, _ _ O
not _ _ O
chars _ _ O
. _ _ O
o _ _ O
and _ _ O
there _ _ O
are _ _ O
three _ _ O
parsing _ _ O
methods _ _ O
for _ _ O
the _ _ O
three _ _ O
main _ _ O
rules _ _ O
. _ _ O
● _ _ O
this _ _ O
real _ _ O
parser _ _ O
handles _ _ O
errors _ _ O
, _ _ O
too _ _ O
. _ _ O
o _ _ O
the _ _ O
expect_blah _ _ O
methods _ _ O
and _ _ O
the _ _ O
match _ _ O
in _ _ O
parse_exp _ _ O
deal _ _ O
with _ _ O
unexpected _ _ O
terminals _ _ O
( _ _ O
tokens _ _ O
) _ _ O
in _ _ O
various _ _ O
positions _ _ O
. _ _ O
▪ _ _ O
they _ _ O
also _ _ O
give _ _ O
customized _ _ O
errors _ _ O
for _ _ O
each _ _ O
of _ _ O
these _ _ O
possibilities _ _ O
. _ _ O
▪ _ _ O
there _ _ O
's _ _ O
no _ _ O
location _ _ O
info _ _ O
, _ _ O
because _ _ O
it _ _ O
's _ _ O
an _ _ O
example _ _ O
. _ _ O
: _ _ O
B _ _ O


 _ _ O
19 _ _ O


 _ _ O
Limits _ _ O
of _ _ O
Recursive _ _ O
Descent _ _ O
time _ _ O
check _ _ O
: _ _ O
≤ _ _ O
68 _ _ O


 _ _ O
20 _ _ O


 _ _ O
If _ _ O
it _ _ O
works _ _ O
so _ _ O
well _ _ O
, _ _ O
why _ _ O
not _ _ O
use _ _ O
it _ _ O
for _ _ O
everything _ _ O
? _ _ O
● _ _ O
there _ _ O
are _ _ O
lots _ _ O
of _ _ O
cases _ _ O
where _ _ O
recursive _ _ O
descent _ _ O
works _ _ O
great _ _ O
! _ _ O
o _ _ O
import _ _ O
java.util.Arrays _ _ O
; _ _ O
o _ _ O
use _ _ O
std _ _ O
: _ _ O
: _ _ O
blah _ _ O
; _ _ O
o _ _ O
fn _ _ O
name _ _ O
( _ _ O
) _ _ O
{ _ _ O
... _ _ O
} _ _ O
o _ _ O
class _ _ O
A _ _ O
{ _ _ O
... _ _ O
} _ _ O
o _ _ O
if _ _ O
x _ _ O
= _ _ O
= _ _ O
y _ _ O
{ _ _ O
... _ _ O
} _ _ O
o _ _ O
match _ _ O
value _ _ O
{ _ _ O
... _ _ O
} _ _ O
● _ _ O
but _ _ O
there _ _ O
's _ _ O
something _ _ O
all _ _ O
of _ _ O
these _ _ O
things _ _ O
have _ _ O
in _ _ O
common _ _ O
: _ _ O
o _ _ O
they _ _ O
all _ _ O
start _ _ O
with _ _ O
a _ _ O
token _ _ O
that _ _ O
unambiguously _ _ O
indicates _ _ O
which _ _ O
rule _ _ O
should _ _ O
be _ _ O
used _ _ O
to _ _ O
parse _ _ O
them _ _ O
. _ _ O
o _ _ O
if _ _ O
you _ _ O
do _ _ O
n't _ _ O
have _ _ O
that _ _ O
, _ _ O
recursive _ _ O
descent _ _ O
gets _ _ O
a _ _ O
lot _ _ O
harder _ _ O
to _ _ O
use _ _ O
. _ _ O
● _ _ O
but _ _ O
, _ _ O
what _ _ O
kind _ _ O
of _ _ O
code _ _ O
looks _ _ O
like _ _ O
that _ _ O
? _ _ O


 _ _ O
21 _ _ O


 _ _ O
Expressions _ _ O
! _ _ O
● _ _ O
we _ _ O
want _ _ O
to _ _ O
be _ _ O
able _ _ O
to _ _ O
write _ _ O
expressions _ _ O
like _ _ O
we _ _ O
do _ _ O
in _ _ O
math _ _ O
. _ _ O
o _ _ O
that _ _ O
is _ _ O
, _ _ O
we _ _ O
want _ _ O
4 _ _ O
+ _ _ O
5 _ _ O
, _ _ O
not _ _ O
( _ _ O
add _ _ O
4 _ _ O
5 _ _ O
) _ _ O
. _ _ O
● _ _ O
but _ _ O
this _ _ O
presents _ _ O
a _ _ O
few _ _ O
problems _ _ O
. _ _ O


 _ _ O
Input _ _ O


 _ _ O
Output _ _ O


 _ _ O
x _ _ O
+ _ _ O
y _ _ O
+ _ _ O
z _ _ O


 _ _ O
( _ _ O
x _ _ O
+ _ _ O
y _ _ O
) _ _ O
+ _ _ O
z _ _ O
or _ _ O
either _ _ O
is _ _ O
fine _ _ O
.. _ _ O
? _ _ O
what _ _ O
x _ _ O
+ _ _ O
( _ _ O
y _ _ O
+ _ _ O
z _ _ O
) _ _ O
? _ _ O
if _ _ O
it _ _ O
were _ _ O
* _ _ O
, _ _ O
- _ _ O
, _ _ O
or _ _ O
/ _ _ O
? _ _ O


 _ _ O
x _ _ O
+ _ _ O
4 _ _ O
* _ _ O
y _ _ O


 _ _ O
( _ _ O
x _ _ O
+ _ _ O
4 _ _ O
) _ _ O
* _ _ O
y _ _ O
or _ _ O
x _ _ O
+ _ _ O
( _ _ O
4 _ _ O
* _ _ O
y _ _ O
) _ _ O
? _ _ O


 _ _ O
the _ _ O
second _ _ O
one _ _ O
is _ _ O
right _ _ O
. _ _ O


 _ _ O
and _ _ O
if _ _ O
we _ _ O
allow _ _ O
* _ _ O
* _ _ O
for _ _ O
exponents _ _ O
, _ _ O
like _ _ O
Python _ _ O
: _ _ O


 _ _ O
2 _ _ O
* _ _ O
* _ _ O
x _ _ O
* _ _ O
* _ _ O
2 _ _ O


 _ _ O
( _ _ O
2 _ _ O
* _ _ O
* _ _ O
x _ _ O
) _ _ O
* _ _ O
* _ _ O
2 _ _ O
or _ _ O
2 _ _ O
* _ _ O
* _ _ O
( _ _ O
x _ _ O
* _ _ O
* _ _ O
2 _ _ O
) _ _ O
? _ _ O


 _ _ O
the _ _ O
second _ _ O
one _ _ O
is _ _ O
right _ _ O
. _ _ O
22 _ _ O


 _ _ O
Even _ _ O
worse _ _ O
... _ _ O
● _ _ O
how _ _ O
do _ _ O
we _ _ O
know _ _ O
what _ _ O
kind _ _ O
of _ _ O
expression _ _ O
we _ _ O
're _ _ O
looking _ _ O
at _ _ O
? _ _ O


 _ _ O
( _ _ O
3 _ _ O
+ _ _ O
x _ _ O
+ _ _ O
y _ _ O
* _ _ O
2 _ _ O
) _ _ O
/ _ _ O
50 _ _ O
let _ _ O
's _ _ O
say _ _ O
our _ _ O
parser _ _ O
is _ _ O
looking _ _ O
at _ _ O
this _ _ O
token _ _ O
.... _ _ O


 _ _ O
... _ _ O
how _ _ O
will _ _ O
it _ _ O
know _ _ O
it _ _ O
's _ _ O
a _ _ O
division _ _ O
until _ _ O
it _ _ O
gets _ _ O
here _ _ O
? _ _ O


 _ _ O
so _ _ O
what _ _ O
do _ _ O
we _ _ O
do _ _ O
? _ _ O
look _ _ O
ahead _ _ O
? _ _ O
how _ _ O
many _ _ O
tokens _ _ O
? _ _ O
5 _ _ O
? _ _ O
10 _ _ O
? _ _ O
is _ _ O
there _ _ O
a _ _ O
limit _ _ O
? _ _ O
what _ _ O
we _ _ O
would _ _ O
have _ _ O
to _ _ O
do _ _ O
here _ _ O
is _ _ O
try _ _ O
each _ _ O
possible _ _ O
parse _ _ O
, _ _ O
and _ _ O
backtrack _ _ O
if _ _ O
we _ _ O
mess _ _ O
up _ _ O
. _ _ O
23 _ _ O


 _ _ O
OH _ _ O
NO _ _ O
, _ _ O
BACKTRACKING _ _ O
● _ _ O
this _ _ O
is _ _ O
an _ _ O
exponential _ _ O
time _ _ O
( _ _ O
O _ _ O
( _ _ O
2n _ _ O
) _ _ O
) _ _ O
algorithm _ _ O
! _ _ O
just _ _ O
awful _ _ O
! _ _ O
o _ _ O
and _ _ O
from _ _ O
an _ _ O
intuitive _ _ O
sense _ _ O
, _ _ O
it _ _ O
feels _ _ O
kind _ _ O
of _ _ O
silly _ _ O
to _ _ O
commit _ _ O
to _ _ O
parsing _ _ O
something _ _ O
when _ _ O
you _ _ O
do _ _ O
n't _ _ O
actually _ _ O
have _ _ O
enough _ _ O
information _ _ O
yet _ _ O
to _ _ O
parse _ _ O
it _ _ O
. _ _ O
● _ _ O
so _ _ O
for _ _ O
these _ _ O
( _ _ O
and _ _ O
other _ _ O
similar _ _ O
) _ _ O
situations _ _ O
, _ _ O
there _ _ O
is _ _ O
another _ _ O
way _ _ O
to _ _ O
parse _ _ O
that _ _ O
's _ _ O
a _ _ O
little _ _ O
more _ _ O
mind-bending _ _ O
, _ _ O
but _ _ O
more _ _ O
powerful _ _ O
. _ _ O
o _ _ O
that _ _ O
's _ _ O
for _ _ O
next _ _ O
time _ _ O
! _ _ O


 _ _ O
24 _ _ O


 _ _ O
Error _ _ O
Reporting _ _ O
time _ _ O
check _ _ O
: _ _ O
≤ _ _ O
85 _ _ O


 _ _ O
25 _ _ O


 _ _ O
Compilers _ _ O
have _ _ O
a _ _ O
bit _ _ O
of _ _ O
a _ _ O
reputation _ _ O
● _ _ O
how _ _ O
many _ _ O
times _ _ O
have _ _ O
you _ _ O
gotten _ _ O
compiler _ _ O
errors _ _ O
that _ _ O
: _ _ O
o _ _ O
seemed _ _ O
totally _ _ O
confused _ _ O
by _ _ O
very _ _ O
simple _ _ O
/ _ _ O
common _ _ O
typos _ _ O
, _ _ O
like _ _ O
missing _ _ O
a _ _ O
semicolon _ _ O
or _ _ O
comma _ _ O
or _ _ O
closing _ _ O
brace _ _ O
? _ _ O
o _ _ O
pointed _ _ O
100 _ _ O
lines _ _ O
after _ _ O
where _ _ O
the _ _ O
actual _ _ O
error _ _ O
was _ _ O
? _ _ O
o _ _ O
used _ _ O
weird _ _ O
terminology _ _ O
, _ _ O
like _ _ O
" _ _ O
specifier-qualifier-list _ _ O
" _ _ O
? _ _ O
o _ _ O
gave _ _ O
almost _ _ O
no _ _ O
information _ _ O
, _ _ O
like _ _ O
" _ _ O
syntax _ _ O
error _ _ O
" _ _ O
? _ _ O
● _ _ O
is _ _ O
it _ _ O
because _ _ O
the _ _ O
compiler _ _ O
writers _ _ O
suck _ _ O
? _ _ O
o _ _ O
no _ _ O
o _ _ O
good _ _ O
error _ _ O
reporting _ _ O
is _ _ O
really _ _ O
hard _ _ O
to _ _ O
do _ _ O
right _ _ O
, _ _ O
okay _ _ O
, _ _ O


 _ _ O
26 _ _ O


 _ _ O
Who _ _ O
are _ _ O
error _ _ O
messages _ _ O
for _ _ O
? _ _ O
● _ _ O
I _ _ O
've _ _ O
said _ _ O
it _ _ O
many _ _ O
times _ _ O
: _ _ O
programming _ _ O
languages _ _ O
exist _ _ O
for _ _ O
humans _ _ O
. _ _ O
● _ _ O
so _ _ O
when _ _ O
a _ _ O
compiler _ _ O
gives _ _ O
errors _ _ O
, _ _ O
they _ _ O
should _ _ O
be _ _ O
... _ _ O
for _ _ O
humans _ _ O
! _ _ O
● _ _ O
but _ _ O
there _ _ O
are _ _ O
two _ _ O
things _ _ O
working _ _ O
against _ _ O
us _ _ O
here _ _ O
. _ _ O
the _ _ O
compiler _ _ O
is _ _ O
a _ _ O
dumb _ _ O
algorithm _ _ O
that _ _ O
does _ _ O
n't _ _ O
understand _ _ O
our _ _ O
human _ _ O
mistakes _ _ O


 _ _ O
f _ _ O
( _ _ O
3 _ _ O
4 _ _ O
) _ _ O
----^ _ _ O
expected _ _ O
` _ _ O
) _ _ O
' _ _ O
or _ _ O
` _ _ O
, _ _ O
' _ _ O
in _ _ O
argument-list _ _ O
, _ _ O
not _ _ O
` _ _ O
4 _ _ O
' _ _ O


 _ _ O
people _ _ O
who _ _ O
write _ _ O
compilers _ _ O
tend _ _ O
to _ _ O
forget _ _ O
that _ _ O
other _ _ O
people _ _ O
do _ _ O
n't _ _ O
know _ _ O
how _ _ O
they _ _ O
work _ _ O


 _ _ O
( _ _ O
substitution _ _ O
of _ _ O
deduced _ _ O
template _ _ O
arguments _ _ O
resulted _ _ O
in _ _ O
errors _ _ O
seen _ _ O
above _ _ O
) _ _ O
27 _ _ O


 _ _ O
Carry _ _ O
on _ _ O
, _ _ O
my _ _ O
wayward _ _ O
son _ _ O
● _ _ O
you _ _ O
know _ _ O
how _ _ O
you _ _ O
sometimes _ _ O
get _ _ O
like _ _ O
1000 _ _ O
error _ _ O
messages _ _ O
? _ _ O
o _ _ O
and _ _ O
it _ _ O
's _ _ O
all _ _ O
because _ _ O
you _ _ O
forgot _ _ O
ONE _ _ O
closing _ _ O
brace _ _ O
? _ _ O
● _ _ O
this _ _ O
is _ _ O
error _ _ O
recovery _ _ O
: _ _ O
instead _ _ O
of _ _ O
stopping _ _ O
at _ _ O
the _ _ O
first _ _ O
error _ _ O
, _ _ O
the _ _ O
compiler _ _ O
tries _ _ O
to _ _ O
keep _ _ O
going _ _ O
. _ _ O
enum _ _ O
E _ _ O
{ _ _ O
X _ _ O
, _ _ O
Y _ _ O
/ _ _ O
/ _ _ O
uh _ _ O
oh _ _ O
. _ _ O


 _ _ O
but _ _ O
how _ _ O
would _ _ O
you _ _ O
algorithmically _ _ O
determine _ _ O
where _ _ O
the _ _ O
closing _ _ O
brace _ _ O
should _ _ O
go _ _ O
? _ _ O


 _ _ O
fn _ _ O
func _ _ O
( _ _ O
) _ _ O
{ _ _ O
let _ _ O
x _ _ O
= _ _ O
E _ _ O
: _ _ O
: _ _ O
X _ _ O
/ _ _ O
/ _ _ O
oops _ _ O
( _ _ O
blah _ _ O
) _ _ O
.y _ _ O
( _ _ O
) _ _ O
; _ _ O
} _ _ O


 _ _ O
this _ _ O
could _ _ O
even _ _ O
parse _ _ O
differently _ _ O
depending _ _ O
on _ _ O
where _ _ O
we _ _ O
infer _ _ O
the _ _ O
semicolon _ _ O
" _ _ O
should _ _ O
" _ _ O
be _ _ O
. _ _ O
28 _ _ O


 _ _ O
To _ _ O
recover _ _ O
or _ _ O
not _ _ O
? _ _ O
● _ _ O
in _ _ O
the _ _ O
past _ _ O
, _ _ O
languages _ _ O
were _ _ O
simpler _ _ O
, _ _ O
and _ _ O
so _ _ O
was _ _ O
error _ _ O
recovery _ _ O
. _ _ O
o _ _ O
compilers _ _ O
also _ _ O
ran _ _ O
on _ _ O
huge _ _ O
computers _ _ O
in _ _ O
batch _ _ O
jobs _ _ O
. _ _ O
o _ _ O
since _ _ O
a _ _ O
compile _ _ O
might _ _ O
take _ _ O
hours _ _ O
, _ _ O
it _ _ O
was _ _ O
useful _ _ O
to _ _ O
report _ _ O
as _ _ O
many _ _ O
errors _ _ O
as _ _ O
possible _ _ O
. _ _ O
● _ _ O
but _ _ O
now _ _ O
, _ _ O
a _ _ O
really _ _ O
, _ _ O
really _ _ O
common _ _ O
thing _ _ O
to _ _ O
do _ _ O
is _ _ O
: _ _ O
o _ _ O
compile _ _ O
, _ _ O
fix _ _ O
the _ _ O
first _ _ O
error _ _ O
, _ _ O
repeat _ _ O
▪ _ _ O
( _ _ O
I _ _ O
really _ _ O
recommend _ _ O
you _ _ O
do _ _ O
this _ _ O
if _ _ O
you _ _ O
do _ _ O
n't _ _ O
already _ _ O
) _ _ O


 _ _ O
● _ _ O
so _ _ O
maybe _ _ O
stopping _ _ O
at _ _ O
the _ _ O
first _ _ O
error _ _ O
is _ _ O
fine _ _ O
? _ _ O
o _ _ O
but _ _ O
what _ _ O
about _ _ O
IDEs _ _ O
? _ _ O
o _ _ O
they _ _ O
can _ _ O
show _ _ O
multiple _ _ O
errors _ _ O
inline _ _ O
with _ _ O
the _ _ O
code _ _ O
o _ _ O
so _ _ O
maybe _ _ O
there _ _ O
's _ _ O
still _ _ O
some _ _ O
use _ _ O
to _ _ O
it _ _ O
? _ _ O
▪ _ _ O
or _ _ O
does _ _ O
it _ _ O
just _ _ O
make _ _ O
using _ _ O
an _ _ O
IDE _ _ O
more _ _ O
annoying _ _ O
? _ _ O
: _ _ O
^ _ _ O
) _ _ O


 _ _ O
● _ _ O
personally _ _ O
I _ _ O
think _ _ O
lexing _ _ O
/ _ _ O
parsing _ _ O
error _ _ O
recovery _ _ O
is _ _ O
pointless _ _ O
, _ _ O
but _ _ O
giving _ _ O
multiple _ _ O
semantic _ _ O
errors _ _ O
can _ _ O
still _ _ O
be _ _ O
useful _ _ O
. _ _ O
sometimes _ _ O
. _ _ O
29 _ _ O


 _ _ O
A _ _ O
philosophy _ _ O
for _ _ O
good _ _ O
errors _ _ O
● _ _ O
there _ _ O
are _ _ O
three _ _ O
ways _ _ O
to _ _ O
improve _ _ O
error _ _ O
messages _ _ O
. _ _ O
1 _ _ O
. _ _ O
say _ _ O
where _ _ O
it _ _ O
is _ _ O
test.foo _ _ O
( _ _ O
9 _ _ O
: _ _ O
17 _ _ O
) _ _ O


 _ _ O
bare _ _ O
minimum _ _ O
... _ _ O


 _ _ O
test.foo _ _ O
( _ _ O
9 _ _ O
: _ _ O
17 _ _ O
) _ _ O
: _ _ O
for _ _ O
num _ _ O
in _ _ O
10 _ _ O
{ _ _ O
^ _ _ O
here _ _ O
better _ _ O
! _ _ O


 _ _ O
2 _ _ O
. _ _ O
give _ _ O
a _ _ O
unique _ _ O
message _ _ O
for _ _ O
that _ _ O
particular _ _ O
error _ _ O
expected _ _ O
' _ _ O
, _ _ O
' _ _ O
, _ _ O
not _ _ O
' _ _ O
{ _ _ O
' _ _ O
ehh _ _ O
... _ _ O


 _ _ O
for-loop _ _ O
missing _ _ O
upper _ _ O
bound _ _ O
better _ _ O
! _ _ O


 _ _ O
3 _ _ O
. _ _ O
extra _ _ O
credit _ _ O
: _ _ O
tell _ _ O
the _ _ O
user _ _ O
how _ _ O
they _ _ O
might _ _ O
fix _ _ O
it _ _ O


 _ _ O
help _ _ O
: _ _ O
maybe _ _ O
you _ _ O
meant _ _ O
" _ _ O
for _ _ O
num _ _ O
in _ _ O
10 _ _ O
, _ _ O
something _ _ O
" _ _ O
? _ _ O
^^^^^^^^^^^ _ _ O
30 _ _ O


 _ _ O
First _ _ O
: _ _ O
location _ _ O
information _ _ O
● _ _ O
the _ _ O
lexer _ _ O
can _ _ O
associate _ _ O
a _ _ O
line _ _ O
and _ _ O
column _ _ O
with _ _ O
each _ _ O
token _ _ O
. _ _ O
o _ _ O
well _ _ O
, _ _ O
some _ _ O
tokens _ _ O
span _ _ O
more _ _ O
than _ _ O
one _ _ O
column _ _ O
... _ _ O
o _ _ O
or _ _ O
even _ _ O
more _ _ O
than _ _ O
one _ _ O
line _ _ O
, _ _ O
if _ _ O
you _ _ O
allow _ _ O
multi-line _ _ O
strings _ _ O
! _ _ O
o _ _ O
so _ _ O
maybe _ _ O
each _ _ O
token _ _ O
should _ _ O
have _ _ O
a _ _ O
range _ _ O
of _ _ O
locations _ _ O
? _ _ O
hmm _ _ O
● _ _ O
when _ _ O
parsing _ _ O
, _ _ O
that _ _ O
info _ _ O
can _ _ O
be _ _ O
carried _ _ O
from _ _ O
the _ _ O
tokens _ _ O
into _ _ O
the _ _ O
AST _ _ O
. _ _ O
o _ _ O
that _ _ O
way _ _ O
, _ _ O
we _ _ O
can _ _ O
report _ _ O
errors _ _ O
during _ _ O
semantic _ _ O
analysis _ _ O
. _ _ O
o _ _ O
or _ _ O
maybe _ _ O
we _ _ O
want _ _ O
to _ _ O
refer _ _ O
back _ _ O
to _ _ O
the _ _ O
token _ _ O
list _ _ O
somehow _ _ O
... _ _ O
? _ _ O
▪ _ _ O
there _ _ O
are _ _ O
lots _ _ O
of _ _ O
ways _ _ O
to _ _ O
implement _ _ O
this _ _ O
! _ _ O


 _ _ O
31 _ _ O


 _ _ O
Second _ _ O
: _ _ O
accurate _ _ O
error _ _ O
messages _ _ O
● _ _ O
it _ _ O
's _ _ O
really _ _ O
easy _ _ O
to _ _ O
make _ _ O
unhelpful _ _ O
, _ _ O
uninformative _ _ O
messages _ _ O
, _ _ O
sadly _ _ O
! _ _ O
● _ _ O
giving _ _ O
accurate _ _ O
errors _ _ O
is _ _ O
largely _ _ O
about _ _ O
customizing _ _ O
the _ _ O
error _ _ O
messages _ _ O
for _ _ O
each _ _ O
place _ _ O
an _ _ O
error _ _ O
could _ _ O
happen _ _ O
. _ _ O
o _ _ O
looking _ _ O
through _ _ O
the _ _ O
parser _ _ O
code _ _ O
, _ _ O
every _ _ O
? _ _ O
is _ _ O
a _ _ O
potential _ _ O
error _ _ O
spot _ _ O
. _ _ O
o _ _ O
in _ _ O
parse_paren_exp _ _ O
, _ _ O
there _ _ O
are _ _ O
several _ _ O
of _ _ O
these _ _ O
. _ _ O
● _ _ O
matches _ _ O
are _ _ O
another _ _ O
place _ _ O
ripe _ _ O
for _ _ O
better _ _ O
errors _ _ O
: _ _ O
o _ _ O
in _ _ O
parse_exp _ _ O
, _ _ O
there _ _ O
are _ _ O
a _ _ O
number _ _ O
of _ _ O
possible _ _ O
options _ _ O
, _ _ O
so _ _ O
we _ _ O
should _ _ O
list _ _ O
the _ _ O
options _ _ O
in _ _ O
the _ _ O
error _ _ O
message _ _ O
, _ _ O
like _ _ O
" _ _ O
expected _ _ O
identifier _ _ O
, _ _ O
integer _ _ O
, _ _ O
or _ _ O
parenthesized _ _ O
expression _ _ O
, _ _ O
not _ _ O
blah _ _ O
blah _ _ O
" _ _ O
● _ _ O
one _ _ O
possibility _ _ O
is _ _ O
to _ _ O
pass _ _ O
some _ _ O
kind _ _ O
of _ _ O
" _ _ O
error _ _ O
context _ _ O
" _ _ O
to _ _ O
the _ _ O
parsing _ _ O
functions _ _ O
which _ _ O
can _ _ O
be _ _ O
used _ _ O
to _ _ O
tailor _ _ O
the _ _ O
messages _ _ O
better _ _ O
o _ _ O
since _ _ O
parse_exp _ _ O
is _ _ O
called _ _ O
from _ _ O
multiple _ _ O
places _ _ O
, _ _ O
the _ _ O
error _ _ O
message _ _ O
might _ _ O
be _ _ O
different _ _ O
depending _ _ O
on _ _ O
who _ _ O
calls _ _ O
it _ _ O
. _ _ O
32 _ _ O


 _ _ O
Third _ _ O
: _ _ O
giving _ _ O
help _ _ O
● _ _ O
this _ _ O
is _ _ O
extremely _ _ O
broad _ _ O
and _ _ O
it _ _ O
's _ _ O
up _ _ O
to _ _ O
you _ _ O
what _ _ O
to _ _ O
say _ _ O
. _ _ O
o _ _ O
it _ _ O
's _ _ O
really _ _ O
kind _ _ O
of _ _ O
an _ _ O
extension _ _ O
of _ _ O
the _ _ O
previous _ _ O
rule _ _ O
. _ _ O
● _ _ O
have _ _ O
a _ _ O
look _ _ O
at _ _ O
the _ _ O
error _ _ O
messages _ _ O
Rust _ _ O
gives _ _ O
. _ _ O
o _ _ O
sometimes _ _ O
it _ _ O
's _ _ O
as _ _ O
simple _ _ O
as _ _ O
" _ _ O
remove _ _ O
this _ _ O
semicolon _ _ O
. _ _ O
" _ _ O
o _ _ O
sometimes _ _ O
it _ _ O
links _ _ O
to _ _ O
the _ _ O
appropriate _ _ O
part _ _ O
of _ _ O
the _ _ O
docs _ _ O
. _ _ O
o _ _ O
sometimes _ _ O
it _ _ O
even _ _ O
detects _ _ O
common _ _ O
mistakes _ _ O
and _ _ O
explains _ _ O
why _ _ O
they _ _ O
wo _ _ O
n't _ _ O
work _ _ O
. _ _ O
it _ _ O
's _ _ O
amazing _ _ O
! _ _ O


 _ _ O
33 _ _ O


 _ _ O


