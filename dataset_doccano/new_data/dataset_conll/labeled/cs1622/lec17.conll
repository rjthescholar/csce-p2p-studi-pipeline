['train_set', 'labeled']|cs1622|lec17
-DOCSTART- -X- -X- O

Local _ _ O
Optimization _ _ B-Concept
CS _ _ O
1622 _ _ O
Jarrett _ _ O
Billingsley _ _ O


 _ _ O
Class _ _ O
Announcements _ _ O
● _ _ O
buhhhhhhh _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O
? _ _ O


 _ _ O
2 _ _ O


 _ _ O
Optimization _ _ B-Concept


 _ _ O
3 _ _ O


 _ _ O
What _ _ O
is _ _ O
it _ _ O
? _ _ O
● _ _ O
optimization _ _ B-Concept
is _ _ O
the _ _ O
name _ _ O
for _ _ O
any _ _ O
technique _ _ O
which _ _ O
: _ _ O
o _ _ O
rewrites _ _ O
part _ _ O
of _ _ O
a _ _ O
program _ _ O
... _ _ O
o _ _ O
in _ _ O
order _ _ O
to _ _ O
improve _ _ O
resource _ _ B-Concept
utilization _ _ I-Concept
... _ _ O
o _ _ O
without _ _ O
changing _ _ O
its _ _ O
behavior _ _ O
. _ _ O
● _ _ O
" _ _ O
resource _ _ B-Concept
utilization _ _ I-Concept
" _ _ O
can _ _ O
mean _ _ O
many _ _ O
things _ _ O
, _ _ O
such _ _ O
as _ _ O
: _ _ O
o _ _ O
time _ _ B-Concept
( _ _ O
how _ _ O
quickly _ _ O
the _ _ O
code _ _ O
executes _ _ O
) _ _ O
o _ _ O
code _ _ B-Concept
size _ _ I-Concept
( _ _ O
how _ _ O
many _ _ O
bytes _ _ O
the _ _ O
code _ _ O
takes _ _ O
up _ _ O
) _ _ O
o _ _ O
memory _ _ B-Concept
size _ _ I-Concept
( _ _ O
how _ _ O
many _ _ O
bytes _ _ O
the _ _ O
data _ _ O
/ _ _ O
variables _ _ O
take _ _ O
up _ _ O
) _ _ O
o _ _ O
power _ _ B-Concept
( _ _ O
how _ _ O
many _ _ O
watts _ _ O
the _ _ O
code _ _ O
uses _ _ O
when _ _ O
executed _ _ O
) _ _ O
o _ _ O
registers _ _ B-Concept
( _ _ O
how _ _ O
many _ _ O
/ _ _ O
what _ _ O
kinds _ _ O
of _ _ O
registers _ _ B-Concept
are _ _ O
used _ _ O
) _ _ O
● _ _ O
some _ _ O
of _ _ O
these _ _ O
goals _ _ O
are _ _ O
even _ _ O
contradictory _ _ O
! _ _ O
o _ _ O
so _ _ O
compilers _ _ O
let _ _ O
you _ _ O
control _ _ O
which _ _ O
optimizations _ _ O
are _ _ O
performed _ _ O
. _ _ O


 _ _ O
4 _ _ O


 _ _ O
We _ _ O
do _ _ O
it _ _ O
all _ _ O
the _ _ O
time _ _ B-Concept
● _ _ O
many _ _ O
of _ _ O
the _ _ O
optimizations _ _ O
we _ _ O
'll _ _ O
discuss _ _ O
are _ _ O
just _ _ O
automated _ _ O
versions _ _ O
of _ _ O
things _ _ O
human _ _ O
programmers _ _ O
do _ _ O
. _ _ O
func1 _ _ O
( _ _ O
some.long _ _ O
+ _ _ O
code _ _ O
[ _ _ O
i _ _ O
] _ _ O
) _ _ O
; _ _ O
func2 _ _ O
( _ _ O
some.long _ _ O
+ _ _ O
code _ _ O
[ _ _ O
i _ _ O
] _ _ O
) _ _ O
; _ _ O


 _ _ O
let _ _ O
v _ _ O
= _ _ O
some.long _ _ O
+ _ _ O
code _ _ O
[ _ _ O
i _ _ O
] _ _ O
; _ _ O
func1 _ _ O
( _ _ O
v _ _ O
) _ _ O
; _ _ O
func2 _ _ O
( _ _ O
v _ _ O
) _ _ O
; _ _ O


 _ _ O
this _ _ O
technique _ _ O
is _ _ O
called _ _ O
common _ _ B-Concept
subexpression _ _ I-Concept
elimination _ _ I-Concept
( _ _ O
CSE _ _ B-Concept
) _ _ O
. _ _ O
let _ _ O
x _ _ O
= _ _ O
1024 _ _ O
* _ _ O
4 _ _ O
; _ _ O


 _ _ O
let _ _ O
x _ _ O
= _ _ O
4096 _ _ O
; _ _ O


 _ _ O
this _ _ O
is _ _ O
constant _ _ B-Concept
folding _ _ I-Concept
. _ _ O
let _ _ O
x _ _ O
= _ _ O
pow _ _ O
( _ _ O
y _ _ O
, _ _ O
2 _ _ O
) _ _ O
; _ _ O


 _ _ O
let _ _ O
x _ _ O
= _ _ O
y _ _ O
* _ _ O
y _ _ O
; _ _ O


 _ _ O
this _ _ O
is _ _ O
strength _ _ B-Concept
reduction _ _ I-Concept
: _ _ O
using _ _ O
a _ _ O
simpler _ _ O
, _ _ O
faster _ _ O
operation _ _ B-Concept
that _ _ O
gives _ _ O
the _ _ O
same _ _ O
answer _ _ O
as _ _ O
a _ _ O
more _ _ O
complex _ _ O
one _ _ O
. _ _ O
5 _ _ O


 _ _ O
Optimization _ _ B-Concept
scope _ _ O
● _ _ O
we _ _ O
'll _ _ O
be _ _ O
doing _ _ O
optimizations _ _ O
on _ _ O
our _ _ O
IR _ _ B-Concept
, _ _ O
rather _ _ O
than _ _ O
the _ _ O
AST _ _ B-Concept
. _ _ O
func _ _ O


 _ _ O
local _ _ B-Concept
optimizations _ _ I-Concept
work _ _ O
on _ _ O
code _ _ O
within _ _ O
a _ _ O
single _ _ O
BB _ _ B-Concept
. _ _ O


 _ _ O
global _ _ B-Concept
optimizations _ _ I-Concept
work _ _ O
on _ _ O
one _ _ O
function _ _ O
's _ _ O
whole _ _ O
CFG _ _ B-Concept
. _ _ O
( _ _ O
I _ _ O
know _ _ O
, _ _ O
" _ _ O
global _ _ O
" _ _ O
sounds _ _ O


 _ _ O
main _ _ O


 _ _ O
interprocedural _ _ O
optimizations _ _ O
work _ _ O
on _ _ O
all _ _ O
functions _ _ O
in _ _ O
the _ _ O
program _ _ O
. _ _ O


 _ _ O
like _ _ O
it _ _ O
should _ _ O
be _ _ O
the _ _ O
whole _ _ O
program _ _ O
but _ _ O
it _ _ O
's _ _ O
not _ _ O
) _ _ O


 _ _ O
as _ _ O
you _ _ O
might _ _ O
imagine _ _ O
, _ _ O
local _ _ O
is _ _ O
the _ _ O
simplest _ _ O
; _ _ O
global _ _ O
is _ _ O
more _ _ O
complex _ _ O
; _ _ O
and _ _ O
interprocedural _ _ O
is _ _ O
the _ _ O
most _ _ O
complex _ _ O
. _ _ O


 _ _ O
6 _ _ O


 _ _ O
Dead _ _ B-Concept
code _ _ I-Concept
elimination _ _ B-Concept
( _ _ O
DCE _ _ O
) _ _ O
● _ _ O
a _ _ O
common _ _ O
technique _ _ O
in _ _ O
Java _ _ O
is _ _ O
to _ _ O
use _ _ O
static _ _ O
final _ _ O
variables _ _ O
to _ _ O
enable _ _ O
or _ _ O
disable _ _ O
pieces _ _ O
of _ _ O
code _ _ O
. _ _ O
in _ _ O
those _ _ O
cases _ _ O
, _ _ O
the _ _ O
condition _ _ O
is _ _ O
a _ _ O
constant _ _ O
, _ _ O
and _ _ O
one _ _ O
or _ _ O
more _ _ O
control _ _ O
paths _ _ O
become _ _ O
" _ _ O
dead _ _ O
code _ _ O
. _ _ O
" _ _ O
static _ _ O
final _ _ O
boolean _ _ O
DEBUG _ _ O
= _ _ O
false _ _ O
; _ _ O
public _ _ O
int _ _ O
getWhatever _ _ O
( _ _ O
) _ _ O
{ _ _ O
if _ _ O
( _ _ O
DEBUG _ _ O
) _ _ O
System.err.println _ _ O
( _ _ O
"here _ _ O
" _ _ O
) _ _ O
; _ _ O


 _ _ O
public _ _ O
int _ _ O
getWhatever _ _ O
( _ _ O
) _ _ O
{ _ _ O
return _ _ O
this.whatever _ _ O
; _ _ O
} _ _ O


 _ _ O
return _ _ O
this.whatever _ _ O
; _ _ O
} _ _ O


 _ _ O
this _ _ O
is _ _ O
a _ _ O
global _ _ O
optimization _ _ O
, _ _ O
as _ _ O
it _ _ O
operates _ _ O
on _ _ O
the _ _ O
CFG _ _ O
of _ _ O
the _ _ O
method _ _ O
. _ _ O
some _ _ O
BBs _ _ O
were _ _ O
removed _ _ O
from _ _ O
this _ _ O
method _ _ O
. _ _ O
7 _ _ O


 _ _ O
Function _ _ O
( _ _ O
or _ _ O
method _ _ O
) _ _ O
inlining _ _ O
● _ _ O
a _ _ O
very _ _ O
common _ _ O
interprocedural _ _ O
optimization _ _ O
is _ _ O
function _ _ O
inlining _ _ O
: _ _ O
eliminating _ _ O
a _ _ O
call _ _ O
by _ _ O
copying _ _ O
the _ _ O
code _ _ O
of _ _ O
the _ _ O
callee _ _ O
into _ _ O
the _ _ O
caller _ _ O
. _ _ O
public _ _ O
void _ _ O
printWhatever _ _ O
( _ _ O
) _ _ O
{ _ _ O
int _ _ O
w _ _ O
= _ _ O
this.getWhatever _ _ O
( _ _ O
) _ _ O
; _ _ O
System.out.println _ _ O
( _ _ O
w _ _ O
) _ _ O
; _ _ O
} _ _ O
public _ _ O
int _ _ O
getWhatever _ _ O
( _ _ O
) _ _ O
{ _ _ O
return _ _ O
this.whatever _ _ O
; _ _ O
} _ _ O


 _ _ O
public _ _ O
void _ _ O
printWhatever _ _ O
( _ _ O
) _ _ O
{ _ _ O
int _ _ O
w _ _ O
= _ _ O
this.whatever _ _ O
; _ _ O
System.out.println _ _ O
( _ _ O
w _ _ O
) _ _ O
; _ _ O
} _ _ O


 _ _ O
think _ _ O
about _ _ O
all _ _ O
the _ _ O
work _ _ O
this _ _ O
is _ _ O
saving _ _ O
- _ _ O
no _ _ O
more _ _ O
passing _ _ O
arguments _ _ O
, _ _ O
doing _ _ O
the _ _ O
function _ _ O
prologue _ _ O
and _ _ O
epilogue _ _ O
, _ _ O
messing _ _ O
with _ _ O
the _ _ O
stack _ _ O
... _ _ O


 _ _ O
but _ _ O
knowing _ _ O
when _ _ O
it _ _ O
's _ _ O
okay _ _ O
to _ _ O
do _ _ O
this _ _ O
, _ _ O
and _ _ O
knowing _ _ O
whether _ _ O
doing _ _ O
this _ _ O
will _ _ O
save _ _ O
time _ _ O
or _ _ O
waste _ _ O
time _ _ O
is _ _ O
really _ _ O
, _ _ O
really _ _ O
complicated _ _ O
. _ _ O
8 _ _ O


 _ _ O
Careful _ _ O
now _ _ O
... _ _ O
● _ _ O
remember _ _ O
the _ _ O
" _ _ O
without _ _ O
changing _ _ O
its _ _ O
behavior _ _ O
" _ _ O
part _ _ O
of _ _ O
the _ _ O
definition _ _ O
? _ _ O
func1 _ _ O
( _ _ O
problem _ _ O
( _ _ O
1 _ _ O
) _ _ O
) _ _ O
; _ _ O
func2 _ _ O
( _ _ O
problem _ _ O
( _ _ O
1 _ _ O
) _ _ O
) _ _ O
; _ _ O


 _ _ O
let _ _ O
v _ _ O
= _ _ O
problem _ _ O
( _ _ O
1 _ _ O
) _ _ O
; _ _ O
func1 _ _ O
( _ _ O
v _ _ O
) _ _ O
; _ _ O
func2 _ _ O
( _ _ O
v _ _ O
) _ _ O
; _ _ O


 _ _ O
what _ _ O
if _ _ O
problem _ _ O
were _ _ O
defined _ _ O
like _ _ O
this _ _ O
: _ _ O
fn _ _ O
problem _ _ O
( _ _ O
x _ _ O
: _ _ O
int _ _ O
) _ _ O
: _ _ O
int _ _ O
{ _ _ O
print_s _ _ O
( _ _ O
"problem _ _ O
: _ _ O
") _ _ O
; _ _ O
println_i _ _ O
( _ _ O
x _ _ O
) _ _ O
; _ _ O
return _ _ O
x _ _ O
; _ _ O
} _ _ O


 _ _ O
now _ _ O
the _ _ O
original _ _ O
and _ _ O
" _ _ O
optimized _ _ O
" _ _ O
versions _ _ O
do _ _ O
different _ _ O
things _ _ O
! _ _ O


 _ _ O
when _ _ O
performing _ _ O
optimizations _ _ O
, _ _ O
we _ _ O
must _ _ O
respect _ _ O
the _ _ O
semantics _ _ O
and _ _ O
evaluation _ _ O
rules _ _ O
of _ _ O
the _ _ O
source _ _ O
language _ _ O
, _ _ O
and _ _ O
we _ _ O
can _ _ O
not _ _ O
ignore _ _ O
side _ _ O
effects _ _ O
. _ _ O
9 _ _ O


 _ _ O
To _ _ O
optimize _ _ O
, _ _ O
or _ _ O
not _ _ O
to _ _ O
optimize _ _ O
? _ _ O
● _ _ O
optimization _ _ O
might _ _ O
sound _ _ O
like _ _ O
a _ _ O
no-brainer _ _ O
. _ _ O
why _ _ O
not _ _ O
do _ _ O
it _ _ O
? _ _ O
well _ _ O
... _ _ O
they _ _ O
can _ _ O
slow _ _ O
down _ _ O
compilation _ _ O
, _ _ O
a _ _ O
lot _ _ O
. _ _ O


 _ _ O
they _ _ O
can _ _ O
be _ _ O
difficult _ _ O
to _ _ O
implement _ _ O
correctly _ _ O
. _ _ O


 _ _ O
Finished _ _ O
[ _ _ O
release _ _ O
] _ _ O
target _ _ O
( _ _ O
s _ _ O
) _ _ O
in _ _ O
1859.3s _ _ O


 _ _ O
$ _ _ O
. _ _ O
/ _ _ O
hello _ _ O
Hello _ _ O
, _ _ O
world _ _ O
! _ _ O
$ _ _ O
. _ _ O
/ _ _ O
hello_optimized _ _ O
Segmentation _ _ O
fault _ _ O


 _ _ O
they _ _ O
may _ _ O
only _ _ O
give _ _ O
a _ _ O
small _ _ O
improvement _ _ O
. _ _ O


 _ _ O
they _ _ O
can _ _ O
make _ _ O
it _ _ O
harder _ _ O
to _ _ O
debug _ _ O
a _ _ O
running _ _ O
program _ _ O
. _ _ O


 _ _ O
$ _ _ O
. _ _ O
/ _ _ O
bench _ _ O
18.93s _ _ O
$ _ _ O
. _ _ O
/ _ _ O
bench_optimized _ _ O
18.11s _ _ O


 _ _ O
$ _ _ O
gdb _ _ O
bench_optimized _ _ O
( _ _ O
gdb _ _ O
) _ _ O
b _ _ O
main _ _ O
Function _ _ O
" _ _ O
main _ _ O
" _ _ O
not _ _ O
defined _ _ O
. _ _ O
( _ _ O
gdb _ _ O
) _ _ O
_ _ _ O


 _ _ O
or _ _ O
some _ _ O
combination _ _ O
of _ _ O
all _ _ O
of _ _ O
these _ _ O
! _ _ O
10 _ _ O


 _ _ O
Peephole _ _ O
Optimizations _ _ O


 _ _ O
11 _ _ O


 _ _ O
Starting _ _ O
small _ _ O
● _ _ O
the _ _ O
simplest _ _ O
kinds _ _ O
of _ _ O
optimizations _ _ O
are _ _ O
peephole _ _ O
optimizations _ _ O
: _ _ O
they _ _ O
work _ _ O
on _ _ O
the _ _ O
level _ _ O
of _ _ O
one _ _ O
or _ _ O
two _ _ O
instructions _ _ O
at _ _ O
a _ _ O
time _ _ O
. _ _ O
● _ _ O
despite _ _ O
their _ _ O
simplicity _ _ O
, _ _ O
they _ _ O
are _ _ O
the _ _ O
foundation _ _ O
of _ _ O
all _ _ O
the _ _ O
more _ _ O
complicated _ _ O
kinds _ _ O
of _ _ O
optimizations _ _ O
. _ _ O
a _ _ O
= _ _ O
5 _ _ O
= _ _ O
= _ _ O
5 _ _ O


 _ _ O
a _ _ O
= _ _ O
true _ _ O


 _ _ O
doing _ _ O
peephole _ _ O
optimizations _ _ O
... _ _ O


 _ _ O
a _ _ O
= _ _ O
true _ _ O
if _ _ O
a _ _ O
then _ _ O
bb1 _ _ O
else _ _ O
bb2 _ _ O


 _ _ O
if _ _ O
true _ _ O
then _ _ O
bb1 _ _ O
else _ _ O
bb2 _ _ O


 _ _ O
... _ _ O
can _ _ O
open _ _ O
up _ _ O
opportunities _ _ O
for _ _ O
larger _ _ O
local _ _ O
optimizations _ _ O
... _ _ O


 _ _ O
if _ _ O
true _ _ O
then _ _ O
bb1 _ _ O
else _ _ O
bb2 _ _ O


 _ _ O
goto _ _ O
bb1 _ _ O
< _ _ O
delete _ _ O
bb2 _ _ O
> _ _ O


 _ _ O
... _ _ O
which _ _ O
are _ _ O
the _ _ O
basis _ _ O
for _ _ O
global _ _ O
optimizations _ _ O
. _ _ O
12 _ _ O


 _ _ O
Operations _ _ O
vs. _ _ O
Moves _ _ O
( _ _ O
assignments _ _ O
) _ _ O
● _ _ O
each _ _ O
instruction _ _ O
in _ _ O
our _ _ O
IR _ _ O
looks _ _ O
( _ _ O
basically _ _ O
) _ _ O
like _ _ O
one _ _ O
of _ _ O
these _ _ O
two _ _ O
: _ _ O
x _ _ O
= _ _ O
y _ _ O
+ _ _ O
z _ _ O
a _ _ O
= _ _ O
b _ _ O
● _ _ O
the _ _ O
first _ _ O
is _ _ O
an _ _ O
operation _ _ O
: _ _ O
it _ _ O
requires _ _ O
computation _ _ O
to _ _ O
complete _ _ O
. _ _ O
● _ _ O
the _ _ O
second _ _ O
is _ _ O
a _ _ O
move _ _ O
: _ _ O
copying _ _ O
a _ _ O
value _ _ O
from _ _ O
place _ _ O
to _ _ O
place _ _ O
. _ _ O
o _ _ O
but _ _ O
, _ _ O
a _ _ O
lot _ _ O
of _ _ O
moves _ _ O
are _ _ O
unnecessary _ _ O
and _ _ O
could _ _ O
be _ _ O
eliminated _ _ O
. _ _ O
● _ _ O
furthermore _ _ O
, _ _ O
if _ _ O
we _ _ O
can _ _ O
somehow _ _ O
convert _ _ O
operations _ _ O
into _ _ O
moves _ _ O
... _ _ O
o _ _ O
we _ _ O
can _ _ O
eliminate _ _ O
entire _ _ O
steps _ _ O
of _ _ O
the _ _ O
program _ _ O
. _ _ O
● _ _ O
all _ _ O
the _ _ O
local _ _ O
optimizations _ _ O
basically _ _ O
follow _ _ O
these _ _ O
principles _ _ O
: _ _ O
o _ _ O
make _ _ O
operations _ _ O
simpler _ _ O
than _ _ O
what _ _ O
was _ _ O
written _ _ O
; _ _ O
o _ _ O
turn _ _ O
operations _ _ O
into _ _ O
moves _ _ O
if _ _ O
possible _ _ O
; _ _ O
and _ _ O
then _ _ O
o _ _ O
eliminate _ _ O
the _ _ O
moves _ _ O
. _ _ O
● _ _ O
and _ _ O
then _ _ O
repeat _ _ O
! _ _ O
13 _ _ O


 _ _ O
Constant _ _ O
Folding _ _ O
● _ _ O
this _ _ O
one _ _ O
is _ _ O
easy _ _ O
: _ _ O
if _ _ O
you _ _ O
see _ _ O
arithmetic _ _ O
being _ _ O
done _ _ O
on _ _ O
constants _ _ O
, _ _ O
replace _ _ O
the _ _ O
arithmetic _ _ O
with _ _ O
the _ _ O
result _ _ O
of _ _ O
the _ _ O
operation _ _ O
. _ _ O


 _ _ O
a _ _ O
= _ _ O
640 _ _ O
* _ _ O
480 _ _ O


 _ _ O
a _ _ O
= _ _ O
307200 _ _ O


 _ _ O
b _ _ O
= _ _ O
not _ _ O
true _ _ O


 _ _ O
b _ _ O
= _ _ O
false _ _ O


 _ _ O
c _ _ O
= _ _ O
" _ _ O
hi _ _ O
" _ _ O
+ _ _ O
" _ _ O
bye _ _ O
" _ _ O


 _ _ O
c _ _ O
= _ _ O
" _ _ O
hibye _ _ O
" _ _ O


 _ _ O
this _ _ O
turns _ _ O
each _ _ O
operation _ _ O
into _ _ O
a _ _ O
move _ _ O
. _ _ O
nice _ _ O
! _ _ O
but _ _ O
what _ _ O
about _ _ O
: _ _ O


 _ _ O
$ _ _ O
t1 _ _ O
= _ _ O
640 _ _ O
* _ _ O
480 _ _ O
x _ _ O
= _ _ O
$ _ _ O
t1 _ _ O
* _ _ O
32 _ _ O


 _ _ O
$ _ _ O
t1 _ _ O
= _ _ O
307200 _ _ O
x _ _ O
= _ _ O
$ _ _ O
t1 _ _ O
* _ _ O
32 _ _ O


 _ _ O
clearly _ _ O
there _ _ O
's _ _ O
more _ _ O
work _ _ O
to _ _ O
be _ _ O
done _ _ O
, _ _ O
but _ _ O
we _ _ O
'll _ _ O
come _ _ O
back _ _ O
to _ _ O
this _ _ O
. _ _ O
14 _ _ O


 _ _ O
Danger _ _ O
ahead _ _ O
● _ _ O
some _ _ O
mathematical _ _ O
operations _ _ O
can _ _ O
cause _ _ O
... _ _ O
problems _ _ O
. _ _ O


 _ _ O
a _ _ O
= _ _ O
1000 _ _ O
/ _ _ O
0 _ _ O


 _ _ O
uh _ _ O
oh _ _ O
. _ _ O
do _ _ O
n't _ _ O
try _ _ O
to _ _ O
simplify _ _ O
this _ _ O
or _ _ O
you _ _ O
'll _ _ O
crash _ _ O
the _ _ O
compiler _ _ O
! _ _ O


 _ _ O
a _ _ O
= _ _ O
1000000000 _ _ O
* _ _ O
5 _ _ O


 _ _ O
that _ _ O
does _ _ O
n't _ _ O
fit _ _ O
in _ _ O
a _ _ O
32-bit _ _ O
int _ _ O
... _ _ O


 _ _ O
confusingly _ _ O
, _ _ O
these _ _ O
may _ _ O
or _ _ O
may _ _ O
not _ _ O
be _ _ O
errors _ _ O
in _ _ O
the _ _ O
code _ _ O
, _ _ O
so _ _ O
we _ _ O
probably _ _ O
should _ _ O
n't _ _ O
give _ _ O
an _ _ O
error _ _ O
here _ _ O
; _ _ O
just _ _ O
give _ _ O
up _ _ O
instead _ _ O
. _ _ O
due _ _ O
to _ _ O
interactions _ _ O
with _ _ O
control _ _ O
flow _ _ O
analysis _ _ O
, _ _ O
these _ _ O
may _ _ O
not _ _ O
even _ _ O
get _ _ O
executed _ _ O
at _ _ O
runtime _ _ O
. _ _ O


 _ _ O
last _ _ O
, _ _ O
unless _ _ O
we _ _ O
're _ _ O
explicitly _ _ O
looking _ _ O
for _ _ O
errors _ _ O
, _ _ O
we _ _ O
really _ _ O
should _ _ O
just _ _ O
let _ _ O
the _ _ O
code _ _ O
through _ _ O
. _ _ O
we _ _ O
ca _ _ O
n't _ _ O
catch _ _ O
every _ _ O
mistake _ _ O
. _ _ O
it _ _ O
's _ _ O
never _ _ O
wrong _ _ O
to _ _ O
leave _ _ O
code _ _ O
the _ _ O
way _ _ O
the _ _ O
programmer _ _ O
wrote _ _ O
it _ _ O
. _ _ O


 _ _ O
15 _ _ O


 _ _ O
Algebraic _ _ O
Simplification _ _ O
● _ _ O
this _ _ O
uses _ _ O
algebraic _ _ O
laws _ _ O
to _ _ O
simplify _ _ O
or _ _ O
even _ _ O
eliminate _ _ O
operations _ _ O
. _ _ O


 _ _ O
a _ _ O
= _ _ O
b _ _ O
* _ _ O
1 _ _ O


 _ _ O
a _ _ O
= _ _ O
b _ _ O


 _ _ O
a _ _ O
= _ _ O
b _ _ O
+ _ _ O
0 _ _ O


 _ _ O
a _ _ O
= _ _ O
b _ _ O


 _ _ O
a _ _ O
= _ _ O
b _ _ O
* _ _ O
0 _ _ O


 _ _ O
a _ _ O
= _ _ O
0 _ _ O


 _ _ O
a _ _ O
= _ _ O
a _ _ O
+ _ _ O
0 _ _ O


 _ _ O
( _ _ O
nothing _ _ O
! _ _ O
) _ _ O


 _ _ O
$ _ _ O
t1 _ _ O
= _ _ O
a _ _ O
= _ _ O
= _ _ O
a _ _ O


 _ _ O
$ _ _ O
t1 _ _ O
= _ _ O
true _ _ O


 _ _ O
$ _ _ O
t1 _ _ O
= _ _ O
a _ _ O
< _ _ O
a _ _ O


 _ _ O
$ _ _ O
t1 _ _ O
= _ _ O
false _ _ O
16 _ _ O


 _ _ O
Strength _ _ O
Reduction _ _ O
● _ _ O
strength _ _ O
reduction _ _ O
might _ _ O
not _ _ O
reduce _ _ O
complexity _ _ O
, _ _ O
but _ _ O
it _ _ O
can _ _ O
improve _ _ O
performance _ _ O
by _ _ O
using _ _ O
cheaper _ _ O
operations _ _ O
to _ _ O
do _ _ O
the _ _ O
same _ _ O
task _ _ O
. _ _ O


 _ _ O
a _ _ O
= _ _ O
b _ _ O
* _ _ O
2 _ _ O


 _ _ O
a _ _ O
= _ _ O
b _ _ O
+ _ _ O
b _ _ O


 _ _ O
a _ _ O
= _ _ O
pow _ _ O
( _ _ O
b _ _ O
, _ _ O
2 _ _ O
) _ _ O


 _ _ O
a _ _ O
= _ _ O
b _ _ O
* _ _ O
b _ _ O


 _ _ O
a _ _ O
= _ _ O
b _ _ O
* _ _ O
8 _ _ O


 _ _ O
a _ _ O
= _ _ O
b _ _ O
< _ _ O
< _ _ O
3 _ _ O


 _ _ O
a _ _ O
= _ _ O
b _ _ O
* _ _ O
9 _ _ O


 _ _ O
a _ _ O
= _ _ O
b _ _ O
< _ _ O
< _ _ O
3 _ _ O
a _ _ O
= _ _ O
a _ _ O
+ _ _ O
b _ _ O


 _ _ O
a _ _ O
= _ _ O
b _ _ O
% _ _ O
8 _ _ O


 _ _ O
a _ _ O
= _ _ O
b _ _ O
& _ _ O
7 _ _ O


 _ _ O
( _ _ O
many _ _ O
compilers _ _ O
" _ _ O
know _ _ O
" _ _ O
about _ _ O
standard _ _ O
library _ _ O
math _ _ O
functions _ _ O
and _ _ O
can _ _ O
optimize _ _ O
them _ _ O
out _ _ O
. _ _ O
) _ _ O


 _ _ O
two _ _ O
instructions _ _ O
may _ _ O
still _ _ O
be _ _ O
faster _ _ O
than _ _ O
a _ _ O
single _ _ O
multiplication _ _ O
! _ _ O


 _ _ O
17 _ _ O


 _ _ O
Optimization _ _ O
: _ _ O
not _ _ O
just _ _ O
for _ _ O
IR _ _ O
● _ _ O
peephole _ _ O
optimizations _ _ O
can _ _ O
be _ _ O
done _ _ O
on _ _ O
the _ _ O
target _ _ O
code _ _ O
too _ _ O
. _ _ O
● _ _ O
here _ _ O
are _ _ O
some _ _ O
Silly _ _ O
Sequences _ _ O
my _ _ O
code _ _ O
generator _ _ O
is _ _ O
producing _ _ O
: _ _ O
addi _ _ O
sp _ _ O
, _ _ O
sp _ _ O
, _ _ O
-4 _ _ O
addi _ _ O
sp _ _ O
, _ _ O
sp _ _ O
, _ _ O
-4 _ _ O


 _ _ O
li _ _ O
s2 _ _ O
, _ _ O
5 _ _ O
add _ _ O
s1 _ _ O
, _ _ O
s1 _ _ O
, _ _ O
s2 _ _ O


 _ _ O
shows _ _ O
up _ _ O
in _ _ O
nested _ _ O
calls _ _ O
like _ _ O
f _ _ O
( _ _ O
g _ _ O
( _ _ O
x _ _ O
) _ _ O
) _ _ O


 _ _ O
adding _ _ O
a _ _ O
constant _ _ O
to _ _ O
a _ _ O
variable _ _ O
, _ _ O
x _ _ O
+ _ _ O
5 _ _ O


 _ _ O
jal _ _ O
func _ _ O
move _ _ O
s0 _ _ O
, _ _ O
v0 _ _ O
sw _ _ O
s0 _ _ O
, _ _ O
-16 _ _ O
( _ _ O
fp _ _ O
) _ _ O


 _ _ O
jal _ _ O
func _ _ O
move _ _ O
s0 _ _ O
, _ _ O
v0 _ _ O
move _ _ O
v0 _ _ O
, _ _ O
s0 _ _ O


 _ _ O
assigning _ _ O
a _ _ O
return _ _ O
value _ _ O
to _ _ O
a _ _ O
variable _ _ O


 _ _ O
returning _ _ O
the _ _ O
value _ _ O
that _ _ O
a _ _ O
call _ _ O
returned _ _ O
18 _ _ O


 _ _ O
Make _ _ O
it _ _ O
better _ _ O
, _ _ O
do _ _ O
it _ _ O
faster _ _ O
● _ _ O
a _ _ O
final _ _ O
pass _ _ O
after _ _ O
codegen _ _ O
can _ _ O
go _ _ O
through _ _ O
and _ _ O
replace _ _ O
these _ _ O
silly _ _ O
sequences _ _ O
with _ _ O
simpler _ _ O
equivalent _ _ O
sequences _ _ O
. _ _ O
addi _ _ O
sp _ _ O
, _ _ O
sp _ _ O
, _ _ O
-4 _ _ O
addi _ _ O
sp _ _ O
, _ _ O
sp _ _ O
, _ _ O
-4 _ _ O


 _ _ O
addi _ _ O
sp _ _ O
, _ _ O
sp _ _ O
, _ _ O
-8 _ _ O


 _ _ O
li _ _ O
s2 _ _ O
, _ _ O
5 _ _ O
add _ _ O
s1 _ _ O
, _ _ O
s1 _ _ O
, _ _ O
s2 _ _ O


 _ _ O
addi _ _ O
s1 _ _ O
, _ _ O
s1 _ _ O
, _ _ O
5 _ _ O


 _ _ O
jal _ _ O
func _ _ O
move _ _ O
s0 _ _ O
, _ _ O
v0 _ _ O
sw _ _ O
s0 _ _ O
, _ _ O
-16 _ _ O
( _ _ O
fp _ _ O
) _ _ O


 _ _ O
jal _ _ O
sw _ _ O


 _ _ O
func _ _ O
v0 _ _ O
, _ _ O
-16 _ _ O
( _ _ O
fp _ _ O
) _ _ O


 _ _ O
jal _ _ O
func _ _ O
move _ _ O
s0 _ _ O
, _ _ O
v0 _ _ O
move _ _ O
v0 _ _ O
, _ _ O
s0 _ _ O


 _ _ O
jal _ _ O


 _ _ O
func _ _ O
19 _ _ O


 _ _ O
Single _ _ O
Static _ _ O
Assignment _ _ O
Form _ _ O
( _ _ O
SSA _ _ O
) _ _ O


 _ _ O
20 _ _ O


 _ _ O
Hitting _ _ O
a _ _ O
wall _ _ O
● _ _ O
let _ _ O
's _ _ O
apply _ _ O
all _ _ O
the _ _ O
optimizations _ _ O
we _ _ O
've _ _ O
seen _ _ O
to _ _ O
this _ _ O
bit _ _ O
of _ _ O
code _ _ O
. _ _ O
x _ _ O
= _ _ O
10 _ _ O
* _ _ O
16 _ _ O
constant _ _ O
folding _ _ O
... _ _ O
println_i _ _ O
( _ _ O
x _ _ O
) _ _ O
strength _ _ O
reduction _ _ O
... _ _ O
x _ _ O
= _ _ O
x _ _ O
* _ _ O
4 _ _ O
println_i _ _ O
( _ _ O
x _ _ O
) _ _ O
x _ _ O
= _ _ O
x _ _ O
* _ _ O
1 _ _ O
algebraic _ _ O
simplification _ _ O
... _ _ O
println_i _ _ O
( _ _ O
x _ _ O
) _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
x _ _ O
kind _ _ O
of _ _ O
leaves _ _ O
something _ _ O
return _ _ O
to _ _ O
be _ _ O
desired _ _ O
, _ _ O
no _ _ O
? _ _ O


 _ _ O
x _ _ O
= _ _ O
160 _ _ O
println_i _ _ O
( _ _ O
x _ _ O
) _ _ O
x _ _ O
= _ _ O
x _ _ O
< _ _ O
< _ _ O
2 _ _ O
println_i _ _ O
( _ _ O
x _ _ O
) _ _ O


 _ _ O
println_i _ _ O
( _ _ O
x _ _ O
) _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
x _ _ O
return _ _ O


 _ _ O
think _ _ O
about _ _ O
it _ _ O
: _ _ O
do _ _ O
we _ _ O
really _ _ O
even _ _ O
need _ _ O
this _ _ O
x _ _ O
variable _ _ O
? _ _ O
well _ _ O
, _ _ O
to _ _ O
make _ _ O
things _ _ O
easier _ _ O
on _ _ O
ourselves _ _ O
, _ _ O
first _ _ O
we _ _ O
're _ _ O
going _ _ O
to _ _ O
convert _ _ O
the _ _ O
code _ _ O
into _ _ O
a _ _ O
single _ _ O
assignment _ _ O
form _ _ O
. _ _ O
21 _ _ O


 _ _ O
I _ _ O
AM _ _ O
LEAVING _ _ O
OUT _ _ O
A _ _ O
LOT _ _ O
OF _ _ O
DETAILS _ _ O
HERE _ _ O
● _ _ O
single _ _ O
static _ _ O
assignment _ _ O
( _ _ O
SSA _ _ O
) _ _ O
form _ _ O
rewrites _ _ O
the _ _ O
code _ _ O
so _ _ O
that _ _ O
each _ _ O
location _ _ O
is _ _ O
only _ _ O
assigned _ _ O
once _ _ O
, _ _ O
and _ _ O
is _ _ O
never _ _ O
reassigned _ _ O
. _ _ O
● _ _ O
this _ _ O
does _ _ O
not _ _ O
" _ _ O
optimize _ _ O
" _ _ O
the _ _ O
code _ _ O
at _ _ O
all _ _ O
, _ _ O
but _ _ O
it _ _ O
does _ _ O
make _ _ O
several _ _ O
other _ _ O
optimizations _ _ O
much _ _ O
easier _ _ O
to _ _ O
perform _ _ O
. _ _ O
x _ _ O
= _ _ O
10 _ _ O
* _ _ O
16 _ _ O
println_i _ _ O
( _ _ O
x _ _ O
) _ _ O
x _ _ O
= _ _ O
x _ _ O
* _ _ O
4 _ _ O
println_i _ _ O
( _ _ O
x _ _ O
) _ _ O
x _ _ O
= _ _ O
x _ _ O
* _ _ O
1 _ _ O
println_i _ _ O
( _ _ O
x _ _ O
) _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
x _ _ O
return _ _ O


 _ _ O
SSA _ _ O
! _ _ O


 _ _ O
x1 _ _ O
= _ _ O
10 _ _ O
* _ _ O
16 _ _ O
println_i _ _ O
( _ _ O
x1 _ _ O
) _ _ O
x2 _ _ O
= _ _ O
x _ _ O
1 _ _ O
* _ _ O
4 _ _ O
println_i _ _ O
( _ _ O
x2 _ _ O
) _ _ O
x3 _ _ O
= _ _ O
x _ _ O
2 _ _ O
* _ _ O
1 _ _ O
println_i _ _ O
( _ _ O
x3 _ _ O
) _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
x3 _ _ O
return _ _ O


 _ _ O
each _ _ O
time _ _ O
x _ _ O
is _ _ O
assigned _ _ O
, _ _ O
we _ _ O
replace _ _ O
it _ _ O
with _ _ O
a _ _ O
new _ _ O
, _ _ O
unique _ _ O
variable _ _ O
. _ _ O


 _ _ O
references _ _ O
to _ _ O
x _ _ O
are _ _ O
replaced _ _ O
with _ _ O
the _ _ O
" _ _ O
most _ _ O
recent _ _ O
version _ _ O
" _ _ O
of _ _ O
x. _ _ O


 _ _ O
22 _ _ O


 _ _ O
Not _ _ O
a _ _ O
requirement _ _ O
● _ _ O
SSA _ _ O
is _ _ O
a _ _ O
super _ _ O
useful _ _ O
form _ _ O
for _ _ O
optimization _ _ O
buuuuuuuuuut _ _ O
... _ _ O
o _ _ O
it _ _ O
has _ _ O
to _ _ O
be _ _ O
done _ _ O
on _ _ O
the _ _ O
whole _ _ O
CFG _ _ O
, _ _ O
which _ _ O
is _ _ O
complicated _ _ O
. _ _ O
o _ _ O
consider _ _ O
a _ _ O
for _ _ O
loop _ _ O
. _ _ O
how _ _ O
do _ _ O
you _ _ O
represent _ _ O
the _ _ O
counter _ _ O
variable _ _ O
in _ _ O
this _ _ O
form _ _ O
at _ _ O
all _ _ O
? _ _ O
? _ _ O
( _ _ O
heheheheh _ _ O
hahah _ _ O
hohohoho _ _ O
ɸ _ _ O
) _ _ O
● _ _ O
then _ _ O
, _ _ O
once _ _ O
you _ _ O
're _ _ O
done _ _ O
optimizing _ _ O
, _ _ O
you _ _ O
have _ _ O
to _ _ O
convert _ _ O
back _ _ O
out _ _ O
of _ _ O
SSA _ _ O
to _ _ O
do _ _ O
the _ _ O
final _ _ O
codegen _ _ O
. _ _ O
o _ _ O
so _ _ O
it _ _ O
's _ _ O
a _ _ O
bit _ _ O
of _ _ O
a _ _ O
mixed _ _ O
bag _ _ O
, _ _ O
depending _ _ O
on _ _ O
what _ _ O
kinds _ _ O
of _ _ O
optimizations _ _ O
you _ _ O
want _ _ O
to _ _ O
do _ _ O
. _ _ O
● _ _ O
it _ _ O
's _ _ O
not _ _ O
required _ _ O
for _ _ O
all _ _ O
optimizations _ _ O
, _ _ O
it _ _ O
just _ _ O
simplifies _ _ O
a _ _ O
lot _ _ O
of _ _ O
them _ _ O
. _ _ O
o _ _ O
the _ _ O
other _ _ O
local _ _ O
optimizations _ _ O
we _ _ O
'll _ _ O
talk _ _ O
about _ _ O
can _ _ O
be _ _ O
implemented _ _ O
with _ _ O
or _ _ O
without _ _ O
SSA _ _ O
, _ _ O
but _ _ O
the _ _ O
algorithms _ _ O
for _ _ O
detecting _ _ O
and _ _ O
applying _ _ O
them _ _ O
are _ _ O
more _ _ O
complicated _ _ O
without _ _ O
it _ _ O
. _ _ O


 _ _ O
23 _ _ O


 _ _ O
More _ _ O
advanced _ _ O
local _ _ O
optimizations _ _ O


 _ _ O
24 _ _ O


 _ _ O
Copy _ _ O
Propagation _ _ O
● _ _ O
if _ _ O
the _ _ O
code _ _ O
is _ _ O
in _ _ O
SSA _ _ O
form _ _ O
, _ _ O
we _ _ O
" _ _ O
unlock _ _ O
" _ _ O
this _ _ O
optimization _ _ O
: _ _ O
● _ _ O
if _ _ O
we _ _ O
see _ _ O
a _ _ O
move _ _ O
x _ _ O
= _ _ O
y _ _ O
, _ _ O
then _ _ O
we _ _ O
can _ _ O
replace _ _ O
all _ _ O
uses _ _ O
of _ _ O
x _ _ O
with _ _ O
y. _ _ O


 _ _ O
x _ _ O
= _ _ O
a _ _ O
b _ _ O
= _ _ O
x _ _ O
+ _ _ O
c _ _ O


 _ _ O
x _ _ O
= _ _ O
a _ _ O
b _ _ O
= _ _ O
a _ _ O
+ _ _ O
c _ _ O


 _ _ O
x _ _ O
= _ _ O
10 _ _ O
a _ _ O
= _ _ O
x _ _ O
+ _ _ O
5 _ _ O


 _ _ O
x _ _ O
= _ _ O
10 _ _ O
a _ _ O
= _ _ O
10 _ _ O
+ _ _ O
5 _ _ O


 _ _ O
two _ _ O
things _ _ O
to _ _ O
notice _ _ O
here _ _ O
: _ _ O


 _ _ O
in _ _ O
the _ _ O
second _ _ O
example _ _ O
, _ _ O
we _ _ O
've _ _ O
produced _ _ O
something _ _ O
that _ _ O
can _ _ O
be _ _ O
further _ _ O
optimized _ _ O
to _ _ O
a _ _ O
= _ _ O
15 _ _ O
! _ _ O
in _ _ O
both _ _ O
examples _ _ O
, _ _ O
x _ _ O
is _ _ O
no _ _ O
longer _ _ O
used _ _ O
anywhere _ _ O
. _ _ O
so _ _ O
what _ _ O
do _ _ O
we _ _ O
do _ _ O
with _ _ O
it _ _ O
? _ _ O
25 _ _ O


 _ _ O
Dead _ _ O
store _ _ O
elimination _ _ O
● _ _ O
if _ _ O
a _ _ O
variable _ _ O
is _ _ O
assigned _ _ O
a _ _ O
value _ _ O
, _ _ O
and _ _ O
that _ _ O
value _ _ O
is _ _ O
never _ _ O
read _ _ O
, _ _ O
then _ _ O
the _ _ O
assignment _ _ O
is _ _ O
a _ _ O
dead _ _ O
store _ _ O
and _ _ O
can _ _ O
be _ _ O
removed _ _ O
. _ _ O
o _ _ O
... _ _ O
as _ _ O
long _ _ O
as _ _ O
the _ _ O
assignment _ _ O
has _ _ O
no _ _ O
side _ _ O
effects _ _ O
! _ _ O
● _ _ O
so _ _ O
continuing _ _ O
with _ _ O
the _ _ O
improved _ _ O
code _ _ O
from _ _ O
last _ _ O
slide _ _ O
: _ _ O


 _ _ O
but _ _ O
: _ _ O


 _ _ O
x _ _ O
= _ _ O
a _ _ O
b _ _ O
= _ _ O
a _ _ O
+ _ _ O
c _ _ O


 _ _ O
b _ _ O
= _ _ O
a _ _ O
+ _ _ O
c _ _ O


 _ _ O
x _ _ O
= _ _ O
10 _ _ O
a _ _ O
= _ _ O
10 _ _ O
+ _ _ O
5 _ _ O


 _ _ O
a _ _ O
= _ _ O
10 _ _ O
+ _ _ O
5 _ _ O


 _ _ O
x _ _ O
= _ _ O
f _ _ O
( _ _ O
) _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
5 _ _ O
return _ _ O


 _ _ O
we _ _ O
ca _ _ O
n't _ _ O
remove _ _ O
the _ _ O
assignment _ _ O
to _ _ O
x _ _ O
, _ _ O
because _ _ O
f _ _ O
( _ _ O
) _ _ O
may _ _ O
have _ _ O
side _ _ O
effects _ _ O
. _ _ O
26 _ _ O


 _ _ O
Common _ _ O
subexpression _ _ O
elimination _ _ O
( _ _ O
CSE _ _ O
) _ _ O
● _ _ O
if _ _ O
the _ _ O
code _ _ O
is _ _ O
in _ _ O
SSA _ _ O
form _ _ O
... _ _ O
o _ _ O
and _ _ O
two _ _ O
variable _ _ O
assignments _ _ O
have _ _ O
the _ _ O
same _ _ O
rhs _ _ O
... _ _ O
o _ _ O
and _ _ O
the _ _ O
rhs _ _ O
has _ _ O
no _ _ O
side _ _ O
effects _ _ O
... _ _ O
● _ _ O
then _ _ O
the _ _ O
second _ _ O
variable _ _ O
assignment _ _ O
can _ _ O
be _ _ O
changed _ _ O
to _ _ O
a _ _ O
move _ _ O
from _ _ O
the _ _ O
first _ _ O
variable _ _ O
. _ _ O


 _ _ O
x _ _ O
= _ _ O
a _ _ O
+ _ _ O
c _ _ O
println_i _ _ O
( _ _ O
x _ _ O
) _ _ O
y _ _ O
= _ _ O
a _ _ O
+ _ _ O
c _ _ O
println_i _ _ O
( _ _ O
y _ _ O
) _ _ O


 _ _ O
x _ _ O
= _ _ O
a _ _ O
+ _ _ O
c _ _ O
println_i _ _ O
( _ _ O
x _ _ O
) _ _ O
y _ _ O
= _ _ O
x _ _ O
println_i _ _ O
( _ _ O
y _ _ O
) _ _ O


 _ _ O
because _ _ O
we _ _ O
're _ _ O
using _ _ O
SSA _ _ O
, _ _ O
the _ _ O
variables _ _ O
on _ _ O
the _ _ O
RHS _ _ O
are _ _ O
guaranteed _ _ O
not _ _ O
to _ _ O
change _ _ O
value _ _ O
between _ _ O
the _ _ O
assignments _ _ O
. _ _ O
( _ _ O
if _ _ O
we _ _ O
were _ _ O
n't _ _ O
using _ _ O
SSA _ _ O
, _ _ O
we _ _ O
'd _ _ O
have _ _ O
to _ _ O
check _ _ O
that _ _ O
. _ _ O
) _ _ O


 _ _ O
27 _ _ O


 _ _ O
Teamwork _ _ O
makes _ _ O
the _ _ O
dream _ _ O
work _ _ O
● _ _ O
each _ _ O
local _ _ O
optimization _ _ O
only _ _ O
does _ _ O
a _ _ O
little _ _ O
work _ _ O
. _ _ O
● _ _ O
but _ _ O
every _ _ O
time _ _ O
you _ _ O
run _ _ O
one _ _ O
, _ _ O
it _ _ O
can _ _ O
make _ _ O
it _ _ O
possible _ _ O
for _ _ O
another _ _ O
one _ _ O
to _ _ O
do _ _ O
a _ _ O
little _ _ O
more _ _ O
work _ _ O
... _ _ O
a _ _ O
copy _ _ O
propagation _ _ O
makes _ _ O
a _ _ O
constant _ _ O
folding _ _ O
possible _ _ O
; _ _ O
which _ _ O
makes _ _ O
another _ _ O
copy _ _ O
propagation _ _ O
possible _ _ O
, _ _ O
followed _ _ O
by _ _ O
a _ _ O
dead _ _ O
store _ _ O
elimination _ _ O
; _ _ O


 _ _ O
around _ _ O
and _ _ O
around _ _ O
until _ _ O
the _ _ O
code _ _ O
is _ _ O
as _ _ O
" _ _ O
simple _ _ O
" _ _ O
as _ _ O
we _ _ O
can _ _ O
make _ _ O
it _ _ O
. _ _ O


 _ _ O
28 _ _ O


 _ _ O
How _ _ O
the _ _ O
compiler _ _ O
does _ _ O
it _ _ O
● _ _ O
it _ _ O
just _ _ O
does _ _ O
a _ _ O
simple _ _ O
round-robin _ _ O
scheme _ _ O
: _ _ O
do _ _ O
{ _ _ O
const_fold _ _ O
( _ _ O
bb _ _ O
) _ _ O
; _ _ O
strength_reduce _ _ O
( _ _ O
bb _ _ O
) _ _ O
; _ _ O
algebraic_simpl _ _ O
( _ _ O
bb _ _ O
) _ _ O
; _ _ O
copy_propagate _ _ O
( _ _ O
bb _ _ O
) _ _ O
; _ _ O
dead_store_elim _ _ O
( _ _ O
bb _ _ O
) _ _ O
; _ _ O
} _ _ O
while _ _ O
( _ _ O
the _ _ O
bb _ _ O
changed _ _ O
) _ _ O
; _ _ O


 _ _ O
each _ _ O
optimization _ _ O
is _ _ O
so _ _ O
simple _ _ O
and _ _ O
quick _ _ O
that _ _ O
you _ _ O
just _ _ O
... _ _ O
keep _ _ O
doing _ _ O
them _ _ O
until _ _ O
they _ _ O
do _ _ O
n't _ _ O
do _ _ O
anything _ _ O
anymore _ _ O
. _ _ O
it _ _ O
is _ _ O
literally _ _ O
more _ _ O
work _ _ O
to _ _ O
" _ _ O
check _ _ O
if _ _ O
the _ _ O
optimization _ _ O
is _ _ O
possible _ _ O
" _ _ O
than _ _ O
it _ _ O
is _ _ O
to _ _ O
just _ _ O
try _ _ O
to _ _ O
do _ _ O
it _ _ O


 _ _ O
if _ _ O
this _ _ O
makes _ _ O
you _ _ O
feel _ _ O
uneasy _ _ O
( _ _ O
could _ _ O
n't _ _ O
it _ _ O
get _ _ O
stuck _ _ O
in _ _ O
an _ _ O
infinite _ _ O
loop _ _ O
? _ _ O
? _ _ O
) _ _ O
, _ _ O
I _ _ O
'm _ _ O
with _ _ O
you _ _ O
! _ _ O
but _ _ O
if _ _ O
it _ _ O
works _ _ O
, _ _ O
it _ _ O
works _ _ O
. _ _ O
( _ _ O
the _ _ O
compiler _ _ O
might _ _ O
stop _ _ O
after _ _ O
some _ _ O
n _ _ O
iterations _ _ O
anyway _ _ O
) _ _ O
. _ _ O


 _ _ O
29 _ _ O


 _ _ O
An _ _ O
example _ _ O
● _ _ O
let _ _ O
's _ _ O
take _ _ O
that _ _ O
code _ _ O
from _ _ O
before _ _ O
and _ _ O
optimize _ _ O
it _ _ O
real _ _ O
good _ _ O
. _ _ O
x1 _ _ O
= _ _ O
10 _ _ O
* _ _ O
16 _ _ O
println_i _ _ O
( _ _ O
x1 _ _ O
) _ _ O
x2 _ _ O
= _ _ O
x1 _ _ O
* _ _ O
4 _ _ O
println_i _ _ O
( _ _ O
x2 _ _ O
) _ _ O
x3 _ _ O
= _ _ O
x2 _ _ O
* _ _ O
1 _ _ O
println_i _ _ O
( _ _ O
x3 _ _ O
) _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
x3 _ _ O
return _ _ O


 _ _ O
x1 _ _ O
= _ _ O
160 _ _ O
println_i _ _ O
( _ _ O
x1 _ _ O
) _ _ O
x2 _ _ O
= _ _ O
x1 _ _ O
< _ _ O
< _ _ O
2 _ _ O
println_i _ _ O
( _ _ O
x2 _ _ O
) _ _ O
x3 _ _ O
= _ _ O
x2 _ _ O
println_i _ _ O
( _ _ O
x3 _ _ O
) _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
x3 _ _ O
return _ _ O


 _ _ O
x1 _ _ O
= _ _ O
160 _ _ O
println_i _ _ O
( _ _ O
160 _ _ O
) _ _ O
x2 _ _ O
= _ _ O
160 _ _ O
< _ _ O
< _ _ O
2 _ _ O
println_i _ _ O
( _ _ O
x2 _ _ O
) _ _ O
x3 _ _ O
= _ _ O
x2 _ _ O
println_i _ _ O
( _ _ O
x2 _ _ O
) _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
x2 _ _ O
return _ _ O


 _ _ O
println_i _ _ O
( _ _ O
160 _ _ O
) _ _ O
x2 _ _ O
= _ _ O
640 _ _ O
println_i _ _ O
( _ _ O
x2 _ _ O
) _ _ O
println_i _ _ O
( _ _ O
x2 _ _ O
) _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
x2 _ _ O
return _ _ O


 _ _ O
println_i _ _ O
( _ _ O
160 _ _ O
) _ _ O
x2 _ _ O
= _ _ O
640 _ _ O
println_i _ _ O
( _ _ O
640 _ _ O
) _ _ O
println_i _ _ O
( _ _ O
640 _ _ O
) _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
640 _ _ O
return _ _ O


 _ _ O
println_i _ _ O
( _ _ O
160 _ _ O
) _ _ O
println_i _ _ O
( _ _ O
640 _ _ O
) _ _ O
println_i _ _ O
( _ _ O
640 _ _ O
) _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
640 _ _ O
return _ _ O


 _ _ O
println_i _ _ O
( _ _ O
160 _ _ O
) _ _ O
x2 _ _ O
= _ _ O
160 _ _ O
< _ _ O
< _ _ O
2 _ _ O
println_i _ _ O
( _ _ O
x2 _ _ O
) _ _ O
println_i _ _ O
( _ _ O
x2 _ _ O
) _ _ O
$ _ _ O
t0 _ _ O
= _ _ O
x2 _ _ O
return _ _ O


 _ _ O
whew _ _ O
! _ _ O


 _ _ O
30 _ _ O


 _ _ O
A _ _ O
bigger _ _ O
example _ _ O
of _ _ O
CSE _ _ O
● _ _ O
even _ _ O
larger _ _ O
common _ _ O
subexpressions _ _ O
can _ _ O
be _ _ O
eliminated _ _ O
. _ _ O
func_1 _ _ O
( _ _ O
a.x _ _ O
+ _ _ O
b.y _ _ O
- _ _ O
c _ _ O
) _ _ O
; _ _ O
func_2 _ _ O
( _ _ O
a.x _ _ O
+ _ _ O
b.y _ _ O
- _ _ O
c _ _ O
) _ _ O
; _ _ O


 _ _ O
$ _ _ O
t1 _ _ O
= _ _ O
a.x _ _ O
+ _ _ O
b.y _ _ O
$ _ _ O
t2 _ _ O
= _ _ O
$ _ _ O
t1 _ _ O
- _ _ O
c _ _ O
func_1 _ _ O
( _ _ O
$t2 _ _ O
) _ _ O
$ _ _ O
t3 _ _ O
= _ _ O
a.x _ _ O
+ _ _ O
b.y _ _ O
$ _ _ O
t4 _ _ O
= _ _ O
$ _ _ O
t3 _ _ O
- _ _ O
c _ _ O
func_2 _ _ O
( _ _ O
$t4 _ _ O
) _ _ O


 _ _ O
$ _ _ O
t1 _ _ O
= _ _ O
a.x _ _ O
+ _ _ O
b.y _ _ O
$ _ _ O
t2 _ _ O
= _ _ O
$ _ _ O
t1 _ _ O
- _ _ O
c _ _ O
func_1 _ _ O
( _ _ O
$t2 _ _ O
) _ _ O
$ _ _ O
t3 _ _ O
= _ _ O
$ _ _ O
t1 _ _ O
$ _ _ O
t4 _ _ O
= _ _ O
$ _ _ O
t3 _ _ O
- _ _ O
c _ _ O
func_2 _ _ O
( _ _ O
$t4 _ _ O
) _ _ O


 _ _ O
$ _ _ O
t1 _ _ O
= _ _ O
a.x _ _ O
+ _ _ O
b.y _ _ O
$ _ _ O
t2 _ _ O
= _ _ O
$ _ _ O
t1 _ _ O
- _ _ O
c _ _ O
func_1 _ _ O
( _ _ O
$t2 _ _ O
) _ _ O
$ _ _ O
t3 _ _ O
= _ _ O
$ _ _ O
t1 _ _ O
$ _ _ O
t4 _ _ O
= _ _ O
$ _ _ O
t1 _ _ O
- _ _ O
c _ _ O
func_2 _ _ O
( _ _ O
$t4 _ _ O
) _ _ O


 _ _ O
$ _ _ O
t1 _ _ O
= _ _ O
a.x _ _ O
+ _ _ O
b.y _ _ O
$ _ _ O
t2 _ _ O
= _ _ O
$ _ _ O
t1 _ _ O
- _ _ O
c _ _ O
func_1 _ _ O
( _ _ O
$t2 _ _ O
) _ _ O
$ _ _ O
t4 _ _ O
= _ _ O
$ _ _ O
t2 _ _ O
func_2 _ _ O
( _ _ O
$t4 _ _ O
) _ _ O


 _ _ O
$ _ _ O
t1 _ _ O
= _ _ O
a.x _ _ O
+ _ _ O
b.y _ _ O
$ _ _ O
t2 _ _ O
= _ _ O
$ _ _ O
t1 _ _ O
- _ _ O
c _ _ O
func_1 _ _ O
( _ _ O
$t2 _ _ O
) _ _ O
$ _ _ O
t4 _ _ O
= _ _ O
$ _ _ O
t2 _ _ O
func_2 _ _ O
( _ _ O
$t2 _ _ O
) _ _ O


 _ _ O
$ _ _ O
t1 _ _ O
= _ _ O
a.x _ _ O
+ _ _ O
b.y _ _ O
$ _ _ O
t2 _ _ O
= _ _ O
$ _ _ O
t1 _ _ O
- _ _ O
c _ _ O
func_1 _ _ O
( _ _ O
$t2 _ _ O
) _ _ O
func_2 _ _ O
( _ _ O
$t2 _ _ O
) _ _ O


 _ _ O
$ _ _ O
t1 _ _ O
= _ _ O
a.x _ _ O
+ _ _ O
b.y _ _ O
$ _ _ O
t2 _ _ O
= _ _ O
$ _ _ O
t1 _ _ O
- _ _ O
c _ _ O
func_1 _ _ O
( _ _ O
$t2 _ _ O
) _ _ O
$ _ _ O
t4 _ _ O
= _ _ O
$ _ _ O
t1 _ _ O
- _ _ O
c _ _ O
func_2 _ _ O
( _ _ O
$t4 _ _ O
) _ _ O


 _ _ O
31 _ _ O


 _ _ O


