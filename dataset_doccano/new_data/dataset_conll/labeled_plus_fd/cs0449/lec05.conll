['test_set', 'labeled']|cs0449|lec05
-DOCSTART- -X- -X- O

5 _ _ O
Introduction _ _ O
to _ _ O
Memory _ _ O
CS _ _ O
/ _ _ O
COE _ _ O
0449 _ _ O
Introduction _ _ O
to _ _ O
Systems _ _ O
Software _ _ O
Luis _ _ O
Oliveira _ _ O
( _ _ O
with _ _ O
content _ _ O
borrowed _ _ O
from _ _ O
wilkie _ _ O
and _ _ O
Vinicius _ _ O
Petrucci _ _ O
) _ _ O
The _ _ O
Memory _ _ O
Model _ _ O
If _ _ O
you _ _ O
forget _ _ O
how _ _ O
addressing _ _ O
works _ _ O
, _ _ O
I _ _ O
have _ _ O
a _ _ O
few _ _ O
pointers _ _ O
for _ _ O
you _ _ O
. _ _ O
2 _ _ O
The _ _ O
C _ _ B-Concept
Memory _ _ I-Concept
Model _ _ I-Concept
â€¢ _ _ O
Memory _ _ O
is _ _ O
a _ _ O
continuous _ _ O
series _ _ O
of _ _ O
bits _ _ O
. _ _ O
Potential _ _ O
Layout _ _ O
( _ _ O
32-bit _ _ O
addresses _ _ O
) _ _ O
â€¢ _ _ O
It _ _ O
can _ _ O
be _ _ O
logically _ _ O
divided _ _ O
into _ _ O
bytes _ _ O
or _ _ O
words _ _ O
. _ _ O
â€¢ _ _ O
We _ _ O
will _ _ O
treat _ _ O
it _ _ O
as _ _ O
byte-addressable _ _ B-Concept
which _ _ O
means _ _ O
individual _ _ O
bytes _ _ O
can _ _ O
be _ _ O
read _ _ O
. _ _ O
stack _ _ B-Concept
â€¢ _ _ O
This _ _ O
is _ _ O
not _ _ O
always _ _ O
the _ _ O
case _ _ O
! _ _ O
! _ _ O
â€¢ _ _ O
Consider _ _ O
masking _ _ O
and _ _ O
shifting _ _ O
to _ _ O
know _ _ O
the _ _ O
workaround _ _ O
! _ _ O
currently _ _ O
unused _ _ O
but _ _ O
available _ _ O
memory _ _ O
â€¢ _ _ O
With _ _ O
byte-addressable _ _ B-Concept
memory _ _ B-Concept
, _ _ O
each _ _ O
and _ _ O
every _ _ O
byte _ _ B-Concept
( _ _ O
8 _ _ O
bits _ _ O
) _ _ O
has _ _ O
its _ _ O
own _ _ O
unique _ _ O
address _ _ B-Concept
. _ _ O
â€¢ _ _ O
It _ _ O
's _ _ O
the _ _ O
place _ _ O
it _ _ O
lives _ _ O
! _ _ O
! _ _ O
Memory _ _ O
is _ _ O
JUST _ _ O
LIKE _ _ O
US _ _ O
! _ _ O
â€¢ _ _ O
Address _ _ B-Concept
starts _ _ O
at _ _ O
0 _ _ O
, _ _ O
second _ _ O
byte _ _ B-Concept
is _ _ O
at _ _ O
address _ _ B-Concept
1 _ _ O
, _ _ O
and _ _ O
increases _ _ O
( _ _ O
" _ _ O
upward _ _ O
" _ _ O
) _ _ O
as _ _ O
you _ _ O
add _ _ O
new _ _ O
data _ _ O
. _ _ O
heap _ _ B-Concept
static _ _ B-Concept
data _ _ B-Concept
code _ _ B-Concept
3 _ _ O
The _ _ O
C _ _ B-Concept
Memory _ _ I-Concept
Model _ _ I-Concept
â€¢ _ _ O
There _ _ O
are _ _ O
two _ _ O
main _ _ O
parts _ _ O
of _ _ O
a _ _ O
program _ _ O
: _ _ O
code _ _ B-Concept
and _ _ O
data _ _ O
â€¢ _ _ O
" _ _ O
code _ _ B-Concept
" _ _ O
is _ _ O
sometimes _ _ O
called _ _ O
" _ _ O
text _ _ B-Concept
" _ _ O
â€¢ _ _ O
Where _ _ O
in _ _ O
memory _ _ O
should _ _ O
each _ _ O
go _ _ O
? _ _ O
â€¢ _ _ O
Should _ _ O
we _ _ O
interleave _ _ O
them _ _ O
? _ _ O
â€¢ _ _ O
Which _ _ O
do _ _ O
you _ _ O
think _ _ O
is _ _ O
usually _ _ O
largest _ _ O
? _ _ O
â€¢ _ _ O
How _ _ O
do _ _ O
we _ _ O
use _ _ O
memory _ _ O
dynamically _ _ O
? _ _ O
â€¢ _ _ O
That _ _ O
is _ _ O
, _ _ O
only _ _ O
when _ _ O
we _ _ O
know _ _ O
we _ _ O
need _ _ O
it _ _ O
, _ _ O
in _ _ O
the _ _ O
moment _ _ O
. _ _ O
Potential _ _ O
Layout _ _ O
( _ _ O
32-bit _ _ O
addresses _ _ O
) _ _ O
stack _ _ B-Concept
currently _ _ O
unused _ _ O
but _ _ O
available _ _ O
memory _ _ O
heap _ _ B-Concept
static _ _ B-Concept
data _ _ B-Concept
code _ _ B-Concept
4 _ _ O
The _ _ O
C _ _ B-Concept
Memory _ _ I-Concept
Model _ _ I-Concept
: _ _ O
Code _ _ B-Concept
â€¢ _ _ O
Code _ _ B-Concept
has _ _ O
a _ _ O
few _ _ O
known _ _ O
properties _ _ O
: _ _ O
Potential _ _ O
Layout _ _ O
( _ _ O
32-bit _ _ O
addresses _ _ O
) _ _ O
â€¢ _ _ O
It _ _ O
likely _ _ O
should _ _ O
not _ _ O
change _ _ O
. _ _ O
â€¢ _ _ O
It _ _ O
must _ _ O
be _ _ O
loaded _ _ O
before _ _ O
a _ _ O
program _ _ O
can _ _ O
start _ _ O
. _ _ O
stack _ _ B-Concept
currently _ _ O
unused _ _ O
but _ _ O
available _ _ O
memory _ _ O
heap _ _ B-Concept
static _ _ B-Concept
data _ _ B-Concept
code _ _ B-Concept
5 _ _ O
The _ _ O
C _ _ B-Concept
Memory _ _ I-Concept
Model _ _ I-Concept
: _ _ O
Static _ _ B-Concept
Data _ _ B-Concept
â€¢ _ _ O
Static _ _ B-Concept
Data _ _ B-Concept
is _ _ O
an _ _ O
oft _ _ O
forgotten _ _ O
but _ _ O
useful _ _ O
section _ _ O
. _ _ O
â€¢ _ _ O
It _ _ O
does _ _ O
change _ _ O
. _ _ O
( _ _ O
contrary _ _ O
to _ _ O
its _ _ O
name _ _ O
) _ _ O
â€¢ _ _ O
It _ _ O
generally _ _ O
must _ _ O
be _ _ O
loaded _ _ O
before _ _ O
a _ _ O
program _ _ O
starts _ _ O
. _ _ O
â€¢ _ _ O
The _ _ O
size _ _ O
of _ _ O
the _ _ O
data _ _ O
and _ _ O
section _ _ O
is _ _ O
fixed _ _ O
. _ _ O
Potential _ _ O
Layout _ _ O
( _ _ O
32-bit _ _ O
addresses _ _ O
) _ _ O
stack _ _ B-Concept
currently _ _ O
unused _ _ O
but _ _ O
available _ _ O
memory _ _ O
heap _ _ B-Concept
static _ _ B-Concept
data _ _ B-Concept
code _ _ B-Concept
6 _ _ O
The _ _ O
C _ _ B-Concept
Memory _ _ I-Concept
Model _ _ I-Concept
: _ _ O
The _ _ O
Stack _ _ B-Concept
â€¢ _ _ O
The _ _ O
Stack _ _ B-Concept
is _ _ O
a _ _ O
space _ _ O
for _ _ O
temporary _ _ O
dynamic _ _ O
data _ _ O
. _ _ O
â€¢ _ _ O
Holds _ _ O
local _ _ O
variables _ _ O
and _ _ O
function _ _ B-Concept
arguments _ _ O
. _ _ O
â€¢ _ _ O
Allocated _ _ O
when _ _ O
functions _ _ O
are _ _ O
called _ _ O
. _ _ O
Freed _ _ O
on _ _ O
return _ _ O
. _ _ O
â€¢ _ _ O
Grows _ _ O
" _ _ O
downward _ _ O
" _ _ O
! _ _ O
( _ _ O
Allocates _ _ O
lower _ _ O
addresses _ _ O
) _ _ O
Potential _ _ O
Layout _ _ O
( _ _ O
32-bit _ _ O
addresses _ _ O
) _ _ O
stack _ _ B-Concept
currently _ _ O
unused _ _ O
but _ _ O
available _ _ O
memory _ _ O
heap _ _ B-Concept
Stack _ _ B-Concept
Allocation _ _ B-Concept
allows _ _ O
recursion _ _ O
. _ _ O
However _ _ O
, _ _ O
the _ _ O
more _ _ O
you _ _ O
recurse _ _ O
, _ _ O
the _ _ O
more _ _ O
you _ _ O
use _ _ O
! _ _ O
( _ _ O
Stack _ _ B-Concept
is _ _ O
only _ _ O
freed _ _ O
on _ _ O
return _ _ O
) _ _ O
static _ _ B-Concept
data _ _ B-Concept
code _ _ B-Concept
7 _ _ O
Revisiting _ _ O
our _ _ O
past _ _ O
troubles _ _ O
: _ _ O
4 _ _ O
. _ _ O
Stack _ _ B-Concept
Allocation _ _ B-Concept
( _ _ O
No _ _ O
initialization _ _ O
! _ _ O
) _ _ O
It _ _ O
reuses _ _ O
what _ _ O
is _ _ O
already _ _ O
there _ _ O
! _ _ O
! _ _ O
2 _ _ O
. _ _ O
Stack _ _ B-Concept
Allocation _ _ B-Concept
1 _ _ O
. _ _ O
Function _ _ B-Concept
Call _ _ O
3 _ _ O
. _ _ O
Function _ _ B-Concept
Call _ _ O
Q _ _ O
: _ _ O
Hmm _ _ O
. _ _ O
Where _ _ O
is _ _ O
the _ _ O
value _ _ O
for _ _ O
' _ _ O
x _ _ O
' _ _ O
coming _ _ O
from _ _ O
? _ _ O
Why _ _ O
? _ _ O
8 _ _ O
The _ _ O
C _ _ B-Concept
Memory _ _ I-Concept
Model _ _ I-Concept
: _ _ O
The _ _ O
Heap _ _ B-Concept
â€¢ _ _ O
The _ _ O
Heap _ _ B-Concept
is _ _ O
the _ _ O
dynamic _ _ O
data _ _ O
section _ _ O
! _ _ O
â€¢ _ _ O
Managing _ _ O
this _ _ O
memory _ _ O
can _ _ O
be _ _ O
very _ _ O
complex _ _ O
. _ _ O
â€¢ _ _ O
No _ _ O
garbage _ _ B-Concept
collection _ _ I-Concept
provided _ _ O
! _ _ O
! _ _ O
â€¢ _ _ O
We _ _ O
will _ _ O
revisit _ _ O
it _ _ O
in _ _ O
greater _ _ O
detail _ _ O
very _ _ O
soon _ _ O
. _ _ O
Potential _ _ O
Layout _ _ O
( _ _ O
32-bit _ _ O
addresses _ _ O
) _ _ O
stack _ _ B-Concept
currently _ _ O
unused _ _ O
but _ _ O
available _ _ O
memory _ _ O
heap _ _ B-Concept
static _ _ B-Concept
data _ _ B-Concept
code _ _ B-Concept
ðŸ˜± _ _ O
9 _ _ O
Can _ _ O
an _ _ O
emoji _ _ O
be _ _ O
a _ _ O
variable _ _ B-Concept
name _ _ O
? _ _ O
The _ _ O
questions _ _ O
that _ _ O
really _ _ O
matter _ _ O
ðŸ˜ƒ _ _ O
Compiler _ _ O
and _ _ O
version _ _ O
Success _ _ O
gcc _ _ O
main.c _ _ O
-std=c99 _ _ O
ðŸ˜” _ _ O
gcc _ _ O
main.c _ _ O
-std=c11 _ _ O
ðŸ˜” _ _ O
gcc _ _ O
main.c _ _ O
-std=c18 _ _ O
ðŸ˜” _ _ O
clang _ _ O
main.c _ _ O
-std=c99 _ _ O
ðŸ˜” _ _ O
clang _ _ O
main.c _ _ O
-std=c11 _ _ O
ðŸ˜ƒ _ _ O
clang _ _ O
main.c _ _ O
-std=c18 _ _ O
ðŸ˜ƒ _ _ O
# _ _ O
include _ _ O
< _ _ O
stdio.h _ _ O
> _ _ O
int _ _ O
main _ _ O
( _ _ O
void _ _ B-Concept
) _ _ O
{ _ _ O
int _ _ O
ðŸ˜± _ _ O
= _ _ O
3 _ _ O
; _ _ O
printf _ _ O
( _ _ O
" _ _ O
ðŸ˜± _ _ O
is _ _ O
% _ _ O
d\n _ _ O
" _ _ O
, _ _ O
ðŸ˜± _ _ O
) _ _ O
; _ _ O
return _ _ O
0 _ _ O
; _ _ O
} _ _ O
lun8@thoth _ _ O
: _ _ O
~ _ _ O
/ _ _ O
code_449 _ _ O
$ _ _ O
. _ _ O
/ _ _ O
Hello _ _ O
ðŸ˜± _ _ O
is _ _ O
3 _ _ O
Answer _ _ O
: _ _ O
So _ _ O
... _ _ O
Not _ _ O
really _ _ O
, _ _ O
so _ _ O
avoid _ _ O
it _ _ O
( _ _ O
unless _ _ O
it _ _ O
's _ _ O
for _ _ O
fun _ _ O
) _ _ O
! _ _ O
10 _ _ O
Pointers _ _ O
They _ _ O
point _ _ O
to _ _ O
things _ _ O
. _ _ O
They _ _ O
are _ _ O
not _ _ O
the _ _ O
things _ _ O
. _ _ O
But _ _ O
they _ _ O
are _ _ O
things _ _ O
! _ _ O
? _ _ O
11 _ _ O
The _ _ O
" _ _ O
Memory _ _ B-Concept
Address _ _ I-Concept
" _ _ B-Concept
Variable _ _ B-Concept
Type _ _ O
â€¢ _ _ O
In _ _ O
C _ _ O
, _ _ O
we _ _ O
have _ _ O
integer _ _ O
types _ _ O
, _ _ O
floating _ _ O
point _ _ O
types _ _ O
... _ _ O
â€¢ _ _ O
Now _ _ O
we _ _ O
introduce _ _ O
our _ _ O
dedicated _ _ O
address _ _ B-Concept
type _ _ O
! _ _ O
â€¢ _ _ O
A _ _ O
pointer _ _ B-Concept
is _ _ O
a _ _ O
specific _ _ O
variable _ _ B-Concept
type _ _ O
that _ _ O
holds _ _ O
a _ _ O
memory _ _ B-Concept
address _ _ I-Concept
. _ _ B-Concept
â€¢ _ _ O
You _ _ O
can _ _ O
create _ _ O
a _ _ O
pointer _ _ B-Concept
that _ _ O
points _ _ O
to _ _ O
any _ _ O
address _ _ B-Concept
in _ _ O
memory _ _ O
. _ _ O
â€¢ _ _ O
Furthermore _ _ O
, _ _ O
you _ _ O
can _ _ O
tell _ _ O
it _ _ O
what _ _ O
type _ _ O
of _ _ O
data _ _ O
it _ _ O
should _ _ O
interpret _ _ O
that _ _ O
memory _ _ O
to _ _ O
be _ _ O
: _ _ O
Just _ _ O
place _ _ O
that _ _ O
at _ _ O
the _ _ O
end _ _ O
. _ _ O
12 _ _ O
Interpreting _ _ O
Pointers _ _ O
: _ _ O
Basics _ _ O
ðŸ‘‰ _ _ O
ðŸ‘‰ _ _ O
Memory _ _ O
( _ _ O
32-bit _ _ O
addresses _ _ O
) _ _ O
3.14159 _ _ O
42 _ _ O
â€¢ _ _ O
Pointers _ _ O
can _ _ O
pointer _ _ B-Concept
to _ _ O
individual _ _ O
sections _ _ O
of _ _ O
memory _ _ O
. _ _ O
â€¢ _ _ O
They _ _ O
interpret _ _ O
whatever _ _ O
binary _ _ O
information _ _ O
is _ _ O
there _ _ O
. _ _ O
13 _ _ O
Interpreting _ _ O
Pointers _ _ O
: _ _ O
Hmm _ _ O
ðŸ‘‰ _ _ O
ðŸ‘‰ _ _ O
Memory _ _ O
( _ _ O
32-bit _ _ O
addresses _ _ O
) _ _ O
3.14159 _ _ O
42 _ _ O
or _ _ O
0.1543e10 _ _ O
( _ _ O
-8 _ _ O
) _ _ O
? _ _ O
â€¢ _ _ O
Pointers _ _ O
can _ _ O
refer _ _ O
to _ _ O
the _ _ O
same _ _ O
address _ _ B-Concept
as _ _ O
other _ _ O
pointers _ _ O
just _ _ O
fine _ _ O
. _ _ O
â€¢ _ _ O
They _ _ O
interpret _ _ O
whatever _ _ O
binary _ _ O
information _ _ O
is _ _ O
there _ _ O
. _ _ O
14 _ _ O
Interpreting _ _ O
Pointers _ _ O
: _ _ O
A _ _ O
Sign _ _ O
of _ _ O
Trouble _ _ O
ðŸ‘‰ _ _ O
Memory _ _ O
( _ _ O
32-bit _ _ O
addresses _ _ O
) _ _ O
Help _ _ O
I _ _ O
'm _ _ O
Lost _ _ O
! _ _ O
ðŸ‘‰ _ _ O
3.14159 _ _ O
ïŒ _ _ O
42 _ _ O
or _ _ O
0.1543e10 _ _ O
( _ _ O
-8 _ _ O
) _ _ O
? _ _ O
â€¢ _ _ O
Without _ _ O
the _ _ O
pointer _ _ B-Concept
, _ _ O
allocated _ _ O
data _ _ O
may _ _ O
linger _ _ O
forever _ _ O
without _ _ O
a _ _ O
way _ _ O
to _ _ O
reference _ _ O
it _ _ O
again _ _ O
! _ _ O
â€¢ _ _ O
C _ _ O
does _ _ O
not _ _ O
manage _ _ O
freeing _ _ O
memory _ _ O
for _ _ O
you _ _ O
. _ _ O
15 _ _ O
Dereferencing _ _ O
Pointers _ _ O
: _ _ O
A _ _ O
Star _ _ O
is _ _ O
Born _ _ O
â€¢ _ _ O
So _ _ O
, _ _ O
we _ _ O
have _ _ O
some _ _ O
ambiguity _ _ O
in _ _ O
our _ _ O
language _ _ O
. _ _ O
â€¢ _ _ O
If _ _ O
we _ _ O
have _ _ O
a _ _ O
variable _ _ B-Concept
that _ _ O
holds _ _ O
an _ _ O
address _ _ B-Concept
, _ _ O
normal _ _ O
operations _ _ O
change _ _ O
the _ _ O
address _ _ B-Concept
not _ _ O
the _ _ O
value _ _ O
referenced _ _ O
by _ _ O
the _ _ O
pointer _ _ B-Concept
. _ _ O
â€¢ _ _ O
We _ _ O
use _ _ O
the _ _ O
dereference _ _ B-Concept
operator _ _ I-Concept
( _ _ O
) _ _ O
ðŸ‘‰ _ _ O
ðŸ‘‰ _ _ O
ðŸ‘‰ _ _ O
ðŸ‘‰ _ _ O
16 _ _ O
Dereferencing _ _ O
Pointers _ _ O
: _ _ O
A _ _ O
Star _ _ O
is _ _ O
Born _ _ O
â€¢ _ _ O
Remember _ _ O
: _ _ O
C _ _ O
implicitly _ _ O
coerces _ _ O
whatever _ _ O
values _ _ O
you _ _ O
throw _ _ O
at _ _ O
it _ _ O
... _ _ O
â€¢ _ _ O
Incorrectly _ _ O
assigning _ _ O
a _ _ O
value _ _ O
to _ _ O
an _ _ O
address _ _ B-Concept
or _ _ O
vice _ _ O
versa _ _ O
will _ _ O
be _ _ O
... _ _ O
â€¢ _ _ O
... _ _ O
Well _ _ O
... _ _ O
It _ _ O
will _ _ O
be _ _ O
surprising _ _ O
to _ _ O
say _ _ O
the _ _ O
least _ _ O
. _ _ O
â€¢ _ _ O
Generally _ _ O
, _ _ O
compilers _ _ O
will _ _ O
issue _ _ O
a _ _ O
warning _ _ O
. _ _ O
â€¢ _ _ O
But _ _ O
warnings _ _ O
mean _ _ O
it _ _ O
still _ _ O
compiles _ _ O
! _ _ O
! _ _ O
( _ _ O
You _ _ O
should _ _ O
eliminate _ _ O
warnings _ _ O
in _ _ O
practice _ _ O
) _ _ O
ðŸ‘‰ _ _ O
ðŸ‘‰ _ _ O
ðŸ‘‰ _ _ O
ðŸ¤” _ _ O
ðŸ‘‰ _ _ O
ðŸ‘‰ _ _ O
17 _ _ O
Referencing _ _ O
Data _ _ O
: _ _ O
An _ _ O
... _ _ O
& _ _ O
... _ _ O
is _ _ O
Born _ _ O
? _ _ O
â€¢ _ _ O
Again _ _ O
... _ _ O
ambiguity _ _ O
. _ _ O
When _ _ O
do _ _ O
you _ _ O
want _ _ O
the _ _ O
address _ _ B-Concept
or _ _ O
the _ _ O
data _ _ O
? _ _ O
â€¢ _ _ O
We _ _ O
can _ _ O
pull _ _ O
out _ _ O
the _ _ O
address _ _ B-Concept
to _ _ O
data _ _ O
and _ _ O
assign _ _ O
that _ _ O
to _ _ O
a _ _ O
pointer _ _ B-Concept
. _ _ O
â€¢ _ _ O
Sometimes _ _ O
we _ _ O
refer _ _ O
to _ _ O
pointers _ _ O
as _ _ O
' _ _ O
references _ _ O
' _ _ O
to _ _ O
data _ _ O
. _ _ O
â€¢ _ _ O
We _ _ O
use _ _ O
the _ _ O
reference _ _ B-Concept
operator _ _ I-Concept
( _ _ O
) _ _ O
ðŸ‘‰ _ _ O
ðŸ‘‰ _ _ O
ðŸ‘‰ _ _ O
18 _ _ O
Turtles _ _ O
all _ _ O
the _ _ O
way _ _ O
down _ _ O
ðŸ‘‰ _ _ O
_ _ _ O
ðŸ‘‰ _ _ O
_ _ _ O
ðŸ‘‰ _ _ O
_ _ _ O
ðŸ‘‰ _ _ O
_ _ _ O
ðŸ‘‰ _ _ O
_ _ _ O
ðŸ‘‰ _ _ O
_ _ _ O
ðŸ‘‰ _ _ O
_ _ _ O
ðŸ‘‰ _ _ O
_ _ _ O
ðŸ‘‰ _ _ O
_ _ _ O
19 _ _ O
Removing _ _ O
the _ _ O
emoji _ _ O
20 _ _ O
Like _ _ O
skipping _ _ O
rocks _ _ O
on _ _ O
the _ _ O
lake _ _ O
... _ _ O
00 _ _ O
01 _ _ O
02 _ _ O
03 _ _ O
04 _ _ O
05 _ _ O
06 _ _ O
42 _ _ O
07 _ _ O
08 _ _ O
09 _ _ O
0A _ _ O
0B _ _ O
0C _ _ O
0D _ _ O
0E _ _ O
0F _ _ O
10 _ _ O
11 _ _ O
12 _ _ O
13 _ _ O
4 _ _ O
data _ _ O
dataptr _ _ O
21 _ _ O
Like _ _ O
skipping _ _ O
rocks _ _ O
on _ _ O
the _ _ O
lake _ _ O
... _ _ O
00 _ _ O
01 _ _ O
02 _ _ O
03 _ _ O
04 _ _ O
05 _ _ O
06 _ _ O
42 _ _ O
07 _ _ O
08 _ _ O
09 _ _ O
0A _ _ O
0B _ _ O
0C _ _ O
4 _ _ O
data _ _ O
0D _ _ O
0E _ _ O
0F _ _ O
10 _ _ O
11 _ _ O
12 _ _ O
13 _ _ O
A _ _ O
dataptr _ _ O
dataptrptr _ _ O
22 _ _ O
The _ _ O
C _ _ B-Concept
Memory _ _ I-Concept
Model _ _ I-Concept
: _ _ O
The _ _ O
Heap _ _ B-Concept
â€¢ _ _ O
The _ _ O
Heap _ _ B-Concept
is _ _ O
the _ _ O
dynamic _ _ O
data _ _ O
section _ _ O
! _ _ O
â€¢ _ _ O
You _ _ O
interact _ _ O
with _ _ O
the _ _ O
heap _ _ B-Concept
entirely _ _ O
with _ _ O
pointers _ _ O
. _ _ O
â€¢ _ _ O
returns _ _ O
the _ _ O
address _ _ B-Concept
to _ _ O
the _ _ O
heap _ _ B-Concept
with _ _ O
at _ _ O
least _ _ O
the _ _ O
number _ _ O
of _ _ O
bytes _ _ O
requested _ _ O
. _ _ O
Or _ _ O
on _ _ O
error _ _ O
. _ _ O
Potential _ _ O
Layout _ _ O
( _ _ O
32-bit _ _ O
addresses _ _ O
) _ _ O
stack _ _ B-Concept
currently _ _ O
unused _ _ O
but _ _ O
available _ _ O
memory _ _ O
heap _ _ B-Concept
static _ _ B-Concept
data _ _ B-Concept
code _ _ B-Concept
23 _ _ O
Arrays _ _ O
It _ _ O
is _ _ O
what _ _ O
all _ _ O
my _ _ O
fellow _ _ O
teachers _ _ O
desperately _ _ O
need _ _ O
: _ _ O
Arrays _ _ O
. _ _ O
24 _ _ O
Many _ _ O
ducks _ _ O
lined _ _ O
up _ _ O
in _ _ O
a _ _ O
row _ _ O
â€¢ _ _ O
An _ _ O
array _ _ B-Concept
is _ _ O
simply _ _ O
a _ _ O
continuous _ _ O
span _ _ O
of _ _ O
memory _ _ O
. _ _ O
â€¢ _ _ O
You _ _ O
can _ _ O
declare _ _ O
an _ _ O
array _ _ B-Concept
on _ _ O
the _ _ O
stack _ _ B-Concept
: _ _ O
â€¢ _ _ O
You _ _ O
can _ _ O
declare _ _ O
an _ _ O
array _ _ B-Concept
on _ _ O
the _ _ O
heap _ _ B-Concept
: _ _ O
writing _ _ O
in _ _ O
a _ _ O
pedantic _ _ O
style _ _ O
, _ _ O
you _ _ O
would _ _ O
write _ _ O
the _ _ O
cast _ _ O
here _ _ O
. _ _ O
25 _ _ O
Initialization _ _ O
â€¢ _ _ O
You _ _ O
can _ _ O
initialize _ _ O
them _ _ O
depending _ _ O
on _ _ O
how _ _ O
they _ _ O
are _ _ O
allocated _ _ O
: _ _ O
â€¢ _ _ O
You _ _ O
can _ _ O
initialize _ _ O
an _ _ O
array _ _ B-Concept
as _ _ O
it _ _ O
is _ _ O
allocated _ _ O
on _ _ O
the _ _ O
stack _ _ B-Concept
: _ _ O
â€¢ _ _ O
And _ _ O
the _ _ O
heap _ _ B-Concept
( _ _ O
for _ _ O
values _ _ O
other _ _ O
than _ _ O
0 _ _ O
, _ _ O
you _ _ O
'll _ _ O
need _ _ O
a _ _ O
loop _ _ O
) _ _ O
: _ _ O
Q _ _ O
: _ _ O
Why _ _ O
is _ _ O
using _ _ O
important _ _ O
here _ _ O
? _ _ O
26 _ _ O
Carelessness _ _ O
means _ _ O
the _ _ O
Stack _ _ B-Concept
; _ _ O
Can _ _ O
stab _ _ O
you _ _ O
in _ _ O
the _ _ O
back _ _ O
! _ _ O
- _ _ O
" _ _ O
A _ _ O
poem _ _ O
about _ _ O
betrayal _ _ O
" _ _ O
by _ _ O
wilkie _ _ O
â€¢ _ _ O
Remember _ _ O
: _ _ O
Variables _ _ O
declared _ _ O
on _ _ O
the _ _ O
stack _ _ B-Concept
are _ _ O
temporary _ _ O
. _ _ O
â€¢ _ _ O
All _ _ O
arrays _ _ O
can _ _ O
be _ _ O
considered _ _ O
pointers _ _ O
, _ _ O
but _ _ O
addresses _ _ O
to _ _ O
the _ _ O
stack _ _ B-Concept
are _ _ O
not _ _ O
reliable _ _ O
: _ _ O
Stack _ _ B-Concept
allocation _ _ B-Concept
Arrays _ _ O
are _ _ O
indeed _ _ O
just _ _ O
pointers _ _ O
! _ _ O
This _ _ O
is _ _ O
an _ _ O
address _ _ B-Concept
on _ _ O
the _ _ O
stack _ _ B-Concept
. _ _ O
Stack _ _ B-Concept
deallocation _ _ O
( _ _ O
oh _ _ O
no _ _ O
! _ _ O
) _ _ O
â€¢ _ _ O
This _ _ O
may _ _ O
work _ _ O
sometimes _ _ O
. _ _ O
â€¢ _ _ O
However _ _ O
calling _ _ O
a _ _ O
new _ _ O
function _ _ B-Concept
will _ _ O
overwrite _ _ O
the _ _ O
array _ _ B-Concept
. _ _ O
Do _ _ O
n't _ _ O
trust _ _ O
it _ _ O
! _ _ O
! _ _ O
â€¢ _ _ O
Instead _ _ O
: _ _ O
Allocate _ _ O
on _ _ O
the _ _ O
heap _ _ B-Concept
and _ _ O
pass _ _ O
in _ _ O
a _ _ O
buffer _ _ O
. _ _ O
( _ _ O
next _ _ O
slide _ _ O
) _ _ O
27 _ _ O
Appropriate _ _ O
use _ _ O
of _ _ O
arrays _ _ O
. _ _ O
Approp-array-te _ _ B-Concept
. _ _ O
Arrays _ _ O
do _ _ O
n't _ _ O
store _ _ O
length _ _ O
. _ _ O
Got _ _ O
ta _ _ O
pass _ _ O
it _ _ O
in _ _ O
. _ _ O
Pointers _ _ O
allow _ _ O
for _ _ O
passing _ _ O
arguments _ _ O
" _ _ O
by _ _ O
reference _ _ O
" _ _ O
Pointers _ _ O
can _ _ O
indeed _ _ O
be _ _ O
array-like _ _ B-Concept
! _ _ O
Heap _ _ B-Concept
allocation _ _ B-Concept
! _ _ O
Although _ _ O
we _ _ O
overwrite _ _ O
all _ _ O
values _ _ O
, _ _ O
using _ _ O
calloc _ _ B-Concept
to _ _ O
initialize _ _ O
array _ _ B-Concept
elements _ _ O
to _ _ O
0 _ _ O
reduces _ _ O
surprises _ _ O
. _ _ O
Q _ _ O
: _ _ O
What _ _ O
happens _ _ O
if _ _ O
we _ _ O
pass _ _ O
20 _ _ O
instead _ _ O
of _ _ O
10 _ _ O
to _ _ O
powers_of_two _ _ O
? _ _ O
28 _ _ O
Quick _ _ O
notes _ _ O
on _ _ O
function _ _ B-Concept
arguments _ _ O
, _ _ O
here _ _ O
... _ _ O
â€¢ _ _ O
All _ _ O
arguments _ _ O
are _ _ O
passed _ _ O
" _ _ O
by _ _ O
value _ _ O
" _ _ O
in _ _ O
C. _ _ O
â€¢ _ _ O
This _ _ O
means _ _ O
the _ _ O
values _ _ O
are _ _ O
copied _ _ O
into _ _ O
temporary _ _ O
space _ _ O
( _ _ O
the _ _ O
stack _ _ B-Concept
, _ _ O
usually _ _ O
) _ _ O
when _ _ O
the _ _ O
functions _ _ O
are _ _ O
called _ _ O
. _ _ O
â€¢ _ _ O
This _ _ O
means _ _ O
changing _ _ O
those _ _ O
values _ _ O
does _ _ O
not _ _ O
change _ _ O
their _ _ O
original _ _ O
sources _ _ O
. _ _ O
â€¢ _ _ O
However _ _ O
, _ _ O
we _ _ O
can _ _ O
pass _ _ O
" _ _ O
by _ _ O
reference _ _ O
" _ _ O
indirectly _ _ O
using _ _ O
pointers _ _ O
: _ _ O
â€¢ _ _ O
Similar _ _ O
to _ _ O
how _ _ O
you _ _ O
pass _ _ O
" _ _ O
by _ _ O
reference _ _ O
" _ _ O
in _ _ O
Java _ _ O
by _ _ O
using _ _ O
arrays _ _ O
. _ _ O
The _ _ O
" _ _ O
value _ _ O
" _ _ O
of _ _ O
the _ _ O
argument _ _ O
is _ _ O
the _ _ O
address _ _ B-Concept
. _ _ O
29 _ _ O
Careful _ _ O
! _ _ O
No _ _ O
guard _ _ O
rails _ _ O
... _ _ O
You _ _ O
might _ _ O
run _ _ O
off _ _ O
the _ _ O
edge _ _ O
... _ _ O
â€¢ _ _ O
Since _ _ O
arrays _ _ O
are _ _ O
just _ _ O
pointers _ _ O
... _ _ O
and _ _ O
the _ _ O
length _ _ O
is _ _ O
not _ _ O
known _ _ O
... _ _ O
â€¢ _ _ O
Accessing _ _ O
any _ _ O
element _ _ O
is _ _ O
correct _ _ O
regardless _ _ O
of _ _ O
actual _ _ O
intended _ _ O
length _ _ O
! _ _ O
â€¢ _ _ O
No _ _ O
array _ _ B-Concept
bounds _ _ B-Concept
checking _ _ I-Concept
is _ _ O
the _ _ O
source _ _ O
of _ _ O
many _ _ O
very _ _ O
serious _ _ O
bugs _ _ O
! _ _ O
â€¢ _ _ O
Can _ _ O
pull _ _ O
out _ _ O
and _ _ O
leak _ _ O
arbitrary _ _ O
memory _ _ O
. _ _ O
â€¢ _ _ O
Can _ _ O
potentially _ _ O
cause _ _ O
the _ _ O
program _ _ O
to _ _ O
execute _ _ O
arbitrarily _ _ O
code _ _ B-Concept
. _ _ O
What _ _ O
if _ _ O
this _ _ O
is _ _ O
too _ _ O
big _ _ O
? _ _ O
A _ _ O
simple _ _ O
mistake _ _ O
, _ _ O
but _ _ O
it _ _ O
will _ _ O
gleefully _ _ O
write _ _ O
to _ _ O
it _ _ O
! _ _ O
30 _ _ O
Pointer _ _ B-Concept
arithmetic _ _ B-Concept
( _ _ O
Warning _ _ O
: _ _ O
it _ _ O
's _ _ O
wacky _ _ O
) _ _ O
â€¢ _ _ O
Because _ _ O
pointers _ _ O
and _ _ O
arrays _ _ O
are _ _ O
essentially _ _ O
the _ _ O
same _ _ O
concept _ _ O
in _ _ O
C _ _ O
... _ _ O
â€¢ _ _ O
Pointers _ _ O
have _ _ O
some _ _ O
strange _ _ O
interactions _ _ O
with _ _ O
math _ _ O
operations _ _ O
. _ _ O
â€¢ _ _ O
Ideally _ _ O
pointers _ _ O
should _ _ O
" _ _ O
align _ _ O
" _ _ O
to _ _ O
their _ _ O
values _ _ O
in _ _ O
memory _ _ O
. _ _ O
â€¢ _ _ O
Goal _ _ O
: _ _ O
Incrementing _ _ O
an _ _ O
pointer _ _ B-Concept
should _ _ O
go _ _ O
to _ _ O
the _ _ O
next _ _ O
â€¢ _ _ O
That _ _ O
is _ _ O
, _ _ O
not _ _ O
part _ _ O
way _ _ O
between _ _ O
two _ _ O
values _ _ O
. _ _ O
in _ _ O
memory _ _ O
. _ _ O
â€¢ _ _ O
Therefore _ _ O
, _ _ O
pointer _ _ B-Concept
sum _ _ O
is _ _ O
scaled _ _ O
to _ _ O
the _ _ O
element _ _ O
size _ _ O
. _ _ O
â€¢ _ _ O
Multiplication _ _ O
and _ _ O
other _ _ O
operators _ _ O
are _ _ O
undefined _ _ O
and _ _ O
result _ _ O
in _ _ O
a _ _ O
compiler _ _ O
error _ _ O
. _ _ O
31 _ _ O
Pointer _ _ B-Concept
arithmetic _ _ B-Concept
in _ _ O
practice _ _ O
: _ _ O
Alternative _ _ O
( _ _ O
and _ _ O
less _ _ O
common _ _ O
) _ _ O
way _ _ O
of _ _ O
expressing _ _ O
a _ _ O
pointer _ _ B-Concept
. _ _ O
The _ _ O
( _ _ O
postfix-increment _ _ B-Concept
) _ _ O
happens _ _ O
AFTER _ _ O
the _ _ O
dereference _ _ O
. _ _ O
This _ _ O
is _ _ O
defined _ _ O
by _ _ O
the _ _ O
C _ _ O
language _ _ O
and _ _ O
is _ _ O
really _ _ O
confusing _ _ O
in _ _ O
practice _ _ O
. _ _ O
( _ _ O
but _ _ O
you _ _ O
'll _ _ O
see _ _ O
it _ _ O
. _ _ O
often _ _ O
. _ _ O
) _ _ O
32 _ _ O
The _ _ O
C _ _ B-Concept
Memory _ _ I-Concept
Model _ _ I-Concept
: _ _ O
The _ _ O
Heap _ _ B-Concept
â€¢ _ _ O
The _ _ O
Heap _ _ B-Concept
is _ _ O
the _ _ O
dynamic _ _ O
data _ _ O
section _ _ O
! _ _ O
â€¢ _ _ O
You _ _ O
interact _ _ O
with _ _ O
the _ _ O
heap _ _ B-Concept
entirely _ _ O
with _ _ O
pointers _ _ O
. _ _ O
â€¢ _ _ O
returns _ _ O
the _ _ O
address _ _ B-Concept
to _ _ O
the _ _ O
heap _ _ B-Concept
with _ _ O
at _ _ O
least _ _ O
the _ _ O
number _ _ O
of _ _ O
bytes _ _ O
requested _ _ O
. _ _ O
Or _ _ O
on _ _ O
error _ _ O
. _ _ O
Potential _ _ O
Layout _ _ O
( _ _ O
32-bit _ _ O
addresses _ _ O
) _ _ O
stack _ _ B-Concept
currently _ _ O
unused _ _ O
but _ _ O
available _ _ O
memory _ _ O
heap _ _ B-Concept
static _ _ B-Concept
data _ _ B-Concept
code _ _ B-Concept
33 _ _ O
Strings _ _ O
No _ _ O
longer _ _ O
just _ _ O
for _ _ O
cats _ _ O
! _ _ O
34 _ _ O
Strings _ _ O
â€¢ _ _ O
They _ _ O
are _ _ O
arrays _ _ O
and _ _ O
, _ _ O
as _ _ O
such _ _ O
, _ _ O
inherit _ _ O
all _ _ O
their _ _ O
limitations _ _ O
/ _ _ O
issues _ _ O
. _ _ O
â€¢ _ _ O
The _ _ O
size _ _ O
is _ _ O
not _ _ O
stored _ _ O
. _ _ O
â€¢ _ _ O
They _ _ O
are _ _ O
essentially _ _ O
just _ _ O
pointers _ _ O
to _ _ O
memory _ _ O
. _ _ O
â€¢ _ _ O
Text _ _ B-Concept
is _ _ O
represented _ _ O
as _ _ O
an _ _ O
array _ _ B-Concept
of _ _ O
elements _ _ O
. _ _ O
â€¢ _ _ O
Representing _ _ O
text _ _ B-Concept
is _ _ O
hard _ _ O
! _ _ O
! _ _ O
! _ _ O
â€¢ _ _ O
Understatement _ _ O
of _ _ O
the _ _ O
dang _ _ O
century _ _ O
. _ _ O
â€¢ _ _ O
Original _ _ O
ASCII _ _ B-Concept
is _ _ O
7-bit _ _ O
, _ _ O
encodes _ _ O
Latin _ _ O
and _ _ O
Greek _ _ O
â€¢ _ _ O
Hence _ _ O
being _ _ O
the _ _ O
C _ _ O
integer _ _ O
byte _ _ B-Concept
type _ _ O
. _ _ O
â€¢ _ _ O
Extended _ _ O
for _ _ O
various _ _ O
locales _ _ O
haphazardly _ _ O
. _ _ O
â€¢ _ _ O
7-bits _ _ O
woefully _ _ O
inadequate _ _ O
for _ _ O
certain _ _ O
languages _ _ O
. _ _ O
â€¢ _ _ O
Unicode _ _ B-Concept
mostly _ _ O
successfully _ _ O
unifies _ _ O
a _ _ O
variety _ _ O
of _ _ O
glyphs _ _ O
. _ _ O
â€¢ _ _ O
Tens _ _ O
of _ _ O
thousands _ _ O
of _ _ O
different _ _ O
characters _ _ O
! _ _ O
More _ _ O
than _ _ O
a _ _ O
byte _ _ B-Concept
! _ _ O
! _ _ O
35 _ _ O
How _ _ O
long _ _ O
is _ _ O
your _ _ O
string _ _ B-Concept
? _ _ O
â€¢ _ _ O
Arrays _ _ O
in _ _ O
C _ _ O
are _ _ O
just _ _ O
pointers _ _ O
and _ _ O
as _ _ O
such _ _ O
do _ _ O
not _ _ O
store _ _ O
their _ _ O
length _ _ O
. _ _ O
â€¢ _ _ O
They _ _ O
are _ _ O
simply _ _ O
continuous _ _ O
sections _ _ O
of _ _ O
memory _ _ O
! _ _ O
â€¢ _ _ O
Up _ _ O
to _ _ O
you _ _ O
to _ _ O
figure _ _ O
out _ _ O
how _ _ O
long _ _ O
it _ _ O
is _ _ O
! _ _ O
â€¢ _ _ O
Misreporting _ _ O
or _ _ O
assuming _ _ O
length _ _ O
is _ _ O
often _ _ O
a _ _ O
big _ _ O
source _ _ O
of _ _ O
bugs _ _ O
! _ _ O
â€¢ _ _ O
So _ _ O
, _ _ O
there _ _ O
are _ _ O
two _ _ O
common _ _ O
ways _ _ O
of _ _ O
expressing _ _ O
length _ _ O
: _ _ O
â€¢ _ _ O
Storing _ _ O
the _ _ O
length _ _ O
alongside _ _ O
the _ _ O
array _ _ B-Concept
. _ _ O
â€¢ _ _ O
Storing _ _ O
a _ _ O
special _ _ O
value _ _ O
within _ _ O
the _ _ O
array _ _ B-Concept
to _ _ O
mark _ _ O
the _ _ O
end _ _ O
. _ _ O
( _ _ O
A _ _ O
sentinel _ _ O
value _ _ O
) _ _ O
â€¢ _ _ O
Strings _ _ O
in _ _ O
C _ _ O
commonly _ _ O
employ _ _ O
a _ _ O
sentinel _ _ B-Concept
value _ _ I-Concept
. _ _ O
â€¢ _ _ O
Such _ _ O
a _ _ O
value _ _ O
must _ _ O
be _ _ O
something _ _ O
considered _ _ O
invalid _ _ O
for _ _ O
actual _ _ O
data _ _ O
. _ _ O
â€¢ _ _ O
How _ _ O
do _ _ O
you _ _ O
know _ _ O
how _ _ O
long _ _ O
such _ _ O
an _ _ O
array _ _ B-Concept
is _ _ O
? _ _ O
â€¢ _ _ O
You _ _ O
will _ _ O
have _ _ O
to _ _ O
search _ _ O
for _ _ O
the _ _ O
sentinel _ _ B-Concept
value _ _ I-Concept
! _ _ O
Incurring _ _ O
a _ _ O
O _ _ O
( _ _ O
n _ _ O
) _ _ O
time _ _ O
cost _ _ O
. _ _ O
36 _ _ O
The _ _ O
string _ _ B-Concept
literal _ _ B-Concept
. _ _ O
â€¢ _ _ O
String _ _ B-Concept
literals _ _ O
should _ _ O
be _ _ O
familiar _ _ O
from _ _ O
Java _ _ O
. _ _ O
â€¢ _ _ O
However _ _ O
, _ _ O
in _ _ O
C _ _ O
, _ _ O
they _ _ O
are _ _ O
pointers _ _ O
. _ _ O
( _ _ O
That _ _ O
is _ _ O
: _ _ O
) _ _ O
â€¢ _ _ O
The _ _ O
contents _ _ O
of _ _ O
the _ _ O
literal _ _ O
are _ _ O
read-only _ _ O
( _ _ O
immutable _ _ O
) _ _ O
so _ _ O
it _ _ O
is _ _ O
a _ _ O
: _ _ O
â€¢ _ _ O
Modifying _ _ O
it _ _ O
crashes _ _ O
your _ _ O
program _ _ O
! _ _ O
! _ _ O
â€¢ _ _ O
A _ _ O
pointer _ _ B-Concept
that _ _ O
ca _ _ O
n't _ _ O
change _ _ O
pointing _ _ O
to _ _ O
an _ _ O
immutable _ _ O
string _ _ B-Concept
is _ _ O
a _ _ O
Let _ _ O
's _ _ O
ignore _ _ O
this _ _ O
! _ _ O
â˜º _ _ O
( _ _ O
for _ _ O
now _ _ O
) _ _ O
The _ _ O
variable _ _ B-Concept
is _ _ O
allocated _ _ O
on _ _ O
the _ _ O
stack _ _ B-Concept
, _ _ O
which _ _ O
is _ _ O
a _ _ O
pointer _ _ B-Concept
. _ _ O
The _ _ O
string _ _ B-Concept
itself _ _ O
is _ _ O
37 _ _ O
likely _ _ O
in _ _ O
the _ _ O
static _ _ B-Concept
data _ _ B-Concept
segment _ _ O
! _ _ O
How _ _ O
long _ _ O
is _ _ O
your _ _ O
string _ _ B-Concept
? _ _ O
Let _ _ O
's _ _ O
find _ _ O
out _ _ O
. _ _ O
â€¢ _ _ O
The _ _ O
standard _ _ O
library _ _ O
function _ _ B-Concept
reports _ _ O
the _ _ O
length _ _ O
of _ _ O
a _ _ O
string _ _ B-Concept
. _ _ O
â€¢ _ _ O
This _ _ O
is _ _ O
done _ _ O
in _ _ O
roughly _ _ O
O _ _ O
( _ _ O
n _ _ O
) _ _ O
time _ _ O
as _ _ O
it _ _ O
must _ _ O
find _ _ O
the _ _ O
sentinel _ _ O
. _ _ O
â€¢ _ _ O
The _ _ O
following _ _ O
code _ _ B-Concept
investigates _ _ O
and _ _ O
prints _ _ O
out _ _ O
the _ _ O
sentinel _ _ O
: _ _ O
38 _ _ O
When _ _ O
good _ _ O
strings _ _ O
go _ _ O
bad _ _ O
. _ _ O
â€¢ _ _ O
What _ _ O
happens _ _ O
if _ _ O
that _ _ O
sentinel _ _ O
... _ _ O
was _ _ O
not _ _ O
there _ _ O
? _ _ O
â€¢ _ _ O
Well _ _ O
... _ _ O
it _ _ O
would _ _ O
keep _ _ O
counting _ _ O
garbage _ _ O
memory _ _ O
until _ _ O
it _ _ O
sees _ _ O
a _ _ O
0 _ _ O
. _ _ O
This _ _ O
syntax _ _ O
copies _ _ O
the _ _ O
string _ _ B-Concept
literal _ _ B-Concept
on _ _ O
to _ _ O
the _ _ O
stack _ _ B-Concept
. _ _ O
This _ _ O
allows _ _ O
us _ _ O
to _ _ O
modify _ _ O
it _ _ O
. _ _ O
( _ _ O
otherwise _ _ O
, _ _ O
it _ _ O
is _ _ O
immutable _ _ O
) _ _ O
The _ _ O
length _ _ O
here _ _ O
depends _ _ O
on _ _ O
the _ _ O
state _ _ O
of _ _ O
memory _ _ O
in _ _ O
the _ _ O
stack _ _ B-Concept
. _ _ O
39 _ _ O
Using _ _ O
stronger _ _ O
strings _ _ O
. _ _ O
A _ _ O
... _ _ O
rope _ _ O
... _ _ O
perhaps _ _ O
. _ _ O
â€¢ _ _ O
To _ _ O
ensure _ _ O
that _ _ O
malicious _ _ O
input _ _ O
is _ _ O
less _ _ O
likely _ _ O
to _ _ O
be _ _ O
disastrous _ _ O
... _ _ O
â€¢ _ _ O
We _ _ O
have _ _ O
alternative _ _ O
standard _ _ O
functions _ _ O
that _ _ O
set _ _ O
a _ _ O
maximum _ _ O
length _ _ O
. _ _ O
strnlen _ _ B-Concept
will _ _ O
stop _ _ O
after _ _ O
the _ _ O
12th _ _ O
character _ _ O
if _ _ O
it _ _ O
does _ _ O
not _ _ O
see _ _ O
a _ _ O
sentinel _ _ O
. _ _ O
40 _ _ O
Comparing _ _ O
" _ _ O
Apples _ _ O
" _ _ O
to _ _ O
" _ _ O
Oranges _ _ O
" _ _ O
â€¢ _ _ O
When _ _ O
you _ _ O
compare _ _ O
strings _ _ O
using _ _ O
it _ _ O
compares _ _ O
the _ _ O
addresses _ _ O
! _ _ O
â€¢ _ _ O
Since _ _ O
string _ _ B-Concept
literals _ _ O
are _ _ O
constant _ _ O
, _ _ O
they _ _ O
only _ _ O
exist _ _ O
in _ _ O
the _ _ O
executable _ _ O
once _ _ O
. _ _ O
â€¢ _ _ O
All _ _ O
references _ _ O
will _ _ O
refer _ _ O
to _ _ O
the _ _ O
same _ _ O
string _ _ B-Concept
! _ _ O
41 _ _ O
Comparing _ _ O
" _ _ O
Apples _ _ O
" _ _ O
to _ _ O
" _ _ O
Oranges _ _ O
" _ _ O
â€¢ _ _ O
When _ _ O
the _ _ O
addresses _ _ O
differ _ _ O
, _ _ O
they _ _ O
are _ _ O
not _ _ O
equal _ _ O
. _ _ O
â€¢ _ _ O
So _ _ O
, _ _ O
you _ _ O
have _ _ O
to _ _ O
be _ _ O
careful _ _ O
when _ _ O
comparing _ _ O
them _ _ O
. _ _ O
â€¢ _ _ O
This _ _ O
is _ _ O
similar _ _ O
to _ _ O
Java _ _ O
when _ _ O
considering _ _ O
versus _ _ O
42 _ _ O
Comparing _ _ O
" _ _ O
Apples _ _ O
" _ _ O
to _ _ O
" _ _ O
Oranges _ _ O
" _ _ O
â€¢ _ _ O
To _ _ O
compare _ _ O
values _ _ O
instead _ _ O
, _ _ O
use _ _ O
the _ _ O
standard _ _ O
library _ _ O
's _ _ O
. _ _ O
â€¢ _ _ O
This _ _ O
will _ _ O
perform _ _ O
a _ _ O
byte-by-byte _ _ B-Concept
comparison _ _ O
of _ _ O
the _ _ O
string _ _ O
. _ _ O
â€¢ _ _ O
Upon _ _ O
finding _ _ O
a _ _ O
difference _ _ O
, _ _ O
it _ _ O
returns _ _ O
rough _ _ O
difference _ _ O
between _ _ O
those _ _ O
contrary _ _ O
bytes _ _ O
. _ _ O
â€¢ _ _ O
When _ _ O
they _ _ O
are _ _ O
the _ _ O
same _ _ O
, _ _ O
then _ _ O
the _ _ O
difference _ _ O
is _ _ O
0 _ _ O
! _ _ O
â€¢ _ _ O
Therefore _ _ O
, _ _ O
it _ _ O
is _ _ O
case _ _ O
sensitive _ _ O
! _ _ O
It _ _ O
also _ _ O
has _ _ O
a _ _ O
O _ _ O
n _ _ O
time _ _ O
complexity _ _ O
. _ _ O
will _ _ O
return _ _ O
0 _ _ O
when _ _ O
the _ _ O
strings _ _ O
are _ _ O
equal _ _ O
. _ _ O
43 _ _ O
Appropriate _ _ O
string _ _ O
construction _ _ O
. _ _ O
A-rope-riate _ _ O
. _ _ O
â€¢ _ _ O
C _ _ O
is _ _ O
a _ _ O
very _ _ O
deliberate _ _ O
language _ _ O
. _ _ O
is _ _ O
important _ _ O
here _ _ O
! _ _ O
Ensures _ _ O
string _ _ O
has _ _ O
a _ _ O
length _ _ O
of _ _ O
0 _ _ O
. _ _ O
( _ _ O
is _ _ O
initially _ _ O
empty _ _ O
, _ _ O
not _ _ O
garbage _ _ O
! _ _ O
) _ _ O
Like _ _ O
a _ _ O
ballroom _ _ O
. _ _ O
Empty _ _ O
, _ _ O
but _ _ O
spacious _ _ O
. _ _ O
is _ _ O
the _ _ O
bounded _ _ O
form _ _ O
of _ _ O
Overwrites _ _ O
string _ _ O
. _ _ O
. _ _ O
is _ _ O
the _ _ O
bounded _ _ O
form _ _ O
of _ _ O
. _ _ O
Concatenates _ _ O
to _ _ O
end _ _ O
of _ _ O
existing _ _ O
string _ _ O
. _ _ O
44 _ _ O
Memory _ _ O
/ _ _ O
Strings _ _ O
: _ _ O
Summary _ _ O
â€¢ _ _ O
Memory _ _ O
Allocation _ _ O
â€¢ _ _ O
â€¢ _ _ O
â€¢ _ _ O
â€¢ _ _ O
Returns _ _ O
pointer _ _ O
to _ _ O
length _ _ O
bytes _ _ O
Returns _ _ O
pointer _ _ O
to _ _ O
( _ _ O
count*size _ _ O
) _ _ O
bytes _ _ O
, _ _ O
zeros _ _ O
them _ _ O
Deallocates _ _ O
memory _ _ O
at _ _ O
' _ _ O
ptr _ _ O
' _ _ O
so _ _ O
it _ _ O
can _ _ O
be _ _ O
allocated _ _ O
elsewhere _ _ O
â€¢ _ _ O
Strings _ _ O
â€¢ _ _ O
â€¢ _ _ O
â€¢ _ _ O
â€¢ _ _ O
â€¢ _ _ O
â€¢ _ _ O
â€¢ _ _ O
â€¢ _ _ O
Generally _ _ O
safer _ _ O
to _ _ O
use _ _ O
the _ _ O
bounded _ _ O
forms _ _ O
. _ _ O
Copies _ _ O
src _ _ O
to _ _ O
dst _ _ O
overwriting _ _ O
dst _ _ O
. _ _ O
Copies _ _ O
up _ _ O
to _ _ O
' _ _ O
max _ _ O
' _ _ O
to _ _ O
dst _ _ O
. _ _ O
Copies _ _ O
string _ _ O
from _ _ O
src _ _ O
to _ _ O
end _ _ O
of _ _ O
dst _ _ O
. _ _ O
Copies _ _ O
up _ _ O
to _ _ O
' _ _ O
max _ _ O
' _ _ O
to _ _ O
end _ _ O
of _ _ O
dst _ _ O
. _ _ O
Returns _ _ O
difference _ _ O
between _ _ O
strings _ _ O
. _ _ O
( _ _ O
0 _ _ O
if _ _ O
equal _ _ O
) _ _ O
Compares _ _ O
up _ _ O
to _ _ O
' _ _ O
max _ _ O
' _ _ O
bytes _ _ O
. _ _ O
45 _ _ O
Input _ _ O
/ _ _ O
Output _ _ O
: _ _ O
Summary _ _ O
â€¢ _ _ O
Input _ _ O
â€¢ _ _ O
â€¢ _ _ O
â€¢ _ _ O
â€¢ _ _ O
â€¢ _ _ O
Output _ _ O
â€¢ _ _ O
â€¢ _ _ O
â€¢ _ _ O
â€¢ _ _ O
â€¢ _ _ O
â€¢ _ _ O
â€¢ _ _ O
Copies _ _ O
string _ _ O
input _ _ O
by _ _ O
user _ _ O
into _ _ O
buffer _ _ O
( _ _ O
unsafe _ _ O
! _ _ O
) _ _ O
Copies _ _ O
up _ _ O
to _ _ O
10 _ _ O
chars _ _ O
into _ _ O
buffer _ _ O
( _ _ O
my_buffer _ _ O
needs _ _ O
to _ _ O
be _ _ O
> _ _ O
= _ _ O
11 _ _ O
bytes _ _ O
for _ _ O
sentinel _ _ O
) _ _ O
Interprets _ _ O
input _ _ O
and _ _ O
places _ _ O
value _ _ O
into _ _ O
int _ _ O
variable _ _ O
. _ _ O
updates _ _ O
your _ _ O
variable _ _ O
, _ _ O
so _ _ O
you _ _ O
need _ _ O
to _ _ O
pass _ _ O
the _ _ O
address _ _ O
. _ _ O
( _ _ O
does _ _ O
not _ _ O
need _ _ O
it _ _ O
. _ _ O
Strings _ _ O
are _ _ O
already _ _ O
) _ _ O
Prints _ _ O
string _ _ O
. _ _ O
( _ _ O
technically _ _ O
unsafe _ _ O
) _ _ O
Prints _ _ O
up _ _ O
to _ _ O
10 _ _ O
chars _ _ O
from _ _ O
string _ _ O
. _ _ O
( _ _ O
safe _ _ O
as _ _ O
long _ _ O
as _ _ O
my_buffer _ _ O
is _ _ O
> _ _ O
= _ _ O
10 _ _ O
bytes _ _ O
) _ _ O
Prints _ _ O
int _ _ O
variable _ _ O
. _ _ O
( _ _ O
d _ _ O
for _ _ O
decimal _ _ O
, _ _ O
unfortunately _ _ O
) _ _ O
Prints _ _ O
int _ _ O
variable _ _ O
in _ _ O
hexadecimal _ _ O
. _ _ O
( _ _ O
x _ _ O
for _ _ O
hex _ _ O
) _ _ O
Prints _ _ O
long _ _ O
variable _ _ O
. _ _ O
Prints _ _ O
unsigned _ _ O
long _ _ O
variable _ _ O
. _ _ O
â€¢ _ _ O
Lots _ _ O
more _ _ O
variations _ _ O
! _ _ O
Generally _ _ O
and _ _ O
share _ _ O
terms _ _ O
. _ _ O
Look _ _ O
them _ _ O
up _ _ O
! _ _ O
46 _ _ O
Structures _ _ O
It _ _ O
may _ _ O
not _ _ O
have _ _ O
class _ _ O
, _ _ O
but _ _ O
it _ _ O
has _ _ O
style _ _ O
. _ _ O
47 _ _ O
Quick _ _ O
note _ _ O
on _ _ O
allocated _ _ O
structures _ _ O
... _ _ O
â€¢ _ _ O
You _ _ O
are _ _ O
gon _ _ O
na _ _ O
allocate _ _ O
a _ _ O
lot _ _ O
of _ _ O
structures _ _ O
... _ _ O
â€¢ _ _ O
They _ _ O
are _ _ O
big _ _ O
... _ _ O
you _ _ O
want _ _ O
them _ _ O
around _ _ O
... _ _ O
therefore _ _ O
, _ _ O
not _ _ O
good _ _ O
on _ _ O
the _ _ O
stack _ _ O
. _ _ O
â€¢ _ _ O
You _ _ O
could _ _ O
make _ _ O
them _ _ O
globals _ _ O
... _ _ O
except _ _ O
when _ _ O
you _ _ O
want _ _ O
them _ _ O
dynamically _ _ O
. _ _ O
48 _ _ O
Pointing _ _ O
to _ _ O
structure _ _ O
fields _ _ O
... _ _ O
â€¢ _ _ O
A _ _ O
shorthand _ _ O
for _ _ O
â€¢ _ _ O
The _ _ O
" _ _ O
arrow _ _ O
" _ _ O
syntax _ _ O
works _ _ O
only _ _ O
on _ _ O
is _ _ O
pointers _ _ O
and _ _ O
dereferences _ _ O
a _ _ O
field _ _ O
. _ _ O
49 _ _ O
Pointing _ _ O
to _ _ O
structure _ _ O
fields _ _ O
... _ _ O
â€¢ _ _ O
Recall _ _ O
that _ _ O
â€¢ _ _ O
If _ _ O
you _ _ O
want _ _ O
a _ _ O
is _ _ O
what _ _ O
names _ _ O
types _ _ O
. _ _ O
data _ _ O
type _ _ O
, _ _ O
you _ _ O
can _ _ O
use _ _ O
to _ _ O
do _ _ O
so _ _ O
: _ _ O
50 _ _ O
It _ _ O
took _ _ O
humanity _ _ O
thousands _ _ O
of _ _ O
years _ _ O
to _ _ O
discover _ _ O
the _ _ O
NULL _ _ O
pointer _ _ O
error _ _ O
. _ _ O
â€¢ _ _ O
So _ _ O
, _ _ O
what _ _ O
do _ _ O
we _ _ O
use _ _ O
to _ _ O
denote _ _ O
that _ _ O
we _ _ O
are _ _ O
not _ _ O
pointing _ _ O
to _ _ O
anything _ _ O
? _ _ O
â€¢ _ _ O
Same _ _ O
as _ _ O
Java _ _ O
... _ _ O
we _ _ O
use _ _ O
a _ _ O
Null _ _ O
value _ _ O
and _ _ O
we _ _ O
hope _ _ O
nobody _ _ O
dereferences _ _ O
it _ _ O
. _ _ O
â€¢ _ _ O
It _ _ O
is _ _ O
not _ _ O
a _ _ O
built-in _ _ O
thing _ _ O
! _ _ O
We _ _ O
have _ _ O
to _ _ O
include _ _ O
to _ _ O
use _ _ O
it _ _ O
. _ _ O
51 _ _ O
When _ _ O
malloc _ _ O
... _ _ O
goes _ _ O
bad _ _ O
â€¢ _ _ O
When _ _ O
your _ _ O
request _ _ O
for _ _ O
memory _ _ O
can _ _ O
not _ _ O
be _ _ O
made _ _ O
, _ _ O
malloc _ _ O
returns _ _ O
! _ _ O
â€¢ _ _ O
In _ _ O
your _ _ O
perfect _ _ O
program _ _ O
, _ _ O
you _ _ O
would _ _ O
always _ _ O
check _ _ O
for _ _ O
this _ _ O
. _ _ O
52 _ _ O
When _ _ O
malloc _ _ O
... _ _ O
goes _ _ O
bad _ _ O
â€¢ _ _ O
You _ _ O
can _ _ O
check _ _ O
if _ _ O
is _ _ O
null _ _ O
with _ _ O
â€¢ _ _ O
You _ _ O
might _ _ O
say _ _ O
, _ _ O
" _ _ O
hey _ _ O
! _ _ O
is _ _ O
not _ _ O
defined _ _ O
as _ _ O
by _ _ O
the _ _ O
C _ _ O
standard _ _ O
! _ _ O
" _ _ O
â€¢ _ _ O
Yet _ _ O
, _ _ O
C _ _ O
specifically _ _ O
considers _ _ O
any _ _ O
pointer _ _ O
equal _ _ O
to _ _ O
to _ _ O
be _ _ O
a _ _ O
false _ _ O
value _ _ O
. _ _ O
â€¢ _ _ O
Regardless _ _ O
of _ _ O
the _ _ O
value _ _ O
of _ _ O
which _ _ O
is _ _ O
usually _ _ O
anyway _ _ O
. _ _ O
53 _ _ O
Examples _ _ O
Some _ _ O
nice _ _ O
examples _ _ O
that _ _ O
address _ _ O
addressing _ _ O
! _ _ O
54 _ _ O
Summing _ _ O
it _ _ O
all _ _ O
up _ _ O
. _ _ O
55 _ _ O
Searching _ _ O
for _ _ O
values _ _ O
Remember _ _ O
that _ _ O
wants _ _ O
pointers _ _ O
to _ _ O
data _ _ O
. _ _ O
56 _ _ O
Paving _ _ O
a _ _ O
new _ _ O
path _ _ O
Remember _ _ O
that _ _ O
wants _ _ O
pointers _ _ O
to _ _ O
data _ _ O
. _ _ O
When _ _ O
it _ _ O
sees _ _ O
more _ _ O
than _ _ O
20 _ _ O
characters _ _ O
... _ _ O
what _ _ O
will _ _ O
it _ _ O
do _ _ O
? _ _ O
( _ _ O
What _ _ O
will _ _ O
the _ _ O
next _ _ O
call _ _ O
to _ _ O
do _ _ O
? _ _ O
) _ _ O
57 _ _ O
Paving _ _ O
a _ _ O
new _ _ O
path _ _ O
( _ _ O
arbitrary _ _ O
number _ _ O
of _ _ O
directories _ _ O
! _ _ O
) _ _ O
will _ _ O
resize _ _ O
the _ _ O
allocated _ _ O
space _ _ O
, _ _ O
copying _ _ O
the _ _ O
old _ _ O
value _ _ O
to _ _ O
a _ _ O
new _ _ O
chunk _ _ O
of _ _ O
memory _ _ O
if _ _ O
necessary _ _ O
. _ _ O
Look _ _ O
it _ _ O
up _ _ O
on _ _ O
your _ _ O
own _ _ O
! _ _ O
58 _ _ O


