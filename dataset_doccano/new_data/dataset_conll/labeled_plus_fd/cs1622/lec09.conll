['train_set', 'labeled']|cs1622|lec09
-DOCSTART- -X- -X- O

Typing _ _ O
CS _ _ O
1622 _ _ O
Jarrett _ _ O
Billingsley _ _ O
Class _ _ O
Announcements _ _ O
‚óè _ _ O
I _ _ O
may _ _ O
hold _ _ O
some _ _ O
Extra _ _ O
Office _ _ O
Hours _ _ O
on _ _ O
Friday _ _ O
... _ _ O
what _ _ O
time _ _ O
would _ _ O
be _ _ O
best _ _ O
for _ _ O
those _ _ O
of _ _ O
you _ _ O
who _ _ O
think _ _ O
you _ _ O
may _ _ O
need _ _ O
them _ _ O
? _ _ O
2 _ _ O
A _ _ O
little _ _ O
Type _ _ B-Concept
Theory _ _ B-Concept
3 _ _ O
Remember _ _ O
what _ _ O
a _ _ O
type _ _ B-Concept
is _ _ O
? _ _ O
‚óè _ _ O
a _ _ O
type _ _ B-Concept
is _ _ O
: _ _ O
o _ _ O
a _ _ O
set _ _ O
of _ _ O
valid _ _ O
values _ _ O
, _ _ O
plus _ _ O
: _ _ O
o _ _ O
a _ _ O
set _ _ O
of _ _ O
valid _ _ O
operations _ _ O
on _ _ O
those _ _ O
values _ _ O
‚óè _ _ O
think _ _ O
about _ _ O
ints _ _ O
: _ _ O
o _ _ O
there _ _ O
's _ _ O
a _ _ O
range _ _ O
of _ _ O
valid _ _ O
values _ _ O
of _ _ O
an _ _ O
int _ _ B-Concept
variable _ _ O
o _ _ O
and _ _ O
a _ _ O
set _ _ O
of _ _ O
operators _ _ O
and _ _ O
other _ _ O
things _ _ O
you _ _ O
can _ _ O
use _ _ O
on _ _ O
them _ _ O
‚óè _ _ O
type _ _ B-Concept
theory _ _ B-Concept
is _ _ O
a _ _ O
branch _ _ O
of _ _ O
mathematics _ _ O
o _ _ O
it _ _ O
might _ _ O
seem _ _ O
kind _ _ O
of _ _ O
abstract _ _ O
and _ _ O
confusing _ _ O
( _ _ O
as _ _ O
most _ _ O
math _ _ O
does _ _ O
) _ _ O
o _ _ O
but _ _ O
it _ _ O
has _ _ O
had _ _ O
profound _ _ O
impacts _ _ O
on _ _ O
the _ _ O
design _ _ O
and _ _ O
behaviors _ _ O
of _ _ O
programming _ _ O
languages _ _ O
, _ _ O
especially _ _ O
in _ _ O
the _ _ O
past _ _ O
30 _ _ O
years _ _ O
‚óè _ _ O
without _ _ O
rigorous _ _ O
type _ _ B-Concept
theory _ _ B-Concept
, _ _ O
you _ _ O
get _ _ O
C _ _ O
üò¨ _ _ O
4 _ _ O
I _ _ O
'll _ _ O
Curry _ _ O
YOUR _ _ O
Howards _ _ O
, _ _ O
isomorphically _ _ O
‚óè _ _ O
remember _ _ O
from _ _ O
the _ _ O
beginning _ _ O
of _ _ O
the _ _ O
term _ _ B-Concept
: _ _ O
programs _ _ O
are _ _ O
proofs _ _ O
. _ _ O
‚óè _ _ O
type _ _ B-Concept
systems _ _ O
are _ _ O
essentially _ _ O
proof _ _ O
justifications _ _ O
. _ _ O
these _ _ O
justifications _ _ O
are _ _ O
saying _ _ O
, _ _ O
" _ _ O
look _ _ O
, _ _ O
I _ _ O
'm _ _ O
using _ _ O
only _ _ O
valid _ _ O
operations _ _ O
on _ _ O
these _ _ O
values _ _ O
! _ _ O
" _ _ O
similarly _ _ O
, _ _ O
when _ _ O
you _ _ O
say _ _ O
" _ _ O
this _ _ O
variable _ _ O
is _ _ O
an _ _ O
int _ _ B-Concept
, _ _ O
" _ _ O
the _ _ O
compiler _ _ O
uses _ _ O
that _ _ O
information _ _ O
to _ _ O
justify _ _ O
the _ _ O
steps _ _ O
of _ _ O
your _ _ O
program _ _ O
. _ _ O
if _ _ O
it _ _ O
ca _ _ O
n't _ _ O
... _ _ O
that _ _ O
's _ _ O
a _ _ O
type _ _ B-Concept
error _ _ B-Concept
! _ _ I-Concept
5 _ _ O
Type _ _ B-Concept
Safety _ _ B-Concept
= _ _ O
Progress _ _ B-Concept
+ _ _ O
Preservation _ _ B-Concept
‚óè _ _ O
type _ _ B-Concept
safety _ _ B-Concept
means _ _ O
that _ _ O
you _ _ O
know _ _ O
exactly _ _ O
what _ _ O
will _ _ O
happen _ _ O
at _ _ O
every _ _ O
step _ _ O
of _ _ O
your _ _ O
program _ _ O
, _ _ O
because _ _ O
you _ _ O
know _ _ O
the _ _ O
types _ _ O
of _ _ O
everything _ _ O
. _ _ O
progress _ _ B-Concept
means _ _ O
that _ _ O
at _ _ O
every _ _ O
step _ _ O
of _ _ O
computation _ _ O
: _ _ O
... _ _ O
or _ _ O
there _ _ O
is _ _ O
exactly _ _ O
one _ _ O
thing _ _ O
that _ _ O
can _ _ O
happen _ _ O
. _ _ O
either _ _ O
the _ _ O
program _ _ O
halts _ _ O
... _ _ O
int _ _ B-Concept
[ _ _ O
] _ _ O
a _ _ O
= _ _ O
{ _ _ O
1 _ _ O
, _ _ O
2 _ _ O
, _ _ O
3 _ _ O
} _ _ O
; _ _ O
a _ _ O
[ _ _ O
4 _ _ O
] _ _ O
= _ _ O
10 _ _ O
; _ _ O
/ _ _ O
/ _ _ O
halts _ _ O
int _ _ B-Concept
[ _ _ O
] _ _ O
a _ _ O
= _ _ O
{ _ _ O
1 _ _ O
, _ _ O
2 _ _ O
, _ _ O
3 _ _ O
} _ _ O
; _ _ O
a _ _ O
[ _ _ O
0 _ _ O
] _ _ O
= _ _ O
10 _ _ O
; _ _ O
/ _ _ O
/ _ _ O
assigns _ _ O
preservation _ _ B-Concept
means _ _ O
that _ _ O
you _ _ O
know _ _ O
the _ _ O
type _ _ B-Concept
of _ _ O
every _ _ O
value _ _ O
, _ _ O
at _ _ O
every _ _ O
step _ _ O
of _ _ O
computation _ _ O
. _ _ O
( _ _ O
you _ _ O
never _ _ O
" _ _ O
leave _ _ O
the _ _ O
walls _ _ O
" _ _ O
of _ _ O
the _ _ O
type _ _ B-Concept
system _ _ B-Concept
. _ _ O
) _ _ O
Java _ _ O
is _ _ O
a _ _ O
type-safe _ _ B-Concept
language _ _ O
, _ _ O
so _ _ O
I _ _ O
ca _ _ O
n't _ _ O
give _ _ O
an _ _ O
example _ _ O
of _ _ O
that _ _ O
. _ _ O
but _ _ O
what _ _ O
about _ _ O
the _ _ O
most _ _ O
popular _ _ O
language _ _ O
used _ _ O
for _ _ O
programming _ _ O
our _ _ O
operating _ _ O
systems _ _ O
, _ _ O
device _ _ O
drivers _ _ O
, _ _ O
embedded _ _ O
device _ _ O
firmware _ _ O
etc _ _ O
. _ _ O
? _ _ O
üôÉ _ _ O
6 _ _ O
A _ _ O
very _ _ O
unsafe _ _ O
language _ _ O
‚óè _ _ O
in _ _ O
C _ _ O
, _ _ O
the _ _ O
type _ _ B-Concept
system _ _ B-Concept
was _ _ O
an _ _ O
afterthought _ _ O
. _ _ O
float _ _ O
f _ _ O
= _ _ O
3.4 _ _ O
; _ _ O
int _ _ B-Concept
a _ _ O
[ _ _ O
10 _ _ O
] _ _ O
; _ _ O
a _ _ O
[ _ _ O
10 _ _ O
] _ _ O
= _ _ O
0xDEADBEEF _ _ O
; _ _ O
printf _ _ O
( _ _ O
"%f\n _ _ O
" _ _ O
, _ _ O
f _ _ O
) _ _ O
; _ _ O
this _ _ O
line _ _ O
of _ _ O
code _ _ O
violates _ _ O
both _ _ O
progress _ _ B-Concept
and _ _ O
preservation _ _ B-Concept
. _ _ O
it _ _ O
violates _ _ O
progress _ _ B-Concept
because _ _ O
accessing _ _ O
an _ _ O
array _ _ O
out-of-bounds _ _ O
is _ _ O
" _ _ O
undefined _ _ B-Concept
behavior _ _ I-Concept
" _ _ O
( _ _ O
UB _ _ B-Concept
) _ _ O
, _ _ O
which _ _ O
means _ _ O
" _ _ O
anything _ _ O
could _ _ O
happen _ _ O
. _ _ O
" _ _ O
it _ _ O
violates _ _ O
preservation _ _ B-Concept
because _ _ O
one _ _ O
of _ _ O
the _ _ O
things _ _ O
that _ _ O
could _ _ O
happen _ _ O
is _ _ O
that _ _ O
this _ _ O
line _ _ O
overwrites _ _ O
the _ _ O
value _ _ O
in _ _ O
f _ _ O
, _ _ O
violating _ _ O
its _ _ O
type _ _ B-Concept
. _ _ O
depending _ _ O
on _ _ O
the _ _ O
platform _ _ O
and _ _ O
compilation _ _ O
settings _ _ O
, _ _ O
this _ _ O
printf _ _ O
might _ _ O
show _ _ O
3.4 _ _ O
or _ _ O
-6259853398707798016.000000 _ _ O
! _ _ O
7 _ _ O
Safety _ _ O
has _ _ O
to _ _ O
be _ _ O
built-in _ _ O
‚óè _ _ O
once _ _ O
you _ _ O
step _ _ O
into _ _ O
UB _ _ B-Concept
, _ _ O
you _ _ O
can _ _ O
not _ _ O
guarantee _ _ O
anything _ _ O
. _ _ O
o _ _ O
it _ _ O
's _ _ O
like _ _ O
writing _ _ O
a _ _ O
proof _ _ O
with _ _ O
an _ _ O
incorrect _ _ O
step _ _ O
. _ _ O
o _ _ O
all _ _ O
the _ _ O
steps _ _ O
after _ _ O
may _ _ O
or _ _ O
may _ _ O
not _ _ O
be _ _ O
invalid _ _ O
! _ _ O
o _ _ O
HLLs _ _ O
are _ _ O
a _ _ O
set _ _ O
of _ _ O
abstractions _ _ O
, _ _ O
and _ _ O
type-unsafety _ _ B-Concept
lets _ _ O
you _ _ O
ruin _ _ O
those _ _ O
abstractions _ _ O
entirely _ _ O
. _ _ O
‚óè _ _ O
you _ _ O
ca _ _ O
n't _ _ O
make _ _ O
C _ _ O
safe _ _ O
. _ _ O
this _ _ O
has _ _ O
big _ _ O
consequences _ _ O
: _ _ O
o _ _ O
you _ _ O
ca _ _ O
n't _ _ O
do _ _ O
automatic _ _ O
memory _ _ O
management _ _ O
, _ _ O
because _ _ O
that _ _ O
requires _ _ O
you _ _ O
to _ _ O
know _ _ O
the _ _ O
types _ _ O
of _ _ O
every _ _ O
value _ _ O
in _ _ O
the _ _ O
program _ _ O
. _ _ O
o _ _ O
you _ _ O
ca _ _ O
n't _ _ O
prove _ _ O
that _ _ O
a _ _ O
C _ _ O
program _ _ O
is _ _ O
correct _ _ O
, _ _ O
because _ _ O
there _ _ O
are _ _ O
many _ _ O
" _ _ O
correct _ _ O
" _ _ O
programs _ _ O
which _ _ O
actually _ _ O
violate _ _ O
type _ _ B-Concept
safety _ _ B-Concept
. _ _ O
‚óè _ _ O
you _ _ O
ca _ _ O
n't _ _ O
be _ _ O
superhuman _ _ O
. _ _ O
sorry _ _ O
, _ _ O
but _ _ O
no _ _ O
amount _ _ O
of _ _ O
" _ _ O
just _ _ O
write _ _ O
the _ _ O
code _ _ O
correctly _ _ O
" _ _ O
is _ _ O
going _ _ O
to _ _ O
lead _ _ O
to _ _ O
correct _ _ O
C _ _ O
code _ _ O
. _ _ O
mistakes _ _ O
happen _ _ O
. _ _ O
o _ _ O
this _ _ O
is _ _ O
why _ _ O
languages _ _ O
like _ _ O
Java _ _ O
and _ _ O
Rust _ _ O
exist _ _ O
! _ _ O
8 _ _ O
Decidability _ _ B-Concept
‚óè _ _ O
decidable _ _ O
means _ _ O
: _ _ O
" _ _ O
can _ _ O
this _ _ O
question _ _ O
be _ _ O
answered _ _ O
in _ _ O
finite _ _ O
time _ _ O
? _ _ O
" _ _ O
‚óè _ _ O
type-checking _ _ B-Concept
is _ _ O
an _ _ O
algorithm _ _ O
, _ _ O
so _ _ O
it _ _ O
can _ _ O
be _ _ O
undecidable _ _ O
. _ _ O
o _ _ O
we _ _ O
can _ _ O
make _ _ O
our _ _ O
type _ _ B-Concept
system _ _ B-Concept
so _ _ O
powerful _ _ O
that _ _ O
we _ _ O
'd _ _ O
have _ _ O
to _ _ O
solve _ _ O
the _ _ O
halting _ _ B-Concept
problem _ _ I-Concept
to _ _ O
check _ _ O
our _ _ O
program _ _ O
's _ _ O
types _ _ O
! _ _ O
‚ñ™ _ _ O
which _ _ O
maybe _ _ O
seems _ _ O
like _ _ O
a _ _ O
bad _ _ O
thing _ _ O
, _ _ O
right _ _ O
? _ _ O
‚óè _ _ O
there _ _ O
's _ _ O
this _ _ O
other _ _ O
related _ _ O
thing _ _ O
that _ _ O
I _ _ O
think _ _ O
is _ _ O
related _ _ O
to _ _ O
decidability _ _ B-Concept
? _ _ O
o _ _ O
you _ _ O
ca _ _ O
n't _ _ O
predict _ _ O
the _ _ O
future _ _ O
. _ _ O
o _ _ O
that _ _ O
means _ _ O
sometimes _ _ O
you _ _ O
ca _ _ O
n't _ _ O
know _ _ O
what _ _ O
type _ _ B-Concept
something _ _ O
is _ _ O
until _ _ O
runtime _ _ O
, _ _ O
no _ _ O
matter _ _ O
how _ _ O
clever _ _ O
your _ _ O
type _ _ O
system _ _ O
is _ _ O
. _ _ O
‚óè _ _ O
so _ _ O
if _ _ O
you _ _ O
want _ _ O
programmers _ _ O
to _ _ O
have _ _ O
that _ _ O
( _ _ O
very _ _ O
useful _ _ O
! _ _ O
) _ _ O
ability _ _ O
, _ _ O
you _ _ O
have _ _ O
to _ _ O
design _ _ O
your _ _ O
type _ _ O
system _ _ O
to _ _ O
allow _ _ O
for _ _ O
it _ _ O
in _ _ O
a _ _ O
safe _ _ O
way _ _ O
. _ _ O
o _ _ O
we _ _ O
'll _ _ O
see _ _ O
some _ _ O
examples _ _ O
shortly _ _ O
. _ _ O
9 _ _ O
Type _ _ O
systems _ _ O
10 _ _ O
The _ _ O
primitive _ _ O
types _ _ O
‚óè _ _ O
a _ _ O
language _ _ O
's _ _ O
problem _ _ O
domain _ _ O
is _ _ O
the _ _ O
problems _ _ O
it _ _ O
's _ _ O
designed _ _ O
to _ _ O
solve _ _ O
. _ _ O
o _ _ O
most _ _ O
languages _ _ O
try _ _ O
to _ _ O
be _ _ O
" _ _ O
general _ _ O
purpose _ _ O
" _ _ O
and _ _ O
therefore _ _ O
give _ _ O
you _ _ O
relatively _ _ O
few _ _ O
, _ _ O
simple _ _ O
primitive _ _ O
types _ _ O
, _ _ O
like _ _ O
int _ _ O
, _ _ O
char _ _ O
, _ _ O
bool _ _ O
, _ _ O
etc _ _ O
. _ _ O
‚óè _ _ O
the _ _ O
hardware _ _ O
also _ _ O
dictates _ _ O
what _ _ O
primitives _ _ O
are _ _ O
available _ _ O
. _ _ O
o _ _ O
e.g. _ _ O
on _ _ O
GPUs _ _ O
, _ _ O
4-element _ _ O
vectors _ _ O
and _ _ O
4x4 _ _ O
matrices _ _ O
are _ _ O
primitives _ _ O
! _ _ O
‚óè _ _ O
domain-specific _ _ O
languages _ _ O
( _ _ O
DSLs _ _ O
) _ _ O
are _ _ O
designed _ _ O
to _ _ O
do _ _ O
one _ _ O
job _ _ O
well _ _ O
. _ _ O
o _ _ O
these _ _ O
might _ _ O
have _ _ O
many _ _ O
primitive _ _ O
types _ _ O
, _ _ O
including _ _ O
types _ _ O
which _ _ O
do _ _ O
n't _ _ O
seem _ _ O
very _ _ O
" _ _ O
primitive _ _ O
" _ _ O
at _ _ O
all _ _ O
. _ _ O
o _ _ O
for _ _ O
example _ _ O
, _ _ O
a _ _ O
shell _ _ O
scripting _ _ O
language _ _ O
may _ _ O
have _ _ O
primitive _ _ O
types _ _ O
like _ _ O
files _ _ O
, _ _ O
processes _ _ O
, _ _ O
and _ _ O
terminal _ _ O
emulators _ _ O
. _ _ O
‚óè _ _ O
the _ _ O
set _ _ O
of _ _ O
primitive _ _ O
types _ _ O
is _ _ O
really _ _ O
a _ _ O
product _ _ O
of _ _ O
what _ _ O
problems _ _ O
you _ _ O
want _ _ O
your _ _ O
language _ _ O
to _ _ O
be _ _ O
able _ _ O
to _ _ O
solve _ _ O
easily _ _ O
. _ _ O
11 _ _ O
Static _ _ O
vs. _ _ O
Dynamic _ _ O
typing _ _ O
‚óè _ _ O
remember _ _ O
: _ _ O
static _ _ O
= _ _ O
" _ _ O
before _ _ O
runtime _ _ O
; _ _ O
" _ _ O
dynamic _ _ O
= _ _ O
" _ _ O
at _ _ O
runtime _ _ O
. _ _ O
" _ _ O
statically _ _ O
typed _ _ O
languages _ _ O
associate _ _ O
types _ _ O
with _ _ O
variables _ _ O
. _ _ O
dynamically _ _ O
typed _ _ O
languages _ _ O
associate _ _ O
types _ _ O
with _ _ O
values _ _ O
. _ _ O
let _ _ O
mut _ _ O
a _ _ O
= _ _ O
10 _ _ O
; _ _ O
a _ _ O
= _ _ O
20 _ _ O
; _ _ O
/ _ _ O
/ _ _ O
ok _ _ O
a _ _ O
= _ _ O
" _ _ O
hello _ _ O
" _ _ O
; _ _ O
/ _ _ O
/ _ _ O
bad _ _ O
a _ _ O
= _ _ O
a _ _ O
/ _ _ O
2 _ _ O
; _ _ O
/ _ _ O
/ _ _ O
ok _ _ O
let _ _ O
a _ _ O
= _ _ O
10 _ _ O
; _ _ O
/ _ _ O
/ _ _ O
JS _ _ O
a _ _ O
= _ _ O
20 _ _ O
; _ _ O
/ _ _ O
/ _ _ O
ok _ _ O
a _ _ O
= _ _ O
" _ _ O
hello _ _ O
" _ _ O
; _ _ O
/ _ _ O
/ _ _ O
ok _ _ O
! _ _ O
a _ _ O
= _ _ O
a _ _ O
/ _ _ O
2 _ _ O
; _ _ O
/ _ _ O
/ _ _ O
bad _ _ O
in _ _ O
dynamically _ _ O
typed _ _ O
languages _ _ O
, _ _ O
type _ _ O
errors _ _ O
can _ _ O
not _ _ O
be _ _ O
found _ _ O
until _ _ O
you _ _ O
run _ _ O
the _ _ O
program _ _ O
. _ _ O
but _ _ O
this _ _ O
is _ _ O
a _ _ O
spectrum _ _ O
: _ _ O
many _ _ O
statically-typed _ _ O
languages _ _ O
include _ _ O
dynamically-typed _ _ O
features _ _ O
too _ _ O
! _ _ O
12 _ _ O
Dynamic _ _ O
types _ _ O
in _ _ O
static _ _ O
languages _ _ O
‚óè _ _ O
sometimes _ _ O
it _ _ O
's _ _ O
useful _ _ O
not _ _ O
to _ _ O
know _ _ O
the _ _ O
type _ _ O
until _ _ O
runtime _ _ O
. _ _ O
class _ _ O
A _ _ O
{ _ _ O
String _ _ O
toString _ _ O
( _ _ O
) _ _ O
{ _ _ O
return _ _ O
" _ _ O
A _ _ O
" _ _ O
; _ _ O
} _ _ O
} _ _ O
class _ _ O
B _ _ O
{ _ _ O
String _ _ O
toString _ _ O
( _ _ O
) _ _ O
{ _ _ O
return _ _ O
" _ _ O
B _ _ O
" _ _ O
; _ _ O
} _ _ O
} _ _ O
Object _ _ O
o _ _ O
; _ _ O
if _ _ O
( _ _ O
user _ _ O
types _ _ O
A _ _ O
) _ _ O
o _ _ O
= _ _ O
new _ _ O
A _ _ O
( _ _ O
) _ _ O
; _ _ O
else _ _ O
o _ _ O
= _ _ O
new _ _ O
B _ _ O
( _ _ O
) _ _ O
; _ _ O
o.toString _ _ O
( _ _ O
) _ _ O
; _ _ O
this _ _ O
works _ _ O
because _ _ O
of _ _ O
Java _ _ O
's _ _ O
subtyping _ _ O
rules _ _ O
and _ _ O
virtual _ _ O
methods _ _ O
. _ _ O
calling _ _ O
toString _ _ O
( _ _ O
) _ _ O
is _ _ O
a _ _ O
valid _ _ O
operation _ _ O
on _ _ O
any _ _ O
Object _ _ O
, _ _ O
and _ _ O
every _ _ O
class _ _ O
instance _ _ O
is _ _ O
an _ _ O
Object _ _ O
. _ _ O
this _ _ O
is _ _ O
a _ _ O
form _ _ O
of _ _ O
existential _ _ O
polymorphism _ _ O
: _ _ O
we _ _ O
do _ _ O
n't _ _ O
know _ _ O
what _ _ O
type _ _ O
it _ _ O
is _ _ O
until _ _ O
runtime _ _ O
, _ _ O
but _ _ O
we _ _ O
at _ _ O
least _ _ O
know _ _ O
that _ _ O
it _ _ O
will _ _ O
support _ _ O
this _ _ O
operation _ _ O
! _ _ O
13 _ _ O
Type _ _ O
coercion _ _ O
( _ _ O
" _ _ O
punning _ _ O
" _ _ O
) _ _ O
and _ _ O
conversion _ _ O
‚óè _ _ O
type _ _ O
coercion _ _ O
is _ _ O
when _ _ O
the _ _ O
language _ _ O
will _ _ O
let _ _ O
you _ _ O
use _ _ O
the _ _ O
" _ _ O
wrong _ _ O
" _ _ O
type _ _ O
and _ _ O
it _ _ O
will _ _ O
automatically _ _ O
turn _ _ O
it _ _ O
into _ _ O
the _ _ O
" _ _ O
right _ _ O
" _ _ O
one _ _ O
. _ _ O
‚óè _ _ O
type _ _ O
conversion _ _ O
creates _ _ O
a _ _ O
new _ _ O
value _ _ O
of _ _ O
a _ _ O
different _ _ O
type _ _ O
. _ _ O
o _ _ O
some _ _ O
type _ _ O
coercions _ _ O
do _ _ O
a _ _ O
type _ _ O
conversion _ _ O
; _ _ O
some _ _ O
do _ _ O
n't _ _ O
! _ _ O
implicit _ _ O
conversions _ _ O
like _ _ O
these _ _ O
can _ _ O
/ _ _ O
/ _ _ O
Java _ _ O
make _ _ O
code _ _ O
shorter _ _ O
and _ _ O
more _ _ O
readable _ _ O
... _ _ O
int _ _ O
x _ _ O
= _ _ O
10 _ _ O
; _ _ O
but _ _ O
they _ _ O
can _ _ O
be _ _ O
confusing _ _ O
too _ _ O
: _ _ O
float _ _ O
f _ _ O
= _ _ O
x _ _ O
; _ _ O
/ _ _ O
/ _ _ O
now _ _ O
f _ _ O
= _ _ O
= _ _ O
10.0 _ _ O
/ _ _ O
/ _ _ O
JavaScript _ _ O
int _ _ O
x _ _ O
= _ _ O
10 _ _ O
; _ _ O
let _ _ O
x _ _ O
= _ _ O
10 _ _ O
+ _ _ O
" _ _ O
20 _ _ O
" _ _ O
; _ _ O
String _ _ O
s _ _ O
= _ _ O
" _ _ O
x _ _ O
= _ _ O
" _ _ O
+ _ _ O
x _ _ O
; _ _ O
let _ _ O
y _ _ O
= _ _ O
10 _ _ O
- _ _ O
" _ _ O
20 _ _ O
" _ _ O
; _ _ O
/ _ _ O
/ _ _ O
now _ _ O
s _ _ O
is _ _ O
" _ _ O
x _ _ O
= _ _ O
10 _ _ O
" _ _ O
/ _ _ O
/ _ _ O
x _ _ O
= _ _ O
= _ _ O
" _ _ O
1020 _ _ O
" _ _ O
/ _ _ O
/ _ _ O
y _ _ O
= _ _ O
= _ _ O
-10 _ _ O
? _ _ O
! _ _ O
14 _ _ O
Strong _ _ O
vs. _ _ O
Weak _ _ O
typing _ _ O
‚óè _ _ O
different _ _ O
people _ _ O
use _ _ O
" _ _ O
strong _ _ O
" _ _ O
and _ _ O
" _ _ O
weak _ _ O
" _ _ O
to _ _ O
mean _ _ O
different _ _ O
things _ _ O
. _ _ O
one _ _ O
definition _ _ O
is _ _ O
basically _ _ O
the _ _ O
same _ _ O
as _ _ O
type _ _ O
safety _ _ O
: _ _ O
it _ _ O
says _ _ O
that _ _ O
weakly-typed _ _ O
languages _ _ O
let _ _ O
you _ _ O
" _ _ O
step _ _ O
around _ _ O
" _ _ O
the _ _ O
type _ _ O
system _ _ O
, _ _ O
while _ _ O
strongly-typed _ _ O
languages _ _ O
keep _ _ O
you _ _ O
in _ _ O
. _ _ O
/ _ _ O
/ _ _ O
C _ _ O
bool _ _ O
b _ _ O
= _ _ O
true _ _ O
; _ _ O
int _ _ O
* _ _ O
p _ _ O
= _ _ O
( _ _ O
int* _ _ O
) _ _ O
& _ _ O
b _ _ O
; _ _ O
* _ _ O
p _ _ O
= _ _ O
700 _ _ O
; _ _ O
/ _ _ O
/ _ _ O
wat _ _ O
. _ _ O
another _ _ O
definition _ _ O
is _ _ O
that _ _ O
weaklytyped _ _ O
languages _ _ O
do _ _ O
lots _ _ O
of _ _ O
implicit _ _ O
conversions _ _ O
and _ _ O
almost _ _ O
never _ _ O
give _ _ O
type _ _ O
errors _ _ O
, _ _ O
instead _ _ O
choosing _ _ O
to _ _ O
" _ _ O
do _ _ O
something _ _ O
else _ _ O
. _ _ O
" _ _ O
/ _ _ O
/ _ _ O
JavaScript _ _ O
again _ _ O
alert _ _ O
( _ _ O
[ _ _ O
] _ _ O
+ _ _ O
[ _ _ O
] _ _ O
) _ _ O
; _ _ O
/ _ _ O
/ _ _ O
" _ _ O
" _ _ O
alert _ _ O
( _ _ O
{ _ _ O
} _ _ O
+ _ _ O
{ _ _ O
} _ _ O
) _ _ O
; _ _ O
/ _ _ O
/ _ _ O
NaN _ _ O
alert _ _ O
( _ _ O
{ _ _ O
} _ _ O
+ _ _ O
[ _ _ O
] _ _ O
) _ _ O
; _ _ O
/ _ _ O
/ _ _ O
0 _ _ O
alert _ _ O
( _ _ O
[ _ _ O
] _ _ O
+ _ _ O
{ _ _ O
} _ _ O
) _ _ O
; _ _ O
/ _ _ O
/ _ _ O
{ _ _ O
} _ _ O
I _ _ O
like _ _ O
to _ _ O
think _ _ O
" _ _ O
weakly-typed _ _ O
" _ _ O
means _ _ O
" _ _ O
the _ _ O
language _ _ O
does _ _ O
n't _ _ O
care _ _ O
about _ _ O
types _ _ O
, _ _ O
for _ _ O
some _ _ O
value _ _ O
of _ _ O
' _ _ O
does _ _ O
n't _ _ O
care _ _ O
' _ _ O
" _ _ O
lol _ _ O
15 _ _ O
The _ _ O
typing _ _ O
alignment _ _ O
chart _ _ O
‚óè _ _ O
if _ _ O
we _ _ O
treat _ _ O
strong _ _ O
/ _ _ O
weak _ _ O
and _ _ O
static _ _ O
/ _ _ O
dynamic _ _ O
as _ _ O
axes _ _ O
on _ _ O
a _ _ O
spectrum _ _ O
... _ _ O
strong _ _ O
Python _ _ O
Rust _ _ O
Fortran _ _ O
Java _ _ O
TypeScript _ _ O
dynamic _ _ O
static _ _ O
C++ _ _ O
JS _ _ O
PHP _ _ O
weak _ _ O
C _ _ O
16 _ _ O
Type _ _ O
inference _ _ O
‚óè _ _ O
type _ _ O
inference _ _ O
automatically _ _ O
determines _ _ O
what _ _ O
type _ _ O
something _ _ O
is _ _ O
. _ _ O
‚óè _ _ O
you _ _ O
may _ _ O
not _ _ O
know _ _ O
it _ _ O
, _ _ O
but _ _ O
you _ _ O
've _ _ O
been _ _ O
using _ _ O
it _ _ O
for _ _ O
years _ _ O
. _ _ O
int _ _ O
x _ _ O
= _ _ O
10 _ _ O
; _ _ O
int _ _ O
y _ _ O
= _ _ O
x _ _ O
+ _ _ O
5 _ _ O
; _ _ O
the _ _ O
compiler _ _ O
implicitly _ _ O
determines _ _ O
the _ _ O
types _ _ O
of _ _ O
the _ _ O
parts _ _ O
of _ _ O
the _ _ O
expressions _ _ O
, _ _ O
and _ _ O
which _ _ O
addition _ _ O
operation _ _ O
to _ _ O
do _ _ O
. _ _ O
imagine _ _ O
having _ _ O
to _ _ O
write _ _ O
this _ _ O
... _ _ O
int _ _ O
x _ _ O
= _ _ O
10 _ _ O
: _ _ O
int _ _ O
; _ _ O
int _ _ O
y _ _ O
= _ _ O
x _ _ O
: _ _ O
int _ _ O
+ _ _ O
: _ _ O
int _ _ O
5 _ _ O
: _ _ O
int _ _ O
; _ _ O
type _ _ O
inference _ _ O
can _ _ O
go _ _ O
further _ _ O
, _ _ O
too _ _ O
, _ _ O
like _ _ O
variables _ _ O
in _ _ O
Rust _ _ O
! _ _ O
let _ _ O
x _ _ O
= _ _ O
10 _ _ O
; _ _ O
/ _ _ O
/ _ _ O
x _ _ O
: _ _ O
i32 _ _ O
let _ _ O
y _ _ O
= _ _ O
Some _ _ O
( _ _ O
x _ _ O
) _ _ O
; _ _ O
/ _ _ O
/ _ _ O
y _ _ O
: _ _ O
Option _ _ O
< _ _ O
i32 _ _ O
> _ _ O
17 _ _ O
Defining _ _ O
Type _ _ O
Systems _ _ O
18 _ _ O
Terms _ _ O
and _ _ O
types _ _ O
‚óè _ _ O
a _ _ O
term _ _ O
is _ _ O
a _ _ O
thing _ _ O
that _ _ O
has _ _ O
a _ _ O
value _ _ O
. _ _ O
o _ _ O
it _ _ O
's _ _ O
either _ _ O
a _ _ O
value _ _ O
itself _ _ O
, _ _ O
or _ _ O
it _ _ O
can _ _ O
be _ _ O
evaluated _ _ O
to _ _ O
get _ _ O
one _ _ O
. _ _ O
‚ñ™ _ _ O
( _ _ O
that _ _ O
sounds _ _ O
a _ _ O
lot _ _ O
like _ _ O
an _ _ O
expression _ _ O
... _ _ O
) _ _ O
‚óè _ _ O
every _ _ O
value _ _ O
has _ _ O
a _ _ O
type _ _ O
, _ _ O
and _ _ O
therefore _ _ O
every _ _ O
term _ _ O
has _ _ O
a _ _ O
type _ _ O
. _ _ O
PL _ _ O
theory _ _ O
writes _ _ O
this _ _ O
relation _ _ O
like _ _ O
so _ _ O
: _ _ O
term _ _ O
: _ _ O
Type _ _ O
like _ _ O
: _ _ O
x _ _ O
: _ _ O
i32 _ _ O
and _ _ O
now _ _ O
you _ _ O
know _ _ O
why _ _ O
Rust _ _ O
uses _ _ O
this _ _ O
syntax _ _ O
. _ _ O
19 _ _ O
Inference _ _ O
rules _ _ O
‚óè _ _ O
a _ _ O
type _ _ O
system _ _ O
's _ _ O
inference _ _ O
rules _ _ O
explain _ _ O
how _ _ O
to _ _ O
give _ _ O
a _ _ O
type _ _ O
to _ _ O
a _ _ O
term _ _ O
. _ _ O
‚óè _ _ O
some _ _ O
rules _ _ O
are _ _ O
axiomatic _ _ O
: _ _ O
they _ _ O
are _ _ O
the _ _ O
" _ _ O
ground _ _ O
truth _ _ O
" _ _ O
of _ _ O
the _ _ O
types _ _ O
. _ _ O
‚óè _ _ O
others _ _ O
say _ _ O
how _ _ O
to _ _ O
determine _ _ O
the _ _ O
type _ _ O
of _ _ O
a _ _ O
more _ _ O
complex _ _ O
term _ _ O
. _ _ O
here _ _ O
's _ _ O
an _ _ O
axiomatic _ _ O
rule _ _ O
that _ _ O
says _ _ O
all _ _ O
integer _ _ O
literals _ _ O
are _ _ O
of _ _ O
type _ _ O
int _ _ O
: _ _ O
and _ _ O
here _ _ O
's _ _ O
a _ _ O
rule _ _ O
for _ _ O
integer _ _ O
addition _ _ O
: _ _ O
< _ _ O
IntExp _ _ O
> _ _ O
: _ _ O
int _ _ O
t _ _ O
: _ _ O
int _ _ O
u _ _ O
: _ _ O
int _ _ O
t _ _ O
+ _ _ O
u _ _ O
: _ _ O
int _ _ O
( _ _ O
where _ _ O
IntExp _ _ O
is _ _ O
the _ _ O
kind _ _ O
of _ _ O
AST _ _ O
node _ _ O
that _ _ O
represents _ _ O
integer _ _ O
literals _ _ O
. _ _ O
) _ _ O
" _ _ O
if _ _ O
t _ _ O
is _ _ O
an _ _ O
int _ _ O
and _ _ O
u _ _ O
is _ _ O
an _ _ O
int _ _ O
, _ _ O
then _ _ O
( _ _ O
t+u _ _ O
) _ _ O
is _ _ O
an _ _ O
int _ _ O
. _ _ O
" _ _ O
our _ _ O
type _ _ O
checking _ _ O
algorithm _ _ O
will _ _ O
be _ _ O
driven _ _ O
by _ _ O
these _ _ O
rules _ _ O
. _ _ O
if _ _ O
no _ _ O
rule _ _ O
can _ _ O
be _ _ O
applied _ _ O
, _ _ O
it _ _ O
's _ _ O
a _ _ O
type _ _ O
error _ _ O
! _ _ O
20 _ _ O
The _ _ O
type _ _ O
context _ _ O
‚óè _ _ O
in _ _ O
addition _ _ O
to _ _ O
the _ _ O
axiomatic _ _ O
rules _ _ O
, _ _ O
we _ _ O
also _ _ O
need _ _ O
some _ _ O
context _ _ O
to _ _ O
assign _ _ O
types _ _ O
to _ _ O
some _ _ O
terms _ _ O
, _ _ O
like _ _ O
variables _ _ O
. _ _ O
int _ _ O
x _ _ O
= _ _ O
10 _ _ O
; _ _ O
how _ _ O
do _ _ O
we _ _ O
know _ _ O
what _ _ O
type _ _ O
x _ _ O
is _ _ O
? _ _ O
int _ _ O
y _ _ O
= _ _ O
x _ _ O
+ _ _ O
5 _ _ O
; _ _ O
we _ _ O
have _ _ O
to _ _ O
look _ _ O
back _ _ O
to _ _ O
its _ _ O
declaration _ _ O
. _ _ O
fortunately _ _ O
, _ _ O
name _ _ O
resolution _ _ O
has _ _ O
already _ _ O
determined _ _ O
which _ _ O
symbol _ _ O
x _ _ O
refers _ _ O
to _ _ O
! _ _ O
the _ _ O
type _ _ O
context _ _ O
is _ _ O
another _ _ O
mapping _ _ O
: _ _ O
it _ _ O
associates _ _ O
symbols _ _ O
in _ _ O
the _ _ O
symbol _ _ O
table _ _ O
with _ _ O
types _ _ O
. _ _ O
here _ _ O
, _ _ O
int _ _ O
x _ _ O
explicitly _ _ O
associates _ _ O
x _ _ O
with _ _ O
the _ _ O
type _ _ O
int _ _ O
... _ _ O
but _ _ O
in _ _ O
languages _ _ O
with _ _ O
type _ _ O
inference _ _ O
, _ _ O
the _ _ O
type _ _ O
of _ _ O
the _ _ O
initializer _ _ O
would _ _ O
have _ _ O
to _ _ O
be _ _ O
determined _ _ O
first _ _ O
. _ _ O
21 _ _ O
Truss _ _ O
's _ _ O
type _ _ O
system _ _ O
‚óè _ _ O
let _ _ O
's _ _ O
examine _ _ O
the _ _ O
type _ _ O
system _ _ O
of _ _ O
this _ _ O
toy _ _ O
language _ _ O
to _ _ O
get _ _ O
familiar _ _ O
with _ _ O
how _ _ O
these _ _ O
concepts _ _ O
play _ _ O
out _ _ O
. _ _ O
‚óè _ _ O
first _ _ O
, _ _ O
it _ _ O
has _ _ O
a _ _ O
set _ _ O
of _ _ O
four _ _ O
primitive _ _ O
types _ _ O
. _ _ O
o _ _ O
int _ _ O
: _ _ O
a _ _ O
signed _ _ O
32-bit _ _ O
integer _ _ O
o _ _ O
bool _ _ O
: _ _ O
a _ _ O
truth _ _ O
value _ _ O
, _ _ O
true _ _ O
or _ _ O
false _ _ O
o _ _ O
string _ _ O
: _ _ O
an _ _ O
immutable _ _ O
sequence _ _ O
of _ _ O
0 _ _ O
or _ _ O
more _ _ O
codepoints _ _ O
o _ _ O
( _ _ O
): _ _ O
the _ _ O
absence _ _ O
of _ _ O
a _ _ O
type _ _ O
, _ _ O
called _ _ O
void _ _ O
‚ñ™ _ _ O
this _ _ O
is _ _ O
only _ _ O
used _ _ O
for _ _ O
function _ _ O
return _ _ O
types _ _ O
. _ _ O
‚óè _ _ O
it _ _ O
might _ _ O
not _ _ O
look _ _ O
like _ _ O
it _ _ O
, _ _ O
but _ _ O
we _ _ O
've _ _ O
sort _ _ O
of _ _ O
implicitly _ _ O
defined _ _ O
the _ _ O
sets _ _ O
of _ _ O
valid _ _ O
values _ _ O
for _ _ O
each _ _ O
type _ _ O
. _ _ O
o _ _ O
there _ _ O
are _ _ O
232 _ _ O
valid _ _ O
values _ _ O
for _ _ O
int _ _ O
... _ _ O
o _ _ O
2 _ _ O
valid _ _ O
values _ _ O
for _ _ O
bool _ _ O
... _ _ O
o _ _ O
and _ _ O
so _ _ O
on _ _ O
. _ _ O
22 _ _ O
Function _ _ O
Types _ _ O
‚óè _ _ O
any _ _ O
language _ _ O
that _ _ O
has _ _ O
functions _ _ O
will _ _ O
also _ _ O
need _ _ O
a _ _ O
type _ _ O
for _ _ O
them _ _ O
. _ _ O
‚óè _ _ O
or _ _ O
to _ _ O
be _ _ O
more _ _ O
accurate _ _ O
, _ _ O
a _ _ O
type _ _ O
constructor _ _ O
for _ _ O
them _ _ O
. _ _ O
Truss _ _ O
writes _ _ O
its _ _ O
function _ _ O
types _ _ O
like _ _ O
: _ _ O
fn _ _ O
( _ _ O
A0 _ _ O
, _ _ O
A1 _ _ O
, _ _ O
... _ _ O
): _ _ O
R _ _ O
, _ _ O
where _ _ O
A0 _ _ O
, _ _ O
A1 _ _ O
etc _ _ O
. _ _ O
are _ _ O
the _ _ O
arguments _ _ O
and _ _ O
R _ _ O
is _ _ O
the _ _ O
return _ _ O
type _ _ O
. _ _ O
functions _ _ O
can _ _ O
have _ _ O
any _ _ O
number _ _ O
of _ _ O
arguments _ _ O
, _ _ O
which _ _ O
is _ _ O
why _ _ O
the _ _ O
argument _ _ O
types _ _ O
are _ _ O
written _ _ O
like _ _ O
that _ _ O
. _ _ O
here _ _ O
are _ _ O
some _ _ O
valid _ _ O
function _ _ O
types _ _ O
: _ _ O
fn _ _ O
( _ _ O
) _ _ O
: _ _ O
( _ _ O
) _ _ O
fn _ _ O
( _ _ O
int _ _ O
) _ _ O
: _ _ O
int _ _ O
fn _ _ O
( _ _ O
string _ _ O
, _ _ O
string _ _ O
) _ _ O
: _ _ O
bool _ _ O
fn _ _ O
( _ _ O
fn _ _ O
( _ _ O
) _ _ O
: _ _ O
( _ _ O
) _ _ O
) _ _ O
: _ _ O
( _ _ O
) _ _ O
the _ _ O
last _ _ O
one _ _ O
is _ _ O
a _ _ O
higher _ _ O
order _ _ O
function _ _ O
: _ _ O
it _ _ O
takes _ _ O
a _ _ O
function _ _ O
as _ _ O
an _ _ O
argument _ _ O
! _ _ O
Truss _ _ O
also _ _ O
has _ _ O
structs _ _ O
, _ _ O
but _ _ O
we _ _ O
'll _ _ O
come _ _ O
back _ _ O
for _ _ O
those _ _ O
later _ _ O
... _ _ O
23 _ _ O
Inference _ _ O
rules _ _ O
‚óè _ _ O
we _ _ O
need _ _ O
rules _ _ O
for _ _ O
every _ _ O
operation _ _ O
in _ _ O
the _ _ O
language _ _ O
. _ _ O
examples _ _ O
: _ _ O
t _ _ O
: _ _ O
int _ _ O
u _ _ O
: _ _ O
int _ _ O
for _ _ O
any _ _ O
op _ _ O
in _ _ O
{ _ _ O
+ _ _ O
, _ _ O
- _ _ O
, _ _ O
* _ _ O
, _ _ O
/ _ _ O
, _ _ O
% _ _ O
} _ _ O
t _ _ O
op _ _ O
u _ _ O
: _ _ O
int _ _ O
t _ _ O
: _ _ O
string _ _ O
u _ _ O
: _ _ O
string _ _ O
( _ _ O
this _ _ O
is _ _ O
for _ _ O
string _ _ O
concatenation _ _ O
! _ _ O
) _ _ O
t _ _ O
+ _ _ O
u _ _ O
: _ _ O
string _ _ O
t _ _ O
: _ _ O
int _ _ O
u _ _ O
: _ _ O
int _ _ O
for _ _ O
any _ _ O
op _ _ O
in _ _ O
{ _ _ O
= _ _ O
= _ _ O
, _ _ O
! _ _ O
= _ _ O
, _ _ O
< _ _ O
, _ _ O
< _ _ O
= _ _ O
, _ _ O
> _ _ O
, _ _ O
> _ _ O
= _ _ O
} _ _ O
t _ _ O
op _ _ O
u _ _ O
: _ _ O
bool _ _ O
t _ _ O
: _ _ O
bool _ _ O
u _ _ O
: _ _ O
bool _ _ O
for _ _ O
any _ _ O
op _ _ O
in _ _ O
{ _ _ O
and _ _ O
, _ _ O
or _ _ O
} _ _ O
t _ _ O
op _ _ O
u _ _ O
: _ _ O
bool _ _ O
f _ _ O
: _ _ O
fn _ _ O
( _ _ O
A0 _ _ O
, _ _ O
A1 _ _ O
, _ _ O
... _ _ O
) _ _ O
: _ _ O
R _ _ O
a0 _ _ O
: _ _ O
A0 _ _ O
a1 _ _ O
: _ _ O
A1 _ _ O
f _ _ O
( _ _ O
a0 _ _ O
, _ _ O
a1 _ _ O
, _ _ O
... _ _ O
) _ _ O
: _ _ O
R _ _ O
... _ _ O
this _ _ O
says _ _ O
, _ _ O
" _ _ O
the _ _ O
type _ _ O
of _ _ O
a _ _ O
function _ _ O
call _ _ O
is _ _ O
the _ _ O
function _ _ O
's _ _ O
return _ _ O
type _ _ O
. _ _ O
" _ _ O
24 _ _ O
What _ _ O
about _ _ O
statements _ _ O
? _ _ O
‚óè _ _ O
statements _ _ O
have _ _ O
gotten _ _ O
left _ _ O
out _ _ O
of _ _ O
the _ _ O
discussion _ _ O
, _ _ O
because _ _ O
they _ _ O
do _ _ O
n't _ _ O
evaluate _ _ O
to _ _ O
a _ _ O
value _ _ O
, _ _ O
and _ _ O
therefore _ _ O
have _ _ O
no _ _ O
type _ _ O
. _ _ O
‚óè _ _ O
but _ _ O
statements _ _ O
can _ _ O
interact _ _ O
with _ _ O
the _ _ O
type _ _ O
system _ _ O
nonetheless _ _ O
. _ _ O
what _ _ O
type _ _ O
does _ _ O
the _ _ O
condition _ _ O
have _ _ O
to _ _ O
be _ _ O
, _ _ O
in _ _ O
Java _ _ O
? _ _ O
if _ _ O
( _ _ O
x _ _ O
< _ _ O
10 _ _ O
) _ _ O
println _ _ O
( _ _ O
"yep _ _ O
" _ _ O
) _ _ O
; _ _ O
boolean _ _ O
. _ _ O
similar _ _ O
things _ _ O
apply _ _ O
for _ _ O
loops _ _ O
, _ _ O
switches _ _ O
( _ _ O
and _ _ O
Rust _ _ O
matches _ _ O
) _ _ O
, _ _ O
return _ _ O
statements _ _ O
, _ _ O
and _ _ O
so _ _ O
on _ _ O
. _ _ O
( _ _ O
we _ _ O
could _ _ O
also _ _ O
say _ _ O
that _ _ O
statements _ _ O
have _ _ O
a _ _ O
type _ _ O
like _ _ O
( _ _ O
) _ _ O
or _ _ O
void _ _ O
, _ _ O
but _ _ O
it _ _ O
is _ _ O
n't _ _ O
strictly _ _ O
necessary _ _ O
to _ _ O
do _ _ O
this _ _ O
. _ _ O
) _ _ O
25 _ _ O
Implementation _ _ O
Details _ _ O
26 _ _ O
Data _ _ O
structures _ _ O
needed _ _ O
‚óè _ _ O
we _ _ O
'll _ _ O
need _ _ O
to _ _ O
represent _ _ O
types _ _ O
in _ _ O
the _ _ O
compiler _ _ O
. _ _ O
o _ _ O
this _ _ O
can _ _ O
be _ _ O
as _ _ O
simple _ _ O
as _ _ O
a _ _ O
Rust _ _ O
enum _ _ O
, _ _ O
very _ _ O
similar _ _ O
to _ _ O
how _ _ O
we _ _ O
represent _ _ O
the _ _ O
kinds _ _ O
of _ _ O
AST _ _ O
nodes _ _ O
. _ _ O
‚óè _ _ O
we _ _ O
'll _ _ O
also _ _ O
need _ _ O
the _ _ O
type _ _ O
context _ _ O
like _ _ O
we _ _ O
said _ _ O
before _ _ O
. _ _ O
o _ _ O
we _ _ O
said _ _ O
we _ _ O
needed _ _ O
this _ _ O
to _ _ O
map _ _ O
from _ _ O
symbols _ _ O
to _ _ O
types _ _ O
... _ _ O
o _ _ O
but _ _ O
we _ _ O
're _ _ O
going _ _ O
to _ _ O
extend _ _ O
this _ _ O
to _ _ O
all _ _ O
AST _ _ O
nodes _ _ O
that _ _ O
can _ _ O
have _ _ O
types _ _ O
, _ _ O
because _ _ O
subsequent _ _ O
compiler _ _ O
passes _ _ O
will _ _ O
need _ _ O
this _ _ O
info _ _ O
. _ _ O
o _ _ O
this _ _ O
will _ _ O
get _ _ O
filled _ _ O
in _ _ O
as _ _ O
we _ _ O
do _ _ O
type _ _ O
checking _ _ O
. _ _ O
‚óè _ _ O
finally _ _ O
, _ _ O
we _ _ O
need _ _ O
a _ _ O
way _ _ O
to _ _ O
represent _ _ O
the _ _ O
terms _ _ O
... _ _ O
o _ _ O
wait _ _ O
, _ _ O
do _ _ O
n't _ _ O
we _ _ O
have _ _ O
that _ _ O
already _ _ O
? _ _ O
27 _ _ O
OH _ _ O
, _ _ O
right _ _ O
, _ _ O
the _ _ O
AST _ _ O
! _ _ O
‚óè _ _ O
the _ _ O
AST _ _ O
encodes _ _ O
terms _ _ O
as _ _ O
trees _ _ O
. _ _ O
‚óè _ _ O
this _ _ O
implies _ _ O
a _ _ O
relatively _ _ O
straightforward _ _ O
way _ _ O
to _ _ O
check _ _ O
for _ _ O
types _ _ O
: _ _ O
1 _ _ O
. _ _ O
do _ _ O
a _ _ O
depth-first _ _ O
traversal _ _ O
to _ _ O
typecheck _ _ O
the _ _ O
leaves _ _ O
, _ _ O
using _ _ O
the _ _ O
axiomatic _ _ O
rules _ _ O
and _ _ O
type _ _ O
context _ _ O
; _ _ O
2 _ _ O
. _ _ O
typecheck _ _ O
the _ _ O
internal _ _ O
nodes _ _ O
according _ _ O
to _ _ O
the _ _ O
types _ _ O
of _ _ O
their _ _ O
children _ _ O
, _ _ O
using _ _ O
the _ _ O
inference _ _ O
rules _ _ O
. _ _ O
CallExp _ _ O
callee _ _ O
args _ _ O
[ _ _ O
] _ _ O
IdentExp _ _ O
name _ _ O
f _ _ O
( _ _ O
y+2 _ _ O
) _ _ O
:() _ _ O
AddExp _ _ O
" _ _ O
f _ _ O
" _ _ O
lhs _ _ O
rhs _ _ O
y+2 _ _ O
: _ _ O
int _ _ O
f _ _ O
: _ _ O
fn _ _ O
( _ _ O
int _ _ O
) _ _ O
: _ _ O
( _ _ O
) _ _ O
IdentExp _ _ O
name _ _ O
" _ _ O
y _ _ O
" _ _ O
y _ _ O
: _ _ O
int _ _ O
IntExp _ _ O
value _ _ O
2 _ _ O
2 _ _ O
: _ _ O
int _ _ O
28 _ _ O
Implementing _ _ O
the _ _ O
inference _ _ O
rules _ _ O
‚óè _ _ O
the _ _ O
inference _ _ O
rules _ _ O
are _ _ O
easier _ _ O
to _ _ O
implement _ _ O
than _ _ O
they _ _ O
might _ _ O
seem _ _ O
. _ _ O
‚óè _ _ O
most _ _ O
of _ _ O
the _ _ O
checks _ _ O
boil _ _ O
down _ _ O
to _ _ O
: _ _ O
is _ _ O
this _ _ O
type _ _ O
equal _ _ O
to _ _ O
that _ _ O
type _ _ O
? _ _ O
‚óè _ _ O
for _ _ O
instance _ _ O
in _ _ O
this _ _ O
rule _ _ O
: _ _ O
t _ _ O
: _ _ O
int _ _ O
u _ _ O
: _ _ O
int _ _ O
o _ _ O
for _ _ O
any _ _ O
op _ _ O
in _ _ O
{ _ _ O
= _ _ O
= _ _ O
, _ _ O
! _ _ O
= _ _ O
, _ _ O
< _ _ O
, _ _ O
< _ _ O
= _ _ O
, _ _ O
> _ _ O
, _ _ O
> _ _ O
= _ _ O
} _ _ O
t _ _ O
op _ _ O
u _ _ O
: _ _ O
bool _ _ O
‚óè _ _ O
if _ _ O
I _ _ O
am _ _ O
looking _ _ O
at _ _ O
an _ _ O
AST _ _ O
node _ _ O
for _ _ O
a _ _ O
= _ _ O
= _ _ O
, _ _ O
the _ _ O
check _ _ O
goes _ _ O
like _ _ O
this _ _ O
: _ _ O
1 _ _ O
. _ _ O
check _ _ O
that _ _ O
LHS _ _ O
's _ _ O
type _ _ O
equals _ _ O
int _ _ O
, _ _ O
and _ _ O
give _ _ O
an _ _ O
error _ _ O
if _ _ O
not _ _ O
. _ _ O
2 _ _ O
. _ _ O
check _ _ O
that _ _ O
RHS _ _ O
's _ _ O
type _ _ O
equals _ _ O
int _ _ O
, _ _ O
and _ _ O
give _ _ O
an _ _ O
error _ _ O
if _ _ O
not _ _ O
. _ _ O
3 _ _ O
. _ _ O
set _ _ O
this _ _ O
= _ _ O
= _ _ O
AST _ _ O
node _ _ O
's _ _ O
type _ _ O
to _ _ O
bool _ _ O
in _ _ O
the _ _ O
type _ _ O
context _ _ O
. _ _ O
‚óè _ _ O
that _ _ O
's _ _ O
it _ _ O
. _ _ O
some _ _ O
of _ _ O
the _ _ O
rules _ _ O
are _ _ O
more _ _ O
involved _ _ O
, _ _ O
but _ _ O
it _ _ O
's _ _ O
rarely _ _ O
much _ _ O
more _ _ O
complex _ _ O
than _ _ O
just _ _ O
checking _ _ O
type _ _ O
equality _ _ O
. _ _ O
29 _ _ O


