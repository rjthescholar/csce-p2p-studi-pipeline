['test_set', 'labeled']|cs0449|lec06
-DOCSTART- -X- -X- O

6 _ _ O


 _ _ O
Memory _ _ O
Management _ _ O


 _ _ O
CS _ _ O
/ _ _ O
COE _ _ O
0449 _ _ O
Introduction _ _ O
to _ _ O
Systems _ _ O
Software _ _ O


 _ _ O
Luis _ _ O
Oliveira _ _ O
( _ _ O
with _ _ O
content _ _ O
borrowed _ _ O
from _ _ O
wilkie _ _ O
and _ _ O
Vinicius _ _ O
Petrucci _ _ O
) _ _ O


 _ _ O
Our _ _ O
Story _ _ O
So _ _ O
Far _ _ O
You _ _ O
Hear _ _ O
a _ _ O
Voice _ _ O
Whisper _ _ O
: _ _ O
" _ _ O
The _ _ O
Memory _ _ B-Concept
Layout _ _ I-Concept
is _ _ O
a _ _ O
Lie _ _ O
" _ _ O


 _ _ O
2 _ _ O


 _ _ O
Reallocating _ _ O
our _ _ O
thoughts _ _ O
• _ _ O
A _ _ O
program _ _ O
has _ _ O
several _ _ O
sections _ _ O
: _ _ O
• _ _ O
Code _ _ B-Concept
• _ _ O
Static _ _ B-Concept
data _ _ I-Concept
• _ _ O
Stack _ _ B-Concept
• _ _ O
Heap _ _ B-Concept


 _ _ O
• _ _ O
Today _ _ O
, _ _ O
we _ _ O
take _ _ O
a _ _ O
deeper _ _ O
dive _ _ O
at _ _ O
how _ _ O
dynamic _ _ O
memory _ _ O
is _ _ O
allocated _ _ O
in _ _ O
the _ _ O
heap _ _ B-Concept
. _ _ O


 _ _ O
Potential _ _ O
Layout _ _ O
( _ _ O
32-bit _ _ O
addresses _ _ O
) _ _ O


 _ _ O
stack _ _ B-Concept
currently _ _ O
unused _ _ O
but _ _ O
available _ _ O
memory _ _ O


 _ _ O
heap _ _ B-Concept
static _ _ B-Concept
data _ _ I-Concept


 _ _ O
code _ _ B-Concept
3 _ _ O


 _ _ O
Reallocating _ _ O
our _ _ O
thoughts _ _ O
• _ _ O
We _ _ O
have _ _ O
looked _ _ O
at _ _ O


 _ _ O
and _ _ O


 _ _ O
. _ _ O


 _ _ O
• _ _ O
They _ _ O
stake _ _ O
out _ _ O
space _ _ O
in _ _ O
the _ _ O
heap _ _ B-Concept
and _ _ O
return _ _ O
an _ _ O
address _ _ O
. _ _ O
• _ _ O
Right _ _ O
now _ _ O
, _ _ O
we _ _ O
live _ _ O
in _ _ O
a _ _ O
nice _ _ O
ideal _ _ O
world _ _ O
. _ _ O
• _ _ O
No _ _ O
other _ _ O
programs _ _ O
are _ _ O
running _ _ O
. _ _ O
• _ _ O
We _ _ O
have _ _ O
access _ _ O
to _ _ O
all _ _ O
of _ _ O
the _ _ O
memory _ _ O
. _ _ O
• _ _ O
Muhahahaha _ _ O
! _ _ O
! _ _ O


 _ _ O
• _ _ O
The _ _ O
OS _ _ O
is _ _ O
lying _ _ O
to _ _ O
our _ _ O
program _ _ O
. _ _ O
• _ _ O
This _ _ O
memory _ _ O
is _ _ O
... _ _ O
virtual _ _ O
... _ _ O
reality _ _ O
. _ _ O
• _ _ O
We _ _ O
will _ _ O
investigate _ _ O
this _ _ O
lie _ _ O
later _ _ O
in _ _ O
the _ _ O
course _ _ O
. _ _ O


 _ _ O
Potential _ _ O
Layout _ _ O
( _ _ O
32-bit _ _ O
addresses _ _ O
) _ _ O


 _ _ O
stack _ _ B-Concept
currently _ _ O
unused _ _ O
but _ _ O
available _ _ O
memory _ _ O


 _ _ O
heap _ _ B-Concept
static _ _ B-Concept
data _ _ I-Concept


 _ _ O
code _ _ B-Concept
4 _ _ O


 _ _ O
The _ _ O
World _ _ O
of _ _ O
Allocation _ _ O
It _ _ O
is _ _ O
a _ _ O
puzzle _ _ O
without _ _ O
any _ _ O
optimal _ _ O
solution _ _ O
. _ _ O
Welcome _ _ O
to _ _ O
computers _ _ O
! _ _ O


 _ _ O
5 _ _ O


 _ _ O
A _ _ O
heap _ _ B-Concept
of _ _ O
possibilities _ _ O
• _ _ O
Stack _ _ B-Concept
access _ _ O
often _ _ O
does _ _ O
not _ _ O
deviate _ _ O
much _ _ O
. _ _ O


 _ _ O
Potential _ _ O
Layout _ _ O
( _ _ O
32-bit _ _ O
addresses _ _ O
) _ _ O


 _ _ O
• _ _ O
We _ _ O
allocate _ _ O
a _ _ O
little _ _ O
bit _ _ O
at _ _ O
a _ _ O
time _ _ O
. _ _ O
• _ _ O
We _ _ O
allocate _ _ O
and _ _ O
free _ _ B-Concept
the _ _ O
memory _ _ O
VERY _ _ O
often _ _ O
. _ _ O


 _ _ O
stack _ _ B-Concept
• _ _ O
Heap _ _ B-Concept
allocations _ _ O
have _ _ O
many _ _ O
access _ _ O
patterns _ _ O
that _ _ O
are _ _ O
possible _ _ O
. _ _ O
• _ _ O
You _ _ O
might _ _ O
allocate _ _ O
a _ _ O
lot _ _ O
at _ _ O
a _ _ O
time _ _ O
and _ _ O
keep _ _ O
it _ _ O
around _ _ O
for _ _ O
a _ _ O
long _ _ O
time _ _ O
. _ _ O
Or _ _ O
a _ _ O
short _ _ O
time _ _ O
. _ _ O
• _ _ O
You _ _ O
might _ _ O
allocate _ _ O
a _ _ O
lot _ _ O
of _ _ O
small _ _ O
things _ _ O
, _ _ O
instead _ _ O
. _ _ O
• _ _ O
Maybe _ _ O
you _ _ O
do _ _ O
a _ _ O
little _ _ O
bit _ _ O
of _ _ O
everything _ _ O
? _ _ O


 _ _ O
• _ _ O
Often _ _ O
, _ _ O
such _ _ O
patterns _ _ O
are _ _ O
not _ _ O
easy _ _ O
to _ _ O
predict _ _ O
. _ _ O
• _ _ O
Do _ _ O
you _ _ O
get _ _ O
a _ _ O
big _ _ O
file _ _ O
as _ _ O
input _ _ O
? _ _ O
A _ _ O
small _ _ O
file _ _ O
? _ _ O


 _ _ O
currently _ _ O
unused _ _ O
but _ _ O
available _ _ O
memory _ _ O


 _ _ O
heap _ _ B-Concept
static _ _ B-Concept
data _ _ I-Concept


 _ _ O
code _ _ B-Concept
6 _ _ O


 _ _ O
A _ _ O
heaping _ _ O
helping _ _ O
of _ _ O
good _ _ O
luck _ _ O
• _ _ O
Allocations _ _ O
could _ _ O
happen _ _ O
in _ _ O
a _ _ O
nice _ _ O
order _ _ O
. _ _ O
• _ _ O
When _ _ O
something _ _ O
is _ _ O
allocated _ _ O
, _ _ O
it _ _ O
can _ _ O
be _ _ O
allocated _ _ O
after _ _ O
everything _ _ O
else _ _ O
. _ _ O


 _ _ O
stack _ _ B-Concept


 _ _ O
available _ _ O
memory _ _ O
available _ _ O
memory _ _ O
available _ _ O
memory _ _ O


 _ _ O
• _ _ O
When _ _ O
freed _ _ O
, _ _ O
it _ _ O
makes _ _ O
room _ _ O
for _ _ O
new _ _ O
things _ _ O
. _ _ O


 _ _ O
• _ _ O
IF _ _ O
ONLY _ _ O
. _ _ O
• _ _ O
I _ _ O
mean _ _ O
, _ _ O
it _ _ O
's _ _ O
possible _ _ O
... _ _ O
but _ _ O
like _ _ O
... _ _ O
• _ _ O
the _ _ O
heap _ _ B-Concept
and _ _ O
stack _ _ B-Concept
are _ _ O
different _ _ O
things _ _ O
for _ _ O
a _ _ O
reason _ _ O
. _ _ O


 _ _ O
heap _ _ B-Concept
static _ _ B-Concept
data _ _ I-Concept
code _ _ B-Concept
7 _ _ O


 _ _ O
Digital _ _ O
potholes _ _ O
... _ _ O
as _ _ O
annoying _ _ O
as _ _ O
real _ _ O
ones _ _ O
• _ _ O
Small _ _ O
allocations _ _ O
interfere _ _ O
with _ _ O
large _ _ O
ones _ _ O
. _ _ O
• _ _ O
When _ _ O
small _ _ O
gaps _ _ O
interfere _ _ O
with _ _ O
allocation _ _ O
, _ _ O
this _ _ O
is _ _ O
called _ _ O
fragmentation _ _ B-Concept
. _ _ O


 _ _ O
stack _ _ B-Concept
available _ _ O
memory _ _ O
available _ _ O
memory _ _ O
available _ _ O
available _ _ O
memory _ _ O
memory _ _ O
available _ _ O
memory _ _ O


 _ _ O
Next _ _ O
Allocation _ _ O


 _ _ O
Ugh _ _ O


 _ _ O
? _ _ O
if _ _ O
we _ _ O
had _ _ O
omniscience _ _ O
of _ _ O
future _ _ O
allocations _ _ O
, _ _ O
we _ _ O
could _ _ O
avoid _ _ O
this _ _ O
... _ _ O
but _ _ O
we _ _ O
ca _ _ O
n't _ _ O
know _ _ O
ahead _ _ O
of _ _ O
time _ _ O
! _ _ O


 _ _ O
heap _ _ B-Concept
static _ _ B-Concept
data _ _ I-Concept
code _ _ B-Concept
8 _ _ O


 _ _ O
The _ _ O
worst _ _ O
case _ _ O
stack _ _ B-Concept


 _ _ O
• _ _ O
When _ _ O
you _ _ O
allocate _ _ O
a _ _ O
lot _ _ O
of _ _ O
small _ _ O
things _ _ O
... _ _ O
• _ _ O
Free _ _ B-Concept
every _ _ O
other _ _ O
one _ _ O
... _ _ O
• _ _ O
And _ _ O
then _ _ O
attempt _ _ O
to _ _ O
allocate _ _ O
a _ _ O
bigger _ _ O
thing _ _ O
... _ _ O


 _ _ O
• _ _ O
Even _ _ O
though _ _ O
there _ _ O
is _ _ O
technically _ _ O
enough _ _ O
memory _ _ O
... _ _ O
• _ _ O
There _ _ O
is _ _ O
no _ _ O
continuous _ _ O
space _ _ O
. _ _ O
• _ _ O
Therefore _ _ O
, _ _ O
our _ _ O
naïve _ _ O
will _ _ O
fail _ _ O
. _ _ O


 _ _ O
• _ _ O
We _ _ O
have _ _ O
to _ _ O
come _ _ O
up _ _ O
with _ _ O
some _ _ O
strategy _ _ O
. _ _ O


 _ _ O
? _ _ O
? _ _ O
? _ _ O


 _ _ O
heap _ _ B-Concept
static _ _ B-Concept
data _ _ I-Concept
code _ _ B-Concept
9 _ _ O


 _ _ O
Moving _ _ O
is _ _ O
never _ _ O
easy _ _ O
stack _ _ B-Concept


 _ _ O
• _ _ O
Why _ _ O
not _ _ O
move _ _ O
things _ _ O
around _ _ O
? _ _ O
? _ _ O
• _ _ O
A _ _ O
defragmentation _ _ B-Concept
process _ _ O
/ _ _ O
algorithm _ _ O


 _ _ O
• _ _ O
Moving _ _ O
around _ _ O
something _ _ O
in _ _ O
the _ _ O
heap _ _ B-Concept
is _ _ O
hard _ _ O
! _ _ O
• _ _ O
Any _ _ O
pointers _ _ O
referring _ _ O
to _ _ O
data _ _ O
within _ _ O
a _ _ O
block _ _ O
must _ _ O
be _ _ O
updated _ _ O
. _ _ O
• _ _ O
Finding _ _ O
these _ _ O
pointers _ _ O
automatically _ _ O
is _ _ O
effectively _ _ O
as _ _ O
difficult _ _ O
as _ _ O
garbage _ _ B-Concept
collection _ _ I-Concept
. _ _ O


 _ _ O
• _ _ O
Because _ _ O
of _ _ O
this _ _ O
, _ _ O
moving _ _ O
blocks _ _ O
around _ _ O
is _ _ O
discouraged _ _ O
. _ _ O
( _ _ O
Easier _ _ O
to _ _ O
solve _ _ O
it _ _ O
another _ _ O
way _ _ O
. _ _ O
) _ _ O
? _ _ O
? _ _ O
? _ _ O


 _ _ O
heap _ _ B-Concept
static _ _ B-Concept
data _ _ I-Concept
code _ _ B-Concept
10 _ _ O


 _ _ O
Moving _ _ O
is _ _ O
NEVER _ _ O
easy _ _ O
stack _ _ B-Concept
available _ _ O
memory _ _ O


 _ _ O
• _ _ O
When _ _ O
blocks _ _ O
move _ _ O
, _ _ O
pointers _ _ O
to _ _ O
anything _ _ O
within _ _ O
them _ _ O
must _ _ O
be _ _ O
updated _ _ O
. _ _ O
• _ _ O
This _ _ O
is _ _ O
hard _ _ O
to _ _ O
keep _ _ O
track _ _ O
of _ _ O
! _ _ O
• _ _ O
C _ _ O
does _ _ O
not _ _ O
check _ _ O
validity _ _ O
of _ _ O
pointers _ _ O
after _ _ O


 _ _ O
heap _ _ B-Concept
static _ _ B-Concept
data _ _ I-Concept
code _ _ B-Concept
11 _ _ O


 _ _ O
Stressing _ _ O
it _ _ O
out _ _ O
• _ _ O
If _ _ O
we _ _ O
allocate _ _ O
a _ _ O
large _ _ O
array _ _ B-Concept
it _ _ O
will _ _ O
be _ _ O
allocated _ _ O
on _ _ O
the _ _ O
heap _ _ B-Concept
somewhere _ _ O
. _ _ O
• _ _ O
Other _ _ O
allocations _ _ O
can _ _ O
also _ _ O
happen _ _ O
, _ _ O
and _ _ O
they _ _ O
go _ _ O
" _ _ O
above _ _ O
" _ _ O
that _ _ O
array _ _ B-Concept
. _ _ O


 _ _ O
stack _ _ B-Concept


 _ _ O
available _ _ O
memory _ _ O


 _ _ O
int _ _ O
arr _ _ O
[ _ _ O
200 _ _ O
] _ _ O


 _ _ O
• _ _ O
What _ _ O
happens _ _ O
when _ _ O
you _ _ O
need _ _ O
to _ _ O
append _ _ O
a _ _ O
101st _ _ O
element _ _ O
to _ _ O
this _ _ O
array _ _ B-Concept
? _ _ O
• _ _ O
Uh _ _ O
oh _ _ O
! _ _ O
old _ _ O
data _ _ O
: _ _ O
int _ _ O
arr _ _ O
[ _ _ O
100 _ _ O
] _ _ O
int _ _ O
arr _ _ O
[ _ _ O
100 _ _ O
] _ _ O


 _ _ O
• _ _ O
You _ _ O
will _ _ O
need _ _ O
to _ _ O
allocate _ _ O
more _ _ O
space _ _ O
. _ _ O
• _ _ O
And _ _ O
then _ _ O
copy _ _ O
the _ _ O
array _ _ B-Concept
contents _ _ O
. _ _ O
• _ _ O
Free _ _ B-Concept
the _ _ O
old _ _ O
array _ _ B-Concept
. _ _ O
• _ _ O
How _ _ O
long _ _ O
does _ _ O
that _ _ O
take _ _ O
? _ _ O


 _ _ O
fragmentation _ _ B-Concept


 _ _ O
heap _ _ B-Concept
12 _ _ O


 _ _ O
Stressing _ _ O
it _ _ O
out _ _ O
: _ _ O
Big _ _ O
Arrays _ _ O
• _ _ O
This _ _ O
happens _ _ O
in _ _ O
very _ _ O
practical _ _ O
situations _ _ O
! _ _ O
• _ _ O
Reallocating _ _ O
means _ _ O
getting _ _ O
rid _ _ O
of _ _ O
a _ _ O
small _ _ O
thing _ _ O
• _ _ O
And _ _ O
replacing _ _ O
it _ _ O
with _ _ O
a _ _ O
larger _ _ O
thing _ _ O
. _ _ O
• _ _ O
You _ _ O
could _ _ O
have _ _ O
TiBs _ _ O
of _ _ O
memory _ _ O
and _ _ O
this _ _ O
will _ _ O
be _ _ O
a _ _ O
problem _ _ O
. _ _ O


 _ _ O
stack _ _ B-Concept


 _ _ O
available _ _ O
memory _ _ O


 _ _ O
• _ _ O
This _ _ O
affects _ _ O
performance _ _ O
: _ _ O
( _ _ O
in _ _ O
terms _ _ O
of _ _ O
writes _ _ O
: _ _ O
) _ _ O
• _ _ O
Appending _ _ O
item _ _ O
arr _ _ O
[ _ _ O
0 _ _ O
] _ _ O
: _ _ O
O _ _ O
1 _ _ O
• _ _ O
Appending _ _ O
item _ _ O
arr _ _ O
[ _ _ O
1 _ _ O
] _ _ O
: _ _ O
O _ _ O
1 _ _ O
• _ _ O
... _ _ O
• _ _ O
Appending _ _ O
item _ _ O
arr _ _ O
[ _ _ O
99 _ _ O
] _ _ O
: _ _ O
O _ _ O
1 _ _ O
• _ _ O
Appending _ _ O
item _ _ O
arr _ _ O
[ _ _ O
100 _ _ O
] _ _ O
: _ _ O
O _ _ O
n _ _ O
+ _ _ O
1 _ _ O
oh _ _ O
no _ _ O
! _ _ O


 _ _ O
• _ _ O
When _ _ O
you _ _ O
would _ _ O
overflow _ _ O
the _ _ O
buffer _ _ O
... _ _ O
• _ _ O
You _ _ O
then _ _ O
need _ _ O
to _ _ O
copy _ _ O
all _ _ O
previous _ _ O
values _ _ O
as _ _ O
well _ _ O
. _ _ O


 _ _ O
old _ _ O
data _ _ O
: _ _ O
int _ _ O
arr _ _ O
[ _ _ O
100 _ _ O
] _ _ O
int _ _ O
arr _ _ O
[ _ _ O
100 _ _ O
] _ _ O


 _ _ O
heap _ _ B-Concept
13 _ _ O


 _ _ O
Stressing _ _ O
it _ _ O
out _ _ O
: _ _ O
Performance _ _ O
Consistency _ _ O
• _ _ O
Big _ _ O
arrays _ _ O
want _ _ O
to _ _ O
be _ _ O
continuous _ _ O
. _ _ O
• _ _ O
Ensuring _ _ O
continuous _ _ O
space _ _ O
is _ _ O
difficult _ _ O
when _ _ O
you _ _ O
do _ _ O
not _ _ O
know _ _ O
how _ _ O
much _ _ O
you _ _ O
will _ _ O
ultimately _ _ O
need _ _ O
. _ _ O


 _ _ O
• _ _ O
This _ _ O
is _ _ O
exactly _ _ O
why _ _ O
linked _ _ O
lists _ _ O
exist _ _ O
! _ _ O


 _ _ O
stack _ _ B-Concept


 _ _ O
available _ _ O
memory _ _ O


 _ _ O
• _ _ O
Since _ _ O
a _ _ O
linked _ _ B-Concept
list _ _ I-Concept
allocates _ _ O
on _ _ O
every _ _ O
append _ _ O
. _ _ O
• _ _ O
Each _ _ O
append _ _ O
takes _ _ O
the _ _ O
same _ _ O
amount _ _ O
of _ _ O
time _ _ O
. _ _ O


 _ _ O
• _ _ O
However _ _ O
, _ _ O
everything _ _ O
is _ _ O
a _ _ O
trade-off _ _ O
. _ _ O
• _ _ O
Dang _ _ O
it _ _ O
! _ _ O
! _ _ O
! _ _ O
• _ _ O
One _ _ O
cost _ _ O
is _ _ O
extra _ _ O
overhead _ _ O
for _ _ O
metadata _ _ B-Concept
. _ _ O
• _ _ O
Linked _ _ B-Concept
list _ _ I-Concept
traversal _ _ B-Concept
can _ _ O
stress _ _ O
memory _ _ O
caches _ _ O
. _ _ O
• _ _ O
It _ _ O
means _ _ O
traversing _ _ O
the _ _ O
array _ _ O
is _ _ O
slower _ _ O
. _ _ O
• _ _ O
However _ _ O
, _ _ O
we _ _ O
will _ _ O
mostly _ _ O
ignore _ _ O
this _ _ O
for _ _ O
now _ _ O
. _ _ O


 _ _ O
old _ _ O
data _ _ O
: _ _ O
int _ _ O
arr _ _ O
[ _ _ O
100 _ _ O
] _ _ O
int _ _ O
arr _ _ O
[ _ _ O
100 _ _ O
] _ _ O


 _ _ O
heap _ _ O
14 _ _ O


 _ _ O
The _ _ O
Linked _ _ O
List _ _ O
A _ _ O
story _ _ O
about _ _ O
trade-offs _ _ O
. _ _ O


 _ _ O
15 _ _ O


 _ _ O
What _ _ O
is _ _ O
a _ _ O
linked _ _ O
list _ _ O
? _ _ O
• _ _ O
A _ _ O
linked _ _ O
list _ _ O
is _ _ O
a _ _ O
non-continuous _ _ O
data _ _ O
structure _ _ O
representing _ _ O
an _ _ O
ordered _ _ O
list _ _ O
. _ _ O
• _ _ O
Each _ _ O
item _ _ O
in _ _ O
the _ _ O
linked _ _ O
list _ _ O
is _ _ O
represented _ _ O
by _ _ O
metadata _ _ O
called _ _ O
a _ _ O
node _ _ O
. _ _ O
• _ _ O
This _ _ O
metadata _ _ O
indirectly _ _ O
refers _ _ O
to _ _ O
the _ _ O
actual _ _ O
data _ _ O
. _ _ O
• _ _ O
Furthermore _ _ O
, _ _ O
it _ _ O
indirectly _ _ O
refers _ _ O
to _ _ O
at _ _ O
least _ _ O
one _ _ O
other _ _ O
item _ _ O
in _ _ O
the _ _ O
list _ _ O
. _ _ O


 _ _ O
Node _ _ O


 _ _ O
" _ _ O
struct _ _ O
" _ _ O
required _ _ O
since _ _ O
Node _ _ O
is _ _ O
not _ _ O
technically _ _ O
defined _ _ O
until _ _ O
after _ _ O
it _ _ O
is _ _ O
defined _ _ O
! _ _ O


 _ _ O
16 _ _ O


 _ _ O
Keeping _ _ O
ahead _ _ O
of _ _ O
the _ _ O
list _ _ O
. _ _ O
• _ _ O
Creation _ _ O
of _ _ O
a _ _ O
list _ _ O
occurs _ _ O
when _ _ O
one _ _ O
allocates _ _ O
a _ _ O
single _ _ O
node _ _ O
and _ _ O
tracks _ _ O
it _ _ O
in _ _ O
a _ _ O
pointer _ _ O
. _ _ O
This _ _ O
is _ _ O
the _ _ O
head _ _ O
of _ _ O
our _ _ O
list _ _ O
( _ _ O
first _ _ O
element _ _ O
. _ _ O
) _ _ O


 _ _ O
Node _ _ O


 _ _ O
17 _ _ O


 _ _ O
Adding _ _ O
some _ _ O
links _ _ O
to _ _ O
our _ _ O
chain _ _ O
• _ _ O
If _ _ O
we _ _ O
want _ _ O
to _ _ O
append _ _ O
an _ _ O
item _ _ O
, _ _ O
we _ _ O
can _ _ O
add _ _ O
a _ _ O
node _ _ O
anywhere _ _ O
! _ _ O


 _ _ O
" _ _ O
tail _ _ O
" _ _ O


 _ _ O
" _ _ O
node _ _ O
" _ _ O


 _ _ O
Remember _ _ O
the _ _ O
' _ _ O
\0 _ _ O
' _ _ O
sentinel _ _ O
! _ _ O


 _ _ O
18 _ _ O


 _ _ O
We _ _ O
can _ _ O
add _ _ O
them _ _ O
anywhere _ _ O
! _ _ O
! _ _ O
• _ _ O
Consider _ _ O
what _ _ O
happens _ _ O
if _ _ O
we _ _ O
update _ _ O
our _ _ O
append _ _ O
to _ _ O
take _ _ O
any _ _ O
Node _ _ O
: _ _ O


 _ _ O
" _ _ O
curNode _ _ O
" _ _ O


 _ _ O
" _ _ O
node _ _ O
" _ _ O


 _ _ O
Tail _ _ O


 _ _ O
19 _ _ O


 _ _ O
We _ _ O
can _ _ O
add _ _ O
them _ _ O
anywhere _ _ O
! _ _ O
! _ _ O
• _ _ O
This _ _ O
function _ _ O
has _ _ O
very _ _ O
consistent _ _ O
performance _ _ O
( _ _ O
constant _ _ O
time _ _ O
) _ _ O
: _ _ O


 _ _ O
• _ _ O
The _ _ O
append _ _ O
always _ _ O
allocates _ _ O
the _ _ O
same _ _ O
amount _ _ O
. _ _ O
• _ _ O
It _ _ O
always _ _ O
copies _ _ O
the _ _ O
same _ _ O
amount _ _ O
. _ _ O
• _ _ O
Compare _ _ O
to _ _ O
a _ _ O
big _ _ O
array _ _ O
where _ _ O
you _ _ O
may _ _ O
have _ _ O
to _ _ O
copy _ _ O
the _ _ O
entire _ _ O
thing _ _ O
to _ _ O
append _ _ O
something _ _ O
new _ _ O
! _ _ O


 _ _ O
Traversal _ _ O
... _ _ O
on _ _ O
the _ _ O
other _ _ O
hand _ _ O
... _ _ O
• _ _ O
Accessing _ _ O
an _ _ O
array _ _ O
element _ _ O
is _ _ O
generally _ _ O
very _ _ O
simple _ _ O
. _ _ O
• _ _ O
is _ _ O
the _ _ O
same _ _ O
as _ _ O
because _ _ O
its _ _ O
location _ _ O
is _ _ O
very _ _ O
well-known _ _ O
! _ _ O
• _ _ O
This _ _ O
is _ _ O
because _ _ O
array _ _ O
items _ _ O
are _ _ O
continuous _ _ O
in _ _ O
memory _ _ O
. _ _ O
Not _ _ O
true _ _ O
for _ _ O
linked _ _ O
lists _ _ O
! _ _ O


 _ _ O
• _ _ O
Here _ _ O
is _ _ O
a _ _ O
function _ _ O
that _ _ O
performs _ _ O
the _ _ O
equivalent _ _ O
for _ _ O
linked _ _ O
lists _ _ O
: _ _ O


 _ _ O
Q _ _ O
: _ _ O
How _ _ O
many _ _ O
times _ _ O
is _ _ O
memory _ _ O
accessed _ _ O
relative _ _ O
to _ _ O
the _ _ O
requested _ _ O
index _ _ O
? _ _ O


 _ _ O
21 _ _ O


 _ _ O
Removing _ _ O
... _ _ O
on _ _ O
the _ _ O
other _ _ O
, _ _ O
other _ _ O
hand _ _ O
! _ _ O
• _ _ O
One _ _ O
nice _ _ O
thing _ _ O
about _ _ O
linked _ _ O
lists _ _ O
is _ _ O
their _ _ O
flexibility _ _ O
to _ _ O
changing _ _ O
shape _ _ O
. _ _ O
• _ _ O
I _ _ O
used _ _ O
to _ _ O
be _ _ O
able _ _ O
to _ _ O
bend _ _ O
a _ _ O
lot _ _ O
better _ _ O
, _ _ O
too _ _ O
, _ _ O
when _ _ O
I _ _ O
was _ _ O
in _ _ O
my _ _ O
20s _ _ O
. _ _ O
Alas _ _ O
. _ _ O
Ca _ _ O
n't _ _ O
find _ _ O
item _ _ O
at _ _ O
index _ _ O
. _ _ O
We _ _ O
are _ _ O
deleting _ _ O
the _ _ O
head _ _ O
. _ _ O


 _ _ O
• _ _ O
Since _ _ O
we _ _ O
do _ _ O
n't _ _ O
have _ _ O
a _ _ O
way _ _ O
to _ _ O
go _ _ O
" _ _ O
backward _ _ O
" _ _ O
• _ _ O
We _ _ O
first _ _ O
find _ _ O
the _ _ O
node _ _ O
we _ _ O
want _ _ O
to _ _ O
delete _ _ O
( _ _ O
) _ _ O
• _ _ O
Keeping _ _ O
track _ _ O
of _ _ O
the _ _ O
node _ _ O
of _ _ O
- _ _ O
( _ _ O
) _ _ O
• _ _ O
Rewire _ _ O
to _ _ O
cut _ _ O
out _ _ O
. _ _ O


 _ _ O
Returns _ _ O
new _ _ O
head _ _ O
( _ _ O
or _ _ O
old _ _ O
head _ _ O
if _ _ O
unchanged _ _ O
) _ _ O
. _ _ O


 _ _ O
22 _ _ O


 _ _ O
Removing _ _ O
... _ _ O
on _ _ O
the _ _ O
other _ _ O
, _ _ O
other _ _ O
hand _ _ O
! _ _ O
• _ _ O
This _ _ O
looks _ _ O
complex _ _ O
, _ _ O
but _ _ O
it _ _ O
really _ _ O
is _ _ O
a _ _ O
simple _ _ O
traversal _ _ O
. _ _ O
• _ _ O
So _ _ O
it _ _ O
takes _ _ O
O _ _ O
n _ _ O
to _ _ O
find _ _ O
the _ _ O
item _ _ O
. _ _ O
• _ _ O
And _ _ O
it _ _ O
performs _ _ O
a _ _ O
simple _ _ O
update _ _ O
and _ _ O
deallocation _ _ O
. _ _ O
( _ _ O
quick _ _ O
to _ _ O
do _ _ O
) _ _ O


 _ _ O
• _ _ O
A _ _ O
big _ _ O
array _ _ O
, _ _ O
on _ _ O
the _ _ O
other _ _ O
hand _ _ O
. _ _ O
• _ _ O
It _ _ O
can _ _ O
find _ _ O
the _ _ O
element _ _ O
to _ _ O
remove _ _ O
immediately _ _ O
. _ _ O
• _ _ O
However _ _ O
, _ _ O
removing _ _ O
it _ _ O
means _ _ O
shifting _ _ O
over _ _ O
every _ _ O
item _ _ O
after _ _ O
it _ _ O
left _ _ O
. _ _ O
• _ _ O
That _ _ O
can _ _ O
be _ _ O
an _ _ O
expensive _ _ O
update _ _ O
! _ _ O
( _ _ O
Memory _ _ O
is _ _ O
slow _ _ O
! _ _ O
! _ _ O
) _ _ O
23 _ _ O


 _ _ O
On _ _ O
your _ _ O
own _ _ O
! _ _ O


 _ _ O
Think _ _ O
about _ _ O
the _ _ O
code _ _ O
you _ _ O
would _ _ O
need _ _ O
to _ _ O
do _ _ O
any _ _ O
of _ _ O
the _ _ O
following _ _ O
: _ _ O
• _ _ O
Delete _ _ O
/ _ _ O
free _ _ O
the _ _ O
entire _ _ O
linked _ _ O
list _ _ O
. _ _ O
• _ _ O
Sort _ _ O
a _ _ O
linked _ _ O
list _ _ O
. _ _ O
• _ _ O
Append _ _ O
a _ _ O
linked _ _ O
list _ _ O
to _ _ O
an _ _ O
existing _ _ O
one _ _ O
. _ _ O
• _ _ O
Copy _ _ O
a _ _ O
subset _ _ O
of _ _ O
a _ _ O
linked _ _ O
list _ _ O
to _ _ O
a _ _ O
new _ _ O
list _ _ O
. _ _ O
Often _ _ O
, _ _ O
operations _ _ O
can _ _ O
be _ _ O
abstracted _ _ O
in _ _ O
such _ _ O
a _ _ O
way _ _ O
that _ _ O
all _ _ O
of _ _ O
these _ _ O
can _ _ O
be _ _ O
written _ _ O
relatively _ _ O
simply _ _ O
. _ _ O
Consider _ _ O
the _ _ O
performance _ _ O
of _ _ O
these _ _ O
operations _ _ O
compared _ _ O
to _ _ O
an _ _ O
Array _ _ O
. _ _ O
24 _ _ O


 _ _ O
Linked _ _ O
lists _ _ O
... _ _ O
link _ _ O
you _ _ O
... _ _ O
to _ _ O
the _ _ O
world _ _ O
! _ _ O
• _ _ O
Consider _ _ O
how _ _ O
much _ _ O
cleaner _ _ O
you _ _ O
can _ _ O
make _ _ O
certain _ _ O
operations _ _ O
if _ _ O
you _ _ O
tracked _ _ O
the _ _ O
previous _ _ O
node _ _ O
as _ _ O
well _ _ O
. _ _ O
• _ _ O
This _ _ O
is _ _ O
a _ _ O
doubly _ _ O
linked _ _ O
list _ _ O
. _ _ O
• _ _ O
This _ _ O
is _ _ O
typically _ _ O
" _ _ O
double-ended _ _ O
" _ _ O
as _ _ O
well _ _ O
: _ _ O
keeping _ _ O
track _ _ O
of _ _ O
both _ _ O
head _ _ O
and _ _ O
tail _ _ O
. _ _ O


 _ _ O
Node _ _ O


 _ _ O
Node _ _ O


 _ _ O
Node _ _ O


 _ _ O
25 _ _ O


 _ _ O
Seeing _ _ O
the _ _ O
trees _ _ O
through _ _ O
the _ _ O
forest _ _ O
• _ _ O
A _ _ O
binary _ _ O
tree _ _ O
can _ _ O
be _ _ O
represented _ _ O
by _ _ O
the _ _ O
same _ _ O
nodes _ _ O
as _ _ O
a _ _ O
linked _ _ O
list _ _ O
. _ _ O
• _ _ O
In _ _ O
this _ _ O
case _ _ O
, _ _ O
you _ _ O
have _ _ O
a _ _ O
left _ _ O
and _ _ O
right _ _ O
child _ _ O
node _ _ O
instead _ _ O
of _ _ O
next _ _ O
and _ _ O
prev _ _ O
. _ _ O
Node _ _ O


 _ _ O
• _ _ O
The _ _ O
operations _ _ O
are _ _ O
very _ _ O
different _ _ O
, _ _ O
though _ _ O
. _ _ O


 _ _ O
Node _ _ O


 _ _ O
Node _ _ O


 _ _ O
Node _ _ O


 _ _ O
26 _ _ O


 _ _ O
De-Stressing _ _ O
it _ _ O
out _ _ O
: _ _ O
Linked _ _ O
Lists _ _ O
• _ _ O
We _ _ O
know _ _ O
big _ _ O
arrays _ _ O
want _ _ O
to _ _ O
be _ _ O
continuous _ _ O
. _ _ O
• _ _ O
However _ _ O
, _ _ O
ensuring _ _ O
continuous _ _ O
space _ _ O
is _ _ O
difficult _ _ O
when _ _ O
you _ _ O
do _ _ O
not _ _ O
know _ _ O
how _ _ O
much _ _ O
you _ _ O
will _ _ O
ultimately _ _ O
need _ _ O
. _ _ O


 _ _ O
• _ _ O
Linked _ _ O
lists _ _ O
allocate _ _ O
very _ _ O
small _ _ O
chunks _ _ O
of _ _ O
metadata _ _ O
. _ _ O
• _ _ O
These _ _ O
chunks _ _ O
can _ _ O
be _ _ O
allocated _ _ O
easily _ _ O
on-demand _ _ O
. _ _ O
• _ _ O
And _ _ O
then _ _ O
deallocated _ _ O
without _ _ O
creating _ _ O
wide _ _ O
gaps _ _ O
. _ _ O


 _ _ O
stack _ _ O


 _ _ O
available _ _ O
memory _ _ O


 _ _ O
• _ _ O
This _ _ O
reduces _ _ O
fragmentation _ _ O
. _ _ O
• _ _ O
Deallocating _ _ O
always _ _ O
leaves _ _ O
a _ _ O
small _ _ O
amount _ _ O
of _ _ O
room _ _ O
. _ _ O
• _ _ O
It _ _ O
is _ _ O
always _ _ O
the _ _ O
exact _ _ O
amount _ _ O
needed _ _ O
to _ _ O
append _ _ O
! _ _ O
• _ _ O
However _ _ O
, _ _ O
it _ _ O
is _ _ O
all _ _ O
at _ _ O
the _ _ O
expense _ _ O
of _ _ O
complexity _ _ O
! _ _ O
• _ _ O
And _ _ O
traversal _ _ O
can _ _ O
be _ _ O
expensive _ _ O
( _ _ O
but _ _ O
we _ _ O
can _ _ O
find _ _ O
ways _ _ O
to _ _ O
deal _ _ O
with _ _ O
that _ _ O
. _ _ O
) _ _ O


 _ _ O
some _ _ O
other _ _ O
data _ _ O


 _ _ O
heap _ _ O
27 _ _ O


 _ _ O
Implementing _ _ O
Malloc _ _ O
It _ _ O
really _ _ O
sounds _ _ O
like _ _ O
some _ _ O
kind _ _ O
of _ _ O
He-Man _ _ O
or _ _ O
She-Ra _ _ O
villain _ _ O
of _ _ O
the _ _ O
week _ _ O
. _ _ O


 _ _ O
28 _ _ O


 _ _ O
The _ _ O
malloc _ _ O
essentials _ _ O
• _ _ O
The _ _ O
following _ _ O
: _ _ O


 _ _ O
stack _ _ O


 _ _ O
function _ _ O
does _ _ O
the _ _ O


 _ _ O
• _ _ O
Allocates _ _ O
memory _ _ O
of _ _ O
at _ _ O
least _ _ O
bytes _ _ O
. _ _ O
• _ _ O
Returns _ _ O
the _ _ O
address _ _ O
to _ _ O
that _ _ O
block _ _ O
of _ _ O
memory _ _ O
( _ _ O
or _ _ O
error _ _ O
) _ _ O


 _ _ O
on _ _ O


 _ _ O
available _ _ O
memory _ _ O


 _ _ O
• _ _ O
Essentially _ _ O
, _ _ O
your _ _ O
program _ _ O
has _ _ O
a _ _ O
potentially _ _ O
large _ _ O
chunk _ _ O
of _ _ O
memory _ _ O
. _ _ O
• _ _ O
The _ _ O
function _ _ O
tears _ _ O
off _ _ O
a _ _ O
piece _ _ O
of _ _ O
the _ _ O
chunk _ _ O
. _ _ O
• _ _ O
Also _ _ O
must _ _ O
then _ _ O
allow _ _ O
that _ _ O
chunk _ _ O
to _ _ O
be _ _ O
reused _ _ O
. _ _ O
• _ _ O
The _ _ O
job _ _ O
of _ _ O
is _ _ O
to _ _ O
do _ _ O
so _ _ O
in _ _ O
the _ _ O
" _ _ O
best _ _ O
" _ _ O
way _ _ O
to _ _ O
reduce _ _ O
fragmentation _ _ O
. _ _ O
We _ _ O
want _ _ O
to _ _ O
avoid _ _ O
fragmentation _ _ O
29 _ _ O


 _ _ O
Choosing _ _ O
where _ _ O
to _ _ O
allocate _ _ O
• _ _ O
Our _ _ O
first _ _ O
problem _ _ O
is _ _ O
, _ _ O
when _ _ O
we _ _ O
tear _ _ O
off _ _ O
a _ _ O
chunk _ _ O
? _ _ O


 _ _ O
is _ _ O
called _ _ O
, _ _ O
where _ _ O
do _ _ O


 _ _ O
• _ _ O
We _ _ O
can _ _ O
do _ _ O
a _ _ O
few _ _ O
simple _ _ O
things _ _ O
: _ _ O
• _ _ O
First-Fit _ _ O
: _ _ O
start _ _ O
at _ _ O
lowest _ _ O
address _ _ O
, _ _ O
find _ _ O
first _ _ O
available _ _ O
section _ _ O
. _ _ O


 _ _ O
stack _ _ O
available _ _ O
memory _ _ O


 _ _ O
• _ _ O
Fast _ _ O
, _ _ O
but _ _ O
small _ _ O
blocks _ _ O
clog _ _ O
up _ _ O
the _ _ O
works _ _ O
. _ _ O


 _ _ O
• _ _ O
Next-fit _ _ O
: _ _ O
Do _ _ O
" _ _ O
First-Fit _ _ O
" _ _ O
but _ _ O
start _ _ O
where _ _ O
we _ _ O
last _ _ O
allocated _ _ O
. _ _ O
• _ _ O
Fast _ _ O
and _ _ O
spreads _ _ O
small _ _ O
blocks _ _ O
around _ _ O
a _ _ O
little _ _ O
better _ _ O
. _ _ O


 _ _ O
• _ _ O
Best-Fit _ _ O
: _ _ O
laboriously _ _ O
look _ _ O
for _ _ O
the _ _ O
smallest _ _ O
available _ _ O
section _ _ O
to _ _ O
divide _ _ O
up _ _ O
. _ _ O


 _ _ O
Last _ _ O
Allocated _ _ O


 _ _ O
• _ _ O
Slow _ _ O
, _ _ O
but _ _ O
limits _ _ O
fragmentation _ _ O
. _ _ O


 _ _ O
? _ _ O
? _ _ O
? _ _ O
30 _ _ O


 _ _ O
Managing _ _ O
that _ _ O
metadata _ _ O
! _ _ O
• _ _ O
You _ _ O
have _ _ O
a _ _ O
whole _ _ O
section _ _ O
of _ _ O
memory _ _ O
to _ _ O
divide _ _ O
up _ _ O
. _ _ O
• _ _ O
You _ _ O
need _ _ O
to _ _ O
keep _ _ O
track _ _ O
of _ _ O
what _ _ O
is _ _ O
allocated _ _ O
and _ _ O
what _ _ O
is _ _ O
free _ _ O
. _ _ O
• _ _ O
One _ _ O
of _ _ O
the _ _ O
least _ _ O
complicated _ _ O
ways _ _ O
of _ _ O
doing _ _ O
so _ _ O
is _ _ O
to _ _ O
use _ _ O
... _ _ O
hmm _ _ O
... _ _ O
• _ _ O
A _ _ O
linked _ _ O
list _ _ O
! _ _ O
( _ _ O
or _ _ O
two _ _ O
! _ _ O
) _ _ O
We _ _ O
know _ _ O
how _ _ O
to _ _ O
do _ _ O
this _ _ O
! _ _ O
! _ _ O


 _ _ O
• _ _ O
We _ _ O
can _ _ O
treat _ _ O
each _ _ O
allocated _ _ O
block _ _ O
( _ _ O
and _ _ O
each _ _ O
empty _ _ O
space _ _ O
) _ _ O
as _ _ O
a _ _ O
node _ _ O
in _ _ O
a _ _ O
linked _ _ O
list _ _ O
. _ _ O
• _ _ O
Allocating _ _ O
memory _ _ O
is _ _ O
just _ _ O
appending _ _ O
a _ _ O
node _ _ O
to _ _ O
our _ _ O
list _ _ O
. _ _ O


 _ _ O
• _ _ O
The _ _ O
trick _ _ O
is _ _ O
to _ _ O
think _ _ O
about _ _ O
how _ _ O
we _ _ O
want _ _ O
to _ _ O
split _ _ O
up _ _ O
the _ _ O
nodes _ _ O
representing _ _ O
available _ _ O
memory _ _ O
. _ _ O


 _ _ O
31 _ _ O


 _ _ O
Tracking _ _ O
memory _ _ O
: _ _ O
Our _ _ O
fresh _ _ O
new _ _ O
world _ _ O
. _ _ O
• _ _ O
Let _ _ O
's _ _ O
orient _ _ O
our _ _ O
memory _ _ O
visually _ _ O
horizontally _ _ O
. _ _ O
• _ _ O
We _ _ O
have _ _ O
control _ _ O
over _ _ O
EVERY _ _ O
byte _ _ O
of _ _ O
it _ _ O
. _ _ O
We _ _ O
can _ _ O
place _ _ O
metadata _ _ O
ANYWHERE _ _ O
. _ _ O


 _ _ O
• _ _ O
Every _ _ O


 _ _ O
is _ _ O
responsible _ _ O
for _ _ O
allocating _ _ O
a _ _ O
block _ _ O
of _ _ O
memory _ _ O
. _ _ O


 _ _ O
• _ _ O
How _ _ O
, _ _ O
then _ _ O
, _ _ O
do _ _ O
we _ _ O
manage _ _ O
where _ _ O
things _ _ O
are _ _ O
allocated _ _ O
and _ _ O
where _ _ O
is _ _ O
empty _ _ O
space _ _ O
? _ _ O
• _ _ O
We _ _ O
can _ _ O
have _ _ O
" _ _ O
allocation _ _ O
" _ _ O
reduce _ _ O
to _ _ O
creating _ _ O
a _ _ O
new _ _ O
node _ _ O
in _ _ O
a _ _ O
linked _ _ O
list _ _ O
. _ _ O


 _ _ O
available _ _ O
memory _ _ O


 _ _ O
We _ _ O
have _ _ O
the _ _ O
power _ _ O
to _ _ O
write _ _ O
data _ _ O
ANYWHERE _ _ O
! _ _ O
So _ _ O
where _ _ O
do _ _ O
linked _ _ O
list _ _ O
nodes _ _ O
go _ _ O
? _ _ O


 _ _ O
32 _ _ O


 _ _ O
Linked _ _ O
lists _ _ O
are _ _ O
our _ _ O
friend _ _ O
, _ _ O
here _ _ O
• _ _ O
We _ _ O
will _ _ O
augment _ _ O
our _ _ O
normal _ _ O
doubly _ _ O
linked _ _ O
list _ _ O
to _ _ O
be _ _ O
useful _ _ O
for _ _ O
tracking _ _ O
the _ _ O
size _ _ O
of _ _ O
the _ _ O
block _ _ O
it _ _ O
represents _ _ O
. _ _ O
( _ _ O
an _ _ O
explicit _ _ O
list _ _ O
allocator _ _ O
) _ _ O
• _ _ O
Here _ _ O
, _ _ O
we _ _ O
will _ _ O
maintain _ _ O
a _ _ O
single _ _ O
linked _ _ O
lists _ _ O
of _ _ O
all _ _ O
allocated _ _ O
or _ _ O
free _ _ O
blocks _ _ O
. _ _ O
• _ _ O
The _ _ O
size _ _ O
field _ _ O
denotes _ _ O
how _ _ O
big _ _ O
the _ _ O
block _ _ O
is _ _ O
( _ _ O
how _ _ O
much _ _ O
is _ _ O
used _ _ O
/ _ _ O
available _ _ O
. _ _ O
) _ _ O
• _ _ O
We _ _ O
need _ _ O
to _ _ O
know _ _ O
when _ _ O
a _ _ O
block _ _ O
represents _ _ O
allocated _ _ O
space _ _ O
or _ _ O
if _ _ O
it _ _ O
is _ _ O
free _ _ O
. _ _ O
• _ _ O
Hmm _ _ O
... _ _ O
we _ _ O
could _ _ O
use _ _ O
a _ _ O
single _ _ O
bit _ _ O
to _ _ O
denote _ _ O
that _ _ O
. _ _ O
Or _ _ O
... _ _ O
negativity _ _ O
! _ _ O
• _ _ O
The _ _ O


 _ _ O
is _ _ O
NEVER _ _ O


 _ _ O
. _ _ O
In _ _ O
fact _ _ O
, _ _ O


 _ _ O
fails _ _ O
when _ _ O
requesting _ _ O
size _ _ O
of _ _ O


 _ _ O
. _ _ O


 _ _ O
AllocNode _ _ O


 _ _ O
We _ _ O
can _ _ O
make _ _ O
other _ _ O
clever _ _ O
space _ _ O
optimizations _ _ O
, _ _ O
but _ _ O
we _ _ O
will _ _ O
start _ _ O
with _ _ O
this _ _ O
. _ _ O


 _ _ O
Signed _ _ O
! _ _ O
Negative _ _ O
number _ _ O
means _ _ O
a _ _ O
free _ _ O
block _ _ O
. _ _ O


 _ _ O
33 _ _ O


 _ _ O
Tracking _ _ O
memory _ _ O
: _ _ O
High _ _ O
level _ _ O
metadata _ _ O
• _ _ O
We _ _ O
can _ _ O
keep _ _ O
track _ _ O
of _ _ O
used _ _ O
/ _ _ O
empty _ _ O
spaces _ _ O
cheaply _ _ O
by _ _ O
having _ _ O
linked _ _ O
list _ _ O
nodes _ _ O
at _ _ O
the _ _ O
beginning _ _ O
of _ _ O
them _ _ O
. _ _ O
The _ _ O
nodes _ _ O
track _ _ O
the _ _ O
size _ _ O
of _ _ O
the _ _ O
space _ _ O
. _ _ O
• _ _ O
Here _ _ O
we _ _ O
have _ _ O
an _ _ O
allocated _ _ O
block _ _ O
followed _ _ O
by _ _ O
a _ _ O
free _ _ O
and _ _ O
then _ _ O
allocated _ _ O
block _ _ O
. _ _ O
• _ _ O
The _ _ O
metadata _ _ O
for _ _ O
the _ _ O
linked _ _ O
list _ _ O
is _ _ O
just _ _ O
smashed _ _ O
into _ _ O
the _ _ O
block _ _ O
itself _ _ O
. _ _ O


 _ _ O
available _ _ O
memory _ _ O


 _ _ O
Q _ _ O
: _ _ O
What _ _ O
happens _ _ O
when _ _ O
we _ _ O
write _ _ O
over _ _ O
the _ _ O
block _ _ O
boundary _ _ O
? _ _ O


 _ _ O
34 _ _ O


 _ _ O
Implementing _ _ O
• _ _ O
To _ _ O
allocate _ _ O
some _ _ O
amount _ _ O
of _ _ O
space _ _ O
, _ _ O
we _ _ O
find _ _ O
a _ _ O
free _ _ O
block _ _ O
that _ _ O
is _ _ O
at _ _ O
least _ _ O
that _ _ O
size _ _ O
+ _ _ O
metadata _ _ O
size _ _ O
. _ _ O
( _ _ O
Which _ _ O
one _ _ O
? _ _ O
Well _ _ O
, _ _ O
first-fit _ _ O
and _ _ O
friends _ _ O
apply _ _ O
! _ _ O
) _ _ O
• _ _ O
Then _ _ O
we _ _ O
will _ _ O
want _ _ O
to _ _ O
split _ _ O
that _ _ O
free _ _ O
block _ _ O
. _ _ O
x _ _ O


 _ _ O
x _ _ O


 _ _ O
x _ _ O


 _ _ O
available _ _ O
memory _ _ O


 _ _ O
35 _ _ O


 _ _ O
Implementing _ _ O
Carefully _ _ O
negate _ _ O
size _ _ O


 _ _ O
• _ _ O
Allocating _ _ O
means _ _ O
finding _ _ O
a _ _ O
free _ _ O
block _ _ O
big _ _ O
enough _ _ O
. _ _ O
• _ _ O
Including _ _ O
the _ _ O
metadata _ _ O
size _ _ O
. _ _ O


 _ _ O
• _ _ O
Then _ _ O
splitting _ _ O
it _ _ O
into _ _ O
a _ _ O
used _ _ O
block _ _ O
and _ _ O
a _ _ O
smaller _ _ O
free _ _ O
block _ _ O
. _ _ O
Linked _ _ O
list _ _ O
traversal _ _ O
; _ _ O
O _ _ O
( _ _ O
n _ _ O
) _ _ O


 _ _ O
• _ _ O
This _ _ O
is _ _ O
incomplete _ _ O
. _ _ O
( _ _ O
Why _ _ O
? _ _ O
) _ _ O


 _ _ O
Linked _ _ O
list _ _ O
append _ _ O
; _ _ O
O _ _ O
( _ _ O
1 _ _ O
) _ _ O


 _ _ O
• _ _ O
( _ _ O
you _ _ O
do _ _ O
n't _ _ O
always _ _ O
split _ _ O
) _ _ O


 _ _ O
Recall _ _ O
that _ _ O
we _ _ O
made _ _ O
size _ _ O
negative _ _ O
for _ _ O
a _ _ O
free _ _ O
block _ _ O
. _ _ O
Positive _ _ O
means _ _ O
non-free _ _ O
. _ _ O
is _ _ O
negative _ _ O
. _ _ O
Think _ _ O
about _ _ O
it _ _ O
! _ _ O
Q _ _ O
: _ _ O
This _ _ O
is _ _ O
first-fit _ _ O
. _ _ O
What _ _ O
should _ _ O
be _ _ O
added _ _ O
to _ _ O
implement _ _ O
next-fit _ _ O
? _ _ O
Best-fit _ _ O
? _ _ O
36 _ _ O


 _ _ O
Implementing _ _ O
• _ _ O
When _ _ O
freeing _ _ O
the _ _ O
middle _ _ O
block _ _ O
, _ _ O
you _ _ O
will _ _ O
create _ _ O
empty _ _ O
space _ _ O
. _ _ O
• _ _ O
Consider _ _ O
allocations _ _ O
... _ _ O
it _ _ O
's _ _ O
somewhat _ _ O
difficult _ _ O
to _ _ O
see _ _ O
the _ _ O
empty _ _ O
space _ _ O
. _ _ O
• _ _ O
You _ _ O
have _ _ O
" _ _ O
false _ _ O
fragmentation _ _ O
, _ _ O
" _ _ O
so _ _ O
you _ _ O
will _ _ O
want _ _ O
to _ _ O
merge _ _ O
adjacent _ _ O
free _ _ O
blocks _ _ O
. _ _ O


 _ _ O
available _ _ O
memory _ _ O


 _ _ O
37 _ _ O


 _ _ O
Implementing _ _ O
• _ _ O
So _ _ O
, _ _ O
when _ _ O
we _ _ O
free _ _ O
blocks _ _ O
, _ _ O
we _ _ O
look _ _ O
to _ _ O
the _ _ O
left _ _ O
. _ _ O
We _ _ O
look _ _ O
to _ _ O
the _ _ O
right _ _ O
. _ _ O
• _ _ O
We _ _ O
coalesce _ _ O
the _ _ O
newly _ _ O
free _ _ O
block _ _ O
with _ _ O
ANY _ _ O
adjacent _ _ O
free _ _ O
blocks _ _ O
. _ _ O
• _ _ O
First _ _ O
one _ _ O
... _ _ O
• _ _ O
Then _ _ O
the _ _ O
other _ _ O
. _ _ O
( _ _ O
And _ _ O
it _ _ O
is _ _ O
linked _ _ O
list _ _ O
node _ _ O
removal _ _ O
; _ _ O
a _ _ O
constant _ _ O
time _ _ O
operation _ _ O
! _ _ O
) _ _ O


 _ _ O
available _ _ O
memory _ _ O


 _ _ O
38 _ _ O


 _ _ O
Implementing _ _ O
Header _ _ O
is _ _ O
just _ _ O
before _ _ O
ptr _ _ O


 _ _ O
• _ _ O
Finding _ _ O
the _ _ O
header _ _ O
metadata _ _ O
node _ _ O
is _ _ O
simple _ _ O
. _ _ O
• _ _ O
Look _ _ O
at _ _ O
our _ _ O


 _ _ O
• _ _ O


 _ _ O
's _ _ O


 _ _ O
. _ _ O


 _ _ O
is _ _ O
slightly _ _ O
less _ _ O
complex _ _ O
. _ _ O
• _ _ O
It _ _ O
does _ _ O
not _ _ O
have _ _ O
to _ _ O
search _ _ O
. _ _ O


 _ _ O
• _ _ O
Where _ _ O
• _ _ O


 _ _ O
Resembles _ _ O
linked _ _ O
list _ _ O
delete _ _ O
; _ _ O
O _ _ O
( _ _ O
1 _ _ O
) _ _ O


 _ _ O
splits _ _ O
nodes _ _ O
merges _ _ O
them _ _ O
. _ _ O


 _ _ O
• _ _ O
Whenever _ _ O
a _ _ O
block _ _ O
is _ _ O
freed _ _ O
next _ _ O
to _ _ O
an _ _ O
existing _ _ O
one _ _ O
... _ _ O
• _ _ O
It _ _ O
should _ _ O
merge _ _ O
them _ _ O
! _ _ O


 _ _ O
However _ _ O
it _ _ O
subtracts _ _ O
from _ _ O
size _ _ O
( _ _ O
which _ _ O
makes _ _ O
reflect _ _ O
a _ _ O
larger _ _ O
space _ _ O
) _ _ O


 _ _ O
• _ _ O
Consider _ _ O
how _ _ O
much _ _ O
a _ _ O
doubly _ _ O
linked _ _ O
list _ _ O
helped _ _ O
. _ _ O
Q _ _ O
: _ _ O
Are _ _ O
any _ _ O
changes _ _ O
required _ _ O
here _ _ O
for _ _ O
best-fit _ _ O
? _ _ O


 _ _ O
39 _ _ O


 _ _ O
Thinking _ _ O
about _ _ O
next-fit _ _ O


 _ _ O
• _ _ O
With _ _ O
a _ _ O
typical _ _ O
first-fit _ _ O
version _ _ O
of _ _ O
the _ _ O
malloc _ _ O
function _ _ O
... _ _ O
• _ _ O
We _ _ O
can _ _ O
now _ _ O
consider _ _ O
simple _ _ O
improvements _ _ O
. _ _ O
• _ _ O
Traversing _ _ O
the _ _ O
list _ _ O
is _ _ O
expensive _ _ O
! _ _ O
O _ _ O
n _ _ O
! _ _ O


 _ _ O
• _ _ O
Next-fit _ _ O
helps _ _ O
because _ _ O
we _ _ O
start _ _ O
from _ _ O
the _ _ O
last _ _ O
allocated _ _ O
item _ _ O
. _ _ O
• _ _ O
Generally _ _ O
, _ _ O
what _ _ O
do _ _ O
you _ _ O
think _ _ O
comes _ _ O
after _ _ O
the _ _ O
last _ _ O
allocated _ _ O
item _ _ O
. _ _ O
• _ _ O
Consider _ _ O
the _ _ O
normal _ _ O
operation _ _ O
... _ _ O
• _ _ O
It _ _ O
splits _ _ O
the _ _ O
node _ _ O
and _ _ O
creates _ _ O
free _ _ O
space _ _ O
. _ _ O


 _ _ O
• _ _ O
Therefore _ _ O
, _ _ O
seems _ _ O
likely _ _ O
free _ _ O
space _ _ O
will _ _ O
exist _ _ O
near _ _ O
the _ _ O
last _ _ O
allocation _ _ O
. _ _ O
• _ _ O
Perhaps _ _ O
causing _ _ O
the _ _ O
average _ _ O
case _ _ O
for _ _ O
malloc _ _ O
to _ _ O
bias _ _ O
itself _ _ O
toward _ _ O
O _ _ O
( _ _ O
1 _ _ O
) _ _ O
• _ _ O
However _ _ O
, _ _ O
all _ _ O
strategies _ _ O
have _ _ O
their _ _ O
own _ _ O
worst-case _ _ O
! _ _ O
! _ _ O
• _ _ O
Think _ _ O
about _ _ O
what _ _ O
that _ _ O
might _ _ O
be _ _ O
. _ _ O


 _ _ O
40 _ _ O


 _ _ O
Thinking _ _ O
about _ _ O
best-fit _ _ O
• _ _ O
Best-fit _ _ O
, _ _ O
on _ _ O
the _ _ O
other _ _ O
hand _ _ O
, _ _ O
is _ _ O
not _ _ O
about _ _ O
avoiding _ _ O
traversal _ _ O
. _ _ O
• _ _ O
Instead _ _ O
, _ _ O
we _ _ O
focus _ _ O
on _ _ O
fragmentation _ _ O
. _ _ O


 _ _ O
• _ _ O
Allocating _ _ O
anywhere _ _ O
means _ _ O
worst-case _ _ O
behavior _ _ O
splits _ _ O
nodes _ _ O
poorly _ _ O
. _ _ O
• _ _ O
If _ _ O
we _ _ O
find _ _ O
a _ _ O
PERFECT _ _ O
fit _ _ O
, _ _ O
we _ _ O
remove _ _ O
fragmentation _ _ O
. _ _ O


 _ _ O
• _ _ O
Traversal _ _ O
is _ _ O
still _ _ O
bad _ _ O
... _ _ O
and _ _ O
we _ _ O
brute _ _ O
force _ _ O
the _ _ O
search _ _ O
... _ _ O
• _ _ O
But _ _ O
, _ _ O
hey _ _ O
, _ _ O
solve _ _ O
one _ _ O
problem _ _ O
, _ _ O
cause _ _ O
another _ _ O
. _ _ O
That _ _ O
's _ _ O
systems _ _ O
! _ _ O
• _ _ O
Fragmentation _ _ O
may _ _ O
indeed _ _ O
be _ _ O
a _ _ O
major _ _ O
issue _ _ O
on _ _ O
small _ _ O
memory _ _ O
systems _ _ O
. _ _ O


 _ _ O
• _ _ O
What _ _ O
is _ _ O
the _ _ O
best _ _ O
of _ _ O
both _ _ O
worlds _ _ O
? _ _ O
Next-fit _ _ O
+ _ _ O
Best-fit _ _ O
? _ _ O
• _ _ O
Hmm _ _ O
. _ _ O
• _ _ O
Works _ _ O
best _ _ O
if _ _ O
you _ _ O
keep _ _ O
large _ _ O
areas _ _ O
open _ _ O
. _ _ O
CS _ _ O
/ _ _ O
COE _ _ O
0449 _ _ O
- _ _ O
Spring _ _ O
2019 _ _ O
/ _ _ O
2020 _ _ O


 _ _ O
41 _ _ O


 _ _ O
Other _ _ O
thoughts _ _ O
• _ _ O
Do _ _ O
n't _ _ O
need _ _ O
pointers _ _ O
since _ _ O
adding _ _ O
size _ _ O
to _ _ O
the _ _ O
block _ _ O
's _ _ O
address _ _ O
will _ _ O
also _ _ O
move _ _ O
there _ _ O
. _ _ O
( _ _ O
unusually _ _ O
, _ _ O
the _ _ O
linked _ _ O
list _ _ O
is _ _ O
always _ _ O
ordered _ _ O
! _ _ O
) _ _ O
• _ _ O
You _ _ O
do _ _ O
n't _ _ O
need _ _ O
to _ _ O
keep _ _ O
the _ _ O
used _ _ O
blocks _ _ O
in _ _ O
the _ _ O
list _ _ O
. _ _ O
• _ _ O
More _ _ O
complex _ _ O
to _ _ O
understand _ _ O
but _ _ O
removes _ _ O
implementation _ _ O
complexity _ _ O
. _ _ O
• _ _ O
Free _ _ O
nodes _ _ O
point _ _ O
to _ _ O
the _ _ O
next _ _ O
and _ _ O
previous _ _ O
free _ _ O
nodes _ _ O
. _ _ O
Used _ _ O
nodes _ _ O
point _ _ O
to _ _ O
their _ _ O
neighbors _ _ O
. _ _ O
Traversal _ _ O
is _ _ O
improved _ _ O
since _ _ O
it _ _ O
only _ _ O
visits _ _ O
free _ _ O
nodes _ _ O
; _ _ O
still _ _ O
O _ _ O
( _ _ O
n _ _ O
) _ _ O


 _ _ O
• _ _ O
The _ _ O
idea _ _ O
is _ _ O
to _ _ O
only _ _ O
keep _ _ O
track _ _ O
of _ _ O
necessary _ _ O
metadata _ _ O
. _ _ O
• _ _ O
You _ _ O
only _ _ O
coalesce _ _ O
when _ _ O
free _ _ O
blocks _ _ O
are _ _ O
adjacent _ _ O
. _ _ O
• _ _ O
With _ _ O
a _ _ O
list _ _ O
of _ _ O
only _ _ O
free _ _ O
blocks _ _ O
, _ _ O
you _ _ O
can _ _ O
easily _ _ O
tell _ _ O
when _ _ O
that _ _ O
condition _ _ O
is _ _ O
met _ _ O
... _ _ O
• _ _ O
just _ _ O
see _ _ O
if _ _ O


 _ _ O
is _ _ O
the _ _ O
same _ _ O
address _ _ O
as _ _ O


 _ _ O
• _ _ O
The _ _ O
only _ _ O
other _ _ O
concern _ _ O
is _ _ O
getting _ _ O
from _ _ O
a _ _ O
used _ _ O
block _ _ O
you _ _ O
want _ _ O
to _ _ O
free _ _ O
to _ _ O
its _ _ O
neighboring _ _ O
free _ _ O
block _ _ O
. _ _ O
So _ _ O
those _ _ O
have _ _ O
normal _ _ O
pointers _ _ O
. _ _ O


 _ _ O
42 _ _ O


 _ _ O
Explicit _ _ O
free _ _ O
lists _ _ O
: _ _ O
giving _ _ O
you _ _ O
VIP _ _ O
access _ _ O
• _ _ O
When _ _ O
you _ _ O
allocate _ _ O
, _ _ O
you _ _ O
go _ _ O
through _ _ O
the _ _ O
free _ _ O
list _ _ O
. _ _ O
• _ _ O
You _ _ O
do _ _ O
n't _ _ O
care _ _ O
about _ _ O
allocated _ _ O
nodes _ _ O
. _ _ O


 _ _ O
• _ _ O
When _ _ O
you _ _ O
free _ _ O
, _ _ O
you _ _ O
only _ _ O
care _ _ O
about _ _ O
coalescing _ _ O
neighbors _ _ O
. _ _ O


 _ _ O
available _ _ O
memory _ _ O


 _ _ O
Q _ _ O
: _ _ O
Do _ _ O
free _ _ O
nodes _ _ O
need _ _ O
a _ _ O


 _ _ O
pointer _ _ O
? _ _ O


 _ _ O
43 _ _ O


 _ _ O
Trees _ _ O
are _ _ O
your _ _ O
buddy _ _ O


 _ _ O
• _ _ O
Recall _ _ O
that _ _ O
we _ _ O
easily _ _ O
took _ _ O
the _ _ O
ideas _ _ O
around _ _ O
linked _ _ O
lists _ _ O
and _ _ O
made _ _ O
binary _ _ O
trees _ _ O
. _ _ O
• _ _ O
You _ _ O
can _ _ O
manage _ _ O
memory _ _ O
with _ _ O
a _ _ O
binary _ _ O
tree _ _ O
as _ _ O
well _ _ O
. _ _ O


 _ _ O
• _ _ O
This _ _ O
is _ _ O
called _ _ O
a _ _ O
buddy _ _ O
allocator _ _ O
. _ _ O


 _ _ O
45 _ _ O


 _ _ O
Divide _ _ O
and _ _ O
conquer _ _ O
• _ _ O
Buddy _ _ O
allocators _ _ O
divide _ _ O
memory _ _ O
into _ _ O
halves _ _ O
that _ _ O
are _ _ O
powers _ _ O
of _ _ O
two _ _ O
. _ _ O
• _ _ O
Can _ _ O
cause _ _ O
internal _ _ O
fragmentation _ _ O


 _ _ O
▪ _ _ O
The _ _ O
total _ _ O
memory _ _ O
, _ _ O
, _ _ O
is _ _ O
a _ _ O
power _ _ O
of _ _ O
two _ _ O
. _ _ O
▪ _ _ O
Each _ _ O
split _ _ O
is _ _ O
, _ _ O
then _ _ O
, _ _ O
also _ _ O
a _ _ O
power _ _ O
of _ _ O
two _ _ O
. _ _ O


 _ _ O
Allocation _ _ O
is _ _ O
not _ _ O
a _ _ O
power _ _ O
of _ _ O
two _ _ O
: _ _ O
internal _ _ O
fragmentation _ _ O


 _ _ O
46 _ _ O


 _ _ O
Allocating _ _ O
with _ _ O
trees _ _ O
• _ _ O
Assuming _ _ O


 _ _ O
is _ _ O


 _ _ O
, _ _ O
and _ _ O
we _ _ O
allocate _ _ O
242MiB _ _ O
: _ _ O


 _ _ O
• _ _ O
We _ _ O
travel _ _ O
left _ _ O
until _ _ O
we _ _ O
find _ _ O
a _ _ O
block _ _ O
that _ _ O
fits _ _ O
. _ _ O


 _ _ O
▪ _ _ O
We _ _ O
travel _ _ O
back _ _ O
up _ _ O
when _ _ O
we _ _ O
ca _ _ O
n't _ _ O
go _ _ O
further _ _ O
left _ _ O
and _ _ O
go _ _ O
right _ _ O
. _ _ O
▪ _ _ O
When _ _ O
we _ _ O
find _ _ O
a _ _ O
unsplit _ _ O
node _ _ O
that _ _ O
fits _ _ O
, _ _ O
we _ _ O
allocate _ _ O
there _ _ O
. _ _ O


 _ _ O
47 _ _ O


 _ _ O
Burying _ _ O
the _ _ O
hatchet _ _ O
: _ _ O
Chopping _ _ O
the _ _ O
trees _ _ O
• _ _ O
Let _ _ O
's _ _ O
allocate _ _ O
64MiB. _ _ O
So _ _ O
nice _ _ O
, _ _ O
we _ _ O
will _ _ O
allocate _ _ O
it _ _ O
twice _ _ O
. _ _ O
• _ _ O
Again _ _ O
a _ _ O
depth-first _ _ O
search _ _ O
to _ _ O
find _ _ O
the _ _ O
first _ _ O
unsplit _ _ O
node _ _ O
that _ _ O
fits _ _ O
us _ _ O
. _ _ O


 _ _ O
▪ _ _ O
This _ _ O
node _ _ O
is _ _ O
fine _ _ O
! _ _ O
Allocate _ _ O
that _ _ O
! _ _ O
▪ _ _ O
Do _ _ O
it _ _ O
again _ _ O
! _ _ O
▪ _ _ O
When _ _ O
we _ _ O
find _ _ O
a _ _ O
unsplit _ _ O
node _ _ O
that _ _ O
is _ _ O
too _ _ O
big _ _ O
, _ _ O
we _ _ O
split _ _ O
in _ _ O
half _ _ O
and _ _ O
keep _ _ O
going _ _ O
. _ _ O


 _ _ O
CS _ _ O
/ _ _ O
COE _ _ O
0449 _ _ O
- _ _ O
Spring _ _ O
2019 _ _ O
/ _ _ O
2020 _ _ O


 _ _ O
48 _ _ O


 _ _ O
Coalescing _ _ O
friendships _ _ O
( _ _ O
animated _ _ O
) _ _ O
• _ _ O
Coalescing _ _ O
happens _ _ O
because _ _ O
every _ _ O
block _ _ O
has _ _ O
a _ _ O
buddy _ _ O
! _ _ O
• _ _ O
When _ _ O
both _ _ O
sides _ _ O
of _ _ O
a _ _ O
split _ _ O
node _ _ O
are _ _ O
free _ _ O
, _ _ O
coalesce _ _ O
them _ _ O
! _ _ O


 _ _ O
▪ _ _ O
If _ _ O
this _ _ O
keeps _ _ O
happening _ _ O
, _ _ O
it _ _ O
will _ _ O
coalesce _ _ O
larger _ _ O
spaces _ _ O
. _ _ O
▪ _ _ O
Repeating _ _ O
as _ _ O
much _ _ O
as _ _ O
necessary _ _ O
. _ _ O


 _ _ O
x _ _ O


 _ _ O
x _ _ O


 _ _ O
x _ _ O
49 _ _ O


 _ _ O
Thinking _ _ O
like _ _ O
an _ _ O
arborist _ _ O
( _ _ O
but _ _ O
only _ _ O
if _ _ O
you _ _ O
are _ _ O
feeling _ _ O
listless _ _ O
) _ _ O
• _ _ O
How _ _ O
does _ _ O
a _ _ O
tree-based _ _ O
allocation _ _ O
system _ _ O
deal _ _ O
with _ _ O
fragmentation _ _ O
? _ _ O
• _ _ O
What _ _ O
are _ _ O
some _ _ O
immediate _ _ O
drawbacks _ _ O
from _ _ O
using _ _ O
a _ _ O
tree _ _ O
scheme _ _ O
? _ _ O


 _ _ O
available _ _ O
memory _ _ O


 _ _ O
• _ _ O
Can _ _ O
you _ _ O
imagine _ _ O
a _ _ O
possibility _ _ O
of _ _ O
using _ _ O
a _ _ O
hybrid _ _ O
approach _ _ O
? _ _ O
50 _ _ O


 _ _ O
Lies _ _ O
and _ _ O
Damned _ _ O
Lies _ _ O
! _ _ O
• _ _ O
Does _ _ O
your _ _ O
program _ _ O
actually _ _ O
own _ _ O
all _ _ O
of _ _ O
memory _ _ O
? _ _ O
• _ _ O
On _ _ O
modern _ _ O
systems _ _ O
, _ _ O
absolutely _ _ O
heckin _ _ O
not _ _ O
. _ _ O


 _ _ O
• _ _ O
Your _ _ O
program _ _ O
still _ _ O
has _ _ O
to _ _ O
request _ _ O
memory _ _ O
allocations _ _ O
from _ _ O
the _ _ O
OS _ _ O
. _ _ O
• _ _ O
Generally _ _ O
, _ _ O
takes _ _ O
on _ _ O
this _ _ O
responsibility _ _ O
behind _ _ O
the _ _ O
scenes _ _ O
. _ _ O
• _ _ O
In _ _ O
Linux _ _ O
, _ _ O
you _ _ O
request _ _ O
pages _ _ O
in _ _ O
the _ _ O
normal _ _ O
heap _ _ O
in _ _ O
LIFO _ _ O
order _ _ O
with _ _ O
• _ _ O
Or _ _ O
, _ _ O
you _ _ O
request _ _ O
specific _ _ O
virtual _ _ O
memory _ _ O
pages _ _ O
with _ _ O
. _ _ O


 _ _ O
. _ _ O


 _ _ O
• _ _ O
What _ _ O
is _ _ O
a _ _ O
segmentation _ _ O
fault _ _ O
. _ _ O
• _ _ O
Segments _ _ O
are _ _ O
the _ _ O
" _ _ O
code _ _ O
" _ _ O
, _ _ O
" _ _ O
data _ _ O
" _ _ O
, _ _ O
" _ _ O
heap _ _ O
" _ _ O
separation _ _ O
. _ _ O
You _ _ O
fault _ _ O
by _ _ O
doing _ _ O
something _ _ O
the _ _ O
segment _ _ O
does _ _ O
not _ _ O
allow _ _ O
. _ _ O
( _ _ O
write _ _ O
to _ _ O
read-only _ _ O
memory _ _ O
) _ _ O
• _ _ O
A _ _ O
historic _ _ O
misnomer _ _ O
since _ _ O
we _ _ O
actually _ _ O
have _ _ O
paging _ _ O
, _ _ O
not _ _ O
segmented _ _ O
memory _ _ O
. _ _ O


 _ _ O
• _ _ O
What _ _ O
is _ _ O
a _ _ O
" _ _ O
page _ _ O
" _ _ O
? _ _ O
Virtual _ _ O
memory _ _ O
? _ _ O
? _ _ O
• _ _ O
It _ _ O
replaced _ _ O
segments _ _ O
and _ _ O
is _ _ O
part _ _ O
of _ _ O
the _ _ O
much _ _ O
grander _ _ O
lie _ _ O
about _ _ O
sharing _ _ O
memory _ _ O
with _ _ O
multiple _ _ O
applications _ _ O
at _ _ O
the _ _ O
same _ _ O
time _ _ O
. _ _ O
More _ _ O
on _ _ O
this _ _ O
later _ _ O
! _ _ O


 _ _ O
51 _ _ O


 _ _ O
I _ _ O
want _ _ O
to _ _ O
know _ _ O
MORE _ _ O
• _ _ O
If _ _ O
you _ _ O
find _ _ O
this _ _ O
topic _ _ O
interesting _ _ O
, _ _ O
it _ _ O
is _ _ O
a _ _ O
WIDE _ _ O
area _ _ O
of _ _ O
research _ _ O
. _ _ O
• _ _ O
Malloc _ _ O
is _ _ O
generally _ _ O
more _ _ O
complex _ _ O
or _ _ O
specialized _ _ O
these _ _ O
days _ _ O
than _ _ O
the _ _ O
options _ _ O
here _ _ O
. _ _ O
• _ _ O
Or _ _ O
some _ _ O
kind _ _ O
of _ _ O
hybrid _ _ O
, _ _ O
as _ _ O
the _ _ O
need _ _ O
arises _ _ O
. _ _ O


 _ _ O
• _ _ O
The _ _ O
Linux _ _ O
kernel _ _ O
makes _ _ O
use _ _ O
of _ _ O
a _ _ O
Slab _ _ O
Allocator _ _ O
• _ _ O
https _ _ O
: _ _ O
/ _ _ O
/ _ _ O
en.wikipedia.org _ _ O
/ _ _ O
wiki _ _ O
/ _ _ O
Slab_allocation _ _ O


 _ _ O
• _ _ O
Modern _ _ O
C _ _ O
( _ _ O
glibc _ _ O
) _ _ O
uses _ _ O
a _ _ O
hybrid _ _ O
malloc _ _ O
: _ _ O
• _ _ O
https _ _ O
: _ _ O
/ _ _ O
/ _ _ O
www.gnu.org _ _ O
/ _ _ O
software _ _ O
/ _ _ O
libc _ _ O
/ _ _ O
manual _ _ O
/ _ _ O
html_node _ _ O
/ _ _ O
The-GNU-Allocator.html _ _ O


 _ _ O
• _ _ O
Professor _ _ O
Knuth _ _ O
has _ _ O
written _ _ O
about _ _ O
several _ _ O
classic _ _ O
algorithms _ _ O
. _ _ O
• _ _ O
Buddy _ _ O
Allocation _ _ O
comes _ _ O
from _ _ O
the _ _ O
60s _ _ O
. _ _ O
Groovy _ _ O
. _ _ O
52 _ _ O


 _ _ O


