unlabeled|cs1550|lec20
-DOCSTART- -X- -X- O

Introduction _ _ O
to _ _ O
Operating _ _ O
Systems _ _ O
CS _ _ O
1550 _ _ O
Spring _ _ O
2022 _ _ O


 _ _ O
Sherif _ _ O
Khattab _ _ O
ksm73@pitt.edu _ _ O
( _ _ O
Some _ _ O
slides _ _ O
are _ _ O
from _ _ O
Silberschatz _ _ O
, _ _ O
Galvin _ _ O
and _ _ O
Gagne _ _ O
© _ _ O
2013 _ _ O
) _ _ O

Announcements _ _ O
• _ _ O
Upcoming _ _ O
deadlines _ _ O
: _ _ O
• _ _ O
Lab _ _ O
3 _ _ O
: _ _ O
due _ _ O
on _ _ O
4 _ _ O
/ _ _ O
1 _ _ O
• _ _ O
Homework _ _ O
9 _ _ O
: _ _ O
due _ _ O
on _ _ O
4 _ _ O
/ _ _ O
4 _ _ O
• _ _ O
Project _ _ O
3 _ _ O
: _ _ O
due _ _ O
on _ _ O
4 _ _ O
/ _ _ O
11 _ _ O


 _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O


 _ _ O
2 _ _ O

Previous _ _ O
lecture _ _ O
… _ _ O
• _ _ O
Large _ _ O
Page _ _ O
Table _ _ O
problem _ _ O
• _ _ O
multi-level _ _ O
page _ _ O
tables _ _ O
• _ _ O
inverted _ _ O
page _ _ O
tables _ _ O


 _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O


 _ _ O
3 _ _ O

Muddiest _ _ O
Points _ _ O
• _ _ O
EAT _ _ O
• _ _ O
Inverted _ _ O
page _ _ O
tables _ _ O
• _ _ O
Would _ _ O
you _ _ O
please _ _ O
solve _ _ O
a _ _ O
problem _ _ O
about _ _ O
Inertial _ _ O
Page _ _ O
Table _ _ O
? _ _ O
Thank _ _ O
you _ _ O
so _ _ O
much _ _ O
• _ _ O
why _ _ O
again _ _ O
will _ _ O
there _ _ O
be _ _ O
multiple _ _ O
memory _ _ O
accesses _ _ O
using _ _ O
a _ _ O
TLB _ _ O
? _ _ O
• _ _ O
Two _ _ O
level _ _ O
page _ _ O
tables _ _ O
and _ _ O
how _ _ O
they _ _ O
are _ _ O
better _ _ O
than _ _ O
single _ _ O
page _ _ O
tables _ _ O
( _ _ O
take _ _ O
up _ _ O
less _ _ O
space _ _ O
) _ _ O
• _ _ O
Where _ _ O
are _ _ O
the _ _ O
second _ _ O
and _ _ O
third _ _ O
level _ _ O
page _ _ O
tables _ _ O
stored _ _ O
? _ _ O
Are _ _ O
they _ _ O
paged _ _ O
in _ _ O
and _ _ O
out _ _ O
of _ _ O
memory _ _ O
like _ _ O
a _ _ O
normal _ _ O
page _ _ O
? _ _ O
• _ _ O
when _ _ O
will _ _ O
we _ _ O
get _ _ O
our _ _ O
midterm _ _ O
grades _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O


 _ _ O
4 _ _ O

How _ _ O
big _ _ O
should _ _ O
a _ _ O
page _ _ O
be _ _ O
? _ _ O
◼ _ _ O


 _ _ O
Smaller _ _ O
pages _ _ O
have _ _ O
advantages _ _ O
Less _ _ O
internal _ _ O
fragmentation _ _ O
◼ _ _ O
Better _ _ O
fit _ _ O
for _ _ O
various _ _ O
data _ _ O
structures _ _ O
, _ _ O
code _ _ O
sections _ _ O
◼ _ _ O
Less _ _ O
unused _ _ O
physical _ _ O
memory _ _ O
( _ _ O
some _ _ O
pages _ _ O
have _ _ O
20 _ _ O
useful _ _ O
bytes _ _ O
and _ _ O
the _ _ O
rest _ _ O
is _ _ O
n’t _ _ O
needed _ _ O
currently _ _ O
) _ _ O
◼ _ _ O


 _ _ O
◼ _ _ O


 _ _ O
Larger _ _ O
pages _ _ O
are _ _ O
better _ _ O
because _ _ O
◼ _ _ O


 _ _ O
Less _ _ O
overhead _ _ O
to _ _ O
keep _ _ O
track _ _ O
of _ _ O
them _ _ O
Smaller _ _ O
page _ _ O
tables _ _ O
◼ _ _ O
TLB _ _ O
can _ _ O
point _ _ O
to _ _ O
more _ _ O
memory _ _ O
( _ _ O
same _ _ O
number _ _ O
of _ _ O
pages _ _ O
, _ _ O
but _ _ O
more _ _ O
memory _ _ O
per _ _ O
page _ _ O
) _ _ O
◼ _ _ O
Faster _ _ O
paging _ _ O
algorithms _ _ O
( _ _ O
fewer _ _ O
table _ _ O
entries _ _ O
to _ _ O
look _ _ O
through _ _ O
) _ _ O
◼ _ _ O


 _ _ O
◼ _ _ O


 _ _ O
More _ _ O
efficient _ _ O
to _ _ O
transfer _ _ O
larger _ _ O
pages _ _ O
to _ _ O
and _ _ O
from _ _ O
disk _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O


 _ _ O
5 _ _ O

Sharing _ _ O
Pages _ _ O


 _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O


 _ _ O
6 _ _ O

Sharing _ _ O
pages _ _ O
◼ _ _ O


 _ _ O
Processes _ _ O
can _ _ O
share _ _ O
pages _ _ O
Entries _ _ O
in _ _ O
page _ _ O
tables _ _ O
point _ _ O
to _ _ O
the _ _ O
same _ _ O
physical _ _ O
page _ _ O
frame _ _ O
◼ _ _ O
Easier _ _ O
to _ _ O
do _ _ O
with _ _ O
code _ _ O
: _ _ O
no _ _ O
problems _ _ O
with _ _ O
modification _ _ O
◼ _ _ O


 _ _ O
◼ _ _ O


 _ _ O
Virtual _ _ O
addresses _ _ O
in _ _ O
different _ _ O
processes _ _ O
can _ _ O
be _ _ O
… _ _ O
The _ _ O
same _ _ O
: _ _ O
easier _ _ O
to _ _ O
exchange _ _ O
pointers _ _ O
, _ _ O
keep _ _ O
data _ _ O
structures _ _ O
consistent _ _ O
◼ _ _ O
Different _ _ O
: _ _ O
may _ _ O
be _ _ O
easier _ _ O
to _ _ O
actually _ _ O
implement _ _ O
◼ _ _ O


 _ _ O
Not _ _ O
a _ _ O
problem _ _ O
if _ _ O
there _ _ O
are _ _ O
only _ _ O
a _ _ O
few _ _ O
shared _ _ O
regions _ _ O
◼ _ _ O
Can _ _ O
be _ _ O
very _ _ O
difficult _ _ O
if _ _ O
many _ _ O
processes _ _ O
share _ _ O
regions _ _ O
with _ _ O
each _ _ O
other _ _ O
◼ _ _ O


 _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O


 _ _ O
7 _ _ O

Page _ _ O
Sharing _ _ O


 _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O


 _ _ O
8 _ _ O

Implementation _ _ O
issues _ _ O
Four _ _ O
times _ _ O
when _ _ O
OS _ _ O
involved _ _ O
with _ _ O
paging _ _ O
◼ _ _ O
Process _ _ O
creation _ _ O
Determine _ _ O
program _ _ O
size _ _ O
◼ _ _ O
Create _ _ O
page _ _ O
table _ _ O
◼ _ _ O


 _ _ O
◼ _ _ O


 _ _ O
During _ _ O
process _ _ O
execution _ _ O
Reset _ _ O
the _ _ O
MMU _ _ O
for _ _ O
new _ _ O
process _ _ O
◼ _ _ O
Flush _ _ O
the _ _ O
TLB _ _ O
( _ _ O
or _ _ O
reload _ _ O
it _ _ O
from _ _ O
saved _ _ O
state _ _ O
) _ _ O
◼ _ _ O


 _ _ O
◼ _ _ O


 _ _ O
Page _ _ O
fault _ _ O
time _ _ O
Determine _ _ O
virtual _ _ O
address _ _ O
causing _ _ O
fault _ _ O
◼ _ _ O
Swap _ _ O
target _ _ O
page _ _ O
out _ _ O
, _ _ O
needed _ _ O
page _ _ O
in _ _ O
◼ _ _ O


 _ _ O
◼ _ _ O


 _ _ O
Process _ _ O
termination _ _ O
time _ _ O
Release _ _ O
page _ _ O
table _ _ O
◼ _ _ O
Return _ _ O
pages _ _ O
to _ _ O
the _ _ O
free _ _ O
pool _ _ O
◼ _ _ O


 _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O


 _ _ O
9 _ _ O

How _ _ O
is _ _ O
a _ _ O
page _ _ O
fault _ _ O
handled _ _ O
? _ _ O
Hardware _ _ O
causes _ _ O
a _ _ O
page _ _ O
fault _ _ O
◼ _ _ O
General _ _ O
registers _ _ O
saved _ _ O
( _ _ O
as _ _ O
on _ _ O
every _ _ O
exception _ _ O
) _ _ O
◼ _ _ O
OS _ _ O
determines _ _ O
which _ _ O
virtual _ _ O
page _ _ O
needed _ _ O
◼ _ _ O


 _ _ O
Actual _ _ O
fault _ _ O
address _ _ O
in _ _ O
a _ _ O
special _ _ O
register _ _ O
◼ _ _ O
Address _ _ O
of _ _ O
faulting _ _ O
instruction _ _ O
in _ _ O
register _ _ O


 _ _ O
◼ _ _ O


 _ _ O
◼ _ _ O


 _ _ O
◼ _ _ O


 _ _ O
◼ _ _ O


 _ _ O
◼ _ _ O


 _ _ O
Page _ _ O
fault _ _ O
was _ _ O
in _ _ O
fetching _ _ O
instruction _ _ O
, _ _ O
or _ _ O
◼ _ _ O
Page _ _ O
fault _ _ O
was _ _ O
in _ _ O
fetching _ _ O
operands _ _ O
for _ _ O
instruction _ _ O
◼ _ _ O
OS _ _ O
must _ _ O
figure _ _ O
out _ _ O
which _ _ O
… _ _ O
◼ _ _ O


 _ _ O
OS _ _ O
checks _ _ O
validity _ _ O
of _ _ O
address _ _ O


 _ _ O
◼ _ _ O


 _ _ O
◼ _ _ O
◼ _ _ O


 _ _ O
◼ _ _ O
◼ _ _ O


 _ _ O
◼ _ _ O


 _ _ O
Process _ _ O
killed _ _ O
if _ _ O
address _ _ O
was _ _ O
illegal _ _ O


 _ _ O
OS _ _ O
finds _ _ O
a _ _ O
place _ _ O
to _ _ O
put _ _ O
new _ _ O
page _ _ O
frame _ _ O
If _ _ O
frame _ _ O
selected _ _ O
for _ _ O
replacement _ _ O
is _ _ O
dirty _ _ O
, _ _ O
write _ _ O
it _ _ O
out _ _ O
to _ _ O
disk _ _ O
OS _ _ O
requests _ _ O
the _ _ O
new _ _ O
page _ _ O
from _ _ O
disk _ _ O
Page _ _ O
tables _ _ O
updated _ _ O
Faulting _ _ O
instruction _ _ O
backed _ _ O
up _ _ O
so _ _ O
it _ _ O
can _ _ O
be _ _ O
restarted _ _ O
Faulting _ _ O
process _ _ O
scheduled _ _ O
Registers _ _ O
restored _ _ O
Program _ _ O
continues _ _ O


 _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O


 _ _ O
10 _ _ O

Page _ _ O
locking _ _ O


 _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O


 _ _ O
11 _ _ O

Locking _ _ O
pages _ _ O
in _ _ O
memory _ _ O
Virtual _ _ O
memory _ _ O
and _ _ O
I _ _ O
/ _ _ O
O _ _ O
occasionally _ _ O
interact _ _ O
◼ _ _ O
P1 _ _ O
issues _ _ O
call _ _ O
for _ _ O
read _ _ O
from _ _ O
device _ _ O
into _ _ O
buffer _ _ O
◼ _ _ O


 _ _ O
While _ _ O
it _ _ O
’s _ _ O
waiting _ _ O
for _ _ O
I _ _ O
/ _ _ O
O _ _ O
, _ _ O
P2 _ _ O
runs _ _ O
◼ _ _ O
P2 _ _ O
has _ _ O
a _ _ O
page _ _ O
fault _ _ O
◼ _ _ O
P1 _ _ O
’s _ _ O
I _ _ O
/ _ _ O
O _ _ O
buffer _ _ O
might _ _ O
be _ _ O
chosen _ _ O
to _ _ O
be _ _ O
paged _ _ O
out _ _ O
◼ _ _ O


 _ _ O
◼ _ _ O


 _ _ O
◼ _ _ O


 _ _ O
This _ _ O
can _ _ O
create _ _ O
a _ _ O
problem _ _ O
because _ _ O
an _ _ O
I _ _ O
/ _ _ O
O _ _ O
device _ _ O
is _ _ O
going _ _ O
to _ _ O
write _ _ O
to _ _ O
the _ _ O
buffer _ _ O
on _ _ O
P1 _ _ O
’s _ _ O
behalf _ _ O


 _ _ O
Solution _ _ O
: _ _ O
allow _ _ O
some _ _ O
pages _ _ O
to _ _ O
be _ _ O
locked _ _ O
into _ _ O
memory _ _ O
Locked _ _ O
pages _ _ O
are _ _ O
immune _ _ O
from _ _ O
being _ _ O
replaced _ _ O
◼ _ _ O
Pages _ _ O
only _ _ O
stay _ _ O
locked _ _ O
for _ _ O
( _ _ O
relatively _ _ O
) _ _ O
short _ _ O
periods _ _ O
◼ _ _ O


 _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O


 _ _ O
12 _ _ O

Map _ _ O
of _ _ O
MMU _ _ O
, _ _ O
TLB _ _ O
, _ _ O
Page _ _ O
Table _ _ O
, _ _ O
etc _ _ O
. _ _ O


 _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O


 _ _ O
13 _ _ O

When _ _ O
are _ _ O
dirty _ _ O
pages _ _ O
written _ _ O
to _ _ O
disk _ _ O
? _ _ O
◼ _ _ O


 _ _ O
On _ _ O
demand _ _ O
( _ _ O
when _ _ O
they _ _ O
’re _ _ O
replaced _ _ O
) _ _ O
Fewest _ _ O
writes _ _ O
to _ _ O
disk _ _ O
◼ _ _ O
Slower _ _ O
: _ _ O
replacement _ _ O
takes _ _ O
twice _ _ O
as _ _ O
long _ _ O
( _ _ O
must _ _ O
wait _ _ O
for _ _ O
disk _ _ O
write _ _ O
and _ _ O
disk _ _ O
read _ _ O
) _ _ O
◼ _ _ O


 _ _ O
◼ _ _ O


 _ _ O
Periodically _ _ O
( _ _ O
in _ _ O
the _ _ O
background _ _ O
) _ _ O
◼ _ _ O


 _ _ O
◼ _ _ O


 _ _ O
Background _ _ O
process _ _ O
scans _ _ O
through _ _ O
page _ _ O
tables _ _ O
, _ _ O
writes _ _ O
out _ _ O
dirty _ _ O
pages _ _ O
that _ _ O
are _ _ O
pretty _ _ O
old _ _ O


 _ _ O
Background _ _ O
process _ _ O
also _ _ O
keeps _ _ O
a _ _ O
list _ _ O
of _ _ O
pages _ _ O
ready _ _ O
for _ _ O
replacement _ _ O
Page _ _ O
faults _ _ O
handled _ _ O
faster _ _ O
: _ _ O
no _ _ O
need _ _ O
to _ _ O
find _ _ O
space _ _ O
on _ _ O
demand _ _ O
◼ _ _ O
Cleaner _ _ O
may _ _ O
use _ _ O
the _ _ O
same _ _ O
structures _ _ O
discussed _ _ O
earlier _ _ O
( _ _ O
clock _ _ O
, _ _ O
etc _ _ O
. _ _ O
) _ _ O
◼ _ _ O


 _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O


 _ _ O
14 _ _ O

Problem _ _ O
of _ _ O
the _ _ O
Day _ _ O


 _ _ O
How _ _ O
to _ _ O
allocate _ _ O
disk _ _ O
blocks _ _ O
to _ _ O
files _ _ O
and _ _ O
directories _ _ O
? _ _ O


 _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O


 _ _ O
15 _ _ O

How _ _ O
complex _ _ O
is _ _ O
the _ _ O
OS _ _ O
’s _ _ O
job _ _ O
? _ _ O
Let _ _ O
’s _ _ O
look _ _ O
at _ _ O
one _ _ O
of _ _ O
the _ _ O
resources _ _ O
managed _ _ O
by _ _ O
the _ _ O
OS _ _ O
: _ _ O
I _ _ O
/ _ _ O
O _ _ O
devices _ _ O


 _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O


 _ _ O
16 _ _ O

Carving _ _ O
up _ _ O
the _ _ O
disk _ _ O
Entire _ _ O
disk _ _ O
Partition _ _ O
table _ _ O
Master _ _ O
boot _ _ O
record _ _ O


 _ _ O
Partition _ _ O
1 _ _ O


 _ _ O
Partition _ _ O
2 _ _ O


 _ _ O
Partition _ _ O
3 _ _ O


 _ _ O
Boot _ _ O
block _ _ O


 _ _ O
Free _ _ O
space _ _ O
management _ _ O


 _ _ O
Index _ _ O
nodes _ _ O


 _ _ O
Files _ _ O
& _ _ O
directories _ _ O


 _ _ O
Super _ _ O
block _ _ O


 _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O


 _ _ O
Partition _ _ O
4 _ _ O


 _ _ O
17 _ _ O

Contiguous _ _ O
allocation _ _ O
for _ _ O
file _ _ O
blocks _ _ O
• _ _ O
Contiguous _ _ O
allocation _ _ O
requires _ _ O
all _ _ O
blocks _ _ O
of _ _ O
a _ _ O
file _ _ O
to _ _ O
be _ _ O
consecutive _ _ O
on _ _ O
disk _ _ O
• _ _ O
Problem _ _ O
: _ _ O
deleting _ _ O
files _ _ O
leaves _ _ O
“ _ _ O
holes _ _ O
” _ _ O
• _ _ O
Similar _ _ O
to _ _ O
memory _ _ O
allocation _ _ O
issues _ _ O
• _ _ O
Compacting _ _ O
the _ _ O
disk _ _ O
can _ _ O
be _ _ O
a _ _ O
very _ _ O
slow _ _ O
procedure _ _ O
… _ _ O
A _ _ O


 _ _ O
B _ _ O


 _ _ O
C _ _ O


 _ _ O
D _ _ O


 _ _ O
E _ _ O


 _ _ O
F _ _ O


 _ _ O
A _ _ O


 _ _ O
Free _ _ O


 _ _ O
C _ _ O


 _ _ O
Free _ _ O


 _ _ O
E _ _ O


 _ _ O
F _ _ O


 _ _ O
CS _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O


 _ _ O
18 _ _ O

Contiguous _ _ O
allocation _ _ O
• _ _ O
Data _ _ O
in _ _ O
each _ _ O
file _ _ O
is _ _ O
stored _ _ O
in _ _ O
consecutive _ _ O
blocks _ _ O
on _ _ O
disk _ _ O
• _ _ O
Simple _ _ O
& _ _ O
efficient _ _ O
indexing _ _ O
• _ _ O
• _ _ O


 _ _ O
Starting _ _ O
location _ _ O
( _ _ O
block _ _ O
# _ _ O
) _ _ O
on _ _ O
disk _ _ O
( _ _ O
start _ _ O
) _ _ O
Length _ _ O
of _ _ O
the _ _ O
file _ _ O
in _ _ O
blocks _ _ O
( _ _ O
length _ _ O
) _ _ O


 _ _ O
0 _ _ O


 _ _ O
1 _ _ O


 _ _ O
2 _ _ O


 _ _ O
3 _ _ O


 _ _ O
4 _ _ O


 _ _ O
5 _ _ O


 _ _ O
6 _ _ O


 _ _ O
7 _ _ O


 _ _ O
8 _ _ O


 _ _ O
9 _ _ O


 _ _ O
10 _ _ O


 _ _ O
11 _ _ O


 _ _ O
• _ _ O
Random _ _ O
access _ _ O
well-supported _ _ O
• _ _ O
Difficult _ _ O
to _ _ O
grow _ _ O
files _ _ O
• _ _ O


 _ _ O
Must _ _ O
pre-allocate _ _ O
all _ _ O
needed _ _ O
space _ _ O


 _ _ O
• _ _ O


 _ _ O
Wasteful _ _ O
of _ _ O
storage _ _ O
if _ _ O
file _ _ O
is _ _ O
n’t _ _ O
using _ _ O
all _ _ O
of _ _ O
the _ _ O
space _ _ O


 _ _ O
• _ _ O
Logical _ _ O
to _ _ O
physical _ _ O
mapping _ _ O
is _ _ O
easy _ _ O
blocknum _ _ O
= _ _ O
( _ _ O
pos _ _ O
/ _ _ O
1024 _ _ O
) _ _ O
+ _ _ O
start _ _ O
; _ _ O
offset_in_block _ _ O
= _ _ O
pos _ _ O
% _ _ O
1024 _ _ O
; _ _ O


 _ _ O
Start=5 _ _ O
Length=2902 _ _ O


 _ _ O
CS _ _ O
/ _ _ O
COE _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O


 _ _ O
19 _ _ O

Linked _ _ O
allocation _ _ O
• _ _ O
File _ _ O
is _ _ O
a _ _ O
linked _ _ O
list _ _ O
of _ _ O
disk _ _ O
blocks _ _ O


 _ _ O
0 _ _ O


 _ _ O
• _ _ O


 _ _ O
Blocks _ _ O
may _ _ O
be _ _ O
scattered _ _ O
around _ _ O
the _ _ O
disk _ _ O
drive _ _ O


 _ _ O
4 _ _ O


 _ _ O
• _ _ O


 _ _ O
Block _ _ O
contains _ _ O
both _ _ O
pointer _ _ O
to _ _ O
next _ _ O
block _ _ O
and _ _ O
data _ _ O


 _ _ O
4 _ _ O


 _ _ O
• _ _ O


 _ _ O
Files _ _ O
may _ _ O
be _ _ O
as _ _ O
long _ _ O
as _ _ O
needed _ _ O


 _ _ O
• _ _ O
New _ _ O
blocks _ _ O
are _ _ O
allocated _ _ O
as _ _ O
needed _ _ O
• _ _ O
• _ _ O


 _ _ O
Linked _ _ O
into _ _ O
list _ _ O
of _ _ O
blocks _ _ O
in _ _ O
file _ _ O
Removed _ _ O
from _ _ O
list _ _ O
( _ _ O
bitmap _ _ O
) _ _ O
of _ _ O
free _ _ O
blocks _ _ O


 _ _ O
1 _ _ O


 _ _ O
3 _ _ O
6 _ _ O


 _ _ O
5 _ _ O


 _ _ O
x _ _ O


 _ _ O
8 _ _ O


 _ _ O
2 _ _ O


 _ _ O
6 _ _ O


 _ _ O
7 _ _ O


 _ _ O
x _ _ O


 _ _ O
9 _ _ O


 _ _ O
10 _ _ O


 _ _ O
11 _ _ O


 _ _ O
0 _ _ O


 _ _ O
Start=9 _ _ O
End=4 _ _ O
Length=2902 _ _ O


 _ _ O
CS _ _ O
/ _ _ O
COE _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O


 _ _ O
Start=3 _ _ O
End=6 _ _ O
Length=1500 _ _ O
20 _ _ O

Data _ _ O
Structures _ _ O
for _ _ O
Linked _ _ O
Allocation _ _ O


 _ _ O
CS _ _ O
/ _ _ O
COE _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O


 _ _ O
21 _ _ O

Finding _ _ O
blocks _ _ O
with _ _ O
linked _ _ O
allocation _ _ O
• _ _ O
Directory _ _ O
structure _ _ O
is _ _ O
simple _ _ O
• _ _ O
• _ _ O


 _ _ O
Starting _ _ O
address _ _ O
looked _ _ O
up _ _ O
from _ _ O
directory _ _ O
Directory _ _ O
only _ _ O
keeps _ _ O
track _ _ O
of _ _ O
first _ _ O
block _ _ O
( _ _ O
not _ _ O
others _ _ O
) _ _ O


 _ _ O
• _ _ O
No _ _ O
wasted _ _ O
blocks _ _ O
- _ _ O
all _ _ O
blocks _ _ O
can _ _ O
be _ _ O
used _ _ O
• _ _ O
Random _ _ O
access _ _ O
is _ _ O
difficult _ _ O
: _ _ O
must _ _ O
always _ _ O
start _ _ O
at _ _ O
first _ _ O
block _ _ O
! _ _ O
• _ _ O
Logical _ _ O
to _ _ O
physical _ _ O
mapping _ _ O
is _ _ O
done _ _ O
by _ _ O
block _ _ O
= _ _ O
start _ _ O
; _ _ O
offset_in_block _ _ O
= _ _ O
pos _ _ O
% _ _ O
1020 _ _ O
; _ _ O
for _ _ O
( _ _ O
j _ _ O
= _ _ O
0 _ _ O
; _ _ O
j _ _ O
< _ _ O
pos _ _ O
/ _ _ O
1020 _ _ O
; _ _ O
j++ _ _ O
) _ _ O
{ _ _ O
block _ _ O
= _ _ O
block- _ _ O
> _ _ O
next _ _ O
; _ _ O
} _ _ O
• _ _ O
• _ _ O


 _ _ O
Assumes _ _ O
that _ _ O
next _ _ O
pointer _ _ O
is _ _ O
stored _ _ O
at _ _ O
end _ _ O
of _ _ O
block _ _ O
May _ _ O
require _ _ O
a _ _ O
long _ _ O
time _ _ O
for _ _ O
seek _ _ O
to _ _ O
random _ _ O
location _ _ O
in _ _ O
file _ _ O
CS _ _ O
/ _ _ O
COE _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O


 _ _ O
22 _ _ O

Offset _ _ O
Calculation _ _ O


 _ _ O
CS _ _ O
/ _ _ O
COE _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O


 _ _ O
23 _ _ O

File _ _ O
Allocation _ _ O
Table _ _ O
( _ _ O
FAT _ _ O
) _ _ O
• _ _ O
Links _ _ O
on _ _ O
disk _ _ O
are _ _ O
slow _ _ O
• _ _ O
Keep _ _ O
linked _ _ O
list _ _ O
in _ _ O
memory _ _ O


 _ _ O
• _ _ O
Advantage _ _ O
: _ _ O
faster _ _ O
• _ _ O
Disadvantages _ _ O
• _ _ O
Have _ _ O
to _ _ O
copy _ _ O
it _ _ O
to _ _ O
disk _ _ O
at _ _ O
some _ _ O
point _ _ O
• _ _ O
Have _ _ O
to _ _ O
keep _ _ O
in-memory _ _ O
and _ _ O
on-disk _ _ O
copy _ _ O
consistent _ _ O


 _ _ O
CS _ _ O
/ _ _ O
COE _ _ O
1550 _ _ O
– _ _ O
Operating _ _ O
Systems _ _ O
– _ _ O
Sherif _ _ O
Khattab _ _ O


 _ _ O
0 _ _ O
1 _ _ O
2 _ _ O
3 _ _ O
4 _ _ O
5 _ _ O
6 _ _ O
7 _ _ O
8 _ _ O
9 _ _ O
10 _ _ O
11 _ _ O
12 _ _ O
13 _ _ O
14 _ _ O
15 _ _ O


 _ _ O
4 _ _ O
-1 _ _ O
-1 _ _ O
-2 _ _ O
-2 _ _ O
-1 _ _ O
3 _ _ O
-1 _ _ O
-1 _ _ O
0 _ _ O
-1 _ _ O
-1 _ _ O
-1 _ _ O
-1 _ _ O
-1 _ _ O
-1 _ _ O


 _ _ O
B _ _ O


 _ _ O
A _ _ O


 _ _ O
24 _ _ O



