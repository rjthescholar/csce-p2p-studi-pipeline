{"id": 3, "segment": ["train_set", "labeled"], "course": "cs1550", "lec": "lec11", "text": "Introduction to Operating Systems\nCS/COE 1550\nSpring 2022\n\nSherif Khattab\nksm73@pitt.edu\n(Some slides are from Silberschatz, Galvin and Gagne \u00a92013)\n\nAnnouncements\n\u2022 Upcoming deadlines:\n\u2022 Project 1: due on 2/18\n\u2022 Homework 5: due 2/21\n\u2022 Lab 2: due on 2/28\n\nCS 1550 - Operating Systems - Sherif Khattab\n\nPrevious lecture ...\n\u2022 Deadlock detection and avoidance using the\nBanker's algorithm\n\u2022 Sleepy Barbers problem\n\nCS 1550 - Operating Systems - Sherif Khattab\n\nMuddiest Points\n\u2022 Checked on Tophat\n\nCS 1550 - Operating Systems - Sherif Khattab\n\nSleepy Barbers Solution: Take 2\nstruct mysems {\nSemaphore RV1a(0), RV1b(0), RV2a(0), RV2b(0);\n};\nSharedBuffer buff; //producers-consumers problem\nWorker Process\n\nCustomer Process\n\nstruct mysems sems = buff.consume();\n\nstruct mysems sems = new struct mysems\n\nup(sems.RV1a);\n\nbuff.produce(sems);\n\ndown(sems.RV1b);\n\ndown(sems.RV1a);\n\n//do work\n\nup(sems.RV1b);\n\ndown(sems.RV2a);\n\n//get work\n\nup(sems.RV2b);\n\nup(sems.RV2a);\n\n//check-in for next customer\n\ndown(sems.RV2b);\n//leave\n\nCS 1550 - Operating Systems - Sherif Khattab\n\nQuestions of the Day\n\u2022 How to implement condition variables?\n\n\u2022 Reflect more on all the solutions/problems that we\nhave studied\n\nUser-level implementation of Condition Variables\nA Lock with two waiting queues\n\nstruct Lock {\nSemaphore mutex(1);\nSemaphore next(0);\nint nextCount = 0;\nRelease(){\n\n}\n\nif(nextCount > 0){\n\nAcquire(){\n\nnext.up();\n\nmutex.down();\n\nnextCount--;\n\n}\n\n} else mutex.up();\n}\n\nCondition Variable\nstruct ConditionVariable {\nSemaphore condSem(0);\nint semCount = 0;\nLock *lk;\n}\nWait(){\nif(lk->nextCount > 0)\n\nSignal(){\n\nlk->next.up();\n\nif(semCount > 0){\n\nlk->nextCount--;\n\ncondSem.up()\nlk->nextCount++\n\nelse {\n\nlk->next.down();\n\nlk->mutex.up();\n\nlk->nextCount-\n\n}\nsemCount++;\ncondSem.down();\nsemCount--;\n}\n\n}\n}\n\nLock and Condition Variable Implementation\n\nCS 1550 - Operating Systems - Sherif Khattab\n\nImplementing locks with semaphores\n\u2022\n\nUse mutex to ensure exclusion within the lock bounds\n\n\u2022\n\nUse next to give lock to processes with a higher priority (why?)\n\n\u2022\n\nnextCount indicates whether there are any higher priority waiters\n\nclass Lock {\nSemaphore mutex(1);\nSemaphore next(0);\nint nextCount = 0;\n};\nLock::Acquire()\n{\nmutex.down();\n}\nLock::Release()\n{\nif (nextCount > 0)\nnext.up();\nelse\nmutex.up();\n}\n\nCS 1550 - Operating Systems - Sherif Khattab\n\nImplementing condition variables\n\u2022\n\nAre these Hoare or Mesa semantics?\n\n\u2022\n\nCan there be multiple condition variables for a single Lock?\n\nclass Condition {\nLock *lock;\nSemaphore condSem(0);\nint semCount = 0;\n};\nCondition::Wait ()\n{\nsemCount += 1;\nif (lock->nextCount > 0)\nlock->next.up();\nelse\nlock->mutex.up();\ncondSem.down ();\nsemCount -= 1;\n}\n\nCondition::Signal ()\n{\nif (semCount > 0) {\nlock->nextCount += 1;\ncondSem.up ();\nlock->next.down ();\nlock->nextCount -= 1;\n}\n}\n\nCS 1550 - Operating Systems - Sherif Khattab\n\nProcess Synchronization inside Monitors\n\nCS 1550 - Operating Systems - Sherif Khattab\n\nCondition Variable-based Solutions\n\u2022 Code Walkthrough at:\n\nhttps://cs1550-2214.github.io/cs1550-codehandouts/ProcessSynchronization/Slides/\n\nCS/COE 1550 - Operating Systems - Sherif Khattab\n\n13\n\nReflections on semaphore usage\n\u2022 Semaphores can be used as\n\u2022 Resource counters\n\u2022 Waiting spaces\n\u2022 For mutual exclusion\n\nReflections on Condition Variables\n\u2022 Define a class and put all shared variables inside the\nclass\n\u2022 Include a mutex and a condition variable in the class\n\u2022 For each public method of the class\n\u2022 Start by locking the mutex lock\n\n\u2022 If need to wait, use a while loop and wait on the condition\nvariable\n\u2022 Before broadcasting on the condition variable, make\nsure to change the waiting condition\n\n", "label": [[590, 599, "Concept"], [1288, 1297, "Concept"], [1308, 1317, "Concept"], [1505, 1514, "Concept"], [2125, 2134, "Concept"], [2145, 2154, "Concept"], [2501, 2510, "Concept"], [3150, 3159, "Concept"], [1244, 1248, "Concept"], [1281, 1285, "Concept"], [1545, 1549, "Concept"], [1791, 1795, "Concept"], [1960, 1964, "Concept"], [1993, 1997, "Concept"], [2118, 2122, "Concept"], [2186, 2190, "Concept"], [2220, 2224, "Concept"], [2464, 2468, "Concept"], [2489, 2493, "Concept"], [2495, 2499, "Concept"], [2584, 2588, "Concept"], [2605, 2609, "Concept"], [2627, 2631, "Concept"], [2723, 2727, "Concept"], [2760, 2764, "Concept"], [2780, 2784, "Concept"], [3476, 3480, "Concept"], [1459, 1477, "Concept"], [1800, 1818, "Concept"], [2940, 2958, "Concept"], [3377, 3395, "Concept"], [3582, 3600, "Concept"], [1381, 1388, "Concept"], [2192, 2199, "Concept"], [1346, 1353, "Concept"], [2226, 2233, "Concept"], [1557, 1561, "Concept"], [2555, 2559, "Concept"], [3495, 3499, "Concept"], [3522, 3526, "Concept"], [1588, 1594, "Concept"], [2691, 2697, "Concept"], [1298, 1303, "Concept"], [1405, 1410, "Concept"], [1444, 1449, "Concept"], [1712, 1717, "Concept"], [1923, 1928, "Concept"], [2135, 2140, "Concept"], [2204, 2209, "Concept"], [2273, 2278, "Concept"], [2633, 2638, "Concept"], [3365, 3370, "Concept"], [3470, 3475, "Concept"], [3237, 3253, "Concept"], [977, 981, "Concept"], [1318, 1322, "Concept"], [1393, 1397, "Concept"], [1603, 1607, "Concept"], [1694, 1698, "Concept"], [1980, 1984, "Concept"], [2155, 2159, "Concept"], [2257, 2261, "Concept"], [2611, 2615, "Concept"], [2766, 2770, "Concept"], [1331, 1340, "Concept"], [1364, 1373, "Concept"], [1420, 1429, "Concept"], [1572, 1581, "Concept"], [1638, 1647, "Concept"], [1669, 1678, "Concept"], [1729, 1738, "Concept"], [2045, 2054, "Concept"], [2168, 2177, "Concept"], [2242, 2251, "Concept"], [2590, 2599, "Concept"], [2729, 2738, "Concept"], [2786, 2795, "Concept"], [2389, 2403, "Concept"], [389, 411, "Concept"], [660, 687, "Concept"], [2853, 2876, "Concept"]]}