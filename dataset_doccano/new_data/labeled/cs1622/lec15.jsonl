{"id": 15, "segment": ["train_set", "labeled"], "course": "cs1622", "lec": "lec15", "text": "Structs and Classes, OOP\nCS 1622\nJarrett Billingsley\n\nClass Announcements\n\u25cf yet another \"real example\" of adding a language feature\no though you already did the lexing, parsing, and some of the\nsemantic analysis for this stuff in the projects...\no so we'll kinda skip that stuff!\n\n2\n\nStructured types\n\n3\n\nType survey\n\u25cf primitive types can only get you so far.\no remember these are things like int, bool, and char.\n\u25cf arrays give the programmer a lot of problem-solving power.\no even in very simplistic languages (like old BASIC dialects), arrays\ngive you the power of indirection and dynamically-sized data\nstructures, which you can't do with primitives.\n\u25cf but more complex problems will require the user to define their own\ntypes suited to solving the problem.\no and if we want to let the user define their own types, the most\nobvious place to start is with... classes structs tuples!\n\n4\n\nTuples??\n\u25cf a tuple is an ordered sequence of heterogeneous types.\no heterogeneous = \"they can be different\"\n\u25cf typically, tuple types are written in parens, like (T1, ..., Tn)\n\u25cf you could use them to represent...\no coordinates in an n-dimensional space: (10, 4)\n\u25aa this one's type is (int, int)\no the absence of a value: ()\n\u25aa this is also called unit or, in our language, void\no simple objects: (\"Billingsley\", \"Jarrett\", 35)\n\u25aa this one's type is (string, string, int)\no maybe you can see where this is going...\n\n5\n\nOperations on tuples\n\u25cf like arrays, we can index them to access their values:\no t[2] = 34;\n\u25cf unlike arrays, we know their length statically...\no but each element can be a different type!\no therefore: we can only index them with constant values.\n\u25cf what if we had a way of defining named constants?\nconst LNAME = 0;\nconst FNAME = 1;\nconst AGE\n= 2;\nlet me = (\"Billingsley\", \"Jarrett\", 35);\nme[AGE] = 36; // next year..\n\n\u25cf\ud83e\udd14\n6\n\n...yeah okay that's basically a struct isn't it\n\u25cf a struct or record type is like a class that only has data.\n\u25cf tuples and structs are almost the same thing, except...\no tuples' fields are anonymous while structs' fields are named.\n\u25cf it's probably pretty obvious now how structs work:\n\nstruct Point {\nx: int, y: int\n}\nlet p = new Point(3, 8);\np.x = p.x + 1;\n\n\u2248\n\u2248 let p = (3, 8);\np[0] = p[0] + 1;\n\u2248\n(int, int)\n\n7\n\nOne important difference\n\u25cf in most languages that have both structs and tuples:\no tuples have structural identity, but structs have nominal identity\n\u25cf what that means is:\n\n(int, int, int)\n\n\u2248\n\nstruct Point3D {\nx: int, y: int, z: int\n}\n\nsame type!\n\ndifferent types!\n\n(int, int, int)\n\nstruct Color {\nr: int, g: int, b: int\n}\n\n\u2248\n\n8\n\nValue types and reference types\n\u25cf all variables contain bit patterns.\n\u25cf for value type variables, that bit pattern is the value.\no examples include int, float, char, and bool.\n\u25cf for reference type variables, that bit pattern is a memory address.\no examples include Java arrays and objects.\n\u25cf assigning from one variable to another copies the bit patterns.\n\u25cf for value types, that means you copy the entire value.\nint x = 5;\nint y = x; // now we have two 5s!\n\u25cf but for reference types, you only copy the address.\nObject x = new Object();\nObject y = x; // still only one Object...\n\n9\n\nDecision time!\n\u25cf Rust, C, C++, and C# consider structs to be value types. In Rust:\nlet s = Point { x: 3, y: 8 };\nlet t = s; // now we have two Points, both {3, 8}!\n\u25cf in these languages, this is nonsense: struct Node { next: Node }\no how can something contain itself??\n\u25cf Java doesn't let the programmer create their own value types.\no so, this is fine: class Node { Node next; }\no because Node next; declares a reference variable.\n\u25cf so: should Truss's structs be value types, or reference types?\n\u25cf well, for \"simplicity,\" let's stick with reference types.\no reference types let us solve more problems than value types do,\njust sometimes with more space/time overhead.\n\u25cf but if we have references, then we probably need... null.\n10\n\nThe billion dollar mistake: null\n\u25cf null is a special value you can put into a reference variable to\nindicate that it is uninitialized or \"not pointing to anything.\"\n\u25cf trying to perform any operation besides assignment on null will\nlead to a runtime error (a crash).\n\u25cf unfortunately, most of the time, you do not want references to be null.\no so by putting null in a language, and not requiring checks before\nusing a reference, you are adding a huge number of potential\ncrashes into virtually every program.\n\u25cf also it's just weird when it comes to typechecking.\no it's the only value that can be put into multiple different types.\no String s = null; Object o = null; int[] a = null;\n\u25cf so null does not have a type of its own! type theory calls it a\nbottom type, because it is at the bottom of the type hierarchy and\nacts as a subtype of all other types.\n11\n\nStruct Runtime\nRepresentation\n\n12\n\nData layout\n\u25cf how are structs (and classes?) going to be represented in memory?\no arrays work by putting the values next to each other.\no okay, let's do that.\n\nstruct Point3D { x: int, y: int, z: int }\nassuming int is\n32 bits (4 Bytes)...\n\n0\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10 11\n\nthese numbers are the offsets from the beginning of the struct.\n(assuming we're using a byte-addressable machine)\n\nthey say how far \"into the struct\" each field is.\n13\n\nNot so fast, Mister Gordon!\n\u25cf since bool takes up 1 byte, what if we had a struct like this:\nstruct Hmm { b: bool, i: int }\n\nb\n\ni\n\n0\n\n1\n\nthis is a totally valid way of doing it.\n\n2\n\n3\n\n4\n\nunfortunately, lots of CPU\narchitectures hate this.\n\nCPUs like values to be aligned. that means: the memory\naddress in an n-byte load/store must be a multiple of n.\nx86 CPUs will access unaligned values very slowly.\nMIPS CPUs will crash. (unless you use the much slower unaligned loads/stores)\n\nso, we need to insert padding (extra unused bytes) into\nour structs to ensure each field is properly aligned.\n14\n\nStruct padding\n\u25cf we place each field at an offset that is a multiple of its alignment.\n\u25cf then, the struct's size as a whole is rounded up to the largest\nalignment of any field. (this is important for arrays of structs.)\n\u25cf so for this: struct Hmm { b: bool, i: int }\n\nb\n0\n\ni\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\nand if we swapped b and i:\n\ni\n0\n\nb\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\neither way, the struct is\n8 bytes, and it must be\n4-byte aligned\nbecause of the int.\n15\n\nWait, why does the whole struct need to be padded?\n\u25cf strictly speaking, for our language where structs are reference types,\nthe structs don't need padding at the end.\n\u25cf but in languages where they're value types, it's crucial for maintaining\nalignment in arrays of structs. consider these arrays of two structs:\ni\n0\n\nb\n1\n\n2\n\n3\n\ni\n0\n\n1\n\n2\n\n3\n\ni\n\n4\n\n5\n\nb\n\ni\n\n4\n\n5\n\n6\n\n7\n\n8\n\nb\n9\n\n10 11 12 13 14 15\n\nb\n6\n\n7\n\n8\n\n9\n\nwithout the end-padding, this int field\nof the second item is now misaligned.\n\nthe memory allocator will\nhave to allocate things at\naligned memory addresses\nas well, for this to work.\n16\n\nAnyway... allocation\n\u25cf now we know the size and alignment of each struct.\n\u25cf we'll need a runtime library function to dynamically allocate structs.\no let's call it rt$new(size: int). it'll return an address.\no to keep it simple, it'll always align things to 4 bytes.\nstruct Thing {\n// size: 12\nname:\nstring,\nin_use: bool,\nflag:\nbool,\ncount: int,\n}\n\nlet t = new Thing();\n\nallocations get generated\nas calls to this function.\naddi sp, sp, -4\nli\ns0, 12\nsw\ns0, 0(sp) # size\njal rt$new\nsw\nv0, -24(fp) # t\n\n17\n\nAccessing fields\n\u25cf we use the fields' offsets and types to generate code for field access.\nstruct Thing {\nname:\nstring, // offs: 0\nin_use: bool,\n// offs: 4\nflag:\nbool,\n// offs: 5\ncount: int,\n// offs: 8\n}\n\nto access a field, we add its\noffset to the struct instance's\naddress, then use the right\n\"flavor\" of load/store.\n\nlet t = new Thing();\nt.in_use = true;\nt.count\n\n= 20;\n\nlw s0, -24(fp) # t\nli s1, 1\n# true\nsb s1, 4(s0)\n# t.in_use = true\nlw s0, -24(fp) # t\nli s1, 20\nsw s1, 8(s0)\n# t.count = 20\n18\n\nOOP\n\n19\n\nWhat is OOP (object-oriented programming)?\n\u25cf we might gesture vaguely in Java's direction and say \"it's like that\"\no but \"Java-flavored OOP\" isn't the only kind...\n\u25cf C has structs, but it isn't \"OOP.\" C++ has \"classes\", and it is \"OOP.\"\n\u25cf the core idea of OOP is packaging data alongside operations on\nthat data into a single, indivisible entity.\no so: the main thing that distinguishes C++ from C... is methods.\n\u25cf a method call is a special kind of function call:\nobj.method();\no method calls can be more complex than \"regular\" function calls.\n\u25cf other OOP concepts, which are not required but are common, include\ninheritance, subtyping, interfaces, privacy, constructors, and runtime type identification.\n\n20\n\nMethods\n\u25cf methods are special functions which are associated with an object.\n\u25cf they take the object they are called on as an argument.\nstruct Point {\nthis is passed implicitly,\nx: int,\nbut it's still an argument.\ny: int\nfn to_string(): string {\nreturn to_string(this.x) + \", \" + to_string(this.y);\n}\n}\nlet p = new Point(3, 8);\nprintln_s(p.to_string());\n\nhere, the method call is syntactic\nsugar for something like:\nPoint.to_string(p)\n\nthis is static dispatch, because we can determine\nwhich method to call at compile-time.\n\n21\n\nConstructors\n\u25cf a constructor is just a method that is called on an instance of an\nobject immediately after allocating it, to let you initialize its fields.\nclass C {\nString s;\n\nC() {\n// s == null\ns = \"hi\";\n}\n}\nC c = new C();\n\nin this Java code, new C() does the following:\n\n1. allocates an instance of C\n2. initializes all its fields to default values*\n\n3. calls the constructor on that instance\nbut Java doesn't really enforce that you do\nanything useful in the constructor, and before\nit completes, the object may be in an\ninconsistent state (i.e. calling methods on\nthis may behave erratically or crash).\n22\n\nData inheritance\n\u25cf first, let's look at a simpler kind of inheritance, which just inherits data\nfields without inheriting methods, and does not imply subtyping.\nstruct RGB { r: int, g: int, b: int } the base class's fields are\nstruct RGBA : RGB { a: int }\ncopied into the derived\nlet color = new RGBA(255, 127, 0, 95);\nclass's definition.\n\nwe represent this in memory by prefixing:\nthe beginning of an RGBA is an RGB.\n\nRGB\nRGBA\n\nr\n\ng\n\nb\n\n0\n\n4\n\n8\n\nr\n\ng\n\nb\n\na\n\n0\n\n4\n\n8\n\n12\n\nreusing only the data is\nlimited in usefulness. reusing\nmethods is much more useful.\n23\n\nMethod inheritance\n\u25cf method inheritance takes advantage of the prefixed representation.\no base class methods can be called on derived class instances,\nbecause the base class fields are at the same offsets.\nstruct Animal {\nspecies: string\nfn to_string(): string {\nreturn \"Animal(\" + this.species + \")\";\n}\n}\nstruct Cat : Animal { whiskers: int }\nlet c = new Cat(\"felis cattus\", 15);\nprintln_s(c.to_string());\n\nthis is still static dispatch: the method\ncall is sugar for Animal.to_string(c).\n\nwe can now say that Cat\nis a subtype of Animal.\n\n24\n\nWhere it starts getting crazy\n\u25cf what if we want to specialize to_string() in the Cat struct?\nstruct Animal {\nspecies: string\nfn to_string(): string {\nreturn \"Animal(\" + this.species + \")\";\n}\nthe compiler might be able to\n}\nstatically determine in this case that\nstruct Cat : Animal {\nit should call Cat.toString(c).\nwhiskers: int\nfn to_string(): string {\nreturn \"meow meow meow!\";\nbut it can't determine that in\n}\nthe general case.\n}\nlet c = new Cat(\"felis cattus\", 15);\nprintln_s(c.to_string());\n25\n\nThe problem\n\u25cf since a subtype can be used anywhere a base type is expected...\no a base type variable can contain different types of values.\n\u25cf and since subtypes can have different implementations of the\nsame methods as the supertype...\no you can't know what subtype implementation to call until runtime!\nfn print(a: Animal) {\n// how does this call to\n// to_string know which\n// implementation to use?\nprintln_s(a.to_string());\n}\nprint(new Cat());\nprint(new Dog());\nprint(new Horse());\n\nthe problem (as it often is) is that\nwe lose type information in the\ntranslation from the source\nlanguage to the target language.\nso, let's... not do that. let's\nkeep some of that type info.\n26\n\nVirtual Methods and\nDynamic Dispatch\n\n27\n\nRTTI (Run-time Type Identification)\n\u25cf the solution is to make each class instance carry an ID card.\no this is implemented as a \"secret\" field in every class instance.\nc = new Cat(...);\ntype: Cat\nspecies: \"felis cattus\"\nwhiskers: 15\n\nd = new Dog(...);\ntype: Dog\nspecies: \"canis lupus\"\ndrooly: true\n\nfn print(a: Animal) {\nprintln_s(a.to_string());\n}\nthis method call could be\nimplemented something like:\n\nif a.type == Cat {\nCat.to_string(a)\n} else if a.type == Dog {\nDog.to_string(a)\n}\nbut that would be horribly inefficient.\n28\n\nVirtual method tables (vtables)\n\u25cf to implement this efficiently, and to allow an unlimited number of\nsubtypes, the \"ID card\" is a pointer to an array of function pointers.\nc = new Cat(...);\n\nCat vtable\n\n0 vtbl\n\n0 breathe\n\nAnimal.breathe()\n\n4 species\n\n4 to_string\n\nCat.to_string()\n\n8 whiskers\n\n8 play_string\n\nCat.play_string()\n\nd = new Dog(...);\n\nDog vtable\n\n0 vtbl\n\n0 breathe\n\n4 species\n\n4 to_string\n\nDog.to_string()\n\n8 drooly\n\n8 play_fetch\n\nDog.play_fetch()\n29\n\nVirtual method calls\n\u25cf to call a virtual method, we index the table to get the address...\no and do an indirect function call to that address.\nthis method call becomes:\nfn print(a: Animal) {\na.vtbl[1](a)\nprintln_s(a.to_string());\n}\nor in assembly:\nthe compiler knows the\nmethod indexes because\nthe vtables for each class\nuse prefixing:\nsubtypes' vtables are\nprefixed with their\nsupertype's vtable.\n\naddi sp, sp, -4\nlw\ns0, -16(fp) # s0 = a\nsw\ns0, 0(sp)\n# pass 'this'\nlw\ns0, 0(s0)\n# s0 = a.vtbl\nlw\ns0, 4(s0)\n# s0 = a.vtbl[1]\njalr s0\n# call to_string\n\njalr works like jal, but uses a register\nas the address of the function to call.\n30\n\nThings to ponder on\n\u25cf what are interfaces, then?\no a \"slice\" of a vtable, sort of!\no when a class implements an interface, those methods are present\nin its vtable at runtime.\n\u25cf what about public/protected/private? final? override?\no these are all semantic; they have no effect on the implementation.\n\u25cf what about static variables/methods?\no they're globals whose names happen to be scoped inside a class.\n\u25cf what about null?\no we could have nullable reference types, like a restricted form of\nRust's Option<T> that only works for references.\n\u25cf what about inheriting from multiple classes?\no don't even go there. noooooope nope nope\n31\n\n", "label": [[12720, 12725, "Concept"], [902, 907, "Concept"], [1010, 1015, "Concept"], [1888, 1899, "Concept"], [1858, 1864, "Concept"], [1878, 1884, "Concept"], [2112, 2118, "Concept"], [2431, 2437, "Concept"], [2521, 2527, "Concept"], [3355, 3361, "Concept"], [4739, 4745, "Concept"], [4934, 4940, "Concept"], [5107, 5113, "Concept"], [5193, 5199, "Concept"], [5295, 5301, "Concept"], [5313, 5319, "Concept"], [5817, 5823, "Concept"], [5916, 5922, "Concept"], [6052, 6058, "Concept"], [6184, 6190, "Concept"], [6282, 6288, "Concept"], [6921, 6927, "Concept"], [7121, 7127, "Concept"], [7450, 7456, "Concept"], [7608, 7614, "Concept"], [8715, 8721, "Concept"], [9881, 9887, "Concept"], [9947, 9953, "Concept"], [10487, 10493, "Concept"], [10587, 10593, "Concept"], [10909, 10915, "Concept"], [10917, 10923, "Concept"], [11086, 11092, "Concept"], [54, 59, "Concept"], [1910, 1915, "Concept"], [3503, 3508, "Concept"], [9264, 9269, "Concept"], [9928, 9933, "Concept"], [10039, 10044, "Concept"], [10376, 10381, "Concept"], [10415, 10420, "Concept"], [10449, 10454, "Concept"], [12115, 12120, "Concept"], [12199, 12204, "Concept"], [13353, 13358, "Concept"], [13764, 13769, "Concept"], [14070, 14075, "Concept"], [2333, 2352, "Concept"], [2371, 2387, "Concept"], [2644, 2654, "Concept"], [2750, 2764, "Concept"], [3872, 3876, "Concept"], [3910, 3914, "Concept"], [3917, 3921, "Concept"], [4103, 4107, "Concept"], [4216, 4220, "Concept"], [4238, 4242, "Concept"], [4525, 4529, "Concept"], [4542, 4546, "Concept"], [4558, 4562, "Concept"], [4569, 4573, "Concept"], [9299, 9303, "Concept"], [14090, 14094, "Concept"], [4630, 4641, "Concept"], [1233, 1237, "Concept"], [1259, 1263, "Concept"], [5893, 5902, "Concept"], [5970, 5979, "Concept"], [6499, 6508, "Concept"], [6903, 6912, "Concept"], [5725, 5732, "Concept"], [5824, 5831, "Concept"], [6404, 6411, "Concept"], [6683, 6690, "Concept"], [7436, 7448, "Concept"], [6944, 6968, "Concept"], [7018, 7024, "Concept"], [7328, 7334, "Concept"], [21, 24, "Concept"], [7860, 7863, "Concept"], [7877, 7880, "Concept"], [8005, 8008, "Concept"], [8064, 8067, "Concept"], [8100, 8103, "Concept"], [8125, 8128, "Concept"], [8422, 8425, "Concept"], [7882, 7909, "Concept"], [8286, 8292, "Concept"], [8338, 8344, "Concept"], [8350, 8356, "Concept"], [8944, 8950, "Concept"], [9071, 9077, "Concept"], [9147, 9153, "Concept"], [10281, 10287, "Concept"], [10302, 10308, "Concept"], [10724, 10730, "Concept"], [12401, 12407, "Concept"], [12584, 12590, "Concept"], [13047, 13053, "Concept"], [13080, 13086, "Concept"], [13186, 13192, "Concept"], [13309, 13315, "Concept"], [8286, 8297, "Concept"], [8944, 8955, "Concept"], [12401, 12412, "Concept"], [13186, 13197, "Concept"], [216, 220, "Concept"], [1152, 1156, "Concept"], [1213, 1217, "Concept"], [1315, 1319, "Concept"], [1382, 1386, "Concept"], [3337, 3341, "Concept"], [3489, 3493, "Concept"], [5307, 5311, "Concept"], [5357, 5361, "Concept"], [5454, 5458, "Concept"], [5995, 5999, "Concept"], [6046, 6050, "Concept"], [6692, 6696, "Concept"], [6837, 6841, "Concept"], [7263, 7267, "Concept"], [8730, 8734, "Concept"], [8842, 8846, "Concept"], [8869, 8873, "Concept"], [9015, 9019, "Concept"], [9337, 9341, "Concept"], [9677, 9681, "Concept"], [10073, 10077, "Concept"], [10563, 10567, "Concept"], [10689, 10693, "Concept"], [10993, 10997, "Concept"], [11071, 11075, "Concept"], [11663, 11667, "Concept"], [12150, 12154, "Concept"], [12396, 12400, "Concept"], [12623, 12627, "Concept"], [13181, 13185, "Concept"], [13498, 13502, "Concept"], [9023, 9038, "Concept"], [10703, 10718, "Concept"], [9125, 9136, "Concept"], [9475, 9486, "Concept"], [9571, 9582, "Concept"], [9720, 9736, "Concept"], [10344, 10367, "Concept"], [10281, 10299, "Concept"], [10302, 10320, "Concept"], [4707, 4714, "Concept"], [10800, 10807, "Concept"], [11347, 11354, "Concept"], [11583, 11590, "Concept"], [8496, 8505, "Concept"], [9870, 9879, "Concept"], [12026, 12042, "Concept"], [12048, 12052, "Concept"], [12054, 12082, "Concept"], [12576, 12590, "Concept"], [13039, 13053, "Concept"], [13072, 13086, "Concept"], [12599, 12606, "Concept"], [13336, 13343, "Concept"], [13384, 13391, "Concept"], [12576, 12597, "Concept"], [13784, 13793, "Concept"], [13860, 13866, "Concept"], [13867, 13876, "Concept"], [13877, 13884, "Concept"], [13886, 13891, "Concept"], [13893, 13901, "Concept"]]}