{"id": 46, "segment": ["train_set", "labeled"], "course": "cs0007", "lec": "lec10", "text": "CS 0007: Introduction to Java\nLecture 10\nNathan Ong\nUniversity of Pittsburgh\nOctober 4, 2016\n\nif() recap\n//always run this code\nif(condition1 is true)\n{\n//run this code\n}\nelse if(condition2 is true)\n{\n//run this code\n}\nelse if(condition3 is true)\n{\n...\n}\n...\nelse //if conditions 1...n were not satisfied\n{\n//run this code\n}\n//always run this code\n\nRevisiting Scope\n\u2022 Scope works by curly brackets.\n\u2022 Curly brackets surround all newly\ndeclared information, keeping it hidden\nfrom code outside of the curly brackets.\n\nScope\nConfidential\nSecret\nTop Secret\n\nScope\npublic class ScopeExample\npublic static void main\n\npublic static void func\n\nif\n\nif\nif\n\nelse if\n\nDarker shades can see lighter shades,\nbut not vice versa\n\nScope in Code\npublic class Name\n{\npublic static void main(String[] args)\n{\nint x = 0;\n//x == 0, y is undefined\nif(x == 0)\n{\nint y = 10;\nx = 15;\n//x == 15, y == 10\n}\n//x == 15, y is undefined\n}//end method main\n}//End class Name\n\nA Special Annoying Case\nScanner scanner = new Scanner(System.in);\nint numTrees = scanner.nextInt();\nif(numTrees == 0)\n{\nSystem.out.println(\"Desert\");\n}\nelse if(numTrees == 1)\n{\nSystem.out.println(\"Island\");\n}\nelse if(numTrees == 2)\n{\nSystem.out.println(\"Beach\");\n}\nelse if(numTrees == 3)\n{\nSystem.out.println(\"Forest\");\n}\nelse\n{\nSystem.out.println(\"Jungle\");\n}\n\nSwitch-Case\n\u2022 A Switch-Case statement is like a long if, elseif, else block concerning only one variable and\nseveral possible discrete values (not ranges).\n\u2022 This increases readability, but they act\nsimilarly.\n\u2022 Works for byte, char, short, int, and\nString. (Any others out of scope)\n\u2022 For every case possibility, you need a break\nstatement, unless you wanted to combine\nseveral cases together.\n\nA Special Annoying Case\nScanner scanner = new Scanner(System.in);\nint numTrees = scanner.nextInt();\nswitch(numTrees)\n{\ncase 0:\nSystem.out.println(\"Desert\");\nbreak;\ncase 1:\nSystem.out.println(\"Island\");\nbreak;\ncase 2:\nSystem.out.println(\"Beach\");\nbreak;\ncase 3:\nSystem.out.println(\"Forest\");\nbreak;\ndefault:\nSystem.out.println(\"Jungle\");\nbreak;\n}\n\nARRAYS, LOOPS, AND\nRECURSION\n\nA Sudden Need\n\u2022 I need a function that returns the first\n100 terms of the harmonic series.\n\u2022 Harmonic series:\uf0a5 1\n1 1\n\n\uf0e5 n \uf03d1 \uf02b 2 \uf02b 3 \uf02b ...\nn \uf03d1\n\nThe Dumb Way\npublic static void main(String[] args)\n{\ndouble term0 = 1.0;\ndouble term1 = 1.0/2.0;\ndouble term2 = 1.0/3.0;\n...\n}\n\nLists\n\u2022 How do we do lists?\n\u2022 Using 100 variables as a list is not\nscalable! What if we need more? What\nif I change the names? What if I wanted\na different series?\n\u2022 A WILD STRUCTURE APPEARS\n\nArrays\n\u2022 Arrays are ordered lists of things\ndepending on the type you specify\n\u2022 How do you make one?\n\nType[] name = new Type[size];\n\nint[] empty = new int[10];\n\nType[] name = values;\n\nint[] list = {1,2,3,4};\n\nNow What?\n\u2022 I want the first element\n\u2022 list[0]\n\u2022 I want the last element\n\u2022 list[3]\n\u2022 I want the length\n\u2022 list.length == 4\n\u2022 All operations for int are allowed for an\nindividual element\n\u2022 list[0] + list[2] == list[3]\n\nHow do I get every element so I can\nprint it?\n\u2022 Reference every element\n\u2022 Many if statements!!!!!!\nYAAAAAAAAYYYY\n\u2022 No please don't\n\u2022 But what else can we do?\n\u2022 WILD KEYWORD APPEARS\n\nwhile(){...}\n\u2022 While a condition is true, run the block\n\u2022 While not at the end of the list, print out\nthe next element\nwhile(not at end of list)\n{\nSystem.out.println(next element);\n}//end loop while(not at end of list)\n\nnot at end of list\n\u2022 How do we know we're at the end of the\nlist?\n\u2022 list.length\n\u2022 How do we know which one we're at?\n- We need to keep track\n\nint currElement = 0;\n\n- starts at 0\n- not equal to the end!\n\ncurrElement != list.length\n\nwhile(){...}\n\u2022 While not at the end of the list, print out the next\nelement\nint currElement = 0;\nwhile(currElement != list.length)\n{\nSystem.out.println(<next element>);\n}//end loop while(currElement!=list.length)\n\n", "label": [[360, 365, "Concept"], [368, 373, "Concept"], [517, 522, "Concept"], [555, 560, "Concept"], [561, 567, "Concept"], [587, 593, "Concept"], [601, 605, "Concept"], [612, 618, "Concept"], [626, 630, "Concept"], [715, 720, "Concept"], [729, 735, "Concept"], [749, 755, "Concept"], [763, 767, "Concept"], [1306, 1317, "Concept"], [1322, 1333, "Concept"], [1363, 1369, "Concept"], [1402, 1410, "Concept"], [1583, 1588, "Concept"], [2049, 2055, "Concept"], [2057, 2062, "Concept"], [2068, 2077, "Concept"], [2104, 2112, "Concept"], [2118, 2125, "Concept"], [2237, 2243, "Concept"], [2251, 2255, "Concept"], [2545, 2551, "Concept"], [2554, 2561, "Concept"], [3153, 3158, "Concept"], [3168, 3174, "Concept"], [3272, 3277, "Concept"], [3346, 3351, "Concept"], [3604, 3609, "Concept"], [3619, 3625, "Concept"]], "Comments": []}