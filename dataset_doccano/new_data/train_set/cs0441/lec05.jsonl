{"id": 5, "segment": ["train_set", "labeled"], "course": "cs0441", "lec": "lec05", "text": "Discrete Structures for Computer\nScience\n\nWilliam Garrison\nbill@cs.pitt.edu\n6311 Sennott Square\nLecture #5: Logic Programming and Nested\nQuantifiers\nBased on materials developed by Dr. Adam Lee\n\nToday's topics\nn Applications of predicate logic\nn Nested quantifiers\n\nLogic programming enables automated reasoning\nProlog\nl Programming in logic\nl Developed in the 1970s for\nAI purposes\n\nDatalog\nl Logical formalization of\ndatabases\nl Developed in the 1980s\n\nFor our purposes, we can consider Prolog and Datalog to be the\nsame, though in reality they have very important differences.\n\nTwo main constructs:\n\nLower case = constant\n\nl Facts\n2 instructor(bill, cs441)\nUpper case = variable\n2 student(smith, cs441)\nl Rules\n2 teaches(P,S) :- instructor(P,C), student(S,C)\n\nRules and facts define predicates\nFacts define predicates by explicitly listing elements that\nsatisfy those predicates\nl \"Dr. Garrison is the instructor for CS441\"\no instructor(bill, cs441)\n\nRules define predicates by combining previously specified\npredicates\nl \"Professors teach the students enrolled in the courses for\nwhich they are the instructor\" o\nteaches(P,S) :- instructor(P,C), student(S,C)\n\nProlog is an environment that lets us issue queries to\ndetermine which predicates are true!\n\nA Security Example\ngrant(U, projector) :- located(U, 105), role(U, presenter)\nlocated(U, R) :- owns(U, D), dev_loc(D, R)\nrole(bob, presenter) owns(alice, laptop12)\nrole(carol, presenter) owns(bob, tablet23)\nowns(carol, cell42)\n\ndev_loc(laptop12, 105)\ndev_loc(tablet23, 105)\ndev_loc(cell42, 105)\n\nCan Bob run the projector?\nl Query: ?grant(bob, projector)\nl Solution: true\nKnowledge base\n\nWho is in room 105?\nl Query: ?located(X, 105)\nl Solution: alice, bob, carol\n\nWrite and evaluate the following queries\ngrant(U, projector) :- located(U, 105), role(U, presenter)\nlocated(U, R) :- owns(U, D), dev_loc(D, R)\nrole(bob, presenter) owns(alice, laptop12)\nrole(carol, presenter) owns(bob, tablet23)\nowns(carol, cell42)\n\nn Can Alice use the projector?\nl ?grant(alice, projector)\nl false\n\nn Can Carol use the projector\nl ?grant(carol, projector)\nl true\n\ndev_loc(laptop12, 105)\ndev_loc(tablet23, 105)\ndev_loc(cell42, 105)\n\nn Which devices does Alice own?\nl ?owns(alice, X)\nl laptop12\n\nLogic programming is a useful tool!\nName\n\nAge\n\nPhone\n\nAlice\n\n19\n\n555-1234\n\nDanielle\n\n33\n\n555-5353\n\nZach\n\n27\n\n555-3217\n\nCharlie\n\n21\n\n555-2335\n\nArtificial Intelligence\n\nDatabases\n\nRoute\nplanning\n\nSecurity\n\nJust for grins...\nIf you are interested in playing around with logic\nprogramming, download SWI-Prolog\nl URL: http://www.swi-prolog.org/\n\nThis (free) package is a runtime environment in which\nyou can write logic programs and evaluate queries.\nDave\n\nCharlie\nAlice\n\nElise\n\nBob\n\nBecky\n\nFrank\nSarah\n\nTommy\n\nNested quantifiers!?!?\nMany times, we need the ability to nest one quantifier\nwithin the scope of another quantifier\n\nExample: All integers have an additive inverse. That is,\nfor any integer x, we can choose an integer y such that\nthe sum of x and y is zero.\n\n\"x $y (x + y = 0)\nThere is no way to express this statement using only a\nsingle quantifier!\n\nDeciphering nested quantifiers isn't as scary as\nit looks...\n... if you remember to read from left to right!\n\n\"x $y \"z [(x + y)\u00d7z = 0]\nFor all x...\n... there exists a y such\nthat...\n... for all z...\n\nAnd think about scope of variables\nlike with programming!\n\n... (x + y)\u00d7 z = 0\n\nA few more examples...\n\"x \"y (x + y = y + x)\n\nThis is the commutative\nlaw for addition!\n\nl For all integers x and for all integers y, x + y = y + x\n\n\"x \"y \"z [(x+y)+z = x+(y+z)]\n\nThis is the associative\nlaw for addition!\n\nl For all integers x, for all integers y, and for all integers z,\n(x+y)+z = x+(y+z)\n\n$x \"y (x\u00d7 y = 0)\nl There exists an x such that for all y, x\u00d7 y = 0\n\nSince we always read from left to right, the\norder of quantifiers matters!\nConsider: \"x $y (x + y = 0)\n\nClearly true!\nJust set y = -x\n\n\u27a3 Every integer has an additive inverse\nNot true...\n\nTranspose: $y \"x (x + y = 0)\n\u27a3 There exists some integer y such that when added to\nany other integer x, the sum of x and y is 0\n\nRemember: As long as you read from left to right, you\nwon't have any problems!\n\nMany mathematical statements can be translated into\nlogical statements with nested quantifiers\nTranslating mathematical expressions is often easier\nthan translating English statements!\nSteps:\n1. Rewrite statement to make quantification and logical\noperators more explicit\n2. Determine the order in which quantifiers should appear\n3. Generate logical expression\n\nLet's try a translation...\nUniversal quantifier\n\nStatement: Every real number except zero has a\nmultiplicative inverse\nx\u00d7y=1\n\nSingular-suggestive of an\nexistential quantifier\n\n\"x\nRewrite: For every real number x, if x \u2260 0, then there\nexists a real number y such that x\u00d7y = 1.\n... $y (x \u00d7 y = 1)\n\n(x \u2260 0) \u2192 ...\n\nTranslation: \"x [(x \u2260 0) \u2192 $y (x \u00d7 y = 1)] OR\n\"x $y [(x \u2260 0) \u2192 (x \u00d7 y = 1)]\n\nMore examples...\n\nStatement: The product of any two negative integers\nis always positive\nl For any integer x and any integer y, if x < 0 and y < 0, then\nx\u00d7 y > 0\nl \"x \"y [(x < 0 \u2227 y < 0) \u2192 (x\u00d7 y > 0)]\n\nStatement: For any real number a, it is possible to\nchoose real numbers b and c such that a2 + b2 = c2\nl For any real number a, there exist real numbers b and c\nsuch that a2 + b2 = c2\nl \"a $b $c (a2 + b2 = c2)\n\nTranslating quantified statements to English is\nas easy as reading a sentence!\nLet:\nl C(x) \u2261 x is enrolled in CS441\nl M(x) \u2261 x has an MP3 player\nl F(x, y) \u2261 x and y are friends\nl Domain of x and y is \"all students\"\n\nStatement: \u2200x [C(x) \u2192 M(x) \u2228 (\u2203y (F(x,y) \u2227 M(y))]\nFor every student x...\n... if x is enrolled in CS441, then...\n... x has an MP3 player...\n... or there exists another student y such that...\n... x and y are friends...\n... and y has an MP3 player.\n\nTranslate the following expressions into English\nLet:\nl O(x,y) \u2261 x is older than y\nl F(x,y) \u2261 x and y are friends\nl The domain for variables x and y is \"all students\"\n\nStatement: \u2203x \u2200y O(x,y)\nl There exists a student x, such that for all students y, x is older\nthan y.\nl Alternatively: There exists an oldest student.\n\nStatement: \u2203x \u2203y [F(x,y) \u2227 \u2200z [(y\u2260z) \u2192 \u00acF(x,z)]]\nl There exists two students x and y such that x and y are friends\nand for all students z, if z \u2260 y, then x and z are not friends.\nl Alternatively: There exists a student with only one friend L\n\nIn-class exercises\nProblem 1: Translate the following mathematical\nstatement into predicate logic: Every even number is a\nmultiple of 2. Assume that the predicate E(x) means \"x\nis even.\"\nl\n\nHint: What does \"x is a multiple of 2\" mean algebraically? Try\nnot to use \"mod.\"\n\nProblem 2: Translate the following expressions into\nEnglish. Assume that C(x) means \"x has a car\", F(x,y)\nmeans \"x and y are friends\", and S(x) means \"x is a\nstudent.\"\nl\nl\n\n\u2200x (S(x) \u2192 C(x) \u2228 \u2203y [F(x,y) \u2227 C(y)])\n\u2200x \u2203y \u2203z [C(x) \u2228 (F(x,y) \u2227 C(y)) \u2228 (F(x,y) \u2227 F(y,z) \u2227 C(z))]\n\nTranslating from English to a logical expression with\nnested quantifiers is a little bit more work...\n\nSteps:\n1. If necessary, rewrite the sentence to make quantifiers and\nlogical operations more explicit\n2. Create propositional functions to express the concepts in\nthe sentence\n3. State the domains of the variables in each propositional\nfunction\n4. Determine the order of quantifiers\n5. Generate logical expression\n\nLet's try an example...\nUniversal quantifier\n\nStatement: Every student has asked at least one\nprofessor a question.\nExistential quantifier\n\nRewrite: For every person x, if x is a student, then there\nexists a professor whom x has asked a question.\n\nLet:\nl S(x) \u2261 x is a student\nl P(x) \u2261 x is a professor\nl Q(x,y) \u2261 x has asked y a question\n\nDomains for x and\ny are \"all people\"\n\nTranslation: \u2200x (S(x) \u2192 \u2203y [P(y) \u2227 Q(x,y)])\n\nTranslate the following from English\nStatement: There is a man who has tasted every type of\nbeer.\n\nRewrite: There exists a person x such that x is man and\nfor all types of drink y, if y is a beer then x has tasted y.\nDomain: all people\n\nLet:\nl M(x) \u2261 x is a man\nl B(x) \u2261 x is a beer\nl T(x,y) \u2261 x has tasted y\n\nDomain: all drinks\nDomains: x = all people,\ny = all drinks\n\nTranslation: \u2203x (M(x) \u2227 \u2200y [B(y) \u2192 T(x,y)])\n\nNegating expression with nested quantifiers is\nactually pretty straightforward...\n... you just repeatedly apply DeMorgan's laws!\n\u00ac[\u2203x (M(x) \u2227 \u2200y [B(y) \u2192 T(x,y)])]\n\u2261 \u2200x \u00ac(M(x) \u2227 \u2200y [B(y) \u2192 T(x,y)])\n\u2261 \u2200x (\u00acM(x) \u2228 \u00ac\u2200y [B(y) \u2192 T(x,y)])\n\u2261 \u2200x (\u00acM(x) \u2228 \u2203y \u00ac[B(y) \u2192 T(x,y)])\n\u2261 \u2200x (\u00acM(x) \u2228 \u2203y \u00ac[\u00acB(y) \u2228 T(x,y)])\n\u2261 \u2200x (\u00acM(x) \u2228 \u2203y [B(y) \u2227 \u00acT(x,y)])\n\u2261 \u2200x (M(x) \u2192 \u2203y [B(y) \u2227 \u00acT(x,y)])\n\na \u2192 b \u2261 \u00aca \u2228 b\n\nIn English: For all people x, if x is a man, then there\nexists some type beer that x has not tasted.\n\nAlternatively: No man has tasted every type of beer.\n\nA few stumbling blocks...\nWhether the negation sign is on the inside or the outside of\na quantified statement makes a big difference!\n\nExample: Let T(x) \u2261 \"x is tall\". Consider the following:\nl \u00ac\u2200x T(x)\n\u27a3\"It is not the case that all people are tall.\"\n\nl \u2200x \u00acT(x)\n\u27a3\"For all people x, it is not the case that x is tall.\"\n\nNote: \u00ac\u2200x T(x) = \u2203x \u00acT(x) \u2260 \u2200x \u00acT(x)\nRecall: When we push negation into a quantifier,\n\nDeMorgan's law says that we need to switch the quantifier!\n\nA few stumbling blocks...\nLet:\n\nC(x) \u2261 \"x is enrolled in CS441\"\nS(x) \u2261 \"x is smart.\"\n\nQuestion: The following two statements look the same,\nwhat's the difference?\nl \u2203x [C(x) \u2227 S(x)]\nl \u2203x [C(x) \u2192 S(x)]\n\nThere is a smart\nstudent in CS441.\n\nThere exists a student x\nsuch that if x is in CS441,\nthen x is smart.\n\nSubtle note: The second statement is true if there exists\none person not in CS441, because F\u2192F or F\u2192T.\n\nNegate \u2200x (S(x) \u2192 \u2203y [P(y) \u2227 Q(x,y)])\n\u00ac\u2200x (S(x) \u2192 \u2203y [P(y) \u2227 Q(x,y)])\n\u2261 \u2203x \u00ac(S(x) \u2192 \u2203y [P(y) \u2227 Q(x,y)])\n\u2261 \u2203x \u00ac(\u00acS(x) \u2228 \u2203y [P(y) \u2227 Q(x,y)])\n\u2261 \u2203x (S(x) \u2227 \u00ac\u2203y [P(y) \u2227 Q(x,y)])\n\u2261 \u2203x (S(x) \u2227 \u2200y \u00ac[P(y) \u2227 Q(x,y)])\n\u2261 \u2203x (S(x) \u2227 \u2200y [\u00acP(y) \u2228 \u00acQ(x,y)])\n\u2261 \u2203x (S(x) \u2227 \u2200y [P(y) \u2192 \u00acQ(x,y)])\n\nIn English: There exists a student x such that for all people\ny, if y is a professor then x has not asked y a question.\n\nAlternatively: There exists a student that has never asked\nany professor a question.\n\nIn-class exercises\nProblem 3: Translate the following English sentences\ninto predicate logic.\na) Every student has at least one friend that is dating a\nSteelers fan.\nb) If a person is a parent and a man, then they are the\nfather of some child.\n\nProblem 4: Negate the results from Problem 3 and\ntranslate the negated expressions back into English.\n\nFinal Thoughts\nn Logic programming is an interesting application of\npredicate logic that is used throughout computer\nscience\nn Quantifiers can be nested\nl Nested quantifiers are read left to right\nl Order is important!\nl Translation and negation work the same as they did before!\n\nn Next lecture:\nl Rules of inference\nl Please read sections 1.6-1.7\n\n", "label": [[228, 243, "Concept"], [6414, 6429, "Concept"], [10119, 10134, "Concept"], [10458, 10473, "Concept"], [108, 125, "Concept"], [266, 283, "Concept"], [2234, 2251, "Concept"], [10407, 10424, "Concept"], [312, 318, "Concept"], [489, 495, "Concept"], [1164, 1170, "Concept"], [2533, 2539, "Concept"], [2562, 2568, "Concept"], [384, 391, "Concept"], [500, 507, "Concept"], [228, 237, "Concept"], [6414, 6423, "Concept"], [6485, 6494, "Concept"], [10119, 10128, "Concept"], [10458, 10467, "Concept"], [616, 624, "Concept"], [673, 681, "Concept"], [1582, 1587, "Concept"], [1667, 1672, "Concept"], [1629, 1643, "Concept"], [246, 264, "Concept"], [2740, 2758, "Concept"], [3105, 3123, "Concept"], [4220, 4238, "Concept"], [6931, 6949, "Concept"], [8158, 8176, "Concept"], [10545, 10563, "Concept"], [4533, 4553, "Concept"], [7319, 7339, "Concept"], [4658, 4680, "Concept"], [7411, 7433, "Concept"], [3309, 3327, "Concept"], [3792, 3812, "Concept"], [7242, 7262, "Concept"], [2888, 2904, "Concept"], [3905, 3921, "Concept"], [4602, 4624, "Concept"], [5486, 5492, "Concept"], [5890, 5896, "Concept"], [7935, 7941, "Concept"], [8028, 8034, "Concept"], [8767, 8787, "Concept"], [8245, 8260, "Concept"]]}