#E

Minimization and
K-maps
Original slides by: Jarrett Billingsley
Modified with bits from: Bruce
Childers, David Wilkinson

CS 0447
Introduction to
Computer Programming

LuÃ­s Oliveira

Fall 2020

Class announcements
â— Check the schedule
o Iâ€™ll post examples of circuits and suggestions of exercises
â— Labs will be submitted via Gradescope

2

How ICs are made in 3 slides
(another For Funâ„¢ section)

3

How ICs (integrated circuits) are made
â— silicon is purified and grown into a
monolithic crystal (extremely expensive)
â— this is sliced thinly to make wafers

o gooey caramel is put between them to make stroopwafel

â— a series of complicated photochemical
processes do things like:
o change its electrical properties
o make wires to connect things
o make inert insulating layers

4

How ICs (integrated circuits) are made
â— many ICs are printed on one wafer
â— the wafers are diced (chopped up)
â— the ICs are tested
â— the ICs are mounted in a package ->
â— they're tested again
â— then they're ready to sell

5

Manufacturing yield
â— ICs are tiny and complex
â— silicon crystals can have defects
â— a tiny speck of dust during production can ruin an entire chip
â— the yield is the percentage of usable chips
o bigger chips have smaller yields: more opportunities for mistakes!
â— the size of the silicon is the biggest factor in the price of an IC
o huge ICs (several cm on each side!), such as very high-resolution camera
sensors, can cost tens of thousands of dollars!
â— manufacturers can also bin resulting chips
o bug-free ones can be sold as Core i7s for lotsa money
o slightly malformed ones can be sold as Core i5s and i3s
o the ones they sweep off the floor are the Celerons

6

Logic Minimization

7

Silicon is expensive, rocks are slow
â— Logic minimization means using the smallest number of gates/transistors
possible to implement a boolean function
o a boolean function is anything we've talked about
o it has boolean inputs, and boolean outputs
â–ª Less inputs can also improve speed
â— Fewer transistors means:
o smaller area:
â–ª cheaper chips!
â–ª more stuff on one chip!
â–ª smaller chance of manufacturing defects!
o less gate delay:
â–ª faster circuits!

8

Minimizing Booleans
â— How do we minimize Boolean functions?
o Logical adjacency!
â— If in two Boolean terms being ORed only one of the variables changes then it
can be removed

à´¥ + ğ€ğ = ğ€ ğ‘©
à´¥ +ğ‘© =ğ‘¨
o ğ‘¸ = ğ€ğ‘©
à´¥ = ğ‘¨ğ‘©
à´¥ = ğ‘¨ğ‘©
à´¥ ğ‘ª + ğ‘¨ğ‘©
à´¥ğ‘ª
à´¥ ğ‘ª+ğ‘ª
à´¥
o ğ‘¸ = ğ‘¨ğ‘©
â— To minimize a Boolean expression
o Find the terms where only one variable changes
o Eliminate that variable

9

A first try
â— The truth table for a two-input 1-bit
multiplexer.

A

A
Q

B

Q

B
S=0

S=1

S Q

S A B Q

0 A

0 0 0 0

0 A

0 0 1 0

0 A

0 1 0 1

0 A

0 1 1 1

1 B

1 0 0 0

1 B

1 0 1 1

1 B

1 1 0 0

1 B

1 1 1 1
10

A first try
â— The truth table for a two-input 1-bit multiplexer.

S A B Q
0 0 0 0
0 0 1 0

à´¥ 0 1 0 1
ğ’à´¤ğ€ğ‘©
ğ’à´¤ğ€ğ 0 1 1 1
1 0 0 0

à´¥ğ 1 0 1 1
ğ’ğ‘¨
1 1 0 0

ğ’ğ€ğ 1 1 1 1

à´¥ + ğ’à´¤ğ€ğ + ğ’ğ‘¨
à´¥ ğ + ğ’ğ€ğ
ğ‘¸ = ğ’à´¤ğ€ğ‘©
Are there any adjacencies?
Wellâ€¦ I guess we donâ€™t need
those variables

ğ‘¸ = ğ’à´¤ğ€ + ğ’à´¤ğ€ + ğ’ğ + ğ’ğ
This seems easyâ€¦

ğ‘¸ = ğ’à´¤ğ€ + ğ’ğ
11

It makes sense, right?
â— We know that if S=0 then the output is A
â— We know that if S=1 then the output is B
o We donâ€™t care about one of the variables
â— So, letâ€™s solve this truth table
1. find all rows with an output of 1
2. for each one, write an AND of all the inputs,
with NOTs on the 0s
3. eliminate duplicate terms
4. OR the remaining terms together

à´¤ + ğ’ğ
ğ = ğ’ğ€

â— Getting the sum-of-products
o an OR of multiple ANDed terms

S A B Q
0 0 X 0

0 0 X 0

ğ’à´¤ğ€ 0 1 X 1
ğ’à´¤ğ€ 0 1 X 1
1 X 0 0

ğ’ğ 1 X 1 1
1 X 0 0

ğ’ğ 1 X 1 1
12

Turning that expression into gates
â— making ğ = ğ’à´¤ğ€ + ğ’ğ into gates is pretty straightforward:

S

A
Q
B

13

Minimization using Boolean
Algebra

14

Boolean algebra
â— Idempotent
o ğ‘. ğ‘ = ğ‘ + ğ‘ = ğ‘
â— Commutative
o ğ‘. ğ‘ = ğ‘. ğ‘
o ğ‘+ğ‘ =ğ‘+ğ‘
â— Associative
o ğ‘. ğ‘. ğ‘ = ğ‘. ğ‘ . ğ‘
o ğ‘+ ğ‘+ğ‘ = ğ‘+ğ‘ +ğ‘
â— Distributive
o ğ‘. ğ‘ + ğ‘ = ğ‘. ğ‘ + ğ‘. ğ‘
o ğ‘ + ğ‘. ğ‘ = ğ‘ + ğ‘ . (ğ‘ + ğ‘)

â— De Morganâ€™s laws
o ğ‘. ğ‘ = ğ‘à´¤ + ğ‘à´¤
o ğ‘ + ğ‘ = ğ‘.
à´¤ ğ‘à´¤
â— Other
o ğ‘ + ğ‘. ğ‘ = ğ‘
o ğ‘. ğ‘ + ğ‘ = ğ‘
o ğ‘à´¤ = ğ‘
o ğ‘ + ğ‘à´¤ = 1
o ğ‘. ğ‘à´¤ = 0

15

What if the function is more complex?
â— if we use that method on the Cout of a full adder:

A
0
0
0
0
1
1
1
1

B
0
0
1
1
0
0
1
1

à´¥ ğğ‚ğ¢ğ§ + ğ€ğ‘©
à´¥ ğ‚ğ¢ğ§ + ğ€ğğ‚ğ¢ğ§ + ğ€ğğ‚ğ¢ğ§
Cin Cout ğ‚ğ¨ğ®ğ­ = ğ€
0
0
â— It feels too complex, somehow
1
0
â— each NOT gate uses 2 transistors
0
0
â— each AND/OR gate uses 6
à´¥ ğğ‚ğ¢ğ§ â— this will use 72 transistors
1
1 ğ€
o just for the carry
0
0
à´¥ ğ‚ğ¢ğ§ o of one one-bit addition
1
1 ğ€ğ‘©
0
1 ğ€ğğ‚ğ¢ğ§
1
1 ğ€ğğ‚ğ¢ğ§
16

Minimizing equations â€“WHYYYYY!!
ğ‘¨ğ‘©ğ‘ª + ğ‘¨ğ‘©ğ‘ª + ğ‘¨ğ‘©ğ‘ª + ğ‘¨ğ‘©ğ‘ª
Using distributivity ğ´ğµ + ğ´ğ¶ = ğ´(ğµ + ğ¶) :
ğ´ğµ ğ¶ + ğ¶ + ğ´ğµğ¶ + ğ´ğµğ¶

72 transistors

Adjacency #1 tackled:
ğ´ğµ + ğ´ğµğ¶ + ğ´ğµğ¶
What about now? Two variables change ïŒ

17

Minimizing equations â€“WHYYYYY!!
ğ‘¨ğ‘©ğ‘ª + ğ‘¨ğ‘©ğ‘ª + ğ‘¨ğ‘©ğ‘ª + ğ‘¨ğ‘©ğ‘ª
Adding (ORing) the same term multiple times is ok:
ğ´ğµ + ğ´ğµğ¶ + ğ´ğµğ¶ + ğ´ğµğ¶ + ğ´ğµğ¶
Note the two adjacencies :D
ğ´ğµ + ğ´ğ¶ ğµ + ğµ + ğµğ¶ ğ´ + ğ´
Adjacency #2 and #3 tackled:
ğ‘¨ğ‘© + ğ‘ªğ‘¨ + ğ‘ªğ‘©
30 transistors
18

Itâ€™s hard!

If only we had a better tool to help us

19

Karnaugh Maps

20

Gray Code
â— Gray code is a way of encoding binary where
only one bit changes on each step
â— How can we construct it?
â— Letâ€™s revisit our binary number table:
o Start by creating the first two 1-bit entries
o Mirror them and complete the next column
o Repeat!
â— See how only one bit changes from the
last to the first number!
â— Weâ€™ll only be using 2-bit code.

000
001
011
010
110
111
101
100

21

Karnaugh Maps (K-maps) â€“ Setting up
â— Karnaugh Maps are a tool for minimizing boolean functions
â— It helps us finding adjacencies
o let's start with a function that has two inputs
Truth Table

K-map

A
0
0
1
1

0

B
0
1
0
1

Q
1
0
1
1

à´¥
ğ

à´¥
0 ğ€

1

ğ

1 0
1 ğ€ 1 1

1. Karnaugh maps are
represented as a table
2. write input values in Gray
code along axes.
o (there's only one input on
each side here, it's easy)
3. Fill in cells from truth table.

22

Karnaugh Maps (K-maps) â€“ Finding rects
K-map

à´¥
ğ

à´¥
ğ€

ğ

1 0
ğ€ 1 1

3. find rectangles of 1s with these rules:
o width and height can only be 1, 2, or 4
â–ª NEVER 3
o overlapping is totally fine! it's good!
o use the biggest rectangles possible
o use the fewest rectangles possible

23

Karnaugh Maps (K-maps) â€“ Interpreting rects
K-map

à´¥
ğ

ğ

à´¥
ğ€

1 0
ğ€ 1 1
à´¥
Red: ğ

Blue: ğ€

à´¥
ğ=ğ€+ğ

4. for each rectangle, look at the values of
the variables along the axes. some
variables change, and others don't.
o which variable changes in the red
rectangle? which doesn't?
o what about the blue rectangle?
5. each rectangle is an AND minterm
o write the variables that stay the same
for that rect (keeping the NOT bars)
o ignore the variables that change
6. OR all the terms together
7. WHEW!
24

I'd like to place an order for the carry-out bit
â— With more than 2 variables, put two along one axis (GRAY CODE!)
try to make the rectangles as big as
C A B Co
possible. overlap is goooood.

0
0
0
0
1
1
1
1

0
0
1
1
0
0
1
1

0
1
0
1
0
1
0
1

0
0
0
1
0
1
1
1

00

01

11

10

à´¥ğ
à´¥ ğ€
à´¥ ğ ğ€ğ ğ€ğ
à´¥ Red: ğ€ğ‘ª
ğ€
0 ğ‚à´¤

0 0 1 0
1 ğ‚ 0 1 1 1

Green: ğ€ğ
Blue: ğğ‚

ğ‚ğ¨ = ğ€ğ‘ª + ğ€ğ + ğğ‘ª
25

I'd like to place an order for the carry-out bit
â— With more than 2 variables, put two along one axis (GRAY CODE!)
try to make the rectangles as big as
C A B Co
possible. overlap is goooood.

0
0
0
0
1
1
1
1

0
0
1
1
0
0
1
1

0
1
0
1
0
1
0
1

0
0
0
1
0
1
1
1

00

01

11

10

à´¥ğ
à´¥ ğ€
à´¥ ğ ğ€ğ ğ€ğ
à´¥
ğ€
0 ğ‚à´¤

0 0 1 0
1 ğ‚ 0 1 1 1
Did you notice this? ğ´ğµğ¶
This is the term we needed to add multiple times :D
26

Just like a 2D RPG world mapâ€¦
â— rectangles on K-maps can wrap around (left-right AND top-bottom!)

00

01

11

10

à´¥ğ˜
à´¥ ğ—
à´¥ğ˜ ğ—ğ˜ ğ—ğ˜
à´¥
ğ—
à´¤
0 ğ™

1 1 0 1
1 ğ™ 1 0 0 1

à´¥
Red: ğ˜
à´¥ğ™à´¤
Blue: ğ—

à´¥+ğ—
à´¥ğ™à´¤
ğ=ğ˜

this is really a 2x2 rectangle.
it's justâ€¦ doing its best.
27

Okay, maybe it's not perfect.
â— let's try the Sum output of a full adder

00

01

11

10

a 1x1 rectangle
becomes a term that
uses all the variables

à´¥ğ‘©
à´¥ğ‘ª
à´¥ğ
à´¥ ğ€
à´¥ ğ ğ€ğ ğ€ğ
à´¥ Red: ğ€
ğ€

à´¥ğ¢
0 ğ‚

0 1 0 1
1 ğ‚ğ¢ 1 0 1 0

à´¥
à´¥ ğğ‘ª
Green: ğ€
Blue: ğ€ğğ‚ğ¢
à´¥
à´¥ğ‘ª
Purple: ğ€ğ

à´¥ + ğ€ğğ‘ª + ğ€ğ
à´¥
à´¥ğ‘©
à´¥ğ‘ª + ğ€
à´¥ ğğ‘ª
à´¥ğ‘ª
ğ’ğ®ğ¦ = ğ€
wait, canâ€™t we do that as:

ğ’ğ®ğ¦ = ğ€â¨ğâ¨ğ‘ª (that's xor!)
28

Tradeoffs, tradeoffs
â— there are extensions to K-maps to detect XORs
â— butâ€¦
o XOR gates are slower than AND/OR gates
o if area is a concern, an XOR make sense
o if speed is a concern, AND/OR gates make sense
â— what do real hardware designers do?
o they use programs to do this stuff for them lol
o things like GALs, CPLDs, and FPGAs are reconfigurable hardware which
usually use "sum-of-products" to do logic, so ANDs and ORs are all you've
got

29

Some more examples
â— Can you solve this?

00

01

11

10

â— In AB: A is both {0,1}
â— In CD: D is both {0,1}

0
à´¥ğ‘« 0
01 ğ‘ª
11 ğ‘ªğ‘« 0
à´¥ 0
10 ğ‘ªğ‘«

0
0
1
1

0
0
1
1

0
0
0
0

â— Eliminate both A,D
â— We get
ğ¶ğµ

à´¥ğ
à´¥ ğ€
à´¥ ğ ğ€ğ ğ€ğ
à´¥
ğ€
à´¥ğ‘«
à´¥
00 ğ‘ª

30

Some more examples
â— Can you solve this?

00

01

11

10

â— In AB: Both have {0,1}
â— In CD: C is both {0,1}

0
à´¥ğ‘« 1
01 ğ‘ª
11 ğ‘ªğ‘« 1
à´¥ 0
10 ğ‘ªğ‘«

0
1
1
0

0
1
1
0

0
1
1
0

â— Eliminate both A, B, C
â— We get

à´¥ğ
à´¥ ğ€
à´¥ ğ ğ€ğ ğ€ğ
à´¥
ğ€
à´¥ğ‘«
à´¥
00 ğ‘ª

ğ·

31

Some more examples
â— Can you solve this?

00

01

11

10

â— In AB: A has both {0,1}
â— In CD: C is both {0,1}

1
à´¥ğ‘« 0
01 ğ‘ª
11 ğ‘ªğ‘« 0
à´¥ 1
10 ğ‘ªğ‘«

0
0
0
0

0
0
0
0

1
0
0
1

â— Eliminate both A, C
â— We get

à´¥ğ
à´¥ ğ€
à´¥ ğ ğ€ğ ğ€ğ
à´¥
ğ€
à´¥ğ‘«
à´¥
00 ğ‘ª

à´¥ğ·
à´¥
B

this is still a 2x2 rectangle!
32

7 segment LED display
â— This is a 7 segment LED display
o It displays numbers
o It has 8 LEDs (one for the decimal point)
â— Problem
o Given a 4-bit number, draw the
corresponding numeral.
o E.g. 0000 is â€œ0â€; 1001 is â€œ9â€.
o Ignore the dot
â— Solution
o Create a Boolean function for each
segment.

d2

d1

d3
d0

d7

d5
d6

d4

33

7 segment LED display
Number 0
01110111

d2

d1

d0

d7

d3
d0

d7

d5

d6

d4

Hex Digit LED
7 segments, 1 decimal point
Turn each segment on/off
State: 0=OFF, 1=ON
â€œDrawâ€ numbers 0 to 9
34

7 segment LED display
Number 1
00010100

d2

d1

d0

d7

d3
d0

d7

d5

d6

d4

Hex Digit LED
7 segments, 1 decimal point
Turn each segment on/off
State: 0=OFF, 1=ON
â€œDrawâ€ numbers 0 to 9
35

7 segment LED display
Number 2
10110011

d2

d1

d0

d7

d3
d0

d7

d5

d6

d4

Hex Digit LED
7 segments, 1 decimal point
Turn each segment on/off
State: 0=OFF, 1=ON
â€œDrawâ€ numbers 0 to 9
36

7 segment LED display
Number 3
10110110

d2

d1

d0

d7

d3
d0

d7

d5

d6

d4

Hex Digit LED
7 segments, 1 decimal point
Turn each segment on/off
State: 0=OFF, 1=ON
â€œDrawâ€ numbers 0 to 9
37

7 segment LED display
Number 4
11010100

d2

d1

d0

d7

d3
d0

d7

d5

d6

d4

Hex Digit LED
7 segments, 1 decimal point
Turn each segment on/off
State: 0=OFF, 1=ON
â€œDrawâ€ numbers 0 to 9
38

7 segment LED display
Number 5
11100110

d2

d1

d0

d7

d3
d0

d7

d5

d6

d4

Hex Digit LED
7 segments, 1 decimal point
Turn each segment on/off
State: 0=OFF, 1=ON
â€œDrawâ€ numbers 0 to 9
39

7 segment LED display
Number 6
11100111

d2

d1

d0

d7

d3
d0

d7

d5

d6

d4

Hex Digit LED
7 segments, 1 decimal point
Turn each segment on/off
State: 0=OFF, 1=ON
â€œDrawâ€ numbers 0 to 9
40

7 segment LED display
Number 7
00110100

d2

d1

d0

d7

d3
d0

d7

d5

d6

d4

Hex Digit LED
7 segments, 1 decimal point
Turn each segment on/off
State: 0=OFF, 1=ON
â€œDrawâ€ numbers 0 to 9
41

7 segment LED display
Number 8
11110111

d2

d1

d0

d7

d3
d0

d7

d5

d6

d4

Hex Digit LED
7 segments, 1 decimal point
Turn each segment on/off
State: 0=OFF, 1=ON
â€œDrawâ€ numbers 0 to 9
42

7 segment LED display
Number 9
11110110

d2

d1

d0

d7

d3
d0

d7

d5

d6

d4

Hex Digit LED
7 segments, 1 decimal point
Turn each segment on/off
State: 0=OFF, 1=ON
â€œDrawâ€ numbers 0 to 9
43

7 segment LED display
How to approach this?
â— Create a truth table
o Inputs are i0 to i3 (4 bits)
o Outputs are numbered d0, to d7, corresponding to segments

â— Minimize the circuit using a K-map
o Create the table
o Follow the rules!
â— Draw the numerals by setting d0 to d7 to 1s or 0s
o Build the circuit!

44

7 segment LED display
i3

i2

i1

i0

d0

d1

d2

d3

d4

d5

d6

d7

0

0

0

0

0

1

1

1

0

1

1

1

0

0

0

1

0

0

0

1

0

1

0

0

0

0

1

0

1

0

1

1

0

0

1

1

0

0

1

1

1

â€¦

â€¦

â€¦

â€¦

â€¦

â€¦

â€¦

0

1

0

0

1

â€¦

â€¦

â€¦

â€¦

â€¦

â€¦

â€¦

0

1

0

1

1

â€¦

â€¦

â€¦

â€¦

â€¦

â€¦

â€¦

0

1

1

0

1

â€¦

â€¦

â€¦

â€¦

â€¦

â€¦

â€¦

0

1

1

1

0

â€¦

â€¦

â€¦

â€¦

â€¦

â€¦

â€¦

1

0

0

0

1

â€¦

â€¦

â€¦

â€¦

â€¦

â€¦

â€¦

1

0

0

1

1

â€¦

â€¦

â€¦

â€¦

â€¦

â€¦

â€¦

1

0

1

0

X

X

X

X

X

X

X

X

â€¦

â€¦

â€¦

â€¦

â€¦

â€¦

â€¦

â€¦

â€¦

â€¦

â€¦

â€¦

45

7 segment LED display
i3

i2

i1

i0

d0

d1

d2

d3

d4

d5

d6

d7

0

0

0

0

0

1

1

1

0

1

1

1

0

0

0

1

0

0

0

1

0

1

0

0

0

0

1

0

1

0

1

1

0

0

1

1

0

0

1

â€¦

â€¦

â€¦

â€¦

â€¦

0

1

0

1 It can
1
â€¦
â€¦
only
0
1
â€¦
â€¦
display

â€¦

â€¦

0

1

0

1 numbers
1
â€¦up â€¦

0

1

1

0

1to 9!â€¦

â€¦

â€¦

â€¦

0

1

1

1

0

â€¦

â€¦

â€¦

1

0

0

0

1

â€¦

â€¦

â€¦

â€¦

â€¦

â€¦

â€¦

1

0

0

1

1

â€¦

â€¦

â€¦

â€¦

â€¦

â€¦

â€¦

1

0

1

0

X

X

X

X

X

X

X

X

â€¦

â€¦

â€¦

â€¦

â€¦

â€¦

â€¦

â€¦

â€¦

â€¦

â€¦

â€¦

So we â€œdonâ€™t
â€¦
â€¦
â€¦
careâ€ about
â€¦
â€¦
â€¦
â€¦
the outputs
â€¦
â€¦
â€¦
â€¦
for larger
â€¦
â€¦
â€¦
â€¦
numbers

46

7 segment LED display
â— Now use a K-map for each output
function d0-d7 - Letâ€™s start with d0

00

01

11

10

ğ’Šà´¥ğŸ ğ’Šà´¥ğŸ ğ’Šà´¥ğŸ ğ’ŠğŸ ğ’ŠğŸ ğ’ŠğŸ ğ’ŠğŸ ğ’Šà´¥ğŸ
00 ğ’Šà´¥ğŸ‘ ğ’Šà´¥ğŸ

0
01 ğ’Šà´¥ğŸ‘ ğ’ŠğŸ 1
11 ğ’ŠğŸ‘ ğ’ŠğŸ X
10 ğ’ŠğŸ‘ ğ’Šà´¥ğŸ 1

0
1
X
1

1
0
X
X

1
1
X
X

i3

i2

i1

i0

d0

0

0

0

0

0

0

0

0

1

0

0

0

1

0

1

0

0

1

1

1

0

1

0

0

1

0

1

0

1

1

0

1

1

0

1

0

1

1

1

0

1

0

0

0

1

1

0

0

1

1

1

0

1

0

X

â€¦

â€¦

â€¦

â€¦

â€¦

47

7 segment LED display
â— Now use a K-map for each output function d0-d7
â— Letâ€™s start with d0

00

01

11

10

0
01 ğ’Šà´¥ğŸ‘ ğ’ŠğŸ 1
11 ğ’ŠğŸ‘ ğ’ŠğŸ X
10 ğ’ŠğŸ‘ ğ’Šà´¥ğŸ 1

0
1
X
1

1
0
X
X

1
1
X
X

ğ’Šà´¥ğŸ ğ’Šà´¥ğŸ ğ’Šà´¥ğŸ ğ’ŠğŸ ğ’ŠğŸ ğ’ŠğŸ ğ’ŠğŸ ğ’Šà´¥ğŸ
00 ğ’Šà´¥ğŸ‘ ğ’Šà´¥ğŸ

Output
â€œdonâ€™t caresâ€
can be
whatever we
need them to
be â˜º

48

7 segment LED display
00

01

11

10

ğ’Šà´¥ğŸ ğ’Šà´¥ğŸ ğ’Šà´¥ğŸ ğ’ŠğŸ ğ’ŠğŸ ğ’ŠğŸ ğ’ŠğŸ ğ’Šà´¥ğŸ
00 ğ’Šà´¥ğŸ‘ ğ’Šà´¥ğŸ

0
01 ğ’Šà´¥ğŸ‘ ğ’ŠğŸ 1
11 ğ’ŠğŸ‘ ğ’ŠğŸ X
10 ğ’ŠğŸ‘ ğ’Šà´¥ğŸ 1

0
1
X
1

1
0
X
X

1
1
X
X

â— Four minterms:

o ğ’ŠğŸ‘
o ğ’ŠğŸ ğ’ŠğŸ
o ğ’ŠğŸ ğ’ŠğŸ
o ğ’ŠğŸ ğ’ŠğŸ

ğ’…ğŸ = ğ’ŠğŸ‘ + ğ’ŠğŸ ğ’ŠğŸ + ğ’ŠğŸ ğ’ŠğŸ + ğ’ŠğŸ ğ’ŠğŸ

49

On your own
â— Try making a circuit in Logisim using the 7 segment LED display
o Find it in input/output
â— Connect the logic you just solved into d0 (top-left pin) and test it

â— Solve for the remaining segments
o Itâ€™s fun and practice

50

