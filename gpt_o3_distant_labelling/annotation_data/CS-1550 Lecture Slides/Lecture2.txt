Introduction to Operating Systems
CS/COE 1550
Process Synchronization - 1
Spring 2022

Sherif Khattab
ksm73@pitt.edu
(Some slides are from Silberschatz, Galvin and Gagne Â©2013)

Announcements
â€¢ Homework 1 is due next Monday at 11:59 pm

â€¢ Recitations started last week
â€¢ Please watch the videos

â€¢ Lab 1 is due on 2/4 at 11:59 pm
â€¢ Distributed using GitHub Classroom

â€¢ Explained in this weekâ€™s recitations

â€¢ Steps of a syscall posted on Canvas
â€¢ TA Office hours available on the syllabus page
â€¢ Muddiest points will be anonymous and not seen to
students
CS/COE 1550 â€“ Operating Systems â€“ Sherif Khattab

2

Muddiest Points
â€¢ storage/access of the mode bits
â€¢ syscalls
â€¢

idt/isr vs syscall table

â€¢

Difference between f1~f7(what to call them?) and
f8~f10(syscall functions)

â€¢

the beginning of the syscall process

â€¢

syscall steps

â€¢

eax register relevance to interrupts/syscall

â€¢

How user programs need to be changed for new syscalls

â€¢

How high level code interacts with syscalls

â€¢ xv6 walkthrough
â€¢

Array of functions syntax in C

â€¢ monolithic vs micro
CS/COE 1550 â€“ Operating Systems â€“ Sherif Khattab

3

Problem: race conditions
â€¢ R is a CPU register

â€¢ X is a variable
stored in memory

P1
x++

P2
x++
x=3

R <= x
R = R+1
R => x

R <= x
R = R+1
R => x

x=5
R <= x

R <= x
R = R+1
R = R+1
R => x
R => x

x=6!

CS/COE 1550 â€“ Operating Systems â€“ Sherif Khattab

4

Race conditions
â€¢

Cooperating processes share storage (memory)

â€¢

Both may read and write the shared memory

â€¢

Problem: canâ€™t guarantee that read followed by write is atomic
â€¢

Atomic means uninterruptible

â€¢

Ordering matters!

â€¢

This can result in erroneous results!

â€¢

We need to eliminate race conditionsâ€¦

CS/COE 1550 â€“ Operating Systems â€“ Sherif Khattab

5

Atomic operations
â€¢ If done in one instruction, then not interruptible

CS/COE 1550 â€“ Operating Systems â€“ Sherif Khattab

6

Context Switching
How did the CPU switch from P1 to P2 then to P1 then
to P2 again â€¦?

CS/COE 1550 â€“ Operating Systems â€“ Sherif Khattab

7

Process Control Block
``Active entities are data structures when viewed from a
lower level.â€™â€™

Raphael Finkel, University of Kentucky

CS/COE 1550 â€“ Operating Systems â€“ Sherif Khattab

8

Process Control Block (PCB)
Information associated with each process
(also called task control block)
â€¢ Process state â€“ running, waiting, etc
â€¢ Program counter â€“ location of instruction to execute next
â€¢ CPU registers â€“ contents of all process-centric registers
â€¢ CPU scheduling information- priorities, scheduling queue
pointers
â€¢ Memory-management information â€“ memory allocated to
the process
â€¢ Accounting information â€“ CPU used, clock time elapsed
since start, time limits
â€¢ I/O status information â€“ I/O devices allocated to process,
list of open files
CS/COE 1550 â€“ Operating Systems â€“ Sherif Khattab

9

Process Representation in Linux
Represented by the C structure task_struct
pid_t pid; /* process identifier */
long state; /* state of the process */
unsigned int time_slice /* scheduling information */
struct task_struct *parent; /* this processâ€™s parent */
struct list_head children; /* this processâ€™s children */
struct files_struct *files; /* list of open files */
struct mm_struct *mm; /* address space of this process */

CS/COE 1550 â€“ Operating Systems â€“ Sherif Khattab

10

Context Switch
â€¢ When CPU switches to another process, the system
must save the state of the old process and load the
saved state for the new process via a context
switch
â€¢ Context of a process represented in the PCB
â€¢ Context-switch time is overhead; the system does no
useful work while switching
â€¢ The more complex the OS and the PCB â” the longer the
context switch

â€¢ Time dependent on hardware support
â€¢ Some hardware provides multiple sets of registers per
CPU â” multiple contexts loaded at once
CS/COE 1550 â€“ Operating Systems â€“ Sherif Khattab

11

Context Switching

CS/COE 1550 â€“ Operating Systems â€“ Sherif Khattab

12

Xv6 Code Walkthrough
â€¢ PCB and process table

â€¢ Context switching
â€¢ Calling of the swtch routine

CS/COE 1550 â€“ Operating Systems â€“ Sherif Khattab

13

Context Switching in Xv6
%eax
%edx

context

PCB of Process ğ‘ƒ0

Return address

%esp
%eip

Stack of Process ğ‘ƒ0

CPU
Return
Return address
address

context

PCB of Process ğ‘ƒ1

Stack of Process ğ‘ƒ1
Memory
CS/COE 1550 â€“ Operating Systems â€“ Sherif Khattab

14

Critical regions
â€¢

Back to the race conditions problem

â€¢

Use critical regions to provide mutual exclusion and help fix race conditions

â€¢

Letâ€™s put the statement x++ in a critical region
P1 enters
critical region

P1 leaves
critical region

Process P1
P2 tries to enter
critical region

Process P2

P2 enters
critical region

P2 leaves
critical region

P2 blocked
Time

CS/COE 1550 â€“ Operating Systems â€“ Sherif Khattab

15

How to implement critical regions?
â€¢ Turn-based solutions

â€¢ Spinlocks
â€¢ Semaphores
â€¢ Monitors

CS/COE 1550 â€“ Operating Systems â€“ Sherif Khattab

16

Using Spinlocks
Spinlock lock;

Code for process Pi

While(1){
Lock(lock)
// critical section
Unlock(lock);
// remainder of code
}
}

CS/COE 1550 â€“ Operating Systems â€“ Sherif Khattab

17

Spinlock implementation (1/2)
â€¢ Solution: use hardware

â€¢ Several hardware methods
â€¢ Test & set: test a variable and set it in one instruction
â€¢ Atomic swap: switch register & memory in one instruction
â€¢ Turn off interrupts: process wonâ€™t be switched out unless it
asks to be suspended

â€¢ The first two methods can be implemented in user
land
â€¢ Why canâ€™t we implement the third method in user land?

CS/COE 1550 â€“ Operating Systems â€“ Sherif Khattab

18

