Exam 1 Review (Chapter 1)
Thumrongsak Kosiyatrakul
tkosiyat@cs.pitt.edu

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

Deterministic Finite Automaton (DFA)

State Diagram of a DFA
Formal Definition of a DFA (Q, Σ, δ, q0 , F )
Q is a non-empty set of states
Σ is a finite set of symbols
δ : Q × Σ → Q transition function
q0 ∈ Q is the start state
F is a set of accept states

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

Formal Definition of a DFA
0

1

0

1

q0

q1

q2
0, 1

M1 = (Q, Σ, δ, q0 , F )
Q = {q0 , q1 , q2 }
Σ = {0, 1}
δ can be defined using the table below:
δ
0
1
q0 q0 q1
q1 q2 q1
q2 q1 q1
q0 is the start state
F = {q1 }

The state diagram and its formal definition are equivalent
Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

Deterministic Finite Automaton (DFA)

How a DFA process an input string?
Accept/Reject

Language of a DFA
The set of all strings accepted by the DFA

A language is regular is there are finite state machines that
recognize it

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

Language Operators

A language is a set of strings
Given language A and B:
A ∪ B = {x | x ∈ A or x ∈ B}
A ◦ B = {xy | x ∈ A and y ∈ B}
A∗ = {x1 x2 . . . xk | k ≥ 0 and xi ∈ A}

Regular language is closed under union, concatenation, and
star operations
Given two regular languages A and B
A ∪ B is a regular language
AB is a regular language
A∗ and B ∗ are regular languages

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

Tool

Given two DFA MA and MB
We obtain an algorithm to construct a DFA M such that
L(M ) = L(MA ) ∪ L(MB )
The algorithm is defined based on formal definitions of DFAs
MA and MB

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

L is regular under union operation

Let MA recognizes A, where MA = (QA , Σ, δA , qA , FA )
Let MB recognizes B, where MB = (QB , Σ, δB , qB , FB )
Machine M = (Q, Σ, δ, q0 , F ) that recognizes A ∪ B can be
constructed as follows:
1
2

Q = {(r1 , r2 ) | r1 ∈ QA and r2 ∈ QB }
For each (r1 , r2 ) ∈ Q and a ∈ Σ
δ((r1 , r2 ), a) = (δA (r1 , a), δB (r2 , a))

3
4

q0 = (qA , qB )
F = {(r1 , r2 ) | r1 ∈ FA or r2 ∈ FB }

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

Nondeterministic Finite Automaton (NFA)

Can split into multiple copies of itself
At a state, it may have 0, 1, or more than 1 exiting arrow for
each symbol
At a state, it may have 0, 1, or more than 1 exiting arrow for ε
We generally use a computational tree to compute an NFA

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

Formal Definition of A Nondeterministic Finite Automaton
A nondeterministic finite automaton is a 5-tuple
(Q, Σ, δ, q0, F )
1
2
3

Q is a finite set of states
Σ is a finite alphabet
δ : Q × Σε → P(Q) is the transition function,
Σε = Σ ∪ {ε} and
P(Q) is the powerset of Q (set of set of states).

4
5

q0 ∈ Q is the start state
F ⊆ Q is the set of accept states.

Notes
In an NFA, one input symbol can change the state of the
machine to multiple states.
Split to multiple copies with different current states
Example: δ(q0 , 1) = {q0 , q1 }
Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

Example
0, 1

0, 1

1

q1

0, ε

q2

1

q3

Q = {q1 , q2 , q3 , q4 }
Σ = {0, 1} and Σε = {0, 1, ε}
δ is given as
δ
0
1
q1 {q1 } {q1 , q2 }
q2 {q3 }
∅
q3
∅
{q4 }
q4 {q4 }
{q4 }

q4

ε
∅
{q3 }
∅
∅

We treat ε as a regular input symbol
If there is no ε transitions, we can ignore the ε column

q1 is the start state
F = {q4 }
Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

Equivalence of NFAs and DFAs

Every nondeterministic finite automaton has an equivalent
deterministic finite automaton.
Let N = (Q, Σ, δ, q0 , F ) be the NFA recognizing some
language A
We are going to construct a DFA M = (Q0 , Σ, δ 0 , q00 , F 0 )
recognizing A
Let’s consider the case where N has no ε transitions.
1
2

Q0 = P(Q) [
δ 0 (R, a) =
δ(r, a)
r∈R

3
4

q00 = {q0 }
F 0 = {R ∈ Q0 | R contains an accept state of N }

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

Example
Let Σ be {0, 1}. The following NFA N recognizes the
language A where A is a set of strings that end with a 1.
0, 1

1

q0

q1

N = (Q, Σ, δ, q0 , F )
1
2
3

Q = {q0 , q1 },
Σ = {0, 1}
δ is given as
q0
q1

4
5

0
{q0 }
∅

1
{q0 , q1 }
∅

q0 is the start state
F = {q1 }

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

Example

Construct a DFA M = (Q0 , Σ, δ 0 , q00 , F 0 )
Q0 = P(Q) = P({q0 , q1 })
Q0 = {∅, {q0 }, {q1 }, {q0 , q1 }}
We will construct δ 0 later
q00 = {q0 } where q0 is the start state of the NFA
F 0 = {R ∈ Q0 | R contains an accept state of N }
F 0 = {{q1 }, {q0 , q1 }}
where F = {q1 }

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

Example

Let’s focus on transition functions
The transition function δ of the NFA is as follows:
0
1
q0 {q0 } {q0 , q1 }
q1
∅
∅
Recall that the set of state of the equivalent DFA is the power
set of set of state of the NFA
δ0
0
1
∅
∅
∅
{q0 } {q0 , q1 }
{q0 }
{q1 }
∅
∅
{q0 , q1 } {q0 } {q0 , q1 }

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

Example
The state diagram of the machine M = (Q0 , Σ, δ 0 , q00 , F 0 )
equivalent to N (L(M ) = L(N )) is shown below:
0

1

1

{q0 }

{q0 , q1 }

0
0

0

{q1 }

∅
1

1

Without bottom part, it is the same as one of our previous
example
It is okay for a DFA to have unreachable states

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

Regular Expression

A regular expression expresses a regular language
A regular expression can be constructed using these rules:
1
2
3
4

5

6

If a ∈ Σ, a is a regular expression
ε is a regular expression
∅ is a regular expression
If R1 and R2 are regular expressions, R1 ∪ R2 is a regular
expression
If R1 and R2 are regular expressions, R1 R2 is a regular
expression
If R1 is a regular expression, R1∗ is a regular expression

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

Tool: Regular Expression to NFA

Construct an NFA from a regular expression
Based on closure of union, concatenation, and star

Given a regular expression
1

2

Break it down into steps how to construct the regular
expression
For each step, slowly construct an NFA

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

Regular Expression to NFA
Convert the regular expression (ab ∪ a)∗ to an NFA.
a

b

ab

ab U a

(ab U a) *

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

Regular Expression to NFA
Convert the regular expression (ab ∪ a)∗ to an NFA.
a
a

b

ab

ab U a

(ab U a) *

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

Regular Expression to NFA
Convert the regular expression (ab ∪ a)∗ to an NFA.
a
a
b
b

ab

ab U a

(ab U a) *

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

Regular Expression to NFA
Convert the regular expression (ab ∪ a)∗ to an NFA.
a
a
b
b
a
ab

ab U a

(ab U a) *

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

Regular Expression to NFA
Convert the regular expression (ab ∪ a)∗ to an NFA.
a
a
b
b
a
ab

ab U a

(ab U a) *

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

b

Regular Expression to NFA
Convert the regular expression (ab ∪ a)∗ to an NFA.
a
a
b
b
a

ε

ab

ab U a

(ab U a) *

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

b

Regular Expression to NFA
Convert the regular expression (ab ∪ a)∗ to an NFA.
a
a
b
b
a

ε

ab

ab U a

(ab U a) *

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

b

Regular Expression to NFA
Convert the regular expression (ab ∪ a)∗ to an NFA.
a
a
b
b
a

ε

b

a

ε

b

ab

ab U a

(ab U a) *

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

Regular Expression to NFA
Convert the regular expression (ab ∪ a)∗ to an NFA.
a
a
b
b
a

ε

b

a

ε

b

ab

ab U a
a

(ab U a) *

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

Regular Expression to NFA
Convert the regular expression (ab ∪ a)∗ to an NFA.
a
a
b
b
a

ε

b

a

ε

b

ab

ε
ab U a
a
ε

(ab U a) *

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

Regular Expression to NFA
Convert the regular expression (ab ∪ a)∗ to an NFA.
a
a
b
b
a

ε

b

a

ε

b

ε

b

ab

ε
ab U a
a
ε

a
ε
(ab U a) *
a
ε

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

Regular Expression to NFA
Convert the regular expression (ab ∪ a)∗ to an NFA.
a
a
b
b
a

ε

b

a

ε

b

ε

b

ab

ε
ab U a
a
ε

a
ε
(ab U a) *

ε
a
ε

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

Regular Expression to NFA
Convert the regular expression (ab ∪ a)∗ to an NFA.
a
a
b
b
a

ε

b

a

ε

b

ab

ε
ab U a
a
ε
ε

a

ε

ε
(ab U a) *

ε
a
ε

ε

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

b

Regular Language

Every regular language can be expressed by a regular
expression
Convert from an DFA to a regular expression
1

Convert a given n-state DFA to n + 2 states (GNFA)
Add a new start state s with ε transition
Add a new accept state a with ε transitions
Convert all transition function from symbol to regular
expression

2

3

Get rid of original states of DFA without changing its language
until we only have two states
The label from s to a is a regular expression that expresses the
language of a given DFA

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

Example
DFA
1

a

b

2

a, b

{w | w contains at least one b}
Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

Example
DFA to GNFA
ε
1

a

s

1

b

a

b
ε

2

a, b

a

2

{w | w contains at least one b}
Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

aUb

Example
Get rid of state 2
ε
1

s

a

1

a

b

b
ε
2

a, b

a

2

ε
s

1

a

b(a U b)*
a

{w | w contains at least one b}
Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

aUb

Example
Get rid of state 1
ε
1

s

a

1

b

a

b
ε
a, b

2

a

2

ε
s

1

a

s

a*b(a U b)*

b(a U b)*
a

a

{w | w contains at least one b}
Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

aUb

Pumping Lemma

The Pumping Lemma is based on a property of a regular
language:
If A is regular, for a string s ∈ A of length at least P , s can
be divided into s = xyz satisfying the following conditions:
1
2
3

xy i z ∈ A for any i ≥ 0
|y| > 0
|xy| ≤ p

To use the Pumping lemma to prove that a language is not
regular, we use prove by contradiction

Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

Show that A = {ai bj | i = j or 2i = j}
Assume that A is regular. Since A is regular, the Pumping lemma says that for any
string s ∈ A of length at least p, s can be divided into s = xyz satisfying the following
conditions:
1

xy i z ∈ D for any i ≥ 0

2

|y| > 0

3

|xy| ≤ p

Let s = ap b2p . In this case, i = p and j = 2p. Since 2i = j, s ∈ A. Since s starts
with p as, to satisfy the third condition, x and y are strings that contain nothing but
as. In other words, x = aq for any q ≥ 0, and y = ar for any r > 0. Note that r must
be greater than 0 because |y| = |ak | = r, and the condition 2 says that |y| > 0. Since
x = aq and y = ar , z = ap−(q+r) b2p . Let i = 0. We have
xy i z = xy 0 z = xz
= aq ap−(q+r) b2p
= ap−r b2p
For the string ap−r b2p , i = p − r and j = 2p. Thus, for this string to be in A, p − r
must be equal to 2p or 2(p − r) must be equal to 2p. For p − r to be equal to 2p, r
must be equal to −p. For 2(p − r) to be equal to 2p, r must be 0. But r must be
greater than 0. Thus, ap−r b2p 6∈ A — contradiction. Therefore, A is not regular.
Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

Note
Let Σ = {0, 1} and consider the following language:
B = {ww | w ∈ Σ∗ }
Suppose you pick the string s to be 0p 0p
This string does not lead to a contradiction
We get the usual x, y, and z
x = 0j for j ≥ 0
y = 0k for k > 0
z = 0p−(j+k) 0p

xy i z = 0j (0k )i 0p−(j+k) 0p = 02p+k(i−1)
For any i, you can always find k > 0 such that
2p + k(i − 1) = 2x for some positive integer x
This allows us to split 02p+k(i−1) to 0x 0x which is in the
language B

You need to pick another s
Thumrongsak Kosiyatrakul tkosiyat@cs.pitt.edu

Exam 1 Review (Chapter 1)

